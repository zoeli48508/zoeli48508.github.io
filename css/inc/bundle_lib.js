/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(28);
	module.exports = __webpack_require__(31);


/***/ }),
/* 1 */,
/* 2 */,
/* 3 */,
/* 4 */,
/* 5 */,
/* 6 */,
/* 7 */,
/* 8 */,
/* 9 */,
/* 10 */,
/* 11 */,
/* 12 */,
/* 13 */,
/* 14 */,
/* 15 */,
/* 16 */,
/* 17 */,
/* 18 */,
/* 19 */,
/* 20 */,
/* 21 */,
/* 22 */,
/* 23 */,
/* 24 */,
/* 25 */,
/* 26 */,
/* 27 */,
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {module.exports = global["jQuery"] = __webpack_require__(29);
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {module.exports = global["$"] = __webpack_require__(30);
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * jQuery JavaScript Library v3.3.1
	 * https://jquery.com/
	 *
	 * Includes Sizzle.js
	 * https://sizzlejs.com/
	 *
	 * Copyright JS Foundation and other contributors
	 * Released under the MIT license
	 * https://jquery.org/license
	 *
	 * Date: 2018-01-20T17:24Z
	 */
	( function( global, factory ) {

		"use strict";

		if ( typeof module === "object" && typeof module.exports === "object" ) {

			// For CommonJS and CommonJS-like environments where a proper `window`
			// is present, execute the factory and get jQuery.
			// For environments that do not have a `window` with a `document`
			// (such as Node.js), expose a factory as module.exports.
			// This accentuates the need for the creation of a real `window`.
			// e.g. var jQuery = require("jquery")(window);
			// See ticket #14549 for more info.
			module.exports = global.document ?
				factory( global, true ) :
				function( w ) {
					if ( !w.document ) {
						throw new Error( "jQuery requires a window with a document" );
					}
					return factory( w );
				};
		} else {
			factory( global );
		}

	// Pass this if window is not defined yet
	} )( typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

	// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1
	// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode
	// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common
	// enough that all such attempts are guarded in a try block.
	"use strict";

	var arr = [];

	var document = window.document;

	var getProto = Object.getPrototypeOf;

	var slice = arr.slice;

	var concat = arr.concat;

	var push = arr.push;

	var indexOf = arr.indexOf;

	var class2type = {};

	var toString = class2type.toString;

	var hasOwn = class2type.hasOwnProperty;

	var fnToString = hasOwn.toString;

	var ObjectFunctionString = fnToString.call( Object );

	var support = {};

	var isFunction = function isFunction( obj ) {

	      // Support: Chrome <=57, Firefox <=52
	      // In some browsers, typeof returns "function" for HTML <object> elements
	      // (i.e., `typeof document.createElement( "object" ) === "function"`).
	      // We don't want to classify *any* DOM node as a function.
	      return typeof obj === "function" && typeof obj.nodeType !== "number";
	  };


	var isWindow = function isWindow( obj ) {
			return obj != null && obj === obj.window;
		};




		var preservedScriptAttributes = {
			type: true,
			src: true,
			noModule: true
		};

		function DOMEval( code, doc, node ) {
			doc = doc || document;

			var i,
				script = doc.createElement( "script" );

			script.text = code;
			if ( node ) {
				for ( i in preservedScriptAttributes ) {
					if ( node[ i ] ) {
						script[ i ] = node[ i ];
					}
				}
			}
			doc.head.appendChild( script ).parentNode.removeChild( script );
		}


	function toType( obj ) {
		if ( obj == null ) {
			return obj + "";
		}

		// Support: Android <=2.3 only (functionish RegExp)
		return typeof obj === "object" || typeof obj === "function" ?
			class2type[ toString.call( obj ) ] || "object" :
			typeof obj;
	}
	/* global Symbol */
	// Defining this global in .eslintrc.json would create a danger of using the global
	// unguarded in another place, it seems safer to define global only for this module



	var
		version = "3.3.1",

		// Define a local copy of jQuery
		jQuery = function( selector, context ) {

			// The jQuery object is actually just the init constructor 'enhanced'
			// Need init if jQuery is called (just allow error to be thrown if not included)
			return new jQuery.fn.init( selector, context );
		},

		// Support: Android <=4.0 only
		// Make sure we trim BOM and NBSP
		rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;

	jQuery.fn = jQuery.prototype = {

		// The current version of jQuery being used
		jquery: version,

		constructor: jQuery,

		// The default length of a jQuery object is 0
		length: 0,

		toArray: function() {
			return slice.call( this );
		},

		// Get the Nth element in the matched element set OR
		// Get the whole matched element set as a clean array
		get: function( num ) {

			// Return all the elements in a clean array
			if ( num == null ) {
				return slice.call( this );
			}

			// Return just the one element from the set
			return num < 0 ? this[ num + this.length ] : this[ num ];
		},

		// Take an array of elements and push it onto the stack
		// (returning the new matched element set)
		pushStack: function( elems ) {

			// Build a new jQuery matched element set
			var ret = jQuery.merge( this.constructor(), elems );

			// Add the old object onto the stack (as a reference)
			ret.prevObject = this;

			// Return the newly-formed element set
			return ret;
		},

		// Execute a callback for every element in the matched set.
		each: function( callback ) {
			return jQuery.each( this, callback );
		},

		map: function( callback ) {
			return this.pushStack( jQuery.map( this, function( elem, i ) {
				return callback.call( elem, i, elem );
			} ) );
		},

		slice: function() {
			return this.pushStack( slice.apply( this, arguments ) );
		},

		first: function() {
			return this.eq( 0 );
		},

		last: function() {
			return this.eq( -1 );
		},

		eq: function( i ) {
			var len = this.length,
				j = +i + ( i < 0 ? len : 0 );
			return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );
		},

		end: function() {
			return this.prevObject || this.constructor();
		},

		// For internal use only.
		// Behaves like an Array's method, not like a jQuery method.
		push: push,
		sort: arr.sort,
		splice: arr.splice
	};

	jQuery.extend = jQuery.fn.extend = function() {
		var options, name, src, copy, copyIsArray, clone,
			target = arguments[ 0 ] || {},
			i = 1,
			length = arguments.length,
			deep = false;

		// Handle a deep copy situation
		if ( typeof target === "boolean" ) {
			deep = target;

			// Skip the boolean and the target
			target = arguments[ i ] || {};
			i++;
		}

		// Handle case when target is a string or something (possible in deep copy)
		if ( typeof target !== "object" && !isFunction( target ) ) {
			target = {};
		}

		// Extend jQuery itself if only one argument is passed
		if ( i === length ) {
			target = this;
			i--;
		}

		for ( ; i < length; i++ ) {

			// Only deal with non-null/undefined values
			if ( ( options = arguments[ i ] ) != null ) {

				// Extend the base object
				for ( name in options ) {
					src = target[ name ];
					copy = options[ name ];

					// Prevent never-ending loop
					if ( target === copy ) {
						continue;
					}

					// Recurse if we're merging plain objects or arrays
					if ( deep && copy && ( jQuery.isPlainObject( copy ) ||
						( copyIsArray = Array.isArray( copy ) ) ) ) {

						if ( copyIsArray ) {
							copyIsArray = false;
							clone = src && Array.isArray( src ) ? src : [];

						} else {
							clone = src && jQuery.isPlainObject( src ) ? src : {};
						}

						// Never move original objects, clone them
						target[ name ] = jQuery.extend( deep, clone, copy );

					// Don't bring in undefined values
					} else if ( copy !== undefined ) {
						target[ name ] = copy;
					}
				}
			}
		}

		// Return the modified object
		return target;
	};

	jQuery.extend( {

		// Unique for each copy of jQuery on the page
		expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

		// Assume jQuery is ready without the ready module
		isReady: true,

		error: function( msg ) {
			throw new Error( msg );
		},

		noop: function() {},

		isPlainObject: function( obj ) {
			var proto, Ctor;

			// Detect obvious negatives
			// Use toString instead of jQuery.type to catch host objects
			if ( !obj || toString.call( obj ) !== "[object Object]" ) {
				return false;
			}

			proto = getProto( obj );

			// Objects with no prototype (e.g., `Object.create( null )`) are plain
			if ( !proto ) {
				return true;
			}

			// Objects with prototype are plain iff they were constructed by a global Object function
			Ctor = hasOwn.call( proto, "constructor" ) && proto.constructor;
			return typeof Ctor === "function" && fnToString.call( Ctor ) === ObjectFunctionString;
		},

		isEmptyObject: function( obj ) {

			/* eslint-disable no-unused-vars */
			// See https://github.com/eslint/eslint/issues/6125
			var name;

			for ( name in obj ) {
				return false;
			}
			return true;
		},

		// Evaluates a script in a global context
		globalEval: function( code ) {
			DOMEval( code );
		},

		each: function( obj, callback ) {
			var length, i = 0;

			if ( isArrayLike( obj ) ) {
				length = obj.length;
				for ( ; i < length; i++ ) {
					if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
						break;
					}
				}
			} else {
				for ( i in obj ) {
					if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
						break;
					}
				}
			}

			return obj;
		},

		// Support: Android <=4.0 only
		trim: function( text ) {
			return text == null ?
				"" :
				( text + "" ).replace( rtrim, "" );
		},

		// results is for internal usage only
		makeArray: function( arr, results ) {
			var ret = results || [];

			if ( arr != null ) {
				if ( isArrayLike( Object( arr ) ) ) {
					jQuery.merge( ret,
						typeof arr === "string" ?
						[ arr ] : arr
					);
				} else {
					push.call( ret, arr );
				}
			}

			return ret;
		},

		inArray: function( elem, arr, i ) {
			return arr == null ? -1 : indexOf.call( arr, elem, i );
		},

		// Support: Android <=4.0 only, PhantomJS 1 only
		// push.apply(_, arraylike) throws on ancient WebKit
		merge: function( first, second ) {
			var len = +second.length,
				j = 0,
				i = first.length;

			for ( ; j < len; j++ ) {
				first[ i++ ] = second[ j ];
			}

			first.length = i;

			return first;
		},

		grep: function( elems, callback, invert ) {
			var callbackInverse,
				matches = [],
				i = 0,
				length = elems.length,
				callbackExpect = !invert;

			// Go through the array, only saving the items
			// that pass the validator function
			for ( ; i < length; i++ ) {
				callbackInverse = !callback( elems[ i ], i );
				if ( callbackInverse !== callbackExpect ) {
					matches.push( elems[ i ] );
				}
			}

			return matches;
		},

		// arg is for internal usage only
		map: function( elems, callback, arg ) {
			var length, value,
				i = 0,
				ret = [];

			// Go through the array, translating each of the items to their new values
			if ( isArrayLike( elems ) ) {
				length = elems.length;
				for ( ; i < length; i++ ) {
					value = callback( elems[ i ], i, arg );

					if ( value != null ) {
						ret.push( value );
					}
				}

			// Go through every key on the object,
			} else {
				for ( i in elems ) {
					value = callback( elems[ i ], i, arg );

					if ( value != null ) {
						ret.push( value );
					}
				}
			}

			// Flatten any nested arrays
			return concat.apply( [], ret );
		},

		// A global GUID counter for objects
		guid: 1,

		// jQuery.support is not used in Core but other projects attach their
		// properties to it so it needs to exist.
		support: support
	} );

	if ( typeof Symbol === "function" ) {
		jQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];
	}

	// Populate the class2type map
	jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
	function( i, name ) {
		class2type[ "[object " + name + "]" ] = name.toLowerCase();
	} );

	function isArrayLike( obj ) {

		// Support: real iOS 8.2 only (not reproducible in simulator)
		// `in` check used to prevent JIT error (gh-2145)
		// hasOwn isn't used here due to false negatives
		// regarding Nodelist length in IE
		var length = !!obj && "length" in obj && obj.length,
			type = toType( obj );

		if ( isFunction( obj ) || isWindow( obj ) ) {
			return false;
		}

		return type === "array" || length === 0 ||
			typeof length === "number" && length > 0 && ( length - 1 ) in obj;
	}
	var Sizzle =
	/*!
	 * Sizzle CSS Selector Engine v2.3.3
	 * https://sizzlejs.com/
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license
	 * http://jquery.org/license
	 *
	 * Date: 2016-08-08
	 */
	(function( window ) {

	var i,
		support,
		Expr,
		getText,
		isXML,
		tokenize,
		compile,
		select,
		outermostContext,
		sortInput,
		hasDuplicate,

		// Local document vars
		setDocument,
		document,
		docElem,
		documentIsHTML,
		rbuggyQSA,
		rbuggyMatches,
		matches,
		contains,

		// Instance-specific data
		expando = "sizzle" + 1 * new Date(),
		preferredDoc = window.document,
		dirruns = 0,
		done = 0,
		classCache = createCache(),
		tokenCache = createCache(),
		compilerCache = createCache(),
		sortOrder = function( a, b ) {
			if ( a === b ) {
				hasDuplicate = true;
			}
			return 0;
		},

		// Instance methods
		hasOwn = ({}).hasOwnProperty,
		arr = [],
		pop = arr.pop,
		push_native = arr.push,
		push = arr.push,
		slice = arr.slice,
		// Use a stripped-down indexOf as it's faster than native
		// https://jsperf.com/thor-indexof-vs-for/5
		indexOf = function( list, elem ) {
			var i = 0,
				len = list.length;
			for ( ; i < len; i++ ) {
				if ( list[i] === elem ) {
					return i;
				}
			}
			return -1;
		},

		booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",

		// Regular expressions

		// http://www.w3.org/TR/css3-selectors/#whitespace
		whitespace = "[\\x20\\t\\r\\n\\f]",

		// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
		identifier = "(?:\\\\.|[\\w-]|[^\0-\\xa0])+",

		// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
		attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +
			// Operator (capture 2)
			"*([*^$|!~]?=)" + whitespace +
			// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
			"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
			"*\\]",

		pseudos = ":(" + identifier + ")(?:\\((" +
			// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
			// 1. quoted (capture 3; capture 4 or capture 5)
			"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
			// 2. simple (capture 6)
			"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
			// 3. anything else (capture 2)
			".*" +
			")\\)|)",

		// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
		rwhitespace = new RegExp( whitespace + "+", "g" ),
		rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),

		rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
		rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),

		rattributeQuotes = new RegExp( "=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g" ),

		rpseudo = new RegExp( pseudos ),
		ridentifier = new RegExp( "^" + identifier + "$" ),

		matchExpr = {
			"ID": new RegExp( "^#(" + identifier + ")" ),
			"CLASS": new RegExp( "^\\.(" + identifier + ")" ),
			"TAG": new RegExp( "^(" + identifier + "|[*])" ),
			"ATTR": new RegExp( "^" + attributes ),
			"PSEUDO": new RegExp( "^" + pseudos ),
			"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
				"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
				"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
			"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
			// For use in libraries implementing .is()
			// We use this for POS matching in `select`
			"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
				whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
		},

		rinputs = /^(?:input|select|textarea|button)$/i,
		rheader = /^h\d$/i,

		rnative = /^[^{]+\{\s*\[native \w/,

		// Easily-parseable/retrievable ID or TAG or CLASS selectors
		rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

		rsibling = /[+~]/,

		// CSS escapes
		// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
		runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
		funescape = function( _, escaped, escapedWhitespace ) {
			var high = "0x" + escaped - 0x10000;
			// NaN means non-codepoint
			// Support: Firefox<24
			// Workaround erroneous numeric interpretation of +"0x"
			return high !== high || escapedWhitespace ?
				escaped :
				high < 0 ?
					// BMP codepoint
					String.fromCharCode( high + 0x10000 ) :
					// Supplemental Plane codepoint (surrogate pair)
					String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
		},

		// CSS string/identifier serialization
		// https://drafts.csswg.org/cssom/#common-serializing-idioms
		rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
		fcssescape = function( ch, asCodePoint ) {
			if ( asCodePoint ) {

				// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
				if ( ch === "\0" ) {
					return "\uFFFD";
				}

				// Control characters and (dependent upon position) numbers get escaped as code points
				return ch.slice( 0, -1 ) + "\\" + ch.charCodeAt( ch.length - 1 ).toString( 16 ) + " ";
			}

			// Other potentially-special ASCII characters get backslash-escaped
			return "\\" + ch;
		},

		// Used for iframes
		// See setDocument()
		// Removing the function wrapper causes a "Permission Denied"
		// error in IE
		unloadHandler = function() {
			setDocument();
		},

		disabledAncestor = addCombinator(
			function( elem ) {
				return elem.disabled === true && ("form" in elem || "label" in elem);
			},
			{ dir: "parentNode", next: "legend" }
		);

	// Optimize for push.apply( _, NodeList )
	try {
		push.apply(
			(arr = slice.call( preferredDoc.childNodes )),
			preferredDoc.childNodes
		);
		// Support: Android<4.0
		// Detect silently failing push.apply
		arr[ preferredDoc.childNodes.length ].nodeType;
	} catch ( e ) {
		push = { apply: arr.length ?

			// Leverage slice if possible
			function( target, els ) {
				push_native.apply( target, slice.call(els) );
			} :

			// Support: IE<9
			// Otherwise append directly
			function( target, els ) {
				var j = target.length,
					i = 0;
				// Can't trust NodeList.length
				while ( (target[j++] = els[i++]) ) {}
				target.length = j - 1;
			}
		};
	}

	function Sizzle( selector, context, results, seed ) {
		var m, i, elem, nid, match, groups, newSelector,
			newContext = context && context.ownerDocument,

			// nodeType defaults to 9, since context defaults to document
			nodeType = context ? context.nodeType : 9;

		results = results || [];

		// Return early from calls with invalid selector or context
		if ( typeof selector !== "string" || !selector ||
			nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

			return results;
		}

		// Try to shortcut find operations (as opposed to filters) in HTML documents
		if ( !seed ) {

			if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
				setDocument( context );
			}
			context = context || document;

			if ( documentIsHTML ) {

				// If the selector is sufficiently simple, try using a "get*By*" DOM method
				// (excepting DocumentFragment context, where the methods don't exist)
				if ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {

					// ID selector
					if ( (m = match[1]) ) {

						// Document context
						if ( nodeType === 9 ) {
							if ( (elem = context.getElementById( m )) ) {

								// Support: IE, Opera, Webkit
								// TODO: identify versions
								// getElementById can match elements by name instead of ID
								if ( elem.id === m ) {
									results.push( elem );
									return results;
								}
							} else {
								return results;
							}

						// Element context
						} else {

							// Support: IE, Opera, Webkit
							// TODO: identify versions
							// getElementById can match elements by name instead of ID
							if ( newContext && (elem = newContext.getElementById( m )) &&
								contains( context, elem ) &&
								elem.id === m ) {

								results.push( elem );
								return results;
							}
						}

					// Type selector
					} else if ( match[2] ) {
						push.apply( results, context.getElementsByTagName( selector ) );
						return results;

					// Class selector
					} else if ( (m = match[3]) && support.getElementsByClassName &&
						context.getElementsByClassName ) {

						push.apply( results, context.getElementsByClassName( m ) );
						return results;
					}
				}

				// Take advantage of querySelectorAll
				if ( support.qsa &&
					!compilerCache[ selector + " " ] &&
					(!rbuggyQSA || !rbuggyQSA.test( selector )) ) {

					if ( nodeType !== 1 ) {
						newContext = context;
						newSelector = selector;

					// qSA looks outside Element context, which is not what we want
					// Thanks to Andrew Dupont for this workaround technique
					// Support: IE <=8
					// Exclude object elements
					} else if ( context.nodeName.toLowerCase() !== "object" ) {

						// Capture the context ID, setting it first if necessary
						if ( (nid = context.getAttribute( "id" )) ) {
							nid = nid.replace( rcssescape, fcssescape );
						} else {
							context.setAttribute( "id", (nid = expando) );
						}

						// Prefix every selector in the list
						groups = tokenize( selector );
						i = groups.length;
						while ( i-- ) {
							groups[i] = "#" + nid + " " + toSelector( groups[i] );
						}
						newSelector = groups.join( "," );

						// Expand context for sibling selectors
						newContext = rsibling.test( selector ) && testContext( context.parentNode ) ||
							context;
					}

					if ( newSelector ) {
						try {
							push.apply( results,
								newContext.querySelectorAll( newSelector )
							);
							return results;
						} catch ( qsaError ) {
						} finally {
							if ( nid === expando ) {
								context.removeAttribute( "id" );
							}
						}
					}
				}
			}
		}

		// All others
		return select( selector.replace( rtrim, "$1" ), context, results, seed );
	}

	/**
	 * Create key-value caches of limited size
	 * @returns {function(string, object)} Returns the Object data after storing it on itself with
	 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
	 *	deleting the oldest entry
	 */
	function createCache() {
		var keys = [];

		function cache( key, value ) {
			// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
			if ( keys.push( key + " " ) > Expr.cacheLength ) {
				// Only keep the most recent entries
				delete cache[ keys.shift() ];
			}
			return (cache[ key + " " ] = value);
		}
		return cache;
	}

	/**
	 * Mark a function for special use by Sizzle
	 * @param {Function} fn The function to mark
	 */
	function markFunction( fn ) {
		fn[ expando ] = true;
		return fn;
	}

	/**
	 * Support testing using an element
	 * @param {Function} fn Passed the created element and returns a boolean result
	 */
	function assert( fn ) {
		var el = document.createElement("fieldset");

		try {
			return !!fn( el );
		} catch (e) {
			return false;
		} finally {
			// Remove from its parent by default
			if ( el.parentNode ) {
				el.parentNode.removeChild( el );
			}
			// release memory in IE
			el = null;
		}
	}

	/**
	 * Adds the same handler for all of the specified attrs
	 * @param {String} attrs Pipe-separated list of attributes
	 * @param {Function} handler The method that will be applied
	 */
	function addHandle( attrs, handler ) {
		var arr = attrs.split("|"),
			i = arr.length;

		while ( i-- ) {
			Expr.attrHandle[ arr[i] ] = handler;
		}
	}

	/**
	 * Checks document order of two siblings
	 * @param {Element} a
	 * @param {Element} b
	 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
	 */
	function siblingCheck( a, b ) {
		var cur = b && a,
			diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
				a.sourceIndex - b.sourceIndex;

		// Use IE sourceIndex if available on both nodes
		if ( diff ) {
			return diff;
		}

		// Check if b follows a
		if ( cur ) {
			while ( (cur = cur.nextSibling) ) {
				if ( cur === b ) {
					return -1;
				}
			}
		}

		return a ? 1 : -1;
	}

	/**
	 * Returns a function to use in pseudos for input types
	 * @param {String} type
	 */
	function createInputPseudo( type ) {
		return function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === type;
		};
	}

	/**
	 * Returns a function to use in pseudos for buttons
	 * @param {String} type
	 */
	function createButtonPseudo( type ) {
		return function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return (name === "input" || name === "button") && elem.type === type;
		};
	}

	/**
	 * Returns a function to use in pseudos for :enabled/:disabled
	 * @param {Boolean} disabled true for :disabled; false for :enabled
	 */
	function createDisabledPseudo( disabled ) {

		// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
		return function( elem ) {

			// Only certain elements can match :enabled or :disabled
			// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
			// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
			if ( "form" in elem ) {

				// Check for inherited disabledness on relevant non-disabled elements:
				// * listed form-associated elements in a disabled fieldset
				//   https://html.spec.whatwg.org/multipage/forms.html#category-listed
				//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
				// * option elements in a disabled optgroup
				//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
				// All such elements have a "form" property.
				if ( elem.parentNode && elem.disabled === false ) {

					// Option elements defer to a parent optgroup if present
					if ( "label" in elem ) {
						if ( "label" in elem.parentNode ) {
							return elem.parentNode.disabled === disabled;
						} else {
							return elem.disabled === disabled;
						}
					}

					// Support: IE 6 - 11
					// Use the isDisabled shortcut property to check for disabled fieldset ancestors
					return elem.isDisabled === disabled ||

						// Where there is no isDisabled, check manually
						/* jshint -W018 */
						elem.isDisabled !== !disabled &&
							disabledAncestor( elem ) === disabled;
				}

				return elem.disabled === disabled;

			// Try to winnow out elements that can't be disabled before trusting the disabled property.
			// Some victims get caught in our net (label, legend, menu, track), but it shouldn't
			// even exist on them, let alone have a boolean value.
			} else if ( "label" in elem ) {
				return elem.disabled === disabled;
			}

			// Remaining elements are neither :enabled nor :disabled
			return false;
		};
	}

	/**
	 * Returns a function to use in pseudos for positionals
	 * @param {Function} fn
	 */
	function createPositionalPseudo( fn ) {
		return markFunction(function( argument ) {
			argument = +argument;
			return markFunction(function( seed, matches ) {
				var j,
					matchIndexes = fn( [], seed.length, argument ),
					i = matchIndexes.length;

				// Match elements found at the specified indexes
				while ( i-- ) {
					if ( seed[ (j = matchIndexes[i]) ] ) {
						seed[j] = !(matches[j] = seed[j]);
					}
				}
			});
		});
	}

	/**
	 * Checks a node for validity as a Sizzle context
	 * @param {Element|Object=} context
	 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
	 */
	function testContext( context ) {
		return context && typeof context.getElementsByTagName !== "undefined" && context;
	}

	// Expose support vars for convenience
	support = Sizzle.support = {};

	/**
	 * Detects XML nodes
	 * @param {Element|Object} elem An element or a document
	 * @returns {Boolean} True iff elem is a non-HTML XML node
	 */
	isXML = Sizzle.isXML = function( elem ) {
		// documentElement is verified for cases where it doesn't yet exist
		// (such as loading iframes in IE - #4833)
		var documentElement = elem && (elem.ownerDocument || elem).documentElement;
		return documentElement ? documentElement.nodeName !== "HTML" : false;
	};

	/**
	 * Sets document-related variables once based on the current document
	 * @param {Element|Object} [doc] An element or document object to use to set the document
	 * @returns {Object} Returns the current document
	 */
	setDocument = Sizzle.setDocument = function( node ) {
		var hasCompare, subWindow,
			doc = node ? node.ownerDocument || node : preferredDoc;

		// Return early if doc is invalid or already selected
		if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
			return document;
		}

		// Update global variables
		document = doc;
		docElem = document.documentElement;
		documentIsHTML = !isXML( document );

		// Support: IE 9-11, Edge
		// Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
		if ( preferredDoc !== document &&
			(subWindow = document.defaultView) && subWindow.top !== subWindow ) {

			// Support: IE 11, Edge
			if ( subWindow.addEventListener ) {
				subWindow.addEventListener( "unload", unloadHandler, false );

			// Support: IE 9 - 10 only
			} else if ( subWindow.attachEvent ) {
				subWindow.attachEvent( "onunload", unloadHandler );
			}
		}

		/* Attributes
		---------------------------------------------------------------------- */

		// Support: IE<8
		// Verify that getAttribute really returns attributes and not properties
		// (excepting IE8 booleans)
		support.attributes = assert(function( el ) {
			el.className = "i";
			return !el.getAttribute("className");
		});

		/* getElement(s)By*
		---------------------------------------------------------------------- */

		// Check if getElementsByTagName("*") returns only elements
		support.getElementsByTagName = assert(function( el ) {
			el.appendChild( document.createComment("") );
			return !el.getElementsByTagName("*").length;
		});

		// Support: IE<9
		support.getElementsByClassName = rnative.test( document.getElementsByClassName );

		// Support: IE<10
		// Check if getElementById returns elements by name
		// The broken getElementById methods don't pick up programmatically-set names,
		// so use a roundabout getElementsByName test
		support.getById = assert(function( el ) {
			docElem.appendChild( el ).id = expando;
			return !document.getElementsByName || !document.getElementsByName( expando ).length;
		});

		// ID filter and find
		if ( support.getById ) {
			Expr.filter["ID"] = function( id ) {
				var attrId = id.replace( runescape, funescape );
				return function( elem ) {
					return elem.getAttribute("id") === attrId;
				};
			};
			Expr.find["ID"] = function( id, context ) {
				if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
					var elem = context.getElementById( id );
					return elem ? [ elem ] : [];
				}
			};
		} else {
			Expr.filter["ID"] =  function( id ) {
				var attrId = id.replace( runescape, funescape );
				return function( elem ) {
					var node = typeof elem.getAttributeNode !== "undefined" &&
						elem.getAttributeNode("id");
					return node && node.value === attrId;
				};
			};

			// Support: IE 6 - 7 only
			// getElementById is not reliable as a find shortcut
			Expr.find["ID"] = function( id, context ) {
				if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
					var node, i, elems,
						elem = context.getElementById( id );

					if ( elem ) {

						// Verify the id attribute
						node = elem.getAttributeNode("id");
						if ( node && node.value === id ) {
							return [ elem ];
						}

						// Fall back on getElementsByName
						elems = context.getElementsByName( id );
						i = 0;
						while ( (elem = elems[i++]) ) {
							node = elem.getAttributeNode("id");
							if ( node && node.value === id ) {
								return [ elem ];
							}
						}
					}

					return [];
				}
			};
		}

		// Tag
		Expr.find["TAG"] = support.getElementsByTagName ?
			function( tag, context ) {
				if ( typeof context.getElementsByTagName !== "undefined" ) {
					return context.getElementsByTagName( tag );

				// DocumentFragment nodes don't have gEBTN
				} else if ( support.qsa ) {
					return context.querySelectorAll( tag );
				}
			} :

			function( tag, context ) {
				var elem,
					tmp = [],
					i = 0,
					// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
					results = context.getElementsByTagName( tag );

				// Filter out possible comments
				if ( tag === "*" ) {
					while ( (elem = results[i++]) ) {
						if ( elem.nodeType === 1 ) {
							tmp.push( elem );
						}
					}

					return tmp;
				}
				return results;
			};

		// Class
		Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
			if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
				return context.getElementsByClassName( className );
			}
		};

		/* QSA/matchesSelector
		---------------------------------------------------------------------- */

		// QSA and matchesSelector support

		// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
		rbuggyMatches = [];

		// qSa(:focus) reports false when true (Chrome 21)
		// We allow this because of a bug in IE8/9 that throws an error
		// whenever `document.activeElement` is accessed on an iframe
		// So, we allow :focus to pass through QSA all the time to avoid the IE error
		// See https://bugs.jquery.com/ticket/13378
		rbuggyQSA = [];

		if ( (support.qsa = rnative.test( document.querySelectorAll )) ) {
			// Build QSA regex
			// Regex strategy adopted from Diego Perini
			assert(function( el ) {
				// Select is set to empty string on purpose
				// This is to test IE's treatment of not explicitly
				// setting a boolean content attribute,
				// since its presence should be enough
				// https://bugs.jquery.com/ticket/12359
				docElem.appendChild( el ).innerHTML = "<a id='" + expando + "'></a>" +
					"<select id='" + expando + "-\r\\' msallowcapture=''>" +
					"<option selected=''></option></select>";

				// Support: IE8, Opera 11-12.16
				// Nothing should be selected when empty strings follow ^= or $= or *=
				// The test attribute must be unknown in Opera but "safe" for WinRT
				// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
				if ( el.querySelectorAll("[msallowcapture^='']").length ) {
					rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
				}

				// Support: IE8
				// Boolean attributes and "value" are not treated correctly
				if ( !el.querySelectorAll("[selected]").length ) {
					rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
				}

				// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
				if ( !el.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
					rbuggyQSA.push("~=");
				}

				// Webkit/Opera - :checked should return selected option elements
				// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
				// IE8 throws error here and will not see later tests
				if ( !el.querySelectorAll(":checked").length ) {
					rbuggyQSA.push(":checked");
				}

				// Support: Safari 8+, iOS 8+
				// https://bugs.webkit.org/show_bug.cgi?id=136851
				// In-page `selector#id sibling-combinator selector` fails
				if ( !el.querySelectorAll( "a#" + expando + "+*" ).length ) {
					rbuggyQSA.push(".#.+[+~]");
				}
			});

			assert(function( el ) {
				el.innerHTML = "<a href='' disabled='disabled'></a>" +
					"<select disabled='disabled'><option/></select>";

				// Support: Windows 8 Native Apps
				// The type and name attributes are restricted during .innerHTML assignment
				var input = document.createElement("input");
				input.setAttribute( "type", "hidden" );
				el.appendChild( input ).setAttribute( "name", "D" );

				// Support: IE8
				// Enforce case-sensitivity of name attribute
				if ( el.querySelectorAll("[name=d]").length ) {
					rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
				}

				// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
				// IE8 throws error here and will not see later tests
				if ( el.querySelectorAll(":enabled").length !== 2 ) {
					rbuggyQSA.push( ":enabled", ":disabled" );
				}

				// Support: IE9-11+
				// IE's :disabled selector does not pick up the children of disabled fieldsets
				docElem.appendChild( el ).disabled = true;
				if ( el.querySelectorAll(":disabled").length !== 2 ) {
					rbuggyQSA.push( ":enabled", ":disabled" );
				}

				// Opera 10-11 does not throw on post-comma invalid pseudos
				el.querySelectorAll("*,:x");
				rbuggyQSA.push(",.*:");
			});
		}

		if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
			docElem.webkitMatchesSelector ||
			docElem.mozMatchesSelector ||
			docElem.oMatchesSelector ||
			docElem.msMatchesSelector) )) ) {

			assert(function( el ) {
				// Check to see if it's possible to do matchesSelector
				// on a disconnected node (IE 9)
				support.disconnectedMatch = matches.call( el, "*" );

				// This should fail with an exception
				// Gecko does not error, returns false instead
				matches.call( el, "[s!='']:x" );
				rbuggyMatches.push( "!=", pseudos );
			});
		}

		rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
		rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );

		/* Contains
		---------------------------------------------------------------------- */
		hasCompare = rnative.test( docElem.compareDocumentPosition );

		// Element contains another
		// Purposefully self-exclusive
		// As in, an element does not contain itself
		contains = hasCompare || rnative.test( docElem.contains ) ?
			function( a, b ) {
				var adown = a.nodeType === 9 ? a.documentElement : a,
					bup = b && b.parentNode;
				return a === bup || !!( bup && bup.nodeType === 1 && (
					adown.contains ?
						adown.contains( bup ) :
						a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
				));
			} :
			function( a, b ) {
				if ( b ) {
					while ( (b = b.parentNode) ) {
						if ( b === a ) {
							return true;
						}
					}
				}
				return false;
			};

		/* Sorting
		---------------------------------------------------------------------- */

		// Document order sorting
		sortOrder = hasCompare ?
		function( a, b ) {

			// Flag for duplicate removal
			if ( a === b ) {
				hasDuplicate = true;
				return 0;
			}

			// Sort on method existence if only one input has compareDocumentPosition
			var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
			if ( compare ) {
				return compare;
			}

			// Calculate position if both inputs belong to the same document
			compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
				a.compareDocumentPosition( b ) :

				// Otherwise we know they are disconnected
				1;

			// Disconnected nodes
			if ( compare & 1 ||
				(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {

				// Choose the first element that is related to our preferred document
				if ( a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
					return -1;
				}
				if ( b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
					return 1;
				}

				// Maintain original order
				return sortInput ?
					( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
					0;
			}

			return compare & 4 ? -1 : 1;
		} :
		function( a, b ) {
			// Exit early if the nodes are identical
			if ( a === b ) {
				hasDuplicate = true;
				return 0;
			}

			var cur,
				i = 0,
				aup = a.parentNode,
				bup = b.parentNode,
				ap = [ a ],
				bp = [ b ];

			// Parentless nodes are either documents or disconnected
			if ( !aup || !bup ) {
				return a === document ? -1 :
					b === document ? 1 :
					aup ? -1 :
					bup ? 1 :
					sortInput ?
					( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
					0;

			// If the nodes are siblings, we can do a quick check
			} else if ( aup === bup ) {
				return siblingCheck( a, b );
			}

			// Otherwise we need full lists of their ancestors for comparison
			cur = a;
			while ( (cur = cur.parentNode) ) {
				ap.unshift( cur );
			}
			cur = b;
			while ( (cur = cur.parentNode) ) {
				bp.unshift( cur );
			}

			// Walk down the tree looking for a discrepancy
			while ( ap[i] === bp[i] ) {
				i++;
			}

			return i ?
				// Do a sibling check if the nodes have a common ancestor
				siblingCheck( ap[i], bp[i] ) :

				// Otherwise nodes in our document sort first
				ap[i] === preferredDoc ? -1 :
				bp[i] === preferredDoc ? 1 :
				0;
		};

		return document;
	};

	Sizzle.matches = function( expr, elements ) {
		return Sizzle( expr, null, null, elements );
	};

	Sizzle.matchesSelector = function( elem, expr ) {
		// Set document vars if needed
		if ( ( elem.ownerDocument || elem ) !== document ) {
			setDocument( elem );
		}

		// Make sure that attribute selectors are quoted
		expr = expr.replace( rattributeQuotes, "='$1']" );

		if ( support.matchesSelector && documentIsHTML &&
			!compilerCache[ expr + " " ] &&
			( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
			( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

			try {
				var ret = matches.call( elem, expr );

				// IE 9's matchesSelector returns false on disconnected nodes
				if ( ret || support.disconnectedMatch ||
						// As well, disconnected nodes are said to be in a document
						// fragment in IE 9
						elem.document && elem.document.nodeType !== 11 ) {
					return ret;
				}
			} catch (e) {}
		}

		return Sizzle( expr, document, null, [ elem ] ).length > 0;
	};

	Sizzle.contains = function( context, elem ) {
		// Set document vars if needed
		if ( ( context.ownerDocument || context ) !== document ) {
			setDocument( context );
		}
		return contains( context, elem );
	};

	Sizzle.attr = function( elem, name ) {
		// Set document vars if needed
		if ( ( elem.ownerDocument || elem ) !== document ) {
			setDocument( elem );
		}

		var fn = Expr.attrHandle[ name.toLowerCase() ],
			// Don't get fooled by Object.prototype properties (jQuery #13807)
			val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
				fn( elem, name, !documentIsHTML ) :
				undefined;

		return val !== undefined ?
			val :
			support.attributes || !documentIsHTML ?
				elem.getAttribute( name ) :
				(val = elem.getAttributeNode(name)) && val.specified ?
					val.value :
					null;
	};

	Sizzle.escape = function( sel ) {
		return (sel + "").replace( rcssescape, fcssescape );
	};

	Sizzle.error = function( msg ) {
		throw new Error( "Syntax error, unrecognized expression: " + msg );
	};

	/**
	 * Document sorting and removing duplicates
	 * @param {ArrayLike} results
	 */
	Sizzle.uniqueSort = function( results ) {
		var elem,
			duplicates = [],
			j = 0,
			i = 0;

		// Unless we *know* we can detect duplicates, assume their presence
		hasDuplicate = !support.detectDuplicates;
		sortInput = !support.sortStable && results.slice( 0 );
		results.sort( sortOrder );

		if ( hasDuplicate ) {
			while ( (elem = results[i++]) ) {
				if ( elem === results[ i ] ) {
					j = duplicates.push( i );
				}
			}
			while ( j-- ) {
				results.splice( duplicates[ j ], 1 );
			}
		}

		// Clear input after sorting to release objects
		// See https://github.com/jquery/sizzle/pull/225
		sortInput = null;

		return results;
	};

	/**
	 * Utility function for retrieving the text value of an array of DOM nodes
	 * @param {Array|Element} elem
	 */
	getText = Sizzle.getText = function( elem ) {
		var node,
			ret = "",
			i = 0,
			nodeType = elem.nodeType;

		if ( !nodeType ) {
			// If no nodeType, this is expected to be an array
			while ( (node = elem[i++]) ) {
				// Do not traverse comment nodes
				ret += getText( node );
			}
		} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
			// Use textContent for elements
			// innerText usage removed for consistency of new lines (jQuery #11153)
			if ( typeof elem.textContent === "string" ) {
				return elem.textContent;
			} else {
				// Traverse its children
				for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
					ret += getText( elem );
				}
			}
		} else if ( nodeType === 3 || nodeType === 4 ) {
			return elem.nodeValue;
		}
		// Do not include comment or processing instruction nodes

		return ret;
	};

	Expr = Sizzle.selectors = {

		// Can be adjusted by the user
		cacheLength: 50,

		createPseudo: markFunction,

		match: matchExpr,

		attrHandle: {},

		find: {},

		relative: {
			">": { dir: "parentNode", first: true },
			" ": { dir: "parentNode" },
			"+": { dir: "previousSibling", first: true },
			"~": { dir: "previousSibling" }
		},

		preFilter: {
			"ATTR": function( match ) {
				match[1] = match[1].replace( runescape, funescape );

				// Move the given value to match[3] whether quoted or unquoted
				match[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );

				if ( match[2] === "~=" ) {
					match[3] = " " + match[3] + " ";
				}

				return match.slice( 0, 4 );
			},

			"CHILD": function( match ) {
				/* matches from matchExpr["CHILD"]
					1 type (only|nth|...)
					2 what (child|of-type)
					3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
					4 xn-component of xn+y argument ([+-]?\d*n|)
					5 sign of xn-component
					6 x of xn-component
					7 sign of y-component
					8 y of y-component
				*/
				match[1] = match[1].toLowerCase();

				if ( match[1].slice( 0, 3 ) === "nth" ) {
					// nth-* requires argument
					if ( !match[3] ) {
						Sizzle.error( match[0] );
					}

					// numeric x and y parameters for Expr.filter.CHILD
					// remember that false/true cast respectively to 0/1
					match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
					match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );

				// other types prohibit arguments
				} else if ( match[3] ) {
					Sizzle.error( match[0] );
				}

				return match;
			},

			"PSEUDO": function( match ) {
				var excess,
					unquoted = !match[6] && match[2];

				if ( matchExpr["CHILD"].test( match[0] ) ) {
					return null;
				}

				// Accept quoted arguments as-is
				if ( match[3] ) {
					match[2] = match[4] || match[5] || "";

				// Strip excess characters from unquoted arguments
				} else if ( unquoted && rpseudo.test( unquoted ) &&
					// Get excess from tokenize (recursively)
					(excess = tokenize( unquoted, true )) &&
					// advance to the next closing parenthesis
					(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {

					// excess is a negative index
					match[0] = match[0].slice( 0, excess );
					match[2] = unquoted.slice( 0, excess );
				}

				// Return only captures needed by the pseudo filter method (type and argument)
				return match.slice( 0, 3 );
			}
		},

		filter: {

			"TAG": function( nodeNameSelector ) {
				var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
				return nodeNameSelector === "*" ?
					function() { return true; } :
					function( elem ) {
						return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
					};
			},

			"CLASS": function( className ) {
				var pattern = classCache[ className + " " ];

				return pattern ||
					(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
					classCache( className, function( elem ) {
						return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "" );
					});
			},

			"ATTR": function( name, operator, check ) {
				return function( elem ) {
					var result = Sizzle.attr( elem, name );

					if ( result == null ) {
						return operator === "!=";
					}
					if ( !operator ) {
						return true;
					}

					result += "";

					return operator === "=" ? result === check :
						operator === "!=" ? result !== check :
						operator === "^=" ? check && result.indexOf( check ) === 0 :
						operator === "*=" ? check && result.indexOf( check ) > -1 :
						operator === "$=" ? check && result.slice( -check.length ) === check :
						operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
						operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
						false;
				};
			},

			"CHILD": function( type, what, argument, first, last ) {
				var simple = type.slice( 0, 3 ) !== "nth",
					forward = type.slice( -4 ) !== "last",
					ofType = what === "of-type";

				return first === 1 && last === 0 ?

					// Shortcut for :nth-*(n)
					function( elem ) {
						return !!elem.parentNode;
					} :

					function( elem, context, xml ) {
						var cache, uniqueCache, outerCache, node, nodeIndex, start,
							dir = simple !== forward ? "nextSibling" : "previousSibling",
							parent = elem.parentNode,
							name = ofType && elem.nodeName.toLowerCase(),
							useCache = !xml && !ofType,
							diff = false;

						if ( parent ) {

							// :(first|last|only)-(child|of-type)
							if ( simple ) {
								while ( dir ) {
									node = elem;
									while ( (node = node[ dir ]) ) {
										if ( ofType ?
											node.nodeName.toLowerCase() === name :
											node.nodeType === 1 ) {

											return false;
										}
									}
									// Reverse direction for :only-* (if we haven't yet done so)
									start = dir = type === "only" && !start && "nextSibling";
								}
								return true;
							}

							start = [ forward ? parent.firstChild : parent.lastChild ];

							// non-xml :nth-child(...) stores cache data on `parent`
							if ( forward && useCache ) {

								// Seek `elem` from a previously-cached index

								// ...in a gzip-friendly way
								node = parent;
								outerCache = node[ expando ] || (node[ expando ] = {});

								// Support: IE <9 only
								// Defend against cloned attroperties (jQuery gh-1709)
								uniqueCache = outerCache[ node.uniqueID ] ||
									(outerCache[ node.uniqueID ] = {});

								cache = uniqueCache[ type ] || [];
								nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
								diff = nodeIndex && cache[ 2 ];
								node = nodeIndex && parent.childNodes[ nodeIndex ];

								while ( (node = ++nodeIndex && node && node[ dir ] ||

									// Fallback to seeking `elem` from the start
									(diff = nodeIndex = 0) || start.pop()) ) {

									// When found, cache indexes on `parent` and break
									if ( node.nodeType === 1 && ++diff && node === elem ) {
										uniqueCache[ type ] = [ dirruns, nodeIndex, diff ];
										break;
									}
								}

							} else {
								// Use previously-cached element index if available
								if ( useCache ) {
									// ...in a gzip-friendly way
									node = elem;
									outerCache = node[ expando ] || (node[ expando ] = {});

									// Support: IE <9 only
									// Defend against cloned attroperties (jQuery gh-1709)
									uniqueCache = outerCache[ node.uniqueID ] ||
										(outerCache[ node.uniqueID ] = {});

									cache = uniqueCache[ type ] || [];
									nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
									diff = nodeIndex;
								}

								// xml :nth-child(...)
								// or :nth-last-child(...) or :nth(-last)?-of-type(...)
								if ( diff === false ) {
									// Use the same loop as above to seek `elem` from the start
									while ( (node = ++nodeIndex && node && node[ dir ] ||
										(diff = nodeIndex = 0) || start.pop()) ) {

										if ( ( ofType ?
											node.nodeName.toLowerCase() === name :
											node.nodeType === 1 ) &&
											++diff ) {

											// Cache the index of each encountered element
											if ( useCache ) {
												outerCache = node[ expando ] || (node[ expando ] = {});

												// Support: IE <9 only
												// Defend against cloned attroperties (jQuery gh-1709)
												uniqueCache = outerCache[ node.uniqueID ] ||
													(outerCache[ node.uniqueID ] = {});

												uniqueCache[ type ] = [ dirruns, diff ];
											}

											if ( node === elem ) {
												break;
											}
										}
									}
								}
							}

							// Incorporate the offset, then check against cycle size
							diff -= last;
							return diff === first || ( diff % first === 0 && diff / first >= 0 );
						}
					};
			},

			"PSEUDO": function( pseudo, argument ) {
				// pseudo-class names are case-insensitive
				// http://www.w3.org/TR/selectors/#pseudo-classes
				// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
				// Remember that setFilters inherits from pseudos
				var args,
					fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
						Sizzle.error( "unsupported pseudo: " + pseudo );

				// The user may use createPseudo to indicate that
				// arguments are needed to create the filter function
				// just as Sizzle does
				if ( fn[ expando ] ) {
					return fn( argument );
				}

				// But maintain support for old signatures
				if ( fn.length > 1 ) {
					args = [ pseudo, pseudo, "", argument ];
					return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
						markFunction(function( seed, matches ) {
							var idx,
								matched = fn( seed, argument ),
								i = matched.length;
							while ( i-- ) {
								idx = indexOf( seed, matched[i] );
								seed[ idx ] = !( matches[ idx ] = matched[i] );
							}
						}) :
						function( elem ) {
							return fn( elem, 0, args );
						};
				}

				return fn;
			}
		},

		pseudos: {
			// Potentially complex pseudos
			"not": markFunction(function( selector ) {
				// Trim the selector passed to compile
				// to avoid treating leading and trailing
				// spaces as combinators
				var input = [],
					results = [],
					matcher = compile( selector.replace( rtrim, "$1" ) );

				return matcher[ expando ] ?
					markFunction(function( seed, matches, context, xml ) {
						var elem,
							unmatched = matcher( seed, null, xml, [] ),
							i = seed.length;

						// Match elements unmatched by `matcher`
						while ( i-- ) {
							if ( (elem = unmatched[i]) ) {
								seed[i] = !(matches[i] = elem);
							}
						}
					}) :
					function( elem, context, xml ) {
						input[0] = elem;
						matcher( input, null, xml, results );
						// Don't keep the element (issue #299)
						input[0] = null;
						return !results.pop();
					};
			}),

			"has": markFunction(function( selector ) {
				return function( elem ) {
					return Sizzle( selector, elem ).length > 0;
				};
			}),

			"contains": markFunction(function( text ) {
				text = text.replace( runescape, funescape );
				return function( elem ) {
					return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
				};
			}),

			// "Whether an element is represented by a :lang() selector
			// is based solely on the element's language value
			// being equal to the identifier C,
			// or beginning with the identifier C immediately followed by "-".
			// The matching of C against the element's language value is performed case-insensitively.
			// The identifier C does not have to be a valid language name."
			// http://www.w3.org/TR/selectors/#lang-pseudo
			"lang": markFunction( function( lang ) {
				// lang value must be a valid identifier
				if ( !ridentifier.test(lang || "") ) {
					Sizzle.error( "unsupported lang: " + lang );
				}
				lang = lang.replace( runescape, funescape ).toLowerCase();
				return function( elem ) {
					var elemLang;
					do {
						if ( (elemLang = documentIsHTML ?
							elem.lang :
							elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {

							elemLang = elemLang.toLowerCase();
							return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
						}
					} while ( (elem = elem.parentNode) && elem.nodeType === 1 );
					return false;
				};
			}),

			// Miscellaneous
			"target": function( elem ) {
				var hash = window.location && window.location.hash;
				return hash && hash.slice( 1 ) === elem.id;
			},

			"root": function( elem ) {
				return elem === docElem;
			},

			"focus": function( elem ) {
				return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
			},

			// Boolean properties
			"enabled": createDisabledPseudo( false ),
			"disabled": createDisabledPseudo( true ),

			"checked": function( elem ) {
				// In CSS3, :checked should return both checked and selected elements
				// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
				var nodeName = elem.nodeName.toLowerCase();
				return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
			},

			"selected": function( elem ) {
				// Accessing this property makes selected-by-default
				// options in Safari work properly
				if ( elem.parentNode ) {
					elem.parentNode.selectedIndex;
				}

				return elem.selected === true;
			},

			// Contents
			"empty": function( elem ) {
				// http://www.w3.org/TR/selectors/#empty-pseudo
				// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
				//   but not by others (comment: 8; processing instruction: 7; etc.)
				// nodeType < 6 works because attributes (2) do not appear as children
				for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
					if ( elem.nodeType < 6 ) {
						return false;
					}
				}
				return true;
			},

			"parent": function( elem ) {
				return !Expr.pseudos["empty"]( elem );
			},

			// Element/input types
			"header": function( elem ) {
				return rheader.test( elem.nodeName );
			},

			"input": function( elem ) {
				return rinputs.test( elem.nodeName );
			},

			"button": function( elem ) {
				var name = elem.nodeName.toLowerCase();
				return name === "input" && elem.type === "button" || name === "button";
			},

			"text": function( elem ) {
				var attr;
				return elem.nodeName.toLowerCase() === "input" &&
					elem.type === "text" &&

					// Support: IE<8
					// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
					( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
			},

			// Position-in-collection
			"first": createPositionalPseudo(function() {
				return [ 0 ];
			}),

			"last": createPositionalPseudo(function( matchIndexes, length ) {
				return [ length - 1 ];
			}),

			"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
				return [ argument < 0 ? argument + length : argument ];
			}),

			"even": createPositionalPseudo(function( matchIndexes, length ) {
				var i = 0;
				for ( ; i < length; i += 2 ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			}),

			"odd": createPositionalPseudo(function( matchIndexes, length ) {
				var i = 1;
				for ( ; i < length; i += 2 ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			}),

			"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
				var i = argument < 0 ? argument + length : argument;
				for ( ; --i >= 0; ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			}),

			"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
				var i = argument < 0 ? argument + length : argument;
				for ( ; ++i < length; ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			})
		}
	};

	Expr.pseudos["nth"] = Expr.pseudos["eq"];

	// Add button/input type pseudos
	for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
		Expr.pseudos[ i ] = createInputPseudo( i );
	}
	for ( i in { submit: true, reset: true } ) {
		Expr.pseudos[ i ] = createButtonPseudo( i );
	}

	// Easy API for creating new setFilters
	function setFilters() {}
	setFilters.prototype = Expr.filters = Expr.pseudos;
	Expr.setFilters = new setFilters();

	tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
		var matched, match, tokens, type,
			soFar, groups, preFilters,
			cached = tokenCache[ selector + " " ];

		if ( cached ) {
			return parseOnly ? 0 : cached.slice( 0 );
		}

		soFar = selector;
		groups = [];
		preFilters = Expr.preFilter;

		while ( soFar ) {

			// Comma and first run
			if ( !matched || (match = rcomma.exec( soFar )) ) {
				if ( match ) {
					// Don't consume trailing commas as valid
					soFar = soFar.slice( match[0].length ) || soFar;
				}
				groups.push( (tokens = []) );
			}

			matched = false;

			// Combinators
			if ( (match = rcombinators.exec( soFar )) ) {
				matched = match.shift();
				tokens.push({
					value: matched,
					// Cast descendant combinators to space
					type: match[0].replace( rtrim, " " )
				});
				soFar = soFar.slice( matched.length );
			}

			// Filters
			for ( type in Expr.filter ) {
				if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
					(match = preFilters[ type ]( match ))) ) {
					matched = match.shift();
					tokens.push({
						value: matched,
						type: type,
						matches: match
					});
					soFar = soFar.slice( matched.length );
				}
			}

			if ( !matched ) {
				break;
			}
		}

		// Return the length of the invalid excess
		// if we're just parsing
		// Otherwise, throw an error or return tokens
		return parseOnly ?
			soFar.length :
			soFar ?
				Sizzle.error( selector ) :
				// Cache the tokens
				tokenCache( selector, groups ).slice( 0 );
	};

	function toSelector( tokens ) {
		var i = 0,
			len = tokens.length,
			selector = "";
		for ( ; i < len; i++ ) {
			selector += tokens[i].value;
		}
		return selector;
	}

	function addCombinator( matcher, combinator, base ) {
		var dir = combinator.dir,
			skip = combinator.next,
			key = skip || dir,
			checkNonElements = base && key === "parentNode",
			doneName = done++;

		return combinator.first ?
			// Check against closest ancestor/preceding element
			function( elem, context, xml ) {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						return matcher( elem, context, xml );
					}
				}
				return false;
			} :

			// Check against all ancestor/preceding elements
			function( elem, context, xml ) {
				var oldCache, uniqueCache, outerCache,
					newCache = [ dirruns, doneName ];

				// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
				if ( xml ) {
					while ( (elem = elem[ dir ]) ) {
						if ( elem.nodeType === 1 || checkNonElements ) {
							if ( matcher( elem, context, xml ) ) {
								return true;
							}
						}
					}
				} else {
					while ( (elem = elem[ dir ]) ) {
						if ( elem.nodeType === 1 || checkNonElements ) {
							outerCache = elem[ expando ] || (elem[ expando ] = {});

							// Support: IE <9 only
							// Defend against cloned attroperties (jQuery gh-1709)
							uniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {});

							if ( skip && skip === elem.nodeName.toLowerCase() ) {
								elem = elem[ dir ] || elem;
							} else if ( (oldCache = uniqueCache[ key ]) &&
								oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

								// Assign to newCache so results back-propagate to previous elements
								return (newCache[ 2 ] = oldCache[ 2 ]);
							} else {
								// Reuse newcache so results back-propagate to previous elements
								uniqueCache[ key ] = newCache;

								// A match means we're done; a fail means we have to keep checking
								if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
									return true;
								}
							}
						}
					}
				}
				return false;
			};
	}

	function elementMatcher( matchers ) {
		return matchers.length > 1 ?
			function( elem, context, xml ) {
				var i = matchers.length;
				while ( i-- ) {
					if ( !matchers[i]( elem, context, xml ) ) {
						return false;
					}
				}
				return true;
			} :
			matchers[0];
	}

	function multipleContexts( selector, contexts, results ) {
		var i = 0,
			len = contexts.length;
		for ( ; i < len; i++ ) {
			Sizzle( selector, contexts[i], results );
		}
		return results;
	}

	function condense( unmatched, map, filter, context, xml ) {
		var elem,
			newUnmatched = [],
			i = 0,
			len = unmatched.length,
			mapped = map != null;

		for ( ; i < len; i++ ) {
			if ( (elem = unmatched[i]) ) {
				if ( !filter || filter( elem, context, xml ) ) {
					newUnmatched.push( elem );
					if ( mapped ) {
						map.push( i );
					}
				}
			}
		}

		return newUnmatched;
	}

	function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
		if ( postFilter && !postFilter[ expando ] ) {
			postFilter = setMatcher( postFilter );
		}
		if ( postFinder && !postFinder[ expando ] ) {
			postFinder = setMatcher( postFinder, postSelector );
		}
		return markFunction(function( seed, results, context, xml ) {
			var temp, i, elem,
				preMap = [],
				postMap = [],
				preexisting = results.length,

				// Get initial elements from seed or context
				elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),

				// Prefilter to get matcher input, preserving a map for seed-results synchronization
				matcherIn = preFilter && ( seed || !selector ) ?
					condense( elems, preMap, preFilter, context, xml ) :
					elems,

				matcherOut = matcher ?
					// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
					postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

						// ...intermediate processing is necessary
						[] :

						// ...otherwise use results directly
						results :
					matcherIn;

			// Find primary matches
			if ( matcher ) {
				matcher( matcherIn, matcherOut, context, xml );
			}

			// Apply postFilter
			if ( postFilter ) {
				temp = condense( matcherOut, postMap );
				postFilter( temp, [], context, xml );

				// Un-match failing elements by moving them back to matcherIn
				i = temp.length;
				while ( i-- ) {
					if ( (elem = temp[i]) ) {
						matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
					}
				}
			}

			if ( seed ) {
				if ( postFinder || preFilter ) {
					if ( postFinder ) {
						// Get the final matcherOut by condensing this intermediate into postFinder contexts
						temp = [];
						i = matcherOut.length;
						while ( i-- ) {
							if ( (elem = matcherOut[i]) ) {
								// Restore matcherIn since elem is not yet a final match
								temp.push( (matcherIn[i] = elem) );
							}
						}
						postFinder( null, (matcherOut = []), temp, xml );
					}

					// Move matched elements from seed to results to keep them synchronized
					i = matcherOut.length;
					while ( i-- ) {
						if ( (elem = matcherOut[i]) &&
							(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {

							seed[temp] = !(results[temp] = elem);
						}
					}
				}

			// Add elements to results, through postFinder if defined
			} else {
				matcherOut = condense(
					matcherOut === results ?
						matcherOut.splice( preexisting, matcherOut.length ) :
						matcherOut
				);
				if ( postFinder ) {
					postFinder( null, results, matcherOut, xml );
				} else {
					push.apply( results, matcherOut );
				}
			}
		});
	}

	function matcherFromTokens( tokens ) {
		var checkContext, matcher, j,
			len = tokens.length,
			leadingRelative = Expr.relative[ tokens[0].type ],
			implicitRelative = leadingRelative || Expr.relative[" "],
			i = leadingRelative ? 1 : 0,

			// The foundational matcher ensures that elements are reachable from top-level context(s)
			matchContext = addCombinator( function( elem ) {
				return elem === checkContext;
			}, implicitRelative, true ),
			matchAnyContext = addCombinator( function( elem ) {
				return indexOf( checkContext, elem ) > -1;
			}, implicitRelative, true ),
			matchers = [ function( elem, context, xml ) {
				var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
					(checkContext = context).nodeType ?
						matchContext( elem, context, xml ) :
						matchAnyContext( elem, context, xml ) );
				// Avoid hanging onto element (issue #299)
				checkContext = null;
				return ret;
			} ];

		for ( ; i < len; i++ ) {
			if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
				matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
			} else {
				matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

				// Return special upon seeing a positional matcher
				if ( matcher[ expando ] ) {
					// Find the next relative operator (if any) for proper handling
					j = ++i;
					for ( ; j < len; j++ ) {
						if ( Expr.relative[ tokens[j].type ] ) {
							break;
						}
					}
					return setMatcher(
						i > 1 && elementMatcher( matchers ),
						i > 1 && toSelector(
							// If the preceding token was a descendant combinator, insert an implicit any-element `*`
							tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
						).replace( rtrim, "$1" ),
						matcher,
						i < j && matcherFromTokens( tokens.slice( i, j ) ),
						j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
						j < len && toSelector( tokens )
					);
				}
				matchers.push( matcher );
			}
		}

		return elementMatcher( matchers );
	}

	function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
		var bySet = setMatchers.length > 0,
			byElement = elementMatchers.length > 0,
			superMatcher = function( seed, context, xml, results, outermost ) {
				var elem, j, matcher,
					matchedCount = 0,
					i = "0",
					unmatched = seed && [],
					setMatched = [],
					contextBackup = outermostContext,
					// We must always have either seed elements or outermost context
					elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
					// Use integer dirruns iff this is the outermost matcher
					dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
					len = elems.length;

				if ( outermost ) {
					outermostContext = context === document || context || outermost;
				}

				// Add elements passing elementMatchers directly to results
				// Support: IE<9, Safari
				// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
				for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
					if ( byElement && elem ) {
						j = 0;
						if ( !context && elem.ownerDocument !== document ) {
							setDocument( elem );
							xml = !documentIsHTML;
						}
						while ( (matcher = elementMatchers[j++]) ) {
							if ( matcher( elem, context || document, xml) ) {
								results.push( elem );
								break;
							}
						}
						if ( outermost ) {
							dirruns = dirrunsUnique;
						}
					}

					// Track unmatched elements for set filters
					if ( bySet ) {
						// They will have gone through all possible matchers
						if ( (elem = !matcher && elem) ) {
							matchedCount--;
						}

						// Lengthen the array for every element, matched or not
						if ( seed ) {
							unmatched.push( elem );
						}
					}
				}

				// `i` is now the count of elements visited above, and adding it to `matchedCount`
				// makes the latter nonnegative.
				matchedCount += i;

				// Apply set filters to unmatched elements
				// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
				// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
				// no element matchers and no seed.
				// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
				// case, which will result in a "00" `matchedCount` that differs from `i` but is also
				// numerically zero.
				if ( bySet && i !== matchedCount ) {
					j = 0;
					while ( (matcher = setMatchers[j++]) ) {
						matcher( unmatched, setMatched, context, xml );
					}

					if ( seed ) {
						// Reintegrate element matches to eliminate the need for sorting
						if ( matchedCount > 0 ) {
							while ( i-- ) {
								if ( !(unmatched[i] || setMatched[i]) ) {
									setMatched[i] = pop.call( results );
								}
							}
						}

						// Discard index placeholder values to get only actual matches
						setMatched = condense( setMatched );
					}

					// Add matches to results
					push.apply( results, setMatched );

					// Seedless set matches succeeding multiple successful matchers stipulate sorting
					if ( outermost && !seed && setMatched.length > 0 &&
						( matchedCount + setMatchers.length ) > 1 ) {

						Sizzle.uniqueSort( results );
					}
				}

				// Override manipulation of globals by nested matchers
				if ( outermost ) {
					dirruns = dirrunsUnique;
					outermostContext = contextBackup;
				}

				return unmatched;
			};

		return bySet ?
			markFunction( superMatcher ) :
			superMatcher;
	}

	compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
		var i,
			setMatchers = [],
			elementMatchers = [],
			cached = compilerCache[ selector + " " ];

		if ( !cached ) {
			// Generate a function of recursive functions that can be used to check each element
			if ( !match ) {
				match = tokenize( selector );
			}
			i = match.length;
			while ( i-- ) {
				cached = matcherFromTokens( match[i] );
				if ( cached[ expando ] ) {
					setMatchers.push( cached );
				} else {
					elementMatchers.push( cached );
				}
			}

			// Cache the compiled function
			cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );

			// Save selector and tokenization
			cached.selector = selector;
		}
		return cached;
	};

	/**
	 * A low-level selection function that works with Sizzle's compiled
	 *  selector functions
	 * @param {String|Function} selector A selector or a pre-compiled
	 *  selector function built with Sizzle.compile
	 * @param {Element} context
	 * @param {Array} [results]
	 * @param {Array} [seed] A set of elements to match against
	 */
	select = Sizzle.select = function( selector, context, results, seed ) {
		var i, tokens, token, type, find,
			compiled = typeof selector === "function" && selector,
			match = !seed && tokenize( (selector = compiled.selector || selector) );

		results = results || [];

		// Try to minimize operations if there is only one selector in the list and no seed
		// (the latter of which guarantees us context)
		if ( match.length === 1 ) {

			// Reduce context if the leading compound selector is an ID
			tokens = match[0] = match[0].slice( 0 );
			if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
					context.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[1].type ] ) {

				context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
				if ( !context ) {
					return results;

				// Precompiled matchers will still verify ancestry, so step up a level
				} else if ( compiled ) {
					context = context.parentNode;
				}

				selector = selector.slice( tokens.shift().value.length );
			}

			// Fetch a seed set for right-to-left matching
			i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
			while ( i-- ) {
				token = tokens[i];

				// Abort if we hit a combinator
				if ( Expr.relative[ (type = token.type) ] ) {
					break;
				}
				if ( (find = Expr.find[ type ]) ) {
					// Search, expanding context for leading sibling combinators
					if ( (seed = find(
						token.matches[0].replace( runescape, funescape ),
						rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
					)) ) {

						// If seed is empty or no tokens remain, we can return early
						tokens.splice( i, 1 );
						selector = seed.length && toSelector( tokens );
						if ( !selector ) {
							push.apply( results, seed );
							return results;
						}

						break;
					}
				}
			}
		}

		// Compile and execute a filtering function if one is not provided
		// Provide `match` to avoid retokenization if we modified the selector above
		( compiled || compile( selector, match ) )(
			seed,
			context,
			!documentIsHTML,
			results,
			!context || rsibling.test( selector ) && testContext( context.parentNode ) || context
		);
		return results;
	};

	// One-time assignments

	// Sort stability
	support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;

	// Support: Chrome 14-35+
	// Always assume duplicates if they aren't passed to the comparison function
	support.detectDuplicates = !!hasDuplicate;

	// Initialize against the default document
	setDocument();

	// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
	// Detached nodes confoundingly follow *each other*
	support.sortDetached = assert(function( el ) {
		// Should return 1, but returns 4 (following)
		return el.compareDocumentPosition( document.createElement("fieldset") ) & 1;
	});

	// Support: IE<8
	// Prevent attribute/property "interpolation"
	// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
	if ( !assert(function( el ) {
		el.innerHTML = "<a href='#'></a>";
		return el.firstChild.getAttribute("href") === "#" ;
	}) ) {
		addHandle( "type|href|height|width", function( elem, name, isXML ) {
			if ( !isXML ) {
				return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
			}
		});
	}

	// Support: IE<9
	// Use defaultValue in place of getAttribute("value")
	if ( !support.attributes || !assert(function( el ) {
		el.innerHTML = "<input/>";
		el.firstChild.setAttribute( "value", "" );
		return el.firstChild.getAttribute( "value" ) === "";
	}) ) {
		addHandle( "value", function( elem, name, isXML ) {
			if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
				return elem.defaultValue;
			}
		});
	}

	// Support: IE<9
	// Use getAttributeNode to fetch booleans when getAttribute lies
	if ( !assert(function( el ) {
		return el.getAttribute("disabled") == null;
	}) ) {
		addHandle( booleans, function( elem, name, isXML ) {
			var val;
			if ( !isXML ) {
				return elem[ name ] === true ? name.toLowerCase() :
						(val = elem.getAttributeNode( name )) && val.specified ?
						val.value :
					null;
			}
		});
	}

	return Sizzle;

	})( window );



	jQuery.find = Sizzle;
	jQuery.expr = Sizzle.selectors;

	// Deprecated
	jQuery.expr[ ":" ] = jQuery.expr.pseudos;
	jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
	jQuery.text = Sizzle.getText;
	jQuery.isXMLDoc = Sizzle.isXML;
	jQuery.contains = Sizzle.contains;
	jQuery.escapeSelector = Sizzle.escape;




	var dir = function( elem, dir, until ) {
		var matched = [],
			truncate = until !== undefined;

		while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {
			if ( elem.nodeType === 1 ) {
				if ( truncate && jQuery( elem ).is( until ) ) {
					break;
				}
				matched.push( elem );
			}
		}
		return matched;
	};


	var siblings = function( n, elem ) {
		var matched = [];

		for ( ; n; n = n.nextSibling ) {
			if ( n.nodeType === 1 && n !== elem ) {
				matched.push( n );
			}
		}

		return matched;
	};


	var rneedsContext = jQuery.expr.match.needsContext;



	function nodeName( elem, name ) {

	  return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();

	};
	var rsingleTag = ( /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i );



	// Implement the identical functionality for filter and not
	function winnow( elements, qualifier, not ) {
		if ( isFunction( qualifier ) ) {
			return jQuery.grep( elements, function( elem, i ) {
				return !!qualifier.call( elem, i, elem ) !== not;
			} );
		}

		// Single element
		if ( qualifier.nodeType ) {
			return jQuery.grep( elements, function( elem ) {
				return ( elem === qualifier ) !== not;
			} );
		}

		// Arraylike of elements (jQuery, arguments, Array)
		if ( typeof qualifier !== "string" ) {
			return jQuery.grep( elements, function( elem ) {
				return ( indexOf.call( qualifier, elem ) > -1 ) !== not;
			} );
		}

		// Filtered directly for both simple and complex selectors
		return jQuery.filter( qualifier, elements, not );
	}

	jQuery.filter = function( expr, elems, not ) {
		var elem = elems[ 0 ];

		if ( not ) {
			expr = ":not(" + expr + ")";
		}

		if ( elems.length === 1 && elem.nodeType === 1 ) {
			return jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];
		}

		return jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
			return elem.nodeType === 1;
		} ) );
	};

	jQuery.fn.extend( {
		find: function( selector ) {
			var i, ret,
				len = this.length,
				self = this;

			if ( typeof selector !== "string" ) {
				return this.pushStack( jQuery( selector ).filter( function() {
					for ( i = 0; i < len; i++ ) {
						if ( jQuery.contains( self[ i ], this ) ) {
							return true;
						}
					}
				} ) );
			}

			ret = this.pushStack( [] );

			for ( i = 0; i < len; i++ ) {
				jQuery.find( selector, self[ i ], ret );
			}

			return len > 1 ? jQuery.uniqueSort( ret ) : ret;
		},
		filter: function( selector ) {
			return this.pushStack( winnow( this, selector || [], false ) );
		},
		not: function( selector ) {
			return this.pushStack( winnow( this, selector || [], true ) );
		},
		is: function( selector ) {
			return !!winnow(
				this,

				// If this is a positional/relative selector, check membership in the returned set
				// so $("p:first").is("p:last") won't return true for a doc with two "p".
				typeof selector === "string" && rneedsContext.test( selector ) ?
					jQuery( selector ) :
					selector || [],
				false
			).length;
		}
	} );


	// Initialize a jQuery object


	// A central reference to the root jQuery(document)
	var rootjQuery,

		// A simple way to check for HTML strings
		// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
		// Strict HTML recognition (#11290: must start with <)
		// Shortcut simple #id case for speed
		rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,

		init = jQuery.fn.init = function( selector, context, root ) {
			var match, elem;

			// HANDLE: $(""), $(null), $(undefined), $(false)
			if ( !selector ) {
				return this;
			}

			// Method init() accepts an alternate rootjQuery
			// so migrate can support jQuery.sub (gh-2101)
			root = root || rootjQuery;

			// Handle HTML strings
			if ( typeof selector === "string" ) {
				if ( selector[ 0 ] === "<" &&
					selector[ selector.length - 1 ] === ">" &&
					selector.length >= 3 ) {

					// Assume that strings that start and end with <> are HTML and skip the regex check
					match = [ null, selector, null ];

				} else {
					match = rquickExpr.exec( selector );
				}

				// Match html or make sure no context is specified for #id
				if ( match && ( match[ 1 ] || !context ) ) {

					// HANDLE: $(html) -> $(array)
					if ( match[ 1 ] ) {
						context = context instanceof jQuery ? context[ 0 ] : context;

						// Option to run scripts is true for back-compat
						// Intentionally let the error be thrown if parseHTML is not present
						jQuery.merge( this, jQuery.parseHTML(
							match[ 1 ],
							context && context.nodeType ? context.ownerDocument || context : document,
							true
						) );

						// HANDLE: $(html, props)
						if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {
							for ( match in context ) {

								// Properties of context are called as methods if possible
								if ( isFunction( this[ match ] ) ) {
									this[ match ]( context[ match ] );

								// ...and otherwise set as attributes
								} else {
									this.attr( match, context[ match ] );
								}
							}
						}

						return this;

					// HANDLE: $(#id)
					} else {
						elem = document.getElementById( match[ 2 ] );

						if ( elem ) {

							// Inject the element directly into the jQuery object
							this[ 0 ] = elem;
							this.length = 1;
						}
						return this;
					}

				// HANDLE: $(expr, $(...))
				} else if ( !context || context.jquery ) {
					return ( context || root ).find( selector );

				// HANDLE: $(expr, context)
				// (which is just equivalent to: $(context).find(expr)
				} else {
					return this.constructor( context ).find( selector );
				}

			// HANDLE: $(DOMElement)
			} else if ( selector.nodeType ) {
				this[ 0 ] = selector;
				this.length = 1;
				return this;

			// HANDLE: $(function)
			// Shortcut for document ready
			} else if ( isFunction( selector ) ) {
				return root.ready !== undefined ?
					root.ready( selector ) :

					// Execute immediately if ready is not present
					selector( jQuery );
			}

			return jQuery.makeArray( selector, this );
		};

	// Give the init function the jQuery prototype for later instantiation
	init.prototype = jQuery.fn;

	// Initialize central reference
	rootjQuery = jQuery( document );


	var rparentsprev = /^(?:parents|prev(?:Until|All))/,

		// Methods guaranteed to produce a unique set when starting from a unique set
		guaranteedUnique = {
			children: true,
			contents: true,
			next: true,
			prev: true
		};

	jQuery.fn.extend( {
		has: function( target ) {
			var targets = jQuery( target, this ),
				l = targets.length;

			return this.filter( function() {
				var i = 0;
				for ( ; i < l; i++ ) {
					if ( jQuery.contains( this, targets[ i ] ) ) {
						return true;
					}
				}
			} );
		},

		closest: function( selectors, context ) {
			var cur,
				i = 0,
				l = this.length,
				matched = [],
				targets = typeof selectors !== "string" && jQuery( selectors );

			// Positional selectors never match, since there's no _selection_ context
			if ( !rneedsContext.test( selectors ) ) {
				for ( ; i < l; i++ ) {
					for ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {

						// Always skip document fragments
						if ( cur.nodeType < 11 && ( targets ?
							targets.index( cur ) > -1 :

							// Don't pass non-elements to Sizzle
							cur.nodeType === 1 &&
								jQuery.find.matchesSelector( cur, selectors ) ) ) {

							matched.push( cur );
							break;
						}
					}
				}
			}

			return this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );
		},

		// Determine the position of an element within the set
		index: function( elem ) {

			// No argument, return index in parent
			if ( !elem ) {
				return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
			}

			// Index in selector
			if ( typeof elem === "string" ) {
				return indexOf.call( jQuery( elem ), this[ 0 ] );
			}

			// Locate the position of the desired element
			return indexOf.call( this,

				// If it receives a jQuery object, the first element is used
				elem.jquery ? elem[ 0 ] : elem
			);
		},

		add: function( selector, context ) {
			return this.pushStack(
				jQuery.uniqueSort(
					jQuery.merge( this.get(), jQuery( selector, context ) )
				)
			);
		},

		addBack: function( selector ) {
			return this.add( selector == null ?
				this.prevObject : this.prevObject.filter( selector )
			);
		}
	} );

	function sibling( cur, dir ) {
		while ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}
		return cur;
	}

	jQuery.each( {
		parent: function( elem ) {
			var parent = elem.parentNode;
			return parent && parent.nodeType !== 11 ? parent : null;
		},
		parents: function( elem ) {
			return dir( elem, "parentNode" );
		},
		parentsUntil: function( elem, i, until ) {
			return dir( elem, "parentNode", until );
		},
		next: function( elem ) {
			return sibling( elem, "nextSibling" );
		},
		prev: function( elem ) {
			return sibling( elem, "previousSibling" );
		},
		nextAll: function( elem ) {
			return dir( elem, "nextSibling" );
		},
		prevAll: function( elem ) {
			return dir( elem, "previousSibling" );
		},
		nextUntil: function( elem, i, until ) {
			return dir( elem, "nextSibling", until );
		},
		prevUntil: function( elem, i, until ) {
			return dir( elem, "previousSibling", until );
		},
		siblings: function( elem ) {
			return siblings( ( elem.parentNode || {} ).firstChild, elem );
		},
		children: function( elem ) {
			return siblings( elem.firstChild );
		},
		contents: function( elem ) {
	        if ( nodeName( elem, "iframe" ) ) {
	            return elem.contentDocument;
	        }

	        // Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only
	        // Treat the template element as a regular one in browsers that
	        // don't support it.
	        if ( nodeName( elem, "template" ) ) {
	            elem = elem.content || elem;
	        }

	        return jQuery.merge( [], elem.childNodes );
		}
	}, function( name, fn ) {
		jQuery.fn[ name ] = function( until, selector ) {
			var matched = jQuery.map( this, fn, until );

			if ( name.slice( -5 ) !== "Until" ) {
				selector = until;
			}

			if ( selector && typeof selector === "string" ) {
				matched = jQuery.filter( selector, matched );
			}

			if ( this.length > 1 ) {

				// Remove duplicates
				if ( !guaranteedUnique[ name ] ) {
					jQuery.uniqueSort( matched );
				}

				// Reverse order for parents* and prev-derivatives
				if ( rparentsprev.test( name ) ) {
					matched.reverse();
				}
			}

			return this.pushStack( matched );
		};
	} );
	var rnothtmlwhite = ( /[^\x20\t\r\n\f]+/g );



	// Convert String-formatted options into Object-formatted ones
	function createOptions( options ) {
		var object = {};
		jQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {
			object[ flag ] = true;
		} );
		return object;
	}

	/*
	 * Create a callback list using the following parameters:
	 *
	 *	options: an optional list of space-separated options that will change how
	 *			the callback list behaves or a more traditional option object
	 *
	 * By default a callback list will act like an event callback list and can be
	 * "fired" multiple times.
	 *
	 * Possible options:
	 *
	 *	once:			will ensure the callback list can only be fired once (like a Deferred)
	 *
	 *	memory:			will keep track of previous values and will call any callback added
	 *					after the list has been fired right away with the latest "memorized"
	 *					values (like a Deferred)
	 *
	 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
	 *
	 *	stopOnFalse:	interrupt callings when a callback returns false
	 *
	 */
	jQuery.Callbacks = function( options ) {

		// Convert options from String-formatted to Object-formatted if needed
		// (we check in cache first)
		options = typeof options === "string" ?
			createOptions( options ) :
			jQuery.extend( {}, options );

		var // Flag to know if list is currently firing
			firing,

			// Last fire value for non-forgettable lists
			memory,

			// Flag to know if list was already fired
			fired,

			// Flag to prevent firing
			locked,

			// Actual callback list
			list = [],

			// Queue of execution data for repeatable lists
			queue = [],

			// Index of currently firing callback (modified by add/remove as needed)
			firingIndex = -1,

			// Fire callbacks
			fire = function() {

				// Enforce single-firing
				locked = locked || options.once;

				// Execute callbacks for all pending executions,
				// respecting firingIndex overrides and runtime changes
				fired = firing = true;
				for ( ; queue.length; firingIndex = -1 ) {
					memory = queue.shift();
					while ( ++firingIndex < list.length ) {

						// Run callback and check for early termination
						if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&
							options.stopOnFalse ) {

							// Jump to end and forget the data so .add doesn't re-fire
							firingIndex = list.length;
							memory = false;
						}
					}
				}

				// Forget the data if we're done with it
				if ( !options.memory ) {
					memory = false;
				}

				firing = false;

				// Clean up if we're done firing for good
				if ( locked ) {

					// Keep an empty list if we have data for future add calls
					if ( memory ) {
						list = [];

					// Otherwise, this object is spent
					} else {
						list = "";
					}
				}
			},

			// Actual Callbacks object
			self = {

				// Add a callback or a collection of callbacks to the list
				add: function() {
					if ( list ) {

						// If we have memory from a past run, we should fire after adding
						if ( memory && !firing ) {
							firingIndex = list.length - 1;
							queue.push( memory );
						}

						( function add( args ) {
							jQuery.each( args, function( _, arg ) {
								if ( isFunction( arg ) ) {
									if ( !options.unique || !self.has( arg ) ) {
										list.push( arg );
									}
								} else if ( arg && arg.length && toType( arg ) !== "string" ) {

									// Inspect recursively
									add( arg );
								}
							} );
						} )( arguments );

						if ( memory && !firing ) {
							fire();
						}
					}
					return this;
				},

				// Remove a callback from the list
				remove: function() {
					jQuery.each( arguments, function( _, arg ) {
						var index;
						while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
							list.splice( index, 1 );

							// Handle firing indexes
							if ( index <= firingIndex ) {
								firingIndex--;
							}
						}
					} );
					return this;
				},

				// Check if a given callback is in the list.
				// If no argument is given, return whether or not list has callbacks attached.
				has: function( fn ) {
					return fn ?
						jQuery.inArray( fn, list ) > -1 :
						list.length > 0;
				},

				// Remove all callbacks from the list
				empty: function() {
					if ( list ) {
						list = [];
					}
					return this;
				},

				// Disable .fire and .add
				// Abort any current/pending executions
				// Clear all callbacks and values
				disable: function() {
					locked = queue = [];
					list = memory = "";
					return this;
				},
				disabled: function() {
					return !list;
				},

				// Disable .fire
				// Also disable .add unless we have memory (since it would have no effect)
				// Abort any pending executions
				lock: function() {
					locked = queue = [];
					if ( !memory && !firing ) {
						list = memory = "";
					}
					return this;
				},
				locked: function() {
					return !!locked;
				},

				// Call all callbacks with the given context and arguments
				fireWith: function( context, args ) {
					if ( !locked ) {
						args = args || [];
						args = [ context, args.slice ? args.slice() : args ];
						queue.push( args );
						if ( !firing ) {
							fire();
						}
					}
					return this;
				},

				// Call all the callbacks with the given arguments
				fire: function() {
					self.fireWith( this, arguments );
					return this;
				},

				// To know if the callbacks have already been called at least once
				fired: function() {
					return !!fired;
				}
			};

		return self;
	};


	function Identity( v ) {
		return v;
	}
	function Thrower( ex ) {
		throw ex;
	}

	function adoptValue( value, resolve, reject, noValue ) {
		var method;

		try {

			// Check for promise aspect first to privilege synchronous behavior
			if ( value && isFunction( ( method = value.promise ) ) ) {
				method.call( value ).done( resolve ).fail( reject );

			// Other thenables
			} else if ( value && isFunction( ( method = value.then ) ) ) {
				method.call( value, resolve, reject );

			// Other non-thenables
			} else {

				// Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:
				// * false: [ value ].slice( 0 ) => resolve( value )
				// * true: [ value ].slice( 1 ) => resolve()
				resolve.apply( undefined, [ value ].slice( noValue ) );
			}

		// For Promises/A+, convert exceptions into rejections
		// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
		// Deferred#then to conditionally suppress rejection.
		} catch ( value ) {

			// Support: Android 4.0 only
			// Strict mode functions invoked without .call/.apply get global-object context
			reject.apply( undefined, [ value ] );
		}
	}

	jQuery.extend( {

		Deferred: function( func ) {
			var tuples = [

					// action, add listener, callbacks,
					// ... .then handlers, argument index, [final state]
					[ "notify", "progress", jQuery.Callbacks( "memory" ),
						jQuery.Callbacks( "memory" ), 2 ],
					[ "resolve", "done", jQuery.Callbacks( "once memory" ),
						jQuery.Callbacks( "once memory" ), 0, "resolved" ],
					[ "reject", "fail", jQuery.Callbacks( "once memory" ),
						jQuery.Callbacks( "once memory" ), 1, "rejected" ]
				],
				state = "pending",
				promise = {
					state: function() {
						return state;
					},
					always: function() {
						deferred.done( arguments ).fail( arguments );
						return this;
					},
					"catch": function( fn ) {
						return promise.then( null, fn );
					},

					// Keep pipe for back-compat
					pipe: function( /* fnDone, fnFail, fnProgress */ ) {
						var fns = arguments;

						return jQuery.Deferred( function( newDefer ) {
							jQuery.each( tuples, function( i, tuple ) {

								// Map tuples (progress, done, fail) to arguments (done, fail, progress)
								var fn = isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];

								// deferred.progress(function() { bind to newDefer or newDefer.notify })
								// deferred.done(function() { bind to newDefer or newDefer.resolve })
								// deferred.fail(function() { bind to newDefer or newDefer.reject })
								deferred[ tuple[ 1 ] ]( function() {
									var returned = fn && fn.apply( this, arguments );
									if ( returned && isFunction( returned.promise ) ) {
										returned.promise()
											.progress( newDefer.notify )
											.done( newDefer.resolve )
											.fail( newDefer.reject );
									} else {
										newDefer[ tuple[ 0 ] + "With" ](
											this,
											fn ? [ returned ] : arguments
										);
									}
								} );
							} );
							fns = null;
						} ).promise();
					},
					then: function( onFulfilled, onRejected, onProgress ) {
						var maxDepth = 0;
						function resolve( depth, deferred, handler, special ) {
							return function() {
								var that = this,
									args = arguments,
									mightThrow = function() {
										var returned, then;

										// Support: Promises/A+ section 2.3.3.3.3
										// https://promisesaplus.com/#point-59
										// Ignore double-resolution attempts
										if ( depth < maxDepth ) {
											return;
										}

										returned = handler.apply( that, args );

										// Support: Promises/A+ section 2.3.1
										// https://promisesaplus.com/#point-48
										if ( returned === deferred.promise() ) {
											throw new TypeError( "Thenable self-resolution" );
										}

										// Support: Promises/A+ sections 2.3.3.1, 3.5
										// https://promisesaplus.com/#point-54
										// https://promisesaplus.com/#point-75
										// Retrieve `then` only once
										then = returned &&

											// Support: Promises/A+ section 2.3.4
											// https://promisesaplus.com/#point-64
											// Only check objects and functions for thenability
											( typeof returned === "object" ||
												typeof returned === "function" ) &&
											returned.then;

										// Handle a returned thenable
										if ( isFunction( then ) ) {

											// Special processors (notify) just wait for resolution
											if ( special ) {
												then.call(
													returned,
													resolve( maxDepth, deferred, Identity, special ),
													resolve( maxDepth, deferred, Thrower, special )
												);

											// Normal processors (resolve) also hook into progress
											} else {

												// ...and disregard older resolution values
												maxDepth++;

												then.call(
													returned,
													resolve( maxDepth, deferred, Identity, special ),
													resolve( maxDepth, deferred, Thrower, special ),
													resolve( maxDepth, deferred, Identity,
														deferred.notifyWith )
												);
											}

										// Handle all other returned values
										} else {

											// Only substitute handlers pass on context
											// and multiple values (non-spec behavior)
											if ( handler !== Identity ) {
												that = undefined;
												args = [ returned ];
											}

											// Process the value(s)
											// Default process is resolve
											( special || deferred.resolveWith )( that, args );
										}
									},

									// Only normal processors (resolve) catch and reject exceptions
									process = special ?
										mightThrow :
										function() {
											try {
												mightThrow();
											} catch ( e ) {

												if ( jQuery.Deferred.exceptionHook ) {
													jQuery.Deferred.exceptionHook( e,
														process.stackTrace );
												}

												// Support: Promises/A+ section 2.3.3.3.4.1
												// https://promisesaplus.com/#point-61
												// Ignore post-resolution exceptions
												if ( depth + 1 >= maxDepth ) {

													// Only substitute handlers pass on context
													// and multiple values (non-spec behavior)
													if ( handler !== Thrower ) {
														that = undefined;
														args = [ e ];
													}

													deferred.rejectWith( that, args );
												}
											}
										};

								// Support: Promises/A+ section 2.3.3.3.1
								// https://promisesaplus.com/#point-57
								// Re-resolve promises immediately to dodge false rejection from
								// subsequent errors
								if ( depth ) {
									process();
								} else {

									// Call an optional hook to record the stack, in case of exception
									// since it's otherwise lost when execution goes async
									if ( jQuery.Deferred.getStackHook ) {
										process.stackTrace = jQuery.Deferred.getStackHook();
									}
									window.setTimeout( process );
								}
							};
						}

						return jQuery.Deferred( function( newDefer ) {

							// progress_handlers.add( ... )
							tuples[ 0 ][ 3 ].add(
								resolve(
									0,
									newDefer,
									isFunction( onProgress ) ?
										onProgress :
										Identity,
									newDefer.notifyWith
								)
							);

							// fulfilled_handlers.add( ... )
							tuples[ 1 ][ 3 ].add(
								resolve(
									0,
									newDefer,
									isFunction( onFulfilled ) ?
										onFulfilled :
										Identity
								)
							);

							// rejected_handlers.add( ... )
							tuples[ 2 ][ 3 ].add(
								resolve(
									0,
									newDefer,
									isFunction( onRejected ) ?
										onRejected :
										Thrower
								)
							);
						} ).promise();
					},

					// Get a promise for this deferred
					// If obj is provided, the promise aspect is added to the object
					promise: function( obj ) {
						return obj != null ? jQuery.extend( obj, promise ) : promise;
					}
				},
				deferred = {};

			// Add list-specific methods
			jQuery.each( tuples, function( i, tuple ) {
				var list = tuple[ 2 ],
					stateString = tuple[ 5 ];

				// promise.progress = list.add
				// promise.done = list.add
				// promise.fail = list.add
				promise[ tuple[ 1 ] ] = list.add;

				// Handle state
				if ( stateString ) {
					list.add(
						function() {

							// state = "resolved" (i.e., fulfilled)
							// state = "rejected"
							state = stateString;
						},

						// rejected_callbacks.disable
						// fulfilled_callbacks.disable
						tuples[ 3 - i ][ 2 ].disable,

						// rejected_handlers.disable
						// fulfilled_handlers.disable
						tuples[ 3 - i ][ 3 ].disable,

						// progress_callbacks.lock
						tuples[ 0 ][ 2 ].lock,

						// progress_handlers.lock
						tuples[ 0 ][ 3 ].lock
					);
				}

				// progress_handlers.fire
				// fulfilled_handlers.fire
				// rejected_handlers.fire
				list.add( tuple[ 3 ].fire );

				// deferred.notify = function() { deferred.notifyWith(...) }
				// deferred.resolve = function() { deferred.resolveWith(...) }
				// deferred.reject = function() { deferred.rejectWith(...) }
				deferred[ tuple[ 0 ] ] = function() {
					deferred[ tuple[ 0 ] + "With" ]( this === deferred ? undefined : this, arguments );
					return this;
				};

				// deferred.notifyWith = list.fireWith
				// deferred.resolveWith = list.fireWith
				// deferred.rejectWith = list.fireWith
				deferred[ tuple[ 0 ] + "With" ] = list.fireWith;
			} );

			// Make the deferred a promise
			promise.promise( deferred );

			// Call given func if any
			if ( func ) {
				func.call( deferred, deferred );
			}

			// All done!
			return deferred;
		},

		// Deferred helper
		when: function( singleValue ) {
			var

				// count of uncompleted subordinates
				remaining = arguments.length,

				// count of unprocessed arguments
				i = remaining,

				// subordinate fulfillment data
				resolveContexts = Array( i ),
				resolveValues = slice.call( arguments ),

				// the master Deferred
				master = jQuery.Deferred(),

				// subordinate callback factory
				updateFunc = function( i ) {
					return function( value ) {
						resolveContexts[ i ] = this;
						resolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
						if ( !( --remaining ) ) {
							master.resolveWith( resolveContexts, resolveValues );
						}
					};
				};

			// Single- and empty arguments are adopted like Promise.resolve
			if ( remaining <= 1 ) {
				adoptValue( singleValue, master.done( updateFunc( i ) ).resolve, master.reject,
					!remaining );

				// Use .then() to unwrap secondary thenables (cf. gh-3000)
				if ( master.state() === "pending" ||
					isFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {

					return master.then();
				}
			}

			// Multiple arguments are aggregated like Promise.all array elements
			while ( i-- ) {
				adoptValue( resolveValues[ i ], updateFunc( i ), master.reject );
			}

			return master.promise();
		}
	} );


	// These usually indicate a programmer mistake during development,
	// warn about them ASAP rather than swallowing them by default.
	var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;

	jQuery.Deferred.exceptionHook = function( error, stack ) {

		// Support: IE 8 - 9 only
		// Console exists when dev tools are open, which can happen at any time
		if ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {
			window.console.warn( "jQuery.Deferred exception: " + error.message, error.stack, stack );
		}
	};




	jQuery.readyException = function( error ) {
		window.setTimeout( function() {
			throw error;
		} );
	};




	// The deferred used on DOM ready
	var readyList = jQuery.Deferred();

	jQuery.fn.ready = function( fn ) {

		readyList
			.then( fn )

			// Wrap jQuery.readyException in a function so that the lookup
			// happens at the time of error handling instead of callback
			// registration.
			.catch( function( error ) {
				jQuery.readyException( error );
			} );

		return this;
	};

	jQuery.extend( {

		// Is the DOM ready to be used? Set to true once it occurs.
		isReady: false,

		// A counter to track how many items to wait for before
		// the ready event fires. See #6781
		readyWait: 1,

		// Handle when the DOM is ready
		ready: function( wait ) {

			// Abort if there are pending holds or we're already ready
			if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
				return;
			}

			// Remember that the DOM is ready
			jQuery.isReady = true;

			// If a normal DOM Ready event fired, decrement, and wait if need be
			if ( wait !== true && --jQuery.readyWait > 0 ) {
				return;
			}

			// If there are functions bound, to execute
			readyList.resolveWith( document, [ jQuery ] );
		}
	} );

	jQuery.ready.then = readyList.then;

	// The ready event handler and self cleanup method
	function completed() {
		document.removeEventListener( "DOMContentLoaded", completed );
		window.removeEventListener( "load", completed );
		jQuery.ready();
	}

	// Catch cases where $(document).ready() is called
	// after the browser event has already occurred.
	// Support: IE <=9 - 10 only
	// Older IE sometimes signals "interactive" too soon
	if ( document.readyState === "complete" ||
		( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {

		// Handle it asynchronously to allow scripts the opportunity to delay ready
		window.setTimeout( jQuery.ready );

	} else {

		// Use the handy event callback
		document.addEventListener( "DOMContentLoaded", completed );

		// A fallback to window.onload, that will always work
		window.addEventListener( "load", completed );
	}




	// Multifunctional method to get and set values of a collection
	// The value/s can optionally be executed if it's a function
	var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
		var i = 0,
			len = elems.length,
			bulk = key == null;

		// Sets many values
		if ( toType( key ) === "object" ) {
			chainable = true;
			for ( i in key ) {
				access( elems, fn, i, key[ i ], true, emptyGet, raw );
			}

		// Sets one value
		} else if ( value !== undefined ) {
			chainable = true;

			if ( !isFunction( value ) ) {
				raw = true;
			}

			if ( bulk ) {

				// Bulk operations run against the entire set
				if ( raw ) {
					fn.call( elems, value );
					fn = null;

				// ...except when executing function values
				} else {
					bulk = fn;
					fn = function( elem, key, value ) {
						return bulk.call( jQuery( elem ), value );
					};
				}
			}

			if ( fn ) {
				for ( ; i < len; i++ ) {
					fn(
						elems[ i ], key, raw ?
						value :
						value.call( elems[ i ], i, fn( elems[ i ], key ) )
					);
				}
			}
		}

		if ( chainable ) {
			return elems;
		}

		// Gets
		if ( bulk ) {
			return fn.call( elems );
		}

		return len ? fn( elems[ 0 ], key ) : emptyGet;
	};


	// Matches dashed string for camelizing
	var rmsPrefix = /^-ms-/,
		rdashAlpha = /-([a-z])/g;

	// Used by camelCase as callback to replace()
	function fcamelCase( all, letter ) {
		return letter.toUpperCase();
	}

	// Convert dashed to camelCase; used by the css and data modules
	// Support: IE <=9 - 11, Edge 12 - 15
	// Microsoft forgot to hump their vendor prefix (#9572)
	function camelCase( string ) {
		return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
	}
	var acceptData = function( owner ) {

		// Accepts only:
		//  - Node
		//    - Node.ELEMENT_NODE
		//    - Node.DOCUMENT_NODE
		//  - Object
		//    - Any
		return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
	};




	function Data() {
		this.expando = jQuery.expando + Data.uid++;
	}

	Data.uid = 1;

	Data.prototype = {

		cache: function( owner ) {

			// Check if the owner object already has a cache
			var value = owner[ this.expando ];

			// If not, create one
			if ( !value ) {
				value = {};

				// We can accept data for non-element nodes in modern browsers,
				// but we should not, see #8335.
				// Always return an empty object.
				if ( acceptData( owner ) ) {

					// If it is a node unlikely to be stringify-ed or looped over
					// use plain assignment
					if ( owner.nodeType ) {
						owner[ this.expando ] = value;

					// Otherwise secure it in a non-enumerable property
					// configurable must be true to allow the property to be
					// deleted when data is removed
					} else {
						Object.defineProperty( owner, this.expando, {
							value: value,
							configurable: true
						} );
					}
				}
			}

			return value;
		},
		set: function( owner, data, value ) {
			var prop,
				cache = this.cache( owner );

			// Handle: [ owner, key, value ] args
			// Always use camelCase key (gh-2257)
			if ( typeof data === "string" ) {
				cache[ camelCase( data ) ] = value;

			// Handle: [ owner, { properties } ] args
			} else {

				// Copy the properties one-by-one to the cache object
				for ( prop in data ) {
					cache[ camelCase( prop ) ] = data[ prop ];
				}
			}
			return cache;
		},
		get: function( owner, key ) {
			return key === undefined ?
				this.cache( owner ) :

				// Always use camelCase key (gh-2257)
				owner[ this.expando ] && owner[ this.expando ][ camelCase( key ) ];
		},
		access: function( owner, key, value ) {

			// In cases where either:
			//
			//   1. No key was specified
			//   2. A string key was specified, but no value provided
			//
			// Take the "read" path and allow the get method to determine
			// which value to return, respectively either:
			//
			//   1. The entire cache object
			//   2. The data stored at the key
			//
			if ( key === undefined ||
					( ( key && typeof key === "string" ) && value === undefined ) ) {

				return this.get( owner, key );
			}

			// When the key is not a string, or both a key and value
			// are specified, set or extend (existing objects) with either:
			//
			//   1. An object of properties
			//   2. A key and value
			//
			this.set( owner, key, value );

			// Since the "set" path can have two possible entry points
			// return the expected data based on which path was taken[*]
			return value !== undefined ? value : key;
		},
		remove: function( owner, key ) {
			var i,
				cache = owner[ this.expando ];

			if ( cache === undefined ) {
				return;
			}

			if ( key !== undefined ) {

				// Support array or space separated string of keys
				if ( Array.isArray( key ) ) {

					// If key is an array of keys...
					// We always set camelCase keys, so remove that.
					key = key.map( camelCase );
				} else {
					key = camelCase( key );

					// If a key with the spaces exists, use it.
					// Otherwise, create an array by matching non-whitespace
					key = key in cache ?
						[ key ] :
						( key.match( rnothtmlwhite ) || [] );
				}

				i = key.length;

				while ( i-- ) {
					delete cache[ key[ i ] ];
				}
			}

			// Remove the expando if there's no more data
			if ( key === undefined || jQuery.isEmptyObject( cache ) ) {

				// Support: Chrome <=35 - 45
				// Webkit & Blink performance suffers when deleting properties
				// from DOM nodes, so set to undefined instead
				// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
				if ( owner.nodeType ) {
					owner[ this.expando ] = undefined;
				} else {
					delete owner[ this.expando ];
				}
			}
		},
		hasData: function( owner ) {
			var cache = owner[ this.expando ];
			return cache !== undefined && !jQuery.isEmptyObject( cache );
		}
	};
	var dataPriv = new Data();

	var dataUser = new Data();



	//	Implementation Summary
	//
	//	1. Enforce API surface and semantic compatibility with 1.9.x branch
	//	2. Improve the module's maintainability by reducing the storage
	//		paths to a single mechanism.
	//	3. Use the same single mechanism to support "private" and "user" data.
	//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
	//	5. Avoid exposing implementation details on user objects (eg. expando properties)
	//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

	var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
		rmultiDash = /[A-Z]/g;

	function getData( data ) {
		if ( data === "true" ) {
			return true;
		}

		if ( data === "false" ) {
			return false;
		}

		if ( data === "null" ) {
			return null;
		}

		// Only convert to a number if it doesn't change the string
		if ( data === +data + "" ) {
			return +data;
		}

		if ( rbrace.test( data ) ) {
			return JSON.parse( data );
		}

		return data;
	}

	function dataAttr( elem, key, data ) {
		var name;

		// If nothing was found internally, try to fetch any
		// data from the HTML5 data-* attribute
		if ( data === undefined && elem.nodeType === 1 ) {
			name = "data-" + key.replace( rmultiDash, "-$&" ).toLowerCase();
			data = elem.getAttribute( name );

			if ( typeof data === "string" ) {
				try {
					data = getData( data );
				} catch ( e ) {}

				// Make sure we set the data so it isn't changed later
				dataUser.set( elem, key, data );
			} else {
				data = undefined;
			}
		}
		return data;
	}

	jQuery.extend( {
		hasData: function( elem ) {
			return dataUser.hasData( elem ) || dataPriv.hasData( elem );
		},

		data: function( elem, name, data ) {
			return dataUser.access( elem, name, data );
		},

		removeData: function( elem, name ) {
			dataUser.remove( elem, name );
		},

		// TODO: Now that all calls to _data and _removeData have been replaced
		// with direct calls to dataPriv methods, these can be deprecated.
		_data: function( elem, name, data ) {
			return dataPriv.access( elem, name, data );
		},

		_removeData: function( elem, name ) {
			dataPriv.remove( elem, name );
		}
	} );

	jQuery.fn.extend( {
		data: function( key, value ) {
			var i, name, data,
				elem = this[ 0 ],
				attrs = elem && elem.attributes;

			// Gets all values
			if ( key === undefined ) {
				if ( this.length ) {
					data = dataUser.get( elem );

					if ( elem.nodeType === 1 && !dataPriv.get( elem, "hasDataAttrs" ) ) {
						i = attrs.length;
						while ( i-- ) {

							// Support: IE 11 only
							// The attrs elements can be null (#14894)
							if ( attrs[ i ] ) {
								name = attrs[ i ].name;
								if ( name.indexOf( "data-" ) === 0 ) {
									name = camelCase( name.slice( 5 ) );
									dataAttr( elem, name, data[ name ] );
								}
							}
						}
						dataPriv.set( elem, "hasDataAttrs", true );
					}
				}

				return data;
			}

			// Sets multiple values
			if ( typeof key === "object" ) {
				return this.each( function() {
					dataUser.set( this, key );
				} );
			}

			return access( this, function( value ) {
				var data;

				// The calling jQuery object (element matches) is not empty
				// (and therefore has an element appears at this[ 0 ]) and the
				// `value` parameter was not undefined. An empty jQuery object
				// will result in `undefined` for elem = this[ 0 ] which will
				// throw an exception if an attempt to read a data cache is made.
				if ( elem && value === undefined ) {

					// Attempt to get data from the cache
					// The key will always be camelCased in Data
					data = dataUser.get( elem, key );
					if ( data !== undefined ) {
						return data;
					}

					// Attempt to "discover" the data in
					// HTML5 custom data-* attrs
					data = dataAttr( elem, key );
					if ( data !== undefined ) {
						return data;
					}

					// We tried really hard, but the data doesn't exist.
					return;
				}

				// Set the data...
				this.each( function() {

					// We always store the camelCased key
					dataUser.set( this, key, value );
				} );
			}, null, value, arguments.length > 1, null, true );
		},

		removeData: function( key ) {
			return this.each( function() {
				dataUser.remove( this, key );
			} );
		}
	} );


	jQuery.extend( {
		queue: function( elem, type, data ) {
			var queue;

			if ( elem ) {
				type = ( type || "fx" ) + "queue";
				queue = dataPriv.get( elem, type );

				// Speed up dequeue by getting out quickly if this is just a lookup
				if ( data ) {
					if ( !queue || Array.isArray( data ) ) {
						queue = dataPriv.access( elem, type, jQuery.makeArray( data ) );
					} else {
						queue.push( data );
					}
				}
				return queue || [];
			}
		},

		dequeue: function( elem, type ) {
			type = type || "fx";

			var queue = jQuery.queue( elem, type ),
				startLength = queue.length,
				fn = queue.shift(),
				hooks = jQuery._queueHooks( elem, type ),
				next = function() {
					jQuery.dequeue( elem, type );
				};

			// If the fx queue is dequeued, always remove the progress sentinel
			if ( fn === "inprogress" ) {
				fn = queue.shift();
				startLength--;
			}

			if ( fn ) {

				// Add a progress sentinel to prevent the fx queue from being
				// automatically dequeued
				if ( type === "fx" ) {
					queue.unshift( "inprogress" );
				}

				// Clear up the last queue stop function
				delete hooks.stop;
				fn.call( elem, next, hooks );
			}

			if ( !startLength && hooks ) {
				hooks.empty.fire();
			}
		},

		// Not public - generate a queueHooks object, or return the current one
		_queueHooks: function( elem, type ) {
			var key = type + "queueHooks";
			return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {
				empty: jQuery.Callbacks( "once memory" ).add( function() {
					dataPriv.remove( elem, [ type + "queue", key ] );
				} )
			} );
		}
	} );

	jQuery.fn.extend( {
		queue: function( type, data ) {
			var setter = 2;

			if ( typeof type !== "string" ) {
				data = type;
				type = "fx";
				setter--;
			}

			if ( arguments.length < setter ) {
				return jQuery.queue( this[ 0 ], type );
			}

			return data === undefined ?
				this :
				this.each( function() {
					var queue = jQuery.queue( this, type, data );

					// Ensure a hooks for this queue
					jQuery._queueHooks( this, type );

					if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {
						jQuery.dequeue( this, type );
					}
				} );
		},
		dequeue: function( type ) {
			return this.each( function() {
				jQuery.dequeue( this, type );
			} );
		},
		clearQueue: function( type ) {
			return this.queue( type || "fx", [] );
		},

		// Get a promise resolved when queues of a certain type
		// are emptied (fx is the type by default)
		promise: function( type, obj ) {
			var tmp,
				count = 1,
				defer = jQuery.Deferred(),
				elements = this,
				i = this.length,
				resolve = function() {
					if ( !( --count ) ) {
						defer.resolveWith( elements, [ elements ] );
					}
				};

			if ( typeof type !== "string" ) {
				obj = type;
				type = undefined;
			}
			type = type || "fx";

			while ( i-- ) {
				tmp = dataPriv.get( elements[ i ], type + "queueHooks" );
				if ( tmp && tmp.empty ) {
					count++;
					tmp.empty.add( resolve );
				}
			}
			resolve();
			return defer.promise( obj );
		}
	} );
	var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;

	var rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );


	var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

	var isHiddenWithinTree = function( elem, el ) {

			// isHiddenWithinTree might be called from jQuery#filter function;
			// in that case, element will be second argument
			elem = el || elem;

			// Inline style trumps all
			return elem.style.display === "none" ||
				elem.style.display === "" &&

				// Otherwise, check computed style
				// Support: Firefox <=43 - 45
				// Disconnected elements can have computed display: none, so first confirm that elem is
				// in the document.
				jQuery.contains( elem.ownerDocument, elem ) &&

				jQuery.css( elem, "display" ) === "none";
		};

	var swap = function( elem, options, callback, args ) {
		var ret, name,
			old = {};

		// Remember the old values, and insert the new ones
		for ( name in options ) {
			old[ name ] = elem.style[ name ];
			elem.style[ name ] = options[ name ];
		}

		ret = callback.apply( elem, args || [] );

		// Revert the old values
		for ( name in options ) {
			elem.style[ name ] = old[ name ];
		}

		return ret;
	};




	function adjustCSS( elem, prop, valueParts, tween ) {
		var adjusted, scale,
			maxIterations = 20,
			currentValue = tween ?
				function() {
					return tween.cur();
				} :
				function() {
					return jQuery.css( elem, prop, "" );
				},
			initial = currentValue(),
			unit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

			// Starting value computation is required for potential unit mismatches
			initialInUnit = ( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&
				rcssNum.exec( jQuery.css( elem, prop ) );

		if ( initialInUnit && initialInUnit[ 3 ] !== unit ) {

			// Support: Firefox <=54
			// Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)
			initial = initial / 2;

			// Trust units reported by jQuery.css
			unit = unit || initialInUnit[ 3 ];

			// Iteratively approximate from a nonzero starting point
			initialInUnit = +initial || 1;

			while ( maxIterations-- ) {

				// Evaluate and update our best guess (doubling guesses that zero out).
				// Finish if the scale equals or crosses 1 (making the old*new product non-positive).
				jQuery.style( elem, prop, initialInUnit + unit );
				if ( ( 1 - scale ) * ( 1 - ( scale = currentValue() / initial || 0.5 ) ) <= 0 ) {
					maxIterations = 0;
				}
				initialInUnit = initialInUnit / scale;

			}

			initialInUnit = initialInUnit * 2;
			jQuery.style( elem, prop, initialInUnit + unit );

			// Make sure we update the tween properties later on
			valueParts = valueParts || [];
		}

		if ( valueParts ) {
			initialInUnit = +initialInUnit || +initial || 0;

			// Apply relative offset (+=/-=) if specified
			adjusted = valueParts[ 1 ] ?
				initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :
				+valueParts[ 2 ];
			if ( tween ) {
				tween.unit = unit;
				tween.start = initialInUnit;
				tween.end = adjusted;
			}
		}
		return adjusted;
	}


	var defaultDisplayMap = {};

	function getDefaultDisplay( elem ) {
		var temp,
			doc = elem.ownerDocument,
			nodeName = elem.nodeName,
			display = defaultDisplayMap[ nodeName ];

		if ( display ) {
			return display;
		}

		temp = doc.body.appendChild( doc.createElement( nodeName ) );
		display = jQuery.css( temp, "display" );

		temp.parentNode.removeChild( temp );

		if ( display === "none" ) {
			display = "block";
		}
		defaultDisplayMap[ nodeName ] = display;

		return display;
	}

	function showHide( elements, show ) {
		var display, elem,
			values = [],
			index = 0,
			length = elements.length;

		// Determine new display value for elements that need to change
		for ( ; index < length; index++ ) {
			elem = elements[ index ];
			if ( !elem.style ) {
				continue;
			}

			display = elem.style.display;
			if ( show ) {

				// Since we force visibility upon cascade-hidden elements, an immediate (and slow)
				// check is required in this first loop unless we have a nonempty display value (either
				// inline or about-to-be-restored)
				if ( display === "none" ) {
					values[ index ] = dataPriv.get( elem, "display" ) || null;
					if ( !values[ index ] ) {
						elem.style.display = "";
					}
				}
				if ( elem.style.display === "" && isHiddenWithinTree( elem ) ) {
					values[ index ] = getDefaultDisplay( elem );
				}
			} else {
				if ( display !== "none" ) {
					values[ index ] = "none";

					// Remember what we're overwriting
					dataPriv.set( elem, "display", display );
				}
			}
		}

		// Set the display of the elements in a second loop to avoid constant reflow
		for ( index = 0; index < length; index++ ) {
			if ( values[ index ] != null ) {
				elements[ index ].style.display = values[ index ];
			}
		}

		return elements;
	}

	jQuery.fn.extend( {
		show: function() {
			return showHide( this, true );
		},
		hide: function() {
			return showHide( this );
		},
		toggle: function( state ) {
			if ( typeof state === "boolean" ) {
				return state ? this.show() : this.hide();
			}

			return this.each( function() {
				if ( isHiddenWithinTree( this ) ) {
					jQuery( this ).show();
				} else {
					jQuery( this ).hide();
				}
			} );
		}
	} );
	var rcheckableType = ( /^(?:checkbox|radio)$/i );

	var rtagName = ( /<([a-z][^\/\0>\x20\t\r\n\f]+)/i );

	var rscriptType = ( /^$|^module$|\/(?:java|ecma)script/i );



	// We have to close these tags to support XHTML (#13200)
	var wrapMap = {

		// Support: IE <=9 only
		option: [ 1, "<select multiple='multiple'>", "</select>" ],

		// XHTML parsers do not magically insert elements in the
		// same way that tag soup parsers do. So we cannot shorten
		// this by omitting <tbody> or other required elements.
		thead: [ 1, "<table>", "</table>" ],
		col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
		tr: [ 2, "<table><tbody>", "</tbody></table>" ],
		td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

		_default: [ 0, "", "" ]
	};

	// Support: IE <=9 only
	wrapMap.optgroup = wrapMap.option;

	wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
	wrapMap.th = wrapMap.td;


	function getAll( context, tag ) {

		// Support: IE <=9 - 11 only
		// Use typeof to avoid zero-argument method invocation on host objects (#15151)
		var ret;

		if ( typeof context.getElementsByTagName !== "undefined" ) {
			ret = context.getElementsByTagName( tag || "*" );

		} else if ( typeof context.querySelectorAll !== "undefined" ) {
			ret = context.querySelectorAll( tag || "*" );

		} else {
			ret = [];
		}

		if ( tag === undefined || tag && nodeName( context, tag ) ) {
			return jQuery.merge( [ context ], ret );
		}

		return ret;
	}


	// Mark scripts as having already been evaluated
	function setGlobalEval( elems, refElements ) {
		var i = 0,
			l = elems.length;

		for ( ; i < l; i++ ) {
			dataPriv.set(
				elems[ i ],
				"globalEval",
				!refElements || dataPriv.get( refElements[ i ], "globalEval" )
			);
		}
	}


	var rhtml = /<|&#?\w+;/;

	function buildFragment( elems, context, scripts, selection, ignored ) {
		var elem, tmp, tag, wrap, contains, j,
			fragment = context.createDocumentFragment(),
			nodes = [],
			i = 0,
			l = elems.length;

		for ( ; i < l; i++ ) {
			elem = elems[ i ];

			if ( elem || elem === 0 ) {

				// Add nodes directly
				if ( toType( elem ) === "object" ) {

					// Support: Android <=4.0 only, PhantomJS 1 only
					// push.apply(_, arraylike) throws on ancient WebKit
					jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

				// Convert non-html into a text node
				} else if ( !rhtml.test( elem ) ) {
					nodes.push( context.createTextNode( elem ) );

				// Convert html into DOM nodes
				} else {
					tmp = tmp || fragment.appendChild( context.createElement( "div" ) );

					// Deserialize a standard representation
					tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
					wrap = wrapMap[ tag ] || wrapMap._default;
					tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];

					// Descend through wrappers to the right content
					j = wrap[ 0 ];
					while ( j-- ) {
						tmp = tmp.lastChild;
					}

					// Support: Android <=4.0 only, PhantomJS 1 only
					// push.apply(_, arraylike) throws on ancient WebKit
					jQuery.merge( nodes, tmp.childNodes );

					// Remember the top-level container
					tmp = fragment.firstChild;

					// Ensure the created nodes are orphaned (#12392)
					tmp.textContent = "";
				}
			}
		}

		// Remove wrapper from fragment
		fragment.textContent = "";

		i = 0;
		while ( ( elem = nodes[ i++ ] ) ) {

			// Skip elements already in the context collection (trac-4087)
			if ( selection && jQuery.inArray( elem, selection ) > -1 ) {
				if ( ignored ) {
					ignored.push( elem );
				}
				continue;
			}

			contains = jQuery.contains( elem.ownerDocument, elem );

			// Append to fragment
			tmp = getAll( fragment.appendChild( elem ), "script" );

			// Preserve script evaluation history
			if ( contains ) {
				setGlobalEval( tmp );
			}

			// Capture executables
			if ( scripts ) {
				j = 0;
				while ( ( elem = tmp[ j++ ] ) ) {
					if ( rscriptType.test( elem.type || "" ) ) {
						scripts.push( elem );
					}
				}
			}
		}

		return fragment;
	}


	( function() {
		var fragment = document.createDocumentFragment(),
			div = fragment.appendChild( document.createElement( "div" ) ),
			input = document.createElement( "input" );

		// Support: Android 4.0 - 4.3 only
		// Check state lost if the name is set (#11217)
		// Support: Windows Web Apps (WWA)
		// `name` and `type` must use .setAttribute for WWA (#14901)
		input.setAttribute( "type", "radio" );
		input.setAttribute( "checked", "checked" );
		input.setAttribute( "name", "t" );

		div.appendChild( input );

		// Support: Android <=4.1 only
		// Older WebKit doesn't clone checked state correctly in fragments
		support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

		// Support: IE <=11 only
		// Make sure textarea (and checkbox) defaultValue is properly cloned
		div.innerHTML = "<textarea>x</textarea>";
		support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;
	} )();
	var documentElement = document.documentElement;



	var
		rkeyEvent = /^key/,
		rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
		rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

	function returnTrue() {
		return true;
	}

	function returnFalse() {
		return false;
	}

	// Support: IE <=9 only
	// See #13393 for more info
	function safeActiveElement() {
		try {
			return document.activeElement;
		} catch ( err ) { }
	}

	function on( elem, types, selector, data, fn, one ) {
		var origFn, type;

		// Types can be a map of types/handlers
		if ( typeof types === "object" ) {

			// ( types-Object, selector, data )
			if ( typeof selector !== "string" ) {

				// ( types-Object, data )
				data = data || selector;
				selector = undefined;
			}
			for ( type in types ) {
				on( elem, type, selector, data, types[ type ], one );
			}
			return elem;
		}

		if ( data == null && fn == null ) {

			// ( types, fn )
			fn = selector;
			data = selector = undefined;
		} else if ( fn == null ) {
			if ( typeof selector === "string" ) {

				// ( types, selector, fn )
				fn = data;
				data = undefined;
			} else {

				// ( types, data, fn )
				fn = data;
				data = selector;
				selector = undefined;
			}
		}
		if ( fn === false ) {
			fn = returnFalse;
		} else if ( !fn ) {
			return elem;
		}

		if ( one === 1 ) {
			origFn = fn;
			fn = function( event ) {

				// Can use an empty set, since event contains the info
				jQuery().off( event );
				return origFn.apply( this, arguments );
			};

			// Use same guid so caller can remove using origFn
			fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
		}
		return elem.each( function() {
			jQuery.event.add( this, types, fn, data, selector );
		} );
	}

	/*
	 * Helper functions for managing events -- not part of the public interface.
	 * Props to Dean Edwards' addEvent library for many of the ideas.
	 */
	jQuery.event = {

		global: {},

		add: function( elem, types, handler, data, selector ) {

			var handleObjIn, eventHandle, tmp,
				events, t, handleObj,
				special, handlers, type, namespaces, origType,
				elemData = dataPriv.get( elem );

			// Don't attach events to noData or text/comment nodes (but allow plain objects)
			if ( !elemData ) {
				return;
			}

			// Caller can pass in an object of custom data in lieu of the handler
			if ( handler.handler ) {
				handleObjIn = handler;
				handler = handleObjIn.handler;
				selector = handleObjIn.selector;
			}

			// Ensure that invalid selectors throw exceptions at attach time
			// Evaluate against documentElement in case elem is a non-element node (e.g., document)
			if ( selector ) {
				jQuery.find.matchesSelector( documentElement, selector );
			}

			// Make sure that the handler has a unique ID, used to find/remove it later
			if ( !handler.guid ) {
				handler.guid = jQuery.guid++;
			}

			// Init the element's event structure and main handler, if this is the first
			if ( !( events = elemData.events ) ) {
				events = elemData.events = {};
			}
			if ( !( eventHandle = elemData.handle ) ) {
				eventHandle = elemData.handle = function( e ) {

					// Discard the second event of a jQuery.event.trigger() and
					// when an event is called after a page has unloaded
					return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
						jQuery.event.dispatch.apply( elem, arguments ) : undefined;
				};
			}

			// Handle multiple events separated by a space
			types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
			t = types.length;
			while ( t-- ) {
				tmp = rtypenamespace.exec( types[ t ] ) || [];
				type = origType = tmp[ 1 ];
				namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

				// There *must* be a type, no attaching namespace-only handlers
				if ( !type ) {
					continue;
				}

				// If event changes its type, use the special event handlers for the changed type
				special = jQuery.event.special[ type ] || {};

				// If selector defined, determine special event api type, otherwise given type
				type = ( selector ? special.delegateType : special.bindType ) || type;

				// Update special based on newly reset type
				special = jQuery.event.special[ type ] || {};

				// handleObj is passed to all event handlers
				handleObj = jQuery.extend( {
					type: type,
					origType: origType,
					data: data,
					handler: handler,
					guid: handler.guid,
					selector: selector,
					needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
					namespace: namespaces.join( "." )
				}, handleObjIn );

				// Init the event handler queue if we're the first
				if ( !( handlers = events[ type ] ) ) {
					handlers = events[ type ] = [];
					handlers.delegateCount = 0;

					// Only use addEventListener if the special events handler returns false
					if ( !special.setup ||
						special.setup.call( elem, data, namespaces, eventHandle ) === false ) {

						if ( elem.addEventListener ) {
							elem.addEventListener( type, eventHandle );
						}
					}
				}

				if ( special.add ) {
					special.add.call( elem, handleObj );

					if ( !handleObj.handler.guid ) {
						handleObj.handler.guid = handler.guid;
					}
				}

				// Add to the element's handler list, delegates in front
				if ( selector ) {
					handlers.splice( handlers.delegateCount++, 0, handleObj );
				} else {
					handlers.push( handleObj );
				}

				// Keep track of which events have ever been used, for event optimization
				jQuery.event.global[ type ] = true;
			}

		},

		// Detach an event or set of events from an element
		remove: function( elem, types, handler, selector, mappedTypes ) {

			var j, origCount, tmp,
				events, t, handleObj,
				special, handlers, type, namespaces, origType,
				elemData = dataPriv.hasData( elem ) && dataPriv.get( elem );

			if ( !elemData || !( events = elemData.events ) ) {
				return;
			}

			// Once for each type.namespace in types; type may be omitted
			types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
			t = types.length;
			while ( t-- ) {
				tmp = rtypenamespace.exec( types[ t ] ) || [];
				type = origType = tmp[ 1 ];
				namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

				// Unbind all events (on this namespace, if provided) for the element
				if ( !type ) {
					for ( type in events ) {
						jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
					}
					continue;
				}

				special = jQuery.event.special[ type ] || {};
				type = ( selector ? special.delegateType : special.bindType ) || type;
				handlers = events[ type ] || [];
				tmp = tmp[ 2 ] &&
					new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" );

				// Remove matching events
				origCount = j = handlers.length;
				while ( j-- ) {
					handleObj = handlers[ j ];

					if ( ( mappedTypes || origType === handleObj.origType ) &&
						( !handler || handler.guid === handleObj.guid ) &&
						( !tmp || tmp.test( handleObj.namespace ) ) &&
						( !selector || selector === handleObj.selector ||
							selector === "**" && handleObj.selector ) ) {
						handlers.splice( j, 1 );

						if ( handleObj.selector ) {
							handlers.delegateCount--;
						}
						if ( special.remove ) {
							special.remove.call( elem, handleObj );
						}
					}
				}

				// Remove generic event handler if we removed something and no more handlers exist
				// (avoids potential for endless recursion during removal of special event handlers)
				if ( origCount && !handlers.length ) {
					if ( !special.teardown ||
						special.teardown.call( elem, namespaces, elemData.handle ) === false ) {

						jQuery.removeEvent( elem, type, elemData.handle );
					}

					delete events[ type ];
				}
			}

			// Remove data and the expando if it's no longer used
			if ( jQuery.isEmptyObject( events ) ) {
				dataPriv.remove( elem, "handle events" );
			}
		},

		dispatch: function( nativeEvent ) {

			// Make a writable jQuery.Event from the native event object
			var event = jQuery.event.fix( nativeEvent );

			var i, j, ret, matched, handleObj, handlerQueue,
				args = new Array( arguments.length ),
				handlers = ( dataPriv.get( this, "events" ) || {} )[ event.type ] || [],
				special = jQuery.event.special[ event.type ] || {};

			// Use the fix-ed jQuery.Event rather than the (read-only) native event
			args[ 0 ] = event;

			for ( i = 1; i < arguments.length; i++ ) {
				args[ i ] = arguments[ i ];
			}

			event.delegateTarget = this;

			// Call the preDispatch hook for the mapped type, and let it bail if desired
			if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
				return;
			}

			// Determine handlers
			handlerQueue = jQuery.event.handlers.call( this, event, handlers );

			// Run delegates first; they may want to stop propagation beneath us
			i = 0;
			while ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {
				event.currentTarget = matched.elem;

				j = 0;
				while ( ( handleObj = matched.handlers[ j++ ] ) &&
					!event.isImmediatePropagationStopped() ) {

					// Triggered event must either 1) have no namespace, or 2) have namespace(s)
					// a subset or equal to those in the bound event (both can have no namespace).
					if ( !event.rnamespace || event.rnamespace.test( handleObj.namespace ) ) {

						event.handleObj = handleObj;
						event.data = handleObj.data;

						ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||
							handleObj.handler ).apply( matched.elem, args );

						if ( ret !== undefined ) {
							if ( ( event.result = ret ) === false ) {
								event.preventDefault();
								event.stopPropagation();
							}
						}
					}
				}
			}

			// Call the postDispatch hook for the mapped type
			if ( special.postDispatch ) {
				special.postDispatch.call( this, event );
			}

			return event.result;
		},

		handlers: function( event, handlers ) {
			var i, handleObj, sel, matchedHandlers, matchedSelectors,
				handlerQueue = [],
				delegateCount = handlers.delegateCount,
				cur = event.target;

			// Find delegate handlers
			if ( delegateCount &&

				// Support: IE <=9
				// Black-hole SVG <use> instance trees (trac-13180)
				cur.nodeType &&

				// Support: Firefox <=42
				// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
				// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
				// Support: IE 11 only
				// ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
				!( event.type === "click" && event.button >= 1 ) ) {

				for ( ; cur !== this; cur = cur.parentNode || this ) {

					// Don't check non-elements (#13208)
					// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
					if ( cur.nodeType === 1 && !( event.type === "click" && cur.disabled === true ) ) {
						matchedHandlers = [];
						matchedSelectors = {};
						for ( i = 0; i < delegateCount; i++ ) {
							handleObj = handlers[ i ];

							// Don't conflict with Object.prototype properties (#13203)
							sel = handleObj.selector + " ";

							if ( matchedSelectors[ sel ] === undefined ) {
								matchedSelectors[ sel ] = handleObj.needsContext ?
									jQuery( sel, this ).index( cur ) > -1 :
									jQuery.find( sel, this, null, [ cur ] ).length;
							}
							if ( matchedSelectors[ sel ] ) {
								matchedHandlers.push( handleObj );
							}
						}
						if ( matchedHandlers.length ) {
							handlerQueue.push( { elem: cur, handlers: matchedHandlers } );
						}
					}
				}
			}

			// Add the remaining (directly-bound) handlers
			cur = this;
			if ( delegateCount < handlers.length ) {
				handlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );
			}

			return handlerQueue;
		},

		addProp: function( name, hook ) {
			Object.defineProperty( jQuery.Event.prototype, name, {
				enumerable: true,
				configurable: true,

				get: isFunction( hook ) ?
					function() {
						if ( this.originalEvent ) {
								return hook( this.originalEvent );
						}
					} :
					function() {
						if ( this.originalEvent ) {
								return this.originalEvent[ name ];
						}
					},

				set: function( value ) {
					Object.defineProperty( this, name, {
						enumerable: true,
						configurable: true,
						writable: true,
						value: value
					} );
				}
			} );
		},

		fix: function( originalEvent ) {
			return originalEvent[ jQuery.expando ] ?
				originalEvent :
				new jQuery.Event( originalEvent );
		},

		special: {
			load: {

				// Prevent triggered image.load events from bubbling to window.load
				noBubble: true
			},
			focus: {

				// Fire native event if possible so blur/focus sequence is correct
				trigger: function() {
					if ( this !== safeActiveElement() && this.focus ) {
						this.focus();
						return false;
					}
				},
				delegateType: "focusin"
			},
			blur: {
				trigger: function() {
					if ( this === safeActiveElement() && this.blur ) {
						this.blur();
						return false;
					}
				},
				delegateType: "focusout"
			},
			click: {

				// For checkbox, fire native event so checked state will be right
				trigger: function() {
					if ( this.type === "checkbox" && this.click && nodeName( this, "input" ) ) {
						this.click();
						return false;
					}
				},

				// For cross-browser consistency, don't fire native .click() on links
				_default: function( event ) {
					return nodeName( event.target, "a" );
				}
			},

			beforeunload: {
				postDispatch: function( event ) {

					// Support: Firefox 20+
					// Firefox doesn't alert if the returnValue field is not set.
					if ( event.result !== undefined && event.originalEvent ) {
						event.originalEvent.returnValue = event.result;
					}
				}
			}
		}
	};

	jQuery.removeEvent = function( elem, type, handle ) {

		// This "if" is needed for plain objects
		if ( elem.removeEventListener ) {
			elem.removeEventListener( type, handle );
		}
	};

	jQuery.Event = function( src, props ) {

		// Allow instantiation without the 'new' keyword
		if ( !( this instanceof jQuery.Event ) ) {
			return new jQuery.Event( src, props );
		}

		// Event object
		if ( src && src.type ) {
			this.originalEvent = src;
			this.type = src.type;

			// Events bubbling up the document may have been marked as prevented
			// by a handler lower down the tree; reflect the correct value.
			this.isDefaultPrevented = src.defaultPrevented ||
					src.defaultPrevented === undefined &&

					// Support: Android <=2.3 only
					src.returnValue === false ?
				returnTrue :
				returnFalse;

			// Create target properties
			// Support: Safari <=6 - 7 only
			// Target should not be a text node (#504, #13143)
			this.target = ( src.target && src.target.nodeType === 3 ) ?
				src.target.parentNode :
				src.target;

			this.currentTarget = src.currentTarget;
			this.relatedTarget = src.relatedTarget;

		// Event type
		} else {
			this.type = src;
		}

		// Put explicitly provided properties onto the event object
		if ( props ) {
			jQuery.extend( this, props );
		}

		// Create a timestamp if incoming event doesn't have one
		this.timeStamp = src && src.timeStamp || Date.now();

		// Mark it as fixed
		this[ jQuery.expando ] = true;
	};

	// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
	// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
	jQuery.Event.prototype = {
		constructor: jQuery.Event,
		isDefaultPrevented: returnFalse,
		isPropagationStopped: returnFalse,
		isImmediatePropagationStopped: returnFalse,
		isSimulated: false,

		preventDefault: function() {
			var e = this.originalEvent;

			this.isDefaultPrevented = returnTrue;

			if ( e && !this.isSimulated ) {
				e.preventDefault();
			}
		},
		stopPropagation: function() {
			var e = this.originalEvent;

			this.isPropagationStopped = returnTrue;

			if ( e && !this.isSimulated ) {
				e.stopPropagation();
			}
		},
		stopImmediatePropagation: function() {
			var e = this.originalEvent;

			this.isImmediatePropagationStopped = returnTrue;

			if ( e && !this.isSimulated ) {
				e.stopImmediatePropagation();
			}

			this.stopPropagation();
		}
	};

	// Includes all common event props including KeyEvent and MouseEvent specific props
	jQuery.each( {
		altKey: true,
		bubbles: true,
		cancelable: true,
		changedTouches: true,
		ctrlKey: true,
		detail: true,
		eventPhase: true,
		metaKey: true,
		pageX: true,
		pageY: true,
		shiftKey: true,
		view: true,
		"char": true,
		charCode: true,
		key: true,
		keyCode: true,
		button: true,
		buttons: true,
		clientX: true,
		clientY: true,
		offsetX: true,
		offsetY: true,
		pointerId: true,
		pointerType: true,
		screenX: true,
		screenY: true,
		targetTouches: true,
		toElement: true,
		touches: true,

		which: function( event ) {
			var button = event.button;

			// Add which for key events
			if ( event.which == null && rkeyEvent.test( event.type ) ) {
				return event.charCode != null ? event.charCode : event.keyCode;
			}

			// Add which for click: 1 === left; 2 === middle; 3 === right
			if ( !event.which && button !== undefined && rmouseEvent.test( event.type ) ) {
				if ( button & 1 ) {
					return 1;
				}

				if ( button & 2 ) {
					return 3;
				}

				if ( button & 4 ) {
					return 2;
				}

				return 0;
			}

			return event.which;
		}
	}, jQuery.event.addProp );

	// Create mouseenter/leave events using mouseover/out and event-time checks
	// so that event delegation works in jQuery.
	// Do the same for pointerenter/pointerleave and pointerover/pointerout
	//
	// Support: Safari 7 only
	// Safari sends mouseenter too often; see:
	// https://bugs.chromium.org/p/chromium/issues/detail?id=470258
	// for the description of the bug (it existed in older Chrome versions as well).
	jQuery.each( {
		mouseenter: "mouseover",
		mouseleave: "mouseout",
		pointerenter: "pointerover",
		pointerleave: "pointerout"
	}, function( orig, fix ) {
		jQuery.event.special[ orig ] = {
			delegateType: fix,
			bindType: fix,

			handle: function( event ) {
				var ret,
					target = this,
					related = event.relatedTarget,
					handleObj = event.handleObj;

				// For mouseenter/leave call the handler if related is outside the target.
				// NB: No relatedTarget if the mouse left/entered the browser window
				if ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {
					event.type = handleObj.origType;
					ret = handleObj.handler.apply( this, arguments );
					event.type = fix;
				}
				return ret;
			}
		};
	} );

	jQuery.fn.extend( {

		on: function( types, selector, data, fn ) {
			return on( this, types, selector, data, fn );
		},
		one: function( types, selector, data, fn ) {
			return on( this, types, selector, data, fn, 1 );
		},
		off: function( types, selector, fn ) {
			var handleObj, type;
			if ( types && types.preventDefault && types.handleObj ) {

				// ( event )  dispatched jQuery.Event
				handleObj = types.handleObj;
				jQuery( types.delegateTarget ).off(
					handleObj.namespace ?
						handleObj.origType + "." + handleObj.namespace :
						handleObj.origType,
					handleObj.selector,
					handleObj.handler
				);
				return this;
			}
			if ( typeof types === "object" ) {

				// ( types-object [, selector] )
				for ( type in types ) {
					this.off( type, selector, types[ type ] );
				}
				return this;
			}
			if ( selector === false || typeof selector === "function" ) {

				// ( types [, fn] )
				fn = selector;
				selector = undefined;
			}
			if ( fn === false ) {
				fn = returnFalse;
			}
			return this.each( function() {
				jQuery.event.remove( this, types, fn, selector );
			} );
		}
	} );


	var

		/* eslint-disable max-len */

		// See https://github.com/eslint/eslint/issues/3229
		rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi,

		/* eslint-enable */

		// Support: IE <=10 - 11, Edge 12 - 13 only
		// In IE/Edge using regex groups here causes severe slowdowns.
		// See https://connect.microsoft.com/IE/feedback/details/1736512/
		rnoInnerhtml = /<script|<style|<link/i,

		// checked="checked" or checked
		rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
		rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

	// Prefer a tbody over its parent table for containing new rows
	function manipulationTarget( elem, content ) {
		if ( nodeName( elem, "table" ) &&
			nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ) {

			return jQuery( elem ).children( "tbody" )[ 0 ] || elem;
		}

		return elem;
	}

	// Replace/restore the type attribute of script elements for safe DOM manipulation
	function disableScript( elem ) {
		elem.type = ( elem.getAttribute( "type" ) !== null ) + "/" + elem.type;
		return elem;
	}
	function restoreScript( elem ) {
		if ( ( elem.type || "" ).slice( 0, 5 ) === "true/" ) {
			elem.type = elem.type.slice( 5 );
		} else {
			elem.removeAttribute( "type" );
		}

		return elem;
	}

	function cloneCopyEvent( src, dest ) {
		var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;

		if ( dest.nodeType !== 1 ) {
			return;
		}

		// 1. Copy private data: events, handlers, etc.
		if ( dataPriv.hasData( src ) ) {
			pdataOld = dataPriv.access( src );
			pdataCur = dataPriv.set( dest, pdataOld );
			events = pdataOld.events;

			if ( events ) {
				delete pdataCur.handle;
				pdataCur.events = {};

				for ( type in events ) {
					for ( i = 0, l = events[ type ].length; i < l; i++ ) {
						jQuery.event.add( dest, type, events[ type ][ i ] );
					}
				}
			}
		}

		// 2. Copy user data
		if ( dataUser.hasData( src ) ) {
			udataOld = dataUser.access( src );
			udataCur = jQuery.extend( {}, udataOld );

			dataUser.set( dest, udataCur );
		}
	}

	// Fix IE bugs, see support tests
	function fixInput( src, dest ) {
		var nodeName = dest.nodeName.toLowerCase();

		// Fails to persist the checked state of a cloned checkbox or radio button.
		if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
			dest.checked = src.checked;

		// Fails to return the selected option to the default selected state when cloning options
		} else if ( nodeName === "input" || nodeName === "textarea" ) {
			dest.defaultValue = src.defaultValue;
		}
	}

	function domManip( collection, args, callback, ignored ) {

		// Flatten any nested arrays
		args = concat.apply( [], args );

		var fragment, first, scripts, hasScripts, node, doc,
			i = 0,
			l = collection.length,
			iNoClone = l - 1,
			value = args[ 0 ],
			valueIsFunction = isFunction( value );

		// We can't cloneNode fragments that contain checked, in WebKit
		if ( valueIsFunction ||
				( l > 1 && typeof value === "string" &&
					!support.checkClone && rchecked.test( value ) ) ) {
			return collection.each( function( index ) {
				var self = collection.eq( index );
				if ( valueIsFunction ) {
					args[ 0 ] = value.call( this, index, self.html() );
				}
				domManip( self, args, callback, ignored );
			} );
		}

		if ( l ) {
			fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
			first = fragment.firstChild;

			if ( fragment.childNodes.length === 1 ) {
				fragment = first;
			}

			// Require either new content or an interest in ignored elements to invoke the callback
			if ( first || ignored ) {
				scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
				hasScripts = scripts.length;

				// Use the original fragment for the last item
				// instead of the first because it can end up
				// being emptied incorrectly in certain situations (#8070).
				for ( ; i < l; i++ ) {
					node = fragment;

					if ( i !== iNoClone ) {
						node = jQuery.clone( node, true, true );

						// Keep references to cloned scripts for later restoration
						if ( hasScripts ) {

							// Support: Android <=4.0 only, PhantomJS 1 only
							// push.apply(_, arraylike) throws on ancient WebKit
							jQuery.merge( scripts, getAll( node, "script" ) );
						}
					}

					callback.call( collection[ i ], node, i );
				}

				if ( hasScripts ) {
					doc = scripts[ scripts.length - 1 ].ownerDocument;

					// Reenable scripts
					jQuery.map( scripts, restoreScript );

					// Evaluate executable scripts on first document insertion
					for ( i = 0; i < hasScripts; i++ ) {
						node = scripts[ i ];
						if ( rscriptType.test( node.type || "" ) &&
							!dataPriv.access( node, "globalEval" ) &&
							jQuery.contains( doc, node ) ) {

							if ( node.src && ( node.type || "" ).toLowerCase()  !== "module" ) {

								// Optional AJAX dependency, but won't run scripts if not present
								if ( jQuery._evalUrl ) {
									jQuery._evalUrl( node.src );
								}
							} else {
								DOMEval( node.textContent.replace( rcleanScript, "" ), doc, node );
							}
						}
					}
				}
			}
		}

		return collection;
	}

	function remove( elem, selector, keepData ) {
		var node,
			nodes = selector ? jQuery.filter( selector, elem ) : elem,
			i = 0;

		for ( ; ( node = nodes[ i ] ) != null; i++ ) {
			if ( !keepData && node.nodeType === 1 ) {
				jQuery.cleanData( getAll( node ) );
			}

			if ( node.parentNode ) {
				if ( keepData && jQuery.contains( node.ownerDocument, node ) ) {
					setGlobalEval( getAll( node, "script" ) );
				}
				node.parentNode.removeChild( node );
			}
		}

		return elem;
	}

	jQuery.extend( {
		htmlPrefilter: function( html ) {
			return html.replace( rxhtmlTag, "<$1></$2>" );
		},

		clone: function( elem, dataAndEvents, deepDataAndEvents ) {
			var i, l, srcElements, destElements,
				clone = elem.cloneNode( true ),
				inPage = jQuery.contains( elem.ownerDocument, elem );

			// Fix IE cloning issues
			if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
					!jQuery.isXMLDoc( elem ) ) {

				// We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2
				destElements = getAll( clone );
				srcElements = getAll( elem );

				for ( i = 0, l = srcElements.length; i < l; i++ ) {
					fixInput( srcElements[ i ], destElements[ i ] );
				}
			}

			// Copy the events from the original to the clone
			if ( dataAndEvents ) {
				if ( deepDataAndEvents ) {
					srcElements = srcElements || getAll( elem );
					destElements = destElements || getAll( clone );

					for ( i = 0, l = srcElements.length; i < l; i++ ) {
						cloneCopyEvent( srcElements[ i ], destElements[ i ] );
					}
				} else {
					cloneCopyEvent( elem, clone );
				}
			}

			// Preserve script evaluation history
			destElements = getAll( clone, "script" );
			if ( destElements.length > 0 ) {
				setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
			}

			// Return the cloned set
			return clone;
		},

		cleanData: function( elems ) {
			var data, elem, type,
				special = jQuery.event.special,
				i = 0;

			for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {
				if ( acceptData( elem ) ) {
					if ( ( data = elem[ dataPriv.expando ] ) ) {
						if ( data.events ) {
							for ( type in data.events ) {
								if ( special[ type ] ) {
									jQuery.event.remove( elem, type );

								// This is a shortcut to avoid jQuery.event.remove's overhead
								} else {
									jQuery.removeEvent( elem, type, data.handle );
								}
							}
						}

						// Support: Chrome <=35 - 45+
						// Assign undefined instead of using delete, see Data#remove
						elem[ dataPriv.expando ] = undefined;
					}
					if ( elem[ dataUser.expando ] ) {

						// Support: Chrome <=35 - 45+
						// Assign undefined instead of using delete, see Data#remove
						elem[ dataUser.expando ] = undefined;
					}
				}
			}
		}
	} );

	jQuery.fn.extend( {
		detach: function( selector ) {
			return remove( this, selector, true );
		},

		remove: function( selector ) {
			return remove( this, selector );
		},

		text: function( value ) {
			return access( this, function( value ) {
				return value === undefined ?
					jQuery.text( this ) :
					this.empty().each( function() {
						if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
							this.textContent = value;
						}
					} );
			}, null, value, arguments.length );
		},

		append: function() {
			return domManip( this, arguments, function( elem ) {
				if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
					var target = manipulationTarget( this, elem );
					target.appendChild( elem );
				}
			} );
		},

		prepend: function() {
			return domManip( this, arguments, function( elem ) {
				if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
					var target = manipulationTarget( this, elem );
					target.insertBefore( elem, target.firstChild );
				}
			} );
		},

		before: function() {
			return domManip( this, arguments, function( elem ) {
				if ( this.parentNode ) {
					this.parentNode.insertBefore( elem, this );
				}
			} );
		},

		after: function() {
			return domManip( this, arguments, function( elem ) {
				if ( this.parentNode ) {
					this.parentNode.insertBefore( elem, this.nextSibling );
				}
			} );
		},

		empty: function() {
			var elem,
				i = 0;

			for ( ; ( elem = this[ i ] ) != null; i++ ) {
				if ( elem.nodeType === 1 ) {

					// Prevent memory leaks
					jQuery.cleanData( getAll( elem, false ) );

					// Remove any remaining nodes
					elem.textContent = "";
				}
			}

			return this;
		},

		clone: function( dataAndEvents, deepDataAndEvents ) {
			dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
			deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

			return this.map( function() {
				return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
			} );
		},

		html: function( value ) {
			return access( this, function( value ) {
				var elem = this[ 0 ] || {},
					i = 0,
					l = this.length;

				if ( value === undefined && elem.nodeType === 1 ) {
					return elem.innerHTML;
				}

				// See if we can take a shortcut and just use innerHTML
				if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
					!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

					value = jQuery.htmlPrefilter( value );

					try {
						for ( ; i < l; i++ ) {
							elem = this[ i ] || {};

							// Remove element nodes and prevent memory leaks
							if ( elem.nodeType === 1 ) {
								jQuery.cleanData( getAll( elem, false ) );
								elem.innerHTML = value;
							}
						}

						elem = 0;

					// If using innerHTML throws an exception, use the fallback method
					} catch ( e ) {}
				}

				if ( elem ) {
					this.empty().append( value );
				}
			}, null, value, arguments.length );
		},

		replaceWith: function() {
			var ignored = [];

			// Make the changes, replacing each non-ignored context element with the new content
			return domManip( this, arguments, function( elem ) {
				var parent = this.parentNode;

				if ( jQuery.inArray( this, ignored ) < 0 ) {
					jQuery.cleanData( getAll( this ) );
					if ( parent ) {
						parent.replaceChild( elem, this );
					}
				}

			// Force callback invocation
			}, ignored );
		}
	} );

	jQuery.each( {
		appendTo: "append",
		prependTo: "prepend",
		insertBefore: "before",
		insertAfter: "after",
		replaceAll: "replaceWith"
	}, function( name, original ) {
		jQuery.fn[ name ] = function( selector ) {
			var elems,
				ret = [],
				insert = jQuery( selector ),
				last = insert.length - 1,
				i = 0;

			for ( ; i <= last; i++ ) {
				elems = i === last ? this : this.clone( true );
				jQuery( insert[ i ] )[ original ]( elems );

				// Support: Android <=4.0 only, PhantomJS 1 only
				// .get() because push.apply(_, arraylike) throws on ancient WebKit
				push.apply( ret, elems.get() );
			}

			return this.pushStack( ret );
		};
	} );
	var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

	var getStyles = function( elem ) {

			// Support: IE <=11 only, Firefox <=30 (#15098, #14150)
			// IE throws on elements created in popups
			// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
			var view = elem.ownerDocument.defaultView;

			if ( !view || !view.opener ) {
				view = window;
			}

			return view.getComputedStyle( elem );
		};

	var rboxStyle = new RegExp( cssExpand.join( "|" ), "i" );



	( function() {

		// Executing both pixelPosition & boxSizingReliable tests require only one layout
		// so they're executed at the same time to save the second computation.
		function computeStyleTests() {

			// This is a singleton, we need to execute it only once
			if ( !div ) {
				return;
			}

			container.style.cssText = "position:absolute;left:-11111px;width:60px;" +
				"margin-top:1px;padding:0;border:0";
			div.style.cssText =
				"position:relative;display:block;box-sizing:border-box;overflow:scroll;" +
				"margin:auto;border:1px;padding:1px;" +
				"width:60%;top:1%";
			documentElement.appendChild( container ).appendChild( div );

			var divStyle = window.getComputedStyle( div );
			pixelPositionVal = divStyle.top !== "1%";

			// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44
			reliableMarginLeftVal = roundPixelMeasures( divStyle.marginLeft ) === 12;

			// Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3
			// Some styles come back with percentage values, even though they shouldn't
			div.style.right = "60%";
			pixelBoxStylesVal = roundPixelMeasures( divStyle.right ) === 36;

			// Support: IE 9 - 11 only
			// Detect misreporting of content dimensions for box-sizing:border-box elements
			boxSizingReliableVal = roundPixelMeasures( divStyle.width ) === 36;

			// Support: IE 9 only
			// Detect overflow:scroll screwiness (gh-3699)
			div.style.position = "absolute";
			scrollboxSizeVal = div.offsetWidth === 36 || "absolute";

			documentElement.removeChild( container );

			// Nullify the div so it wouldn't be stored in the memory and
			// it will also be a sign that checks already performed
			div = null;
		}

		function roundPixelMeasures( measure ) {
			return Math.round( parseFloat( measure ) );
		}

		var pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal,
			reliableMarginLeftVal,
			container = document.createElement( "div" ),
			div = document.createElement( "div" );

		// Finish early in limited (non-browser) environments
		if ( !div.style ) {
			return;
		}

		// Support: IE <=9 - 11 only
		// Style of cloned element affects source element cloned (#8908)
		div.style.backgroundClip = "content-box";
		div.cloneNode( true ).style.backgroundClip = "";
		support.clearCloneStyle = div.style.backgroundClip === "content-box";

		jQuery.extend( support, {
			boxSizingReliable: function() {
				computeStyleTests();
				return boxSizingReliableVal;
			},
			pixelBoxStyles: function() {
				computeStyleTests();
				return pixelBoxStylesVal;
			},
			pixelPosition: function() {
				computeStyleTests();
				return pixelPositionVal;
			},
			reliableMarginLeft: function() {
				computeStyleTests();
				return reliableMarginLeftVal;
			},
			scrollboxSize: function() {
				computeStyleTests();
				return scrollboxSizeVal;
			}
		} );
	} )();


	function curCSS( elem, name, computed ) {
		var width, minWidth, maxWidth, ret,

			// Support: Firefox 51+
			// Retrieving style before computed somehow
			// fixes an issue with getting wrong values
			// on detached elements
			style = elem.style;

		computed = computed || getStyles( elem );

		// getPropertyValue is needed for:
		//   .css('filter') (IE 9 only, #12537)
		//   .css('--customProperty) (#3144)
		if ( computed ) {
			ret = computed.getPropertyValue( name ) || computed[ name ];

			if ( ret === "" && !jQuery.contains( elem.ownerDocument, elem ) ) {
				ret = jQuery.style( elem, name );
			}

			// A tribute to the "awesome hack by Dean Edwards"
			// Android Browser returns percentage for some values,
			// but width seems to be reliably pixels.
			// This is against the CSSOM draft spec:
			// https://drafts.csswg.org/cssom/#resolved-values
			if ( !support.pixelBoxStyles() && rnumnonpx.test( ret ) && rboxStyle.test( name ) ) {

				// Remember the original values
				width = style.width;
				minWidth = style.minWidth;
				maxWidth = style.maxWidth;

				// Put in the new values to get a computed value out
				style.minWidth = style.maxWidth = style.width = ret;
				ret = computed.width;

				// Revert the changed values
				style.width = width;
				style.minWidth = minWidth;
				style.maxWidth = maxWidth;
			}
		}

		return ret !== undefined ?

			// Support: IE <=9 - 11 only
			// IE returns zIndex value as an integer.
			ret + "" :
			ret;
	}


	function addGetHookIf( conditionFn, hookFn ) {

		// Define the hook, we'll check on the first run if it's really needed.
		return {
			get: function() {
				if ( conditionFn() ) {

					// Hook not needed (or it's not possible to use it due
					// to missing dependency), remove it.
					delete this.get;
					return;
				}

				// Hook needed; redefine it so that the support test is not executed again.
				return ( this.get = hookFn ).apply( this, arguments );
			}
		};
	}


	var

		// Swappable if display is none or starts with table
		// except "table", "table-cell", or "table-caption"
		// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
		rdisplayswap = /^(none|table(?!-c[ea]).+)/,
		rcustomProp = /^--/,
		cssShow = { position: "absolute", visibility: "hidden", display: "block" },
		cssNormalTransform = {
			letterSpacing: "0",
			fontWeight: "400"
		},

		cssPrefixes = [ "Webkit", "Moz", "ms" ],
		emptyStyle = document.createElement( "div" ).style;

	// Return a css property mapped to a potentially vendor prefixed property
	function vendorPropName( name ) {

		// Shortcut for names that are not vendor prefixed
		if ( name in emptyStyle ) {
			return name;
		}

		// Check for vendor prefixed names
		var capName = name[ 0 ].toUpperCase() + name.slice( 1 ),
			i = cssPrefixes.length;

		while ( i-- ) {
			name = cssPrefixes[ i ] + capName;
			if ( name in emptyStyle ) {
				return name;
			}
		}
	}

	// Return a property mapped along what jQuery.cssProps suggests or to
	// a vendor prefixed property.
	function finalPropName( name ) {
		var ret = jQuery.cssProps[ name ];
		if ( !ret ) {
			ret = jQuery.cssProps[ name ] = vendorPropName( name ) || name;
		}
		return ret;
	}

	function setPositiveNumber( elem, value, subtract ) {

		// Any relative (+/-) values have already been
		// normalized at this point
		var matches = rcssNum.exec( value );
		return matches ?

			// Guard against undefined "subtract", e.g., when used as in cssHooks
			Math.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || "px" ) :
			value;
	}

	function boxModelAdjustment( elem, dimension, box, isBorderBox, styles, computedVal ) {
		var i = dimension === "width" ? 1 : 0,
			extra = 0,
			delta = 0;

		// Adjustment may not be necessary
		if ( box === ( isBorderBox ? "border" : "content" ) ) {
			return 0;
		}

		for ( ; i < 4; i += 2 ) {

			// Both box models exclude margin
			if ( box === "margin" ) {
				delta += jQuery.css( elem, box + cssExpand[ i ], true, styles );
			}

			// If we get here with a content-box, we're seeking "padding" or "border" or "margin"
			if ( !isBorderBox ) {

				// Add padding
				delta += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

				// For "border" or "margin", add border
				if ( box !== "padding" ) {
					delta += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );

				// But still keep track of it otherwise
				} else {
					extra += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
				}

			// If we get here with a border-box (content + padding + border), we're seeking "content" or
			// "padding" or "margin"
			} else {

				// For "content", subtract padding
				if ( box === "content" ) {
					delta -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
				}

				// For "content" or "padding", subtract border
				if ( box !== "margin" ) {
					delta -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
				}
			}
		}

		// Account for positive content-box scroll gutter when requested by providing computedVal
		if ( !isBorderBox && computedVal >= 0 ) {

			// offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border
			// Assuming integer scroll gutter, subtract the rest and round down
			delta += Math.max( 0, Math.ceil(
				elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
				computedVal -
				delta -
				extra -
				0.5
			) );
		}

		return delta;
	}

	function getWidthOrHeight( elem, dimension, extra ) {

		// Start with computed style
		var styles = getStyles( elem ),
			val = curCSS( elem, dimension, styles ),
			isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
			valueIsBorderBox = isBorderBox;

		// Support: Firefox <=54
		// Return a confounding non-pixel value or feign ignorance, as appropriate.
		if ( rnumnonpx.test( val ) ) {
			if ( !extra ) {
				return val;
			}
			val = "auto";
		}

		// Check for style in case a browser which returns unreliable values
		// for getComputedStyle silently falls back to the reliable elem.style
		valueIsBorderBox = valueIsBorderBox &&
			( support.boxSizingReliable() || val === elem.style[ dimension ] );

		// Fall back to offsetWidth/offsetHeight when value is "auto"
		// This happens for inline elements with no explicit setting (gh-3571)
		// Support: Android <=4.1 - 4.3 only
		// Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)
		if ( val === "auto" ||
			!parseFloat( val ) && jQuery.css( elem, "display", false, styles ) === "inline" ) {

			val = elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ];

			// offsetWidth/offsetHeight provide border-box values
			valueIsBorderBox = true;
		}

		// Normalize "" and auto
		val = parseFloat( val ) || 0;

		// Adjust for the element's box model
		return ( val +
			boxModelAdjustment(
				elem,
				dimension,
				extra || ( isBorderBox ? "border" : "content" ),
				valueIsBorderBox,
				styles,

				// Provide the current computed size to request scroll gutter calculation (gh-3589)
				val
			)
		) + "px";
	}

	jQuery.extend( {

		// Add in style property hooks for overriding the default
		// behavior of getting and setting a style property
		cssHooks: {
			opacity: {
				get: function( elem, computed ) {
					if ( computed ) {

						// We should always get a number back from opacity
						var ret = curCSS( elem, "opacity" );
						return ret === "" ? "1" : ret;
					}
				}
			}
		},

		// Don't automatically add "px" to these possibly-unitless properties
		cssNumber: {
			"animationIterationCount": true,
			"columnCount": true,
			"fillOpacity": true,
			"flexGrow": true,
			"flexShrink": true,
			"fontWeight": true,
			"lineHeight": true,
			"opacity": true,
			"order": true,
			"orphans": true,
			"widows": true,
			"zIndex": true,
			"zoom": true
		},

		// Add in properties whose names you wish to fix before
		// setting or getting the value
		cssProps: {},

		// Get and set the style property on a DOM Node
		style: function( elem, name, value, extra ) {

			// Don't set styles on text and comment nodes
			if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
				return;
			}

			// Make sure that we're working with the right name
			var ret, type, hooks,
				origName = camelCase( name ),
				isCustomProp = rcustomProp.test( name ),
				style = elem.style;

			// Make sure that we're working with the right name. We don't
			// want to query the value if it is a CSS custom property
			// since they are user-defined.
			if ( !isCustomProp ) {
				name = finalPropName( origName );
			}

			// Gets hook for the prefixed version, then unprefixed version
			hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

			// Check if we're setting a value
			if ( value !== undefined ) {
				type = typeof value;

				// Convert "+=" or "-=" to relative numbers (#7345)
				if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
					value = adjustCSS( elem, name, ret );

					// Fixes bug #9237
					type = "number";
				}

				// Make sure that null and NaN values aren't set (#7116)
				if ( value == null || value !== value ) {
					return;
				}

				// If a number was passed in, add the unit (except for certain CSS properties)
				if ( type === "number" ) {
					value += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );
				}

				// background-* props affect original clone's values
				if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
					style[ name ] = "inherit";
				}

				// If a hook was provided, use that value, otherwise just set the specified value
				if ( !hooks || !( "set" in hooks ) ||
					( value = hooks.set( elem, value, extra ) ) !== undefined ) {

					if ( isCustomProp ) {
						style.setProperty( name, value );
					} else {
						style[ name ] = value;
					}
				}

			} else {

				// If a hook was provided get the non-computed value from there
				if ( hooks && "get" in hooks &&
					( ret = hooks.get( elem, false, extra ) ) !== undefined ) {

					return ret;
				}

				// Otherwise just get the value from the style object
				return style[ name ];
			}
		},

		css: function( elem, name, extra, styles ) {
			var val, num, hooks,
				origName = camelCase( name ),
				isCustomProp = rcustomProp.test( name );

			// Make sure that we're working with the right name. We don't
			// want to modify the value if it is a CSS custom property
			// since they are user-defined.
			if ( !isCustomProp ) {
				name = finalPropName( origName );
			}

			// Try prefixed name followed by the unprefixed name
			hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

			// If a hook was provided get the computed value from there
			if ( hooks && "get" in hooks ) {
				val = hooks.get( elem, true, extra );
			}

			// Otherwise, if a way to get the computed value exists, use that
			if ( val === undefined ) {
				val = curCSS( elem, name, styles );
			}

			// Convert "normal" to computed value
			if ( val === "normal" && name in cssNormalTransform ) {
				val = cssNormalTransform[ name ];
			}

			// Make numeric if forced or a qualifier was provided and val looks numeric
			if ( extra === "" || extra ) {
				num = parseFloat( val );
				return extra === true || isFinite( num ) ? num || 0 : val;
			}

			return val;
		}
	} );

	jQuery.each( [ "height", "width" ], function( i, dimension ) {
		jQuery.cssHooks[ dimension ] = {
			get: function( elem, computed, extra ) {
				if ( computed ) {

					// Certain elements can have dimension info if we invisibly show them
					// but it must have a current display style that would benefit
					return rdisplayswap.test( jQuery.css( elem, "display" ) ) &&

						// Support: Safari 8+
						// Table columns in Safari have non-zero offsetWidth & zero
						// getBoundingClientRect().width unless display is changed.
						// Support: IE <=11 only
						// Running getBoundingClientRect on a disconnected node
						// in IE throws an error.
						( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?
							swap( elem, cssShow, function() {
								return getWidthOrHeight( elem, dimension, extra );
							} ) :
							getWidthOrHeight( elem, dimension, extra );
				}
			},

			set: function( elem, value, extra ) {
				var matches,
					styles = getStyles( elem ),
					isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
					subtract = extra && boxModelAdjustment(
						elem,
						dimension,
						extra,
						isBorderBox,
						styles
					);

				// Account for unreliable border-box dimensions by comparing offset* to computed and
				// faking a content-box to get border and padding (gh-3699)
				if ( isBorderBox && support.scrollboxSize() === styles.position ) {
					subtract -= Math.ceil(
						elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
						parseFloat( styles[ dimension ] ) -
						boxModelAdjustment( elem, dimension, "border", false, styles ) -
						0.5
					);
				}

				// Convert to pixels if value adjustment is needed
				if ( subtract && ( matches = rcssNum.exec( value ) ) &&
					( matches[ 3 ] || "px" ) !== "px" ) {

					elem.style[ dimension ] = value;
					value = jQuery.css( elem, dimension );
				}

				return setPositiveNumber( elem, value, subtract );
			}
		};
	} );

	jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,
		function( elem, computed ) {
			if ( computed ) {
				return ( parseFloat( curCSS( elem, "marginLeft" ) ) ||
					elem.getBoundingClientRect().left -
						swap( elem, { marginLeft: 0 }, function() {
							return elem.getBoundingClientRect().left;
						} )
					) + "px";
			}
		}
	);

	// These hooks are used by animate to expand properties
	jQuery.each( {
		margin: "",
		padding: "",
		border: "Width"
	}, function( prefix, suffix ) {
		jQuery.cssHooks[ prefix + suffix ] = {
			expand: function( value ) {
				var i = 0,
					expanded = {},

					// Assumes a single number if not a string
					parts = typeof value === "string" ? value.split( " " ) : [ value ];

				for ( ; i < 4; i++ ) {
					expanded[ prefix + cssExpand[ i ] + suffix ] =
						parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
				}

				return expanded;
			}
		};

		if ( prefix !== "margin" ) {
			jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
		}
	} );

	jQuery.fn.extend( {
		css: function( name, value ) {
			return access( this, function( elem, name, value ) {
				var styles, len,
					map = {},
					i = 0;

				if ( Array.isArray( name ) ) {
					styles = getStyles( elem );
					len = name.length;

					for ( ; i < len; i++ ) {
						map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
					}

					return map;
				}

				return value !== undefined ?
					jQuery.style( elem, name, value ) :
					jQuery.css( elem, name );
			}, name, value, arguments.length > 1 );
		}
	} );


	function Tween( elem, options, prop, end, easing ) {
		return new Tween.prototype.init( elem, options, prop, end, easing );
	}
	jQuery.Tween = Tween;

	Tween.prototype = {
		constructor: Tween,
		init: function( elem, options, prop, end, easing, unit ) {
			this.elem = elem;
			this.prop = prop;
			this.easing = easing || jQuery.easing._default;
			this.options = options;
			this.start = this.now = this.cur();
			this.end = end;
			this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
		},
		cur: function() {
			var hooks = Tween.propHooks[ this.prop ];

			return hooks && hooks.get ?
				hooks.get( this ) :
				Tween.propHooks._default.get( this );
		},
		run: function( percent ) {
			var eased,
				hooks = Tween.propHooks[ this.prop ];

			if ( this.options.duration ) {
				this.pos = eased = jQuery.easing[ this.easing ](
					percent, this.options.duration * percent, 0, 1, this.options.duration
				);
			} else {
				this.pos = eased = percent;
			}
			this.now = ( this.end - this.start ) * eased + this.start;

			if ( this.options.step ) {
				this.options.step.call( this.elem, this.now, this );
			}

			if ( hooks && hooks.set ) {
				hooks.set( this );
			} else {
				Tween.propHooks._default.set( this );
			}
			return this;
		}
	};

	Tween.prototype.init.prototype = Tween.prototype;

	Tween.propHooks = {
		_default: {
			get: function( tween ) {
				var result;

				// Use a property on the element directly when it is not a DOM element,
				// or when there is no matching style property that exists.
				if ( tween.elem.nodeType !== 1 ||
					tween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {
					return tween.elem[ tween.prop ];
				}

				// Passing an empty string as a 3rd parameter to .css will automatically
				// attempt a parseFloat and fallback to a string if the parse fails.
				// Simple values such as "10px" are parsed to Float;
				// complex values such as "rotate(1rad)" are returned as-is.
				result = jQuery.css( tween.elem, tween.prop, "" );

				// Empty strings, null, undefined and "auto" are converted to 0.
				return !result || result === "auto" ? 0 : result;
			},
			set: function( tween ) {

				// Use step hook for back compat.
				// Use cssHook if its there.
				// Use .style if available and use plain properties where available.
				if ( jQuery.fx.step[ tween.prop ] ) {
					jQuery.fx.step[ tween.prop ]( tween );
				} else if ( tween.elem.nodeType === 1 &&
					( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null ||
						jQuery.cssHooks[ tween.prop ] ) ) {
					jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
				} else {
					tween.elem[ tween.prop ] = tween.now;
				}
			}
		}
	};

	// Support: IE <=9 only
	// Panic based approach to setting things on disconnected nodes
	Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
		set: function( tween ) {
			if ( tween.elem.nodeType && tween.elem.parentNode ) {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	};

	jQuery.easing = {
		linear: function( p ) {
			return p;
		},
		swing: function( p ) {
			return 0.5 - Math.cos( p * Math.PI ) / 2;
		},
		_default: "swing"
	};

	jQuery.fx = Tween.prototype.init;

	// Back compat <1.8 extension point
	jQuery.fx.step = {};




	var
		fxNow, inProgress,
		rfxtypes = /^(?:toggle|show|hide)$/,
		rrun = /queueHooks$/;

	function schedule() {
		if ( inProgress ) {
			if ( document.hidden === false && window.requestAnimationFrame ) {
				window.requestAnimationFrame( schedule );
			} else {
				window.setTimeout( schedule, jQuery.fx.interval );
			}

			jQuery.fx.tick();
		}
	}

	// Animations created synchronously will run synchronously
	function createFxNow() {
		window.setTimeout( function() {
			fxNow = undefined;
		} );
		return ( fxNow = Date.now() );
	}

	// Generate parameters to create a standard animation
	function genFx( type, includeWidth ) {
		var which,
			i = 0,
			attrs = { height: type };

		// If we include width, step value is 1 to do all cssExpand values,
		// otherwise step value is 2 to skip over Left and Right
		includeWidth = includeWidth ? 1 : 0;
		for ( ; i < 4; i += 2 - includeWidth ) {
			which = cssExpand[ i ];
			attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
		}

		if ( includeWidth ) {
			attrs.opacity = attrs.width = type;
		}

		return attrs;
	}

	function createTween( value, prop, animation ) {
		var tween,
			collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),
			index = 0,
			length = collection.length;
		for ( ; index < length; index++ ) {
			if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {

				// We're done with this property
				return tween;
			}
		}
	}

	function defaultPrefilter( elem, props, opts ) {
		var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,
			isBox = "width" in props || "height" in props,
			anim = this,
			orig = {},
			style = elem.style,
			hidden = elem.nodeType && isHiddenWithinTree( elem ),
			dataShow = dataPriv.get( elem, "fxshow" );

		// Queue-skipping animations hijack the fx hooks
		if ( !opts.queue ) {
			hooks = jQuery._queueHooks( elem, "fx" );
			if ( hooks.unqueued == null ) {
				hooks.unqueued = 0;
				oldfire = hooks.empty.fire;
				hooks.empty.fire = function() {
					if ( !hooks.unqueued ) {
						oldfire();
					}
				};
			}
			hooks.unqueued++;

			anim.always( function() {

				// Ensure the complete handler is called before this completes
				anim.always( function() {
					hooks.unqueued--;
					if ( !jQuery.queue( elem, "fx" ).length ) {
						hooks.empty.fire();
					}
				} );
			} );
		}

		// Detect show/hide animations
		for ( prop in props ) {
			value = props[ prop ];
			if ( rfxtypes.test( value ) ) {
				delete props[ prop ];
				toggle = toggle || value === "toggle";
				if ( value === ( hidden ? "hide" : "show" ) ) {

					// Pretend to be hidden if this is a "show" and
					// there is still data from a stopped show/hide
					if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
						hidden = true;

					// Ignore all other no-op show/hide data
					} else {
						continue;
					}
				}
				orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );
			}
		}

		// Bail out if this is a no-op like .hide().hide()
		propTween = !jQuery.isEmptyObject( props );
		if ( !propTween && jQuery.isEmptyObject( orig ) ) {
			return;
		}

		// Restrict "overflow" and "display" styles during box animations
		if ( isBox && elem.nodeType === 1 ) {

			// Support: IE <=9 - 11, Edge 12 - 15
			// Record all 3 overflow attributes because IE does not infer the shorthand
			// from identically-valued overflowX and overflowY and Edge just mirrors
			// the overflowX value there.
			opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

			// Identify a display type, preferring old show/hide data over the CSS cascade
			restoreDisplay = dataShow && dataShow.display;
			if ( restoreDisplay == null ) {
				restoreDisplay = dataPriv.get( elem, "display" );
			}
			display = jQuery.css( elem, "display" );
			if ( display === "none" ) {
				if ( restoreDisplay ) {
					display = restoreDisplay;
				} else {

					// Get nonempty value(s) by temporarily forcing visibility
					showHide( [ elem ], true );
					restoreDisplay = elem.style.display || restoreDisplay;
					display = jQuery.css( elem, "display" );
					showHide( [ elem ] );
				}
			}

			// Animate inline elements as inline-block
			if ( display === "inline" || display === "inline-block" && restoreDisplay != null ) {
				if ( jQuery.css( elem, "float" ) === "none" ) {

					// Restore the original display value at the end of pure show/hide animations
					if ( !propTween ) {
						anim.done( function() {
							style.display = restoreDisplay;
						} );
						if ( restoreDisplay == null ) {
							display = style.display;
							restoreDisplay = display === "none" ? "" : display;
						}
					}
					style.display = "inline-block";
				}
			}
		}

		if ( opts.overflow ) {
			style.overflow = "hidden";
			anim.always( function() {
				style.overflow = opts.overflow[ 0 ];
				style.overflowX = opts.overflow[ 1 ];
				style.overflowY = opts.overflow[ 2 ];
			} );
		}

		// Implement show/hide animations
		propTween = false;
		for ( prop in orig ) {

			// General show/hide setup for this element animation
			if ( !propTween ) {
				if ( dataShow ) {
					if ( "hidden" in dataShow ) {
						hidden = dataShow.hidden;
					}
				} else {
					dataShow = dataPriv.access( elem, "fxshow", { display: restoreDisplay } );
				}

				// Store hidden/visible for toggle so `.stop().toggle()` "reverses"
				if ( toggle ) {
					dataShow.hidden = !hidden;
				}

				// Show elements before animating them
				if ( hidden ) {
					showHide( [ elem ], true );
				}

				/* eslint-disable no-loop-func */

				anim.done( function() {

				/* eslint-enable no-loop-func */

					// The final step of a "hide" animation is actually hiding the element
					if ( !hidden ) {
						showHide( [ elem ] );
					}
					dataPriv.remove( elem, "fxshow" );
					for ( prop in orig ) {
						jQuery.style( elem, prop, orig[ prop ] );
					}
				} );
			}

			// Per-property setup
			propTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );
			if ( !( prop in dataShow ) ) {
				dataShow[ prop ] = propTween.start;
				if ( hidden ) {
					propTween.end = propTween.start;
					propTween.start = 0;
				}
			}
		}
	}

	function propFilter( props, specialEasing ) {
		var index, name, easing, value, hooks;

		// camelCase, specialEasing and expand cssHook pass
		for ( index in props ) {
			name = camelCase( index );
			easing = specialEasing[ name ];
			value = props[ index ];
			if ( Array.isArray( value ) ) {
				easing = value[ 1 ];
				value = props[ index ] = value[ 0 ];
			}

			if ( index !== name ) {
				props[ name ] = value;
				delete props[ index ];
			}

			hooks = jQuery.cssHooks[ name ];
			if ( hooks && "expand" in hooks ) {
				value = hooks.expand( value );
				delete props[ name ];

				// Not quite $.extend, this won't overwrite existing keys.
				// Reusing 'index' because we have the correct "name"
				for ( index in value ) {
					if ( !( index in props ) ) {
						props[ index ] = value[ index ];
						specialEasing[ index ] = easing;
					}
				}
			} else {
				specialEasing[ name ] = easing;
			}
		}
	}

	function Animation( elem, properties, options ) {
		var result,
			stopped,
			index = 0,
			length = Animation.prefilters.length,
			deferred = jQuery.Deferred().always( function() {

				// Don't match elem in the :animated selector
				delete tick.elem;
			} ),
			tick = function() {
				if ( stopped ) {
					return false;
				}
				var currentTime = fxNow || createFxNow(),
					remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),

					// Support: Android 2.3 only
					// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
					temp = remaining / animation.duration || 0,
					percent = 1 - temp,
					index = 0,
					length = animation.tweens.length;

				for ( ; index < length; index++ ) {
					animation.tweens[ index ].run( percent );
				}

				deferred.notifyWith( elem, [ animation, percent, remaining ] );

				// If there's more to do, yield
				if ( percent < 1 && length ) {
					return remaining;
				}

				// If this was an empty animation, synthesize a final progress notification
				if ( !length ) {
					deferred.notifyWith( elem, [ animation, 1, 0 ] );
				}

				// Resolve the animation and report its conclusion
				deferred.resolveWith( elem, [ animation ] );
				return false;
			},
			animation = deferred.promise( {
				elem: elem,
				props: jQuery.extend( {}, properties ),
				opts: jQuery.extend( true, {
					specialEasing: {},
					easing: jQuery.easing._default
				}, options ),
				originalProperties: properties,
				originalOptions: options,
				startTime: fxNow || createFxNow(),
				duration: options.duration,
				tweens: [],
				createTween: function( prop, end ) {
					var tween = jQuery.Tween( elem, animation.opts, prop, end,
							animation.opts.specialEasing[ prop ] || animation.opts.easing );
					animation.tweens.push( tween );
					return tween;
				},
				stop: function( gotoEnd ) {
					var index = 0,

						// If we are going to the end, we want to run all the tweens
						// otherwise we skip this part
						length = gotoEnd ? animation.tweens.length : 0;
					if ( stopped ) {
						return this;
					}
					stopped = true;
					for ( ; index < length; index++ ) {
						animation.tweens[ index ].run( 1 );
					}

					// Resolve when we played the last frame; otherwise, reject
					if ( gotoEnd ) {
						deferred.notifyWith( elem, [ animation, 1, 0 ] );
						deferred.resolveWith( elem, [ animation, gotoEnd ] );
					} else {
						deferred.rejectWith( elem, [ animation, gotoEnd ] );
					}
					return this;
				}
			} ),
			props = animation.props;

		propFilter( props, animation.opts.specialEasing );

		for ( ; index < length; index++ ) {
			result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
			if ( result ) {
				if ( isFunction( result.stop ) ) {
					jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =
						result.stop.bind( result );
				}
				return result;
			}
		}

		jQuery.map( props, createTween, animation );

		if ( isFunction( animation.opts.start ) ) {
			animation.opts.start.call( elem, animation );
		}

		// Attach callbacks from options
		animation
			.progress( animation.opts.progress )
			.done( animation.opts.done, animation.opts.complete )
			.fail( animation.opts.fail )
			.always( animation.opts.always );

		jQuery.fx.timer(
			jQuery.extend( tick, {
				elem: elem,
				anim: animation,
				queue: animation.opts.queue
			} )
		);

		return animation;
	}

	jQuery.Animation = jQuery.extend( Animation, {

		tweeners: {
			"*": [ function( prop, value ) {
				var tween = this.createTween( prop, value );
				adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
				return tween;
			} ]
		},

		tweener: function( props, callback ) {
			if ( isFunction( props ) ) {
				callback = props;
				props = [ "*" ];
			} else {
				props = props.match( rnothtmlwhite );
			}

			var prop,
				index = 0,
				length = props.length;

			for ( ; index < length; index++ ) {
				prop = props[ index ];
				Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];
				Animation.tweeners[ prop ].unshift( callback );
			}
		},

		prefilters: [ defaultPrefilter ],

		prefilter: function( callback, prepend ) {
			if ( prepend ) {
				Animation.prefilters.unshift( callback );
			} else {
				Animation.prefilters.push( callback );
			}
		}
	} );

	jQuery.speed = function( speed, easing, fn ) {
		var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
			complete: fn || !fn && easing ||
				isFunction( speed ) && speed,
			duration: speed,
			easing: fn && easing || easing && !isFunction( easing ) && easing
		};

		// Go to the end state if fx are off
		if ( jQuery.fx.off ) {
			opt.duration = 0;

		} else {
			if ( typeof opt.duration !== "number" ) {
				if ( opt.duration in jQuery.fx.speeds ) {
					opt.duration = jQuery.fx.speeds[ opt.duration ];

				} else {
					opt.duration = jQuery.fx.speeds._default;
				}
			}
		}

		// Normalize opt.queue - true/undefined/null -> "fx"
		if ( opt.queue == null || opt.queue === true ) {
			opt.queue = "fx";
		}

		// Queueing
		opt.old = opt.complete;

		opt.complete = function() {
			if ( isFunction( opt.old ) ) {
				opt.old.call( this );
			}

			if ( opt.queue ) {
				jQuery.dequeue( this, opt.queue );
			}
		};

		return opt;
	};

	jQuery.fn.extend( {
		fadeTo: function( speed, to, easing, callback ) {

			// Show any hidden elements after setting opacity to 0
			return this.filter( isHiddenWithinTree ).css( "opacity", 0 ).show()

				// Animate to the value specified
				.end().animate( { opacity: to }, speed, easing, callback );
		},
		animate: function( prop, speed, easing, callback ) {
			var empty = jQuery.isEmptyObject( prop ),
				optall = jQuery.speed( speed, easing, callback ),
				doAnimation = function() {

					// Operate on a copy of prop so per-property easing won't be lost
					var anim = Animation( this, jQuery.extend( {}, prop ), optall );

					// Empty animations, or finishing resolves immediately
					if ( empty || dataPriv.get( this, "finish" ) ) {
						anim.stop( true );
					}
				};
				doAnimation.finish = doAnimation;

			return empty || optall.queue === false ?
				this.each( doAnimation ) :
				this.queue( optall.queue, doAnimation );
		},
		stop: function( type, clearQueue, gotoEnd ) {
			var stopQueue = function( hooks ) {
				var stop = hooks.stop;
				delete hooks.stop;
				stop( gotoEnd );
			};

			if ( typeof type !== "string" ) {
				gotoEnd = clearQueue;
				clearQueue = type;
				type = undefined;
			}
			if ( clearQueue && type !== false ) {
				this.queue( type || "fx", [] );
			}

			return this.each( function() {
				var dequeue = true,
					index = type != null && type + "queueHooks",
					timers = jQuery.timers,
					data = dataPriv.get( this );

				if ( index ) {
					if ( data[ index ] && data[ index ].stop ) {
						stopQueue( data[ index ] );
					}
				} else {
					for ( index in data ) {
						if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
							stopQueue( data[ index ] );
						}
					}
				}

				for ( index = timers.length; index--; ) {
					if ( timers[ index ].elem === this &&
						( type == null || timers[ index ].queue === type ) ) {

						timers[ index ].anim.stop( gotoEnd );
						dequeue = false;
						timers.splice( index, 1 );
					}
				}

				// Start the next in the queue if the last step wasn't forced.
				// Timers currently will call their complete callbacks, which
				// will dequeue but only if they were gotoEnd.
				if ( dequeue || !gotoEnd ) {
					jQuery.dequeue( this, type );
				}
			} );
		},
		finish: function( type ) {
			if ( type !== false ) {
				type = type || "fx";
			}
			return this.each( function() {
				var index,
					data = dataPriv.get( this ),
					queue = data[ type + "queue" ],
					hooks = data[ type + "queueHooks" ],
					timers = jQuery.timers,
					length = queue ? queue.length : 0;

				// Enable finishing flag on private data
				data.finish = true;

				// Empty the queue first
				jQuery.queue( this, type, [] );

				if ( hooks && hooks.stop ) {
					hooks.stop.call( this, true );
				}

				// Look for any active animations, and finish them
				for ( index = timers.length; index--; ) {
					if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
						timers[ index ].anim.stop( true );
						timers.splice( index, 1 );
					}
				}

				// Look for any animations in the old queue and finish them
				for ( index = 0; index < length; index++ ) {
					if ( queue[ index ] && queue[ index ].finish ) {
						queue[ index ].finish.call( this );
					}
				}

				// Turn off finishing flag
				delete data.finish;
			} );
		}
	} );

	jQuery.each( [ "toggle", "show", "hide" ], function( i, name ) {
		var cssFn = jQuery.fn[ name ];
		jQuery.fn[ name ] = function( speed, easing, callback ) {
			return speed == null || typeof speed === "boolean" ?
				cssFn.apply( this, arguments ) :
				this.animate( genFx( name, true ), speed, easing, callback );
		};
	} );

	// Generate shortcuts for custom animations
	jQuery.each( {
		slideDown: genFx( "show" ),
		slideUp: genFx( "hide" ),
		slideToggle: genFx( "toggle" ),
		fadeIn: { opacity: "show" },
		fadeOut: { opacity: "hide" },
		fadeToggle: { opacity: "toggle" }
	}, function( name, props ) {
		jQuery.fn[ name ] = function( speed, easing, callback ) {
			return this.animate( props, speed, easing, callback );
		};
	} );

	jQuery.timers = [];
	jQuery.fx.tick = function() {
		var timer,
			i = 0,
			timers = jQuery.timers;

		fxNow = Date.now();

		for ( ; i < timers.length; i++ ) {
			timer = timers[ i ];

			// Run the timer and safely remove it when done (allowing for external removal)
			if ( !timer() && timers[ i ] === timer ) {
				timers.splice( i--, 1 );
			}
		}

		if ( !timers.length ) {
			jQuery.fx.stop();
		}
		fxNow = undefined;
	};

	jQuery.fx.timer = function( timer ) {
		jQuery.timers.push( timer );
		jQuery.fx.start();
	};

	jQuery.fx.interval = 13;
	jQuery.fx.start = function() {
		if ( inProgress ) {
			return;
		}

		inProgress = true;
		schedule();
	};

	jQuery.fx.stop = function() {
		inProgress = null;
	};

	jQuery.fx.speeds = {
		slow: 600,
		fast: 200,

		// Default speed
		_default: 400
	};


	// Based off of the plugin by Clint Helfers, with permission.
	// https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
	jQuery.fn.delay = function( time, type ) {
		time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
		type = type || "fx";

		return this.queue( type, function( next, hooks ) {
			var timeout = window.setTimeout( next, time );
			hooks.stop = function() {
				window.clearTimeout( timeout );
			};
		} );
	};


	( function() {
		var input = document.createElement( "input" ),
			select = document.createElement( "select" ),
			opt = select.appendChild( document.createElement( "option" ) );

		input.type = "checkbox";

		// Support: Android <=4.3 only
		// Default value for a checkbox should be "on"
		support.checkOn = input.value !== "";

		// Support: IE <=11 only
		// Must access selectedIndex to make default options select
		support.optSelected = opt.selected;

		// Support: IE <=11 only
		// An input loses its value after becoming a radio
		input = document.createElement( "input" );
		input.value = "t";
		input.type = "radio";
		support.radioValue = input.value === "t";
	} )();


	var boolHook,
		attrHandle = jQuery.expr.attrHandle;

	jQuery.fn.extend( {
		attr: function( name, value ) {
			return access( this, jQuery.attr, name, value, arguments.length > 1 );
		},

		removeAttr: function( name ) {
			return this.each( function() {
				jQuery.removeAttr( this, name );
			} );
		}
	} );

	jQuery.extend( {
		attr: function( elem, name, value ) {
			var ret, hooks,
				nType = elem.nodeType;

			// Don't get/set attributes on text, comment and attribute nodes
			if ( nType === 3 || nType === 8 || nType === 2 ) {
				return;
			}

			// Fallback to prop when attributes are not supported
			if ( typeof elem.getAttribute === "undefined" ) {
				return jQuery.prop( elem, name, value );
			}

			// Attribute hooks are determined by the lowercase version
			// Grab necessary hook if one is defined
			if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
				hooks = jQuery.attrHooks[ name.toLowerCase() ] ||
					( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );
			}

			if ( value !== undefined ) {
				if ( value === null ) {
					jQuery.removeAttr( elem, name );
					return;
				}

				if ( hooks && "set" in hooks &&
					( ret = hooks.set( elem, value, name ) ) !== undefined ) {
					return ret;
				}

				elem.setAttribute( name, value + "" );
				return value;
			}

			if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
				return ret;
			}

			ret = jQuery.find.attr( elem, name );

			// Non-existent attributes return null, we normalize to undefined
			return ret == null ? undefined : ret;
		},

		attrHooks: {
			type: {
				set: function( elem, value ) {
					if ( !support.radioValue && value === "radio" &&
						nodeName( elem, "input" ) ) {
						var val = elem.value;
						elem.setAttribute( "type", value );
						if ( val ) {
							elem.value = val;
						}
						return value;
					}
				}
			}
		},

		removeAttr: function( elem, value ) {
			var name,
				i = 0,

				// Attribute names can contain non-HTML whitespace characters
				// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
				attrNames = value && value.match( rnothtmlwhite );

			if ( attrNames && elem.nodeType === 1 ) {
				while ( ( name = attrNames[ i++ ] ) ) {
					elem.removeAttribute( name );
				}
			}
		}
	} );

	// Hooks for boolean attributes
	boolHook = {
		set: function( elem, value, name ) {
			if ( value === false ) {

				// Remove boolean attributes when set to false
				jQuery.removeAttr( elem, name );
			} else {
				elem.setAttribute( name, name );
			}
			return name;
		}
	};

	jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {
		var getter = attrHandle[ name ] || jQuery.find.attr;

		attrHandle[ name ] = function( elem, name, isXML ) {
			var ret, handle,
				lowercaseName = name.toLowerCase();

			if ( !isXML ) {

				// Avoid an infinite loop by temporarily removing this function from the getter
				handle = attrHandle[ lowercaseName ];
				attrHandle[ lowercaseName ] = ret;
				ret = getter( elem, name, isXML ) != null ?
					lowercaseName :
					null;
				attrHandle[ lowercaseName ] = handle;
			}
			return ret;
		};
	} );




	var rfocusable = /^(?:input|select|textarea|button)$/i,
		rclickable = /^(?:a|area)$/i;

	jQuery.fn.extend( {
		prop: function( name, value ) {
			return access( this, jQuery.prop, name, value, arguments.length > 1 );
		},

		removeProp: function( name ) {
			return this.each( function() {
				delete this[ jQuery.propFix[ name ] || name ];
			} );
		}
	} );

	jQuery.extend( {
		prop: function( elem, name, value ) {
			var ret, hooks,
				nType = elem.nodeType;

			// Don't get/set properties on text, comment and attribute nodes
			if ( nType === 3 || nType === 8 || nType === 2 ) {
				return;
			}

			if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {

				// Fix name and attach hooks
				name = jQuery.propFix[ name ] || name;
				hooks = jQuery.propHooks[ name ];
			}

			if ( value !== undefined ) {
				if ( hooks && "set" in hooks &&
					( ret = hooks.set( elem, value, name ) ) !== undefined ) {
					return ret;
				}

				return ( elem[ name ] = value );
			}

			if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
				return ret;
			}

			return elem[ name ];
		},

		propHooks: {
			tabIndex: {
				get: function( elem ) {

					// Support: IE <=9 - 11 only
					// elem.tabIndex doesn't always return the
					// correct value when it hasn't been explicitly set
					// https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
					// Use proper attribute retrieval(#12072)
					var tabindex = jQuery.find.attr( elem, "tabindex" );

					if ( tabindex ) {
						return parseInt( tabindex, 10 );
					}

					if (
						rfocusable.test( elem.nodeName ) ||
						rclickable.test( elem.nodeName ) &&
						elem.href
					) {
						return 0;
					}

					return -1;
				}
			}
		},

		propFix: {
			"for": "htmlFor",
			"class": "className"
		}
	} );

	// Support: IE <=11 only
	// Accessing the selectedIndex property
	// forces the browser to respect setting selected
	// on the option
	// The getter ensures a default option is selected
	// when in an optgroup
	// eslint rule "no-unused-expressions" is disabled for this code
	// since it considers such accessions noop
	if ( !support.optSelected ) {
		jQuery.propHooks.selected = {
			get: function( elem ) {

				/* eslint no-unused-expressions: "off" */

				var parent = elem.parentNode;
				if ( parent && parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
				return null;
			},
			set: function( elem ) {

				/* eslint no-unused-expressions: "off" */

				var parent = elem.parentNode;
				if ( parent ) {
					parent.selectedIndex;

					if ( parent.parentNode ) {
						parent.parentNode.selectedIndex;
					}
				}
			}
		};
	}

	jQuery.each( [
		"tabIndex",
		"readOnly",
		"maxLength",
		"cellSpacing",
		"cellPadding",
		"rowSpan",
		"colSpan",
		"useMap",
		"frameBorder",
		"contentEditable"
	], function() {
		jQuery.propFix[ this.toLowerCase() ] = this;
	} );




		// Strip and collapse whitespace according to HTML spec
		// https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace
		function stripAndCollapse( value ) {
			var tokens = value.match( rnothtmlwhite ) || [];
			return tokens.join( " " );
		}


	function getClass( elem ) {
		return elem.getAttribute && elem.getAttribute( "class" ) || "";
	}

	function classesToArray( value ) {
		if ( Array.isArray( value ) ) {
			return value;
		}
		if ( typeof value === "string" ) {
			return value.match( rnothtmlwhite ) || [];
		}
		return [];
	}

	jQuery.fn.extend( {
		addClass: function( value ) {
			var classes, elem, cur, curValue, clazz, j, finalValue,
				i = 0;

			if ( isFunction( value ) ) {
				return this.each( function( j ) {
					jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
				} );
			}

			classes = classesToArray( value );

			if ( classes.length ) {
				while ( ( elem = this[ i++ ] ) ) {
					curValue = getClass( elem );
					cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

					if ( cur ) {
						j = 0;
						while ( ( clazz = classes[ j++ ] ) ) {
							if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
								cur += clazz + " ";
							}
						}

						// Only assign if different to avoid unneeded rendering.
						finalValue = stripAndCollapse( cur );
						if ( curValue !== finalValue ) {
							elem.setAttribute( "class", finalValue );
						}
					}
				}
			}

			return this;
		},

		removeClass: function( value ) {
			var classes, elem, cur, curValue, clazz, j, finalValue,
				i = 0;

			if ( isFunction( value ) ) {
				return this.each( function( j ) {
					jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
				} );
			}

			if ( !arguments.length ) {
				return this.attr( "class", "" );
			}

			classes = classesToArray( value );

			if ( classes.length ) {
				while ( ( elem = this[ i++ ] ) ) {
					curValue = getClass( elem );

					// This expression is here for better compressibility (see addClass)
					cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

					if ( cur ) {
						j = 0;
						while ( ( clazz = classes[ j++ ] ) ) {

							// Remove *all* instances
							while ( cur.indexOf( " " + clazz + " " ) > -1 ) {
								cur = cur.replace( " " + clazz + " ", " " );
							}
						}

						// Only assign if different to avoid unneeded rendering.
						finalValue = stripAndCollapse( cur );
						if ( curValue !== finalValue ) {
							elem.setAttribute( "class", finalValue );
						}
					}
				}
			}

			return this;
		},

		toggleClass: function( value, stateVal ) {
			var type = typeof value,
				isValidValue = type === "string" || Array.isArray( value );

			if ( typeof stateVal === "boolean" && isValidValue ) {
				return stateVal ? this.addClass( value ) : this.removeClass( value );
			}

			if ( isFunction( value ) ) {
				return this.each( function( i ) {
					jQuery( this ).toggleClass(
						value.call( this, i, getClass( this ), stateVal ),
						stateVal
					);
				} );
			}

			return this.each( function() {
				var className, i, self, classNames;

				if ( isValidValue ) {

					// Toggle individual class names
					i = 0;
					self = jQuery( this );
					classNames = classesToArray( value );

					while ( ( className = classNames[ i++ ] ) ) {

						// Check each className given, space separated list
						if ( self.hasClass( className ) ) {
							self.removeClass( className );
						} else {
							self.addClass( className );
						}
					}

				// Toggle whole class name
				} else if ( value === undefined || type === "boolean" ) {
					className = getClass( this );
					if ( className ) {

						// Store className if set
						dataPriv.set( this, "__className__", className );
					}

					// If the element has a class name or if we're passed `false`,
					// then remove the whole classname (if there was one, the above saved it).
					// Otherwise bring back whatever was previously saved (if anything),
					// falling back to the empty string if nothing was stored.
					if ( this.setAttribute ) {
						this.setAttribute( "class",
							className || value === false ?
							"" :
							dataPriv.get( this, "__className__" ) || ""
						);
					}
				}
			} );
		},

		hasClass: function( selector ) {
			var className, elem,
				i = 0;

			className = " " + selector + " ";
			while ( ( elem = this[ i++ ] ) ) {
				if ( elem.nodeType === 1 &&
					( " " + stripAndCollapse( getClass( elem ) ) + " " ).indexOf( className ) > -1 ) {
						return true;
				}
			}

			return false;
		}
	} );




	var rreturn = /\r/g;

	jQuery.fn.extend( {
		val: function( value ) {
			var hooks, ret, valueIsFunction,
				elem = this[ 0 ];

			if ( !arguments.length ) {
				if ( elem ) {
					hooks = jQuery.valHooks[ elem.type ] ||
						jQuery.valHooks[ elem.nodeName.toLowerCase() ];

					if ( hooks &&
						"get" in hooks &&
						( ret = hooks.get( elem, "value" ) ) !== undefined
					) {
						return ret;
					}

					ret = elem.value;

					// Handle most common string cases
					if ( typeof ret === "string" ) {
						return ret.replace( rreturn, "" );
					}

					// Handle cases where value is null/undef or number
					return ret == null ? "" : ret;
				}

				return;
			}

			valueIsFunction = isFunction( value );

			return this.each( function( i ) {
				var val;

				if ( this.nodeType !== 1 ) {
					return;
				}

				if ( valueIsFunction ) {
					val = value.call( this, i, jQuery( this ).val() );
				} else {
					val = value;
				}

				// Treat null/undefined as ""; convert numbers to string
				if ( val == null ) {
					val = "";

				} else if ( typeof val === "number" ) {
					val += "";

				} else if ( Array.isArray( val ) ) {
					val = jQuery.map( val, function( value ) {
						return value == null ? "" : value + "";
					} );
				}

				hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

				// If set returns undefined, fall back to normal setting
				if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {
					this.value = val;
				}
			} );
		}
	} );

	jQuery.extend( {
		valHooks: {
			option: {
				get: function( elem ) {

					var val = jQuery.find.attr( elem, "value" );
					return val != null ?
						val :

						// Support: IE <=10 - 11 only
						// option.text throws exceptions (#14686, #14858)
						// Strip and collapse whitespace
						// https://html.spec.whatwg.org/#strip-and-collapse-whitespace
						stripAndCollapse( jQuery.text( elem ) );
				}
			},
			select: {
				get: function( elem ) {
					var value, option, i,
						options = elem.options,
						index = elem.selectedIndex,
						one = elem.type === "select-one",
						values = one ? null : [],
						max = one ? index + 1 : options.length;

					if ( index < 0 ) {
						i = max;

					} else {
						i = one ? index : 0;
					}

					// Loop through all the selected options
					for ( ; i < max; i++ ) {
						option = options[ i ];

						// Support: IE <=9 only
						// IE8-9 doesn't update selected after form reset (#2551)
						if ( ( option.selected || i === index ) &&

								// Don't return options that are disabled or in a disabled optgroup
								!option.disabled &&
								( !option.parentNode.disabled ||
									!nodeName( option.parentNode, "optgroup" ) ) ) {

							// Get the specific value for the option
							value = jQuery( option ).val();

							// We don't need an array for one selects
							if ( one ) {
								return value;
							}

							// Multi-Selects return an array
							values.push( value );
						}
					}

					return values;
				},

				set: function( elem, value ) {
					var optionSet, option,
						options = elem.options,
						values = jQuery.makeArray( value ),
						i = options.length;

					while ( i-- ) {
						option = options[ i ];

						/* eslint-disable no-cond-assign */

						if ( option.selected =
							jQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1
						) {
							optionSet = true;
						}

						/* eslint-enable no-cond-assign */
					}

					// Force browsers to behave consistently when non-matching value is set
					if ( !optionSet ) {
						elem.selectedIndex = -1;
					}
					return values;
				}
			}
		}
	} );

	// Radios and checkboxes getter/setter
	jQuery.each( [ "radio", "checkbox" ], function() {
		jQuery.valHooks[ this ] = {
			set: function( elem, value ) {
				if ( Array.isArray( value ) ) {
					return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );
				}
			}
		};
		if ( !support.checkOn ) {
			jQuery.valHooks[ this ].get = function( elem ) {
				return elem.getAttribute( "value" ) === null ? "on" : elem.value;
			};
		}
	} );




	// Return jQuery for attributes-only inclusion


	support.focusin = "onfocusin" in window;


	var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
		stopPropagationCallback = function( e ) {
			e.stopPropagation();
		};

	jQuery.extend( jQuery.event, {

		trigger: function( event, data, elem, onlyHandlers ) {

			var i, cur, tmp, bubbleType, ontype, handle, special, lastElement,
				eventPath = [ elem || document ],
				type = hasOwn.call( event, "type" ) ? event.type : event,
				namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];

			cur = lastElement = tmp = elem = elem || document;

			// Don't do events on text and comment nodes
			if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
				return;
			}

			// focus/blur morphs to focusin/out; ensure we're not firing them right now
			if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
				return;
			}

			if ( type.indexOf( "." ) > -1 ) {

				// Namespaced trigger; create a regexp to match event type in handle()
				namespaces = type.split( "." );
				type = namespaces.shift();
				namespaces.sort();
			}
			ontype = type.indexOf( ":" ) < 0 && "on" + type;

			// Caller can pass in a jQuery.Event object, Object, or just an event type string
			event = event[ jQuery.expando ] ?
				event :
				new jQuery.Event( type, typeof event === "object" && event );

			// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
			event.isTrigger = onlyHandlers ? 2 : 3;
			event.namespace = namespaces.join( "." );
			event.rnamespace = event.namespace ?
				new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ) :
				null;

			// Clean up the event in case it is being reused
			event.result = undefined;
			if ( !event.target ) {
				event.target = elem;
			}

			// Clone any incoming data and prepend the event, creating the handler arg list
			data = data == null ?
				[ event ] :
				jQuery.makeArray( data, [ event ] );

			// Allow special events to draw outside the lines
			special = jQuery.event.special[ type ] || {};
			if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
				return;
			}

			// Determine event propagation path in advance, per W3C events spec (#9951)
			// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
			if ( !onlyHandlers && !special.noBubble && !isWindow( elem ) ) {

				bubbleType = special.delegateType || type;
				if ( !rfocusMorph.test( bubbleType + type ) ) {
					cur = cur.parentNode;
				}
				for ( ; cur; cur = cur.parentNode ) {
					eventPath.push( cur );
					tmp = cur;
				}

				// Only add window if we got to document (e.g., not plain obj or detached DOM)
				if ( tmp === ( elem.ownerDocument || document ) ) {
					eventPath.push( tmp.defaultView || tmp.parentWindow || window );
				}
			}

			// Fire handlers on the event path
			i = 0;
			while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {
				lastElement = cur;
				event.type = i > 1 ?
					bubbleType :
					special.bindType || type;

				// jQuery handler
				handle = ( dataPriv.get( cur, "events" ) || {} )[ event.type ] &&
					dataPriv.get( cur, "handle" );
				if ( handle ) {
					handle.apply( cur, data );
				}

				// Native handler
				handle = ontype && cur[ ontype ];
				if ( handle && handle.apply && acceptData( cur ) ) {
					event.result = handle.apply( cur, data );
					if ( event.result === false ) {
						event.preventDefault();
					}
				}
			}
			event.type = type;

			// If nobody prevented the default action, do it now
			if ( !onlyHandlers && !event.isDefaultPrevented() ) {

				if ( ( !special._default ||
					special._default.apply( eventPath.pop(), data ) === false ) &&
					acceptData( elem ) ) {

					// Call a native DOM method on the target with the same name as the event.
					// Don't do default actions on window, that's where global variables be (#6170)
					if ( ontype && isFunction( elem[ type ] ) && !isWindow( elem ) ) {

						// Don't re-trigger an onFOO event when we call its FOO() method
						tmp = elem[ ontype ];

						if ( tmp ) {
							elem[ ontype ] = null;
						}

						// Prevent re-triggering of the same event, since we already bubbled it above
						jQuery.event.triggered = type;

						if ( event.isPropagationStopped() ) {
							lastElement.addEventListener( type, stopPropagationCallback );
						}

						elem[ type ]();

						if ( event.isPropagationStopped() ) {
							lastElement.removeEventListener( type, stopPropagationCallback );
						}

						jQuery.event.triggered = undefined;

						if ( tmp ) {
							elem[ ontype ] = tmp;
						}
					}
				}
			}

			return event.result;
		},

		// Piggyback on a donor event to simulate a different one
		// Used only for `focus(in | out)` events
		simulate: function( type, elem, event ) {
			var e = jQuery.extend(
				new jQuery.Event(),
				event,
				{
					type: type,
					isSimulated: true
				}
			);

			jQuery.event.trigger( e, null, elem );
		}

	} );

	jQuery.fn.extend( {

		trigger: function( type, data ) {
			return this.each( function() {
				jQuery.event.trigger( type, data, this );
			} );
		},
		triggerHandler: function( type, data ) {
			var elem = this[ 0 ];
			if ( elem ) {
				return jQuery.event.trigger( type, data, elem, true );
			}
		}
	} );


	// Support: Firefox <=44
	// Firefox doesn't have focus(in | out) events
	// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
	//
	// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
	// focus(in | out) events fire after focus & blur events,
	// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
	// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857
	if ( !support.focusin ) {
		jQuery.each( { focus: "focusin", blur: "focusout" }, function( orig, fix ) {

			// Attach a single capturing handler on the document while someone wants focusin/focusout
			var handler = function( event ) {
				jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );
			};

			jQuery.event.special[ fix ] = {
				setup: function() {
					var doc = this.ownerDocument || this,
						attaches = dataPriv.access( doc, fix );

					if ( !attaches ) {
						doc.addEventListener( orig, handler, true );
					}
					dataPriv.access( doc, fix, ( attaches || 0 ) + 1 );
				},
				teardown: function() {
					var doc = this.ownerDocument || this,
						attaches = dataPriv.access( doc, fix ) - 1;

					if ( !attaches ) {
						doc.removeEventListener( orig, handler, true );
						dataPriv.remove( doc, fix );

					} else {
						dataPriv.access( doc, fix, attaches );
					}
				}
			};
		} );
	}
	var location = window.location;

	var nonce = Date.now();

	var rquery = ( /\?/ );



	// Cross-browser xml parsing
	jQuery.parseXML = function( data ) {
		var xml;
		if ( !data || typeof data !== "string" ) {
			return null;
		}

		// Support: IE 9 - 11 only
		// IE throws on parseFromString with invalid input.
		try {
			xml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );
		} catch ( e ) {
			xml = undefined;
		}

		if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {
			jQuery.error( "Invalid XML: " + data );
		}
		return xml;
	};


	var
		rbracket = /\[\]$/,
		rCRLF = /\r?\n/g,
		rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
		rsubmittable = /^(?:input|select|textarea|keygen)/i;

	function buildParams( prefix, obj, traditional, add ) {
		var name;

		if ( Array.isArray( obj ) ) {

			// Serialize array item.
			jQuery.each( obj, function( i, v ) {
				if ( traditional || rbracket.test( prefix ) ) {

					// Treat each array item as a scalar.
					add( prefix, v );

				} else {

					// Item is non-scalar (array or object), encode its numeric index.
					buildParams(
						prefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",
						v,
						traditional,
						add
					);
				}
			} );

		} else if ( !traditional && toType( obj ) === "object" ) {

			// Serialize object item.
			for ( name in obj ) {
				buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
			}

		} else {

			// Serialize scalar item.
			add( prefix, obj );
		}
	}

	// Serialize an array of form elements or a set of
	// key/values into a query string
	jQuery.param = function( a, traditional ) {
		var prefix,
			s = [],
			add = function( key, valueOrFunction ) {

				// If value is a function, invoke it and use its return value
				var value = isFunction( valueOrFunction ) ?
					valueOrFunction() :
					valueOrFunction;

				s[ s.length ] = encodeURIComponent( key ) + "=" +
					encodeURIComponent( value == null ? "" : value );
			};

		// If an array was passed in, assume that it is an array of form elements.
		if ( Array.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {

			// Serialize the form elements
			jQuery.each( a, function() {
				add( this.name, this.value );
			} );

		} else {

			// If traditional, encode the "old" way (the way 1.3.2 or older
			// did it), otherwise encode params recursively.
			for ( prefix in a ) {
				buildParams( prefix, a[ prefix ], traditional, add );
			}
		}

		// Return the resulting serialization
		return s.join( "&" );
	};

	jQuery.fn.extend( {
		serialize: function() {
			return jQuery.param( this.serializeArray() );
		},
		serializeArray: function() {
			return this.map( function() {

				// Can add propHook for "elements" to filter or add form elements
				var elements = jQuery.prop( this, "elements" );
				return elements ? jQuery.makeArray( elements ) : this;
			} )
			.filter( function() {
				var type = this.type;

				// Use .is( ":disabled" ) so that fieldset[disabled] works
				return this.name && !jQuery( this ).is( ":disabled" ) &&
					rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
					( this.checked || !rcheckableType.test( type ) );
			} )
			.map( function( i, elem ) {
				var val = jQuery( this ).val();

				if ( val == null ) {
					return null;
				}

				if ( Array.isArray( val ) ) {
					return jQuery.map( val, function( val ) {
						return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
					} );
				}

				return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
			} ).get();
		}
	} );


	var
		r20 = /%20/g,
		rhash = /#.*$/,
		rantiCache = /([?&])_=[^&]*/,
		rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,

		// #7653, #8125, #8152: local protocol detection
		rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
		rnoContent = /^(?:GET|HEAD)$/,
		rprotocol = /^\/\//,

		/* Prefilters
		 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
		 * 2) These are called:
		 *    - BEFORE asking for a transport
		 *    - AFTER param serialization (s.data is a string if s.processData is true)
		 * 3) key is the dataType
		 * 4) the catchall symbol "*" can be used
		 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
		 */
		prefilters = {},

		/* Transports bindings
		 * 1) key is the dataType
		 * 2) the catchall symbol "*" can be used
		 * 3) selection will start with transport dataType and THEN go to "*" if needed
		 */
		transports = {},

		// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
		allTypes = "*/".concat( "*" ),

		// Anchor tag for parsing the document origin
		originAnchor = document.createElement( "a" );
		originAnchor.href = location.href;

	// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
	function addToPrefiltersOrTransports( structure ) {

		// dataTypeExpression is optional and defaults to "*"
		return function( dataTypeExpression, func ) {

			if ( typeof dataTypeExpression !== "string" ) {
				func = dataTypeExpression;
				dataTypeExpression = "*";
			}

			var dataType,
				i = 0,
				dataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];

			if ( isFunction( func ) ) {

				// For each dataType in the dataTypeExpression
				while ( ( dataType = dataTypes[ i++ ] ) ) {

					// Prepend if requested
					if ( dataType[ 0 ] === "+" ) {
						dataType = dataType.slice( 1 ) || "*";
						( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );

					// Otherwise append
					} else {
						( structure[ dataType ] = structure[ dataType ] || [] ).push( func );
					}
				}
			}
		};
	}

	// Base inspection function for prefilters and transports
	function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

		var inspected = {},
			seekingTransport = ( structure === transports );

		function inspect( dataType ) {
			var selected;
			inspected[ dataType ] = true;
			jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
				var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
				if ( typeof dataTypeOrTransport === "string" &&
					!seekingTransport && !inspected[ dataTypeOrTransport ] ) {

					options.dataTypes.unshift( dataTypeOrTransport );
					inspect( dataTypeOrTransport );
					return false;
				} else if ( seekingTransport ) {
					return !( selected = dataTypeOrTransport );
				}
			} );
			return selected;
		}

		return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
	}

	// A special extend for ajax options
	// that takes "flat" options (not to be deep extended)
	// Fixes #9887
	function ajaxExtend( target, src ) {
		var key, deep,
			flatOptions = jQuery.ajaxSettings.flatOptions || {};

		for ( key in src ) {
			if ( src[ key ] !== undefined ) {
				( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
			}
		}
		if ( deep ) {
			jQuery.extend( true, target, deep );
		}

		return target;
	}

	/* Handles responses to an ajax request:
	 * - finds the right dataType (mediates between content-type and expected dataType)
	 * - returns the corresponding response
	 */
	function ajaxHandleResponses( s, jqXHR, responses ) {

		var ct, type, finalDataType, firstDataType,
			contents = s.contents,
			dataTypes = s.dataTypes;

		// Remove auto dataType and get content-type in the process
		while ( dataTypes[ 0 ] === "*" ) {
			dataTypes.shift();
			if ( ct === undefined ) {
				ct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );
			}
		}

		// Check if we're dealing with a known content-type
		if ( ct ) {
			for ( type in contents ) {
				if ( contents[ type ] && contents[ type ].test( ct ) ) {
					dataTypes.unshift( type );
					break;
				}
			}
		}

		// Check to see if we have a response for the expected dataType
		if ( dataTypes[ 0 ] in responses ) {
			finalDataType = dataTypes[ 0 ];
		} else {

			// Try convertible dataTypes
			for ( type in responses ) {
				if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {
					finalDataType = type;
					break;
				}
				if ( !firstDataType ) {
					firstDataType = type;
				}
			}

			// Or just use first one
			finalDataType = finalDataType || firstDataType;
		}

		// If we found a dataType
		// We add the dataType to the list if needed
		// and return the corresponding response
		if ( finalDataType ) {
			if ( finalDataType !== dataTypes[ 0 ] ) {
				dataTypes.unshift( finalDataType );
			}
			return responses[ finalDataType ];
		}
	}

	/* Chain conversions given the request and the original response
	 * Also sets the responseXXX fields on the jqXHR instance
	 */
	function ajaxConvert( s, response, jqXHR, isSuccess ) {
		var conv2, current, conv, tmp, prev,
			converters = {},

			// Work with a copy of dataTypes in case we need to modify it for conversion
			dataTypes = s.dataTypes.slice();

		// Create converters map with lowercased keys
		if ( dataTypes[ 1 ] ) {
			for ( conv in s.converters ) {
				converters[ conv.toLowerCase() ] = s.converters[ conv ];
			}
		}

		current = dataTypes.shift();

		// Convert to each sequential dataType
		while ( current ) {

			if ( s.responseFields[ current ] ) {
				jqXHR[ s.responseFields[ current ] ] = response;
			}

			// Apply the dataFilter if provided
			if ( !prev && isSuccess && s.dataFilter ) {
				response = s.dataFilter( response, s.dataType );
			}

			prev = current;
			current = dataTypes.shift();

			if ( current ) {

				// There's only work to do if current dataType is non-auto
				if ( current === "*" ) {

					current = prev;

				// Convert response if prev dataType is non-auto and differs from current
				} else if ( prev !== "*" && prev !== current ) {

					// Seek a direct converter
					conv = converters[ prev + " " + current ] || converters[ "* " + current ];

					// If none found, seek a pair
					if ( !conv ) {
						for ( conv2 in converters ) {

							// If conv2 outputs current
							tmp = conv2.split( " " );
							if ( tmp[ 1 ] === current ) {

								// If prev can be converted to accepted input
								conv = converters[ prev + " " + tmp[ 0 ] ] ||
									converters[ "* " + tmp[ 0 ] ];
								if ( conv ) {

									// Condense equivalence converters
									if ( conv === true ) {
										conv = converters[ conv2 ];

									// Otherwise, insert the intermediate dataType
									} else if ( converters[ conv2 ] !== true ) {
										current = tmp[ 0 ];
										dataTypes.unshift( tmp[ 1 ] );
									}
									break;
								}
							}
						}
					}

					// Apply converter (if not an equivalence)
					if ( conv !== true ) {

						// Unless errors are allowed to bubble, catch and return them
						if ( conv && s.throws ) {
							response = conv( response );
						} else {
							try {
								response = conv( response );
							} catch ( e ) {
								return {
									state: "parsererror",
									error: conv ? e : "No conversion from " + prev + " to " + current
								};
							}
						}
					}
				}
			}
		}

		return { state: "success", data: response };
	}

	jQuery.extend( {

		// Counter for holding the number of active queries
		active: 0,

		// Last-Modified header cache for next request
		lastModified: {},
		etag: {},

		ajaxSettings: {
			url: location.href,
			type: "GET",
			isLocal: rlocalProtocol.test( location.protocol ),
			global: true,
			processData: true,
			async: true,
			contentType: "application/x-www-form-urlencoded; charset=UTF-8",

			/*
			timeout: 0,
			data: null,
			dataType: null,
			username: null,
			password: null,
			cache: null,
			throws: false,
			traditional: false,
			headers: {},
			*/

			accepts: {
				"*": allTypes,
				text: "text/plain",
				html: "text/html",
				xml: "application/xml, text/xml",
				json: "application/json, text/javascript"
			},

			contents: {
				xml: /\bxml\b/,
				html: /\bhtml/,
				json: /\bjson\b/
			},

			responseFields: {
				xml: "responseXML",
				text: "responseText",
				json: "responseJSON"
			},

			// Data converters
			// Keys separate source (or catchall "*") and destination types with a single space
			converters: {

				// Convert anything to text
				"* text": String,

				// Text to html (true = no transformation)
				"text html": true,

				// Evaluate text as a json expression
				"text json": JSON.parse,

				// Parse text as xml
				"text xml": jQuery.parseXML
			},

			// For options that shouldn't be deep extended:
			// you can add your own custom options here if
			// and when you create one that shouldn't be
			// deep extended (see ajaxExtend)
			flatOptions: {
				url: true,
				context: true
			}
		},

		// Creates a full fledged settings object into target
		// with both ajaxSettings and settings fields.
		// If target is omitted, writes into ajaxSettings.
		ajaxSetup: function( target, settings ) {
			return settings ?

				// Building a settings object
				ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

				// Extending ajaxSettings
				ajaxExtend( jQuery.ajaxSettings, target );
		},

		ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
		ajaxTransport: addToPrefiltersOrTransports( transports ),

		// Main method
		ajax: function( url, options ) {

			// If url is an object, simulate pre-1.5 signature
			if ( typeof url === "object" ) {
				options = url;
				url = undefined;
			}

			// Force options to be an object
			options = options || {};

			var transport,

				// URL without anti-cache param
				cacheURL,

				// Response headers
				responseHeadersString,
				responseHeaders,

				// timeout handle
				timeoutTimer,

				// Url cleanup var
				urlAnchor,

				// Request state (becomes false upon send and true upon completion)
				completed,

				// To know if global events are to be dispatched
				fireGlobals,

				// Loop variable
				i,

				// uncached part of the url
				uncached,

				// Create the final options object
				s = jQuery.ajaxSetup( {}, options ),

				// Callbacks context
				callbackContext = s.context || s,

				// Context for global events is callbackContext if it is a DOM node or jQuery collection
				globalEventContext = s.context &&
					( callbackContext.nodeType || callbackContext.jquery ) ?
						jQuery( callbackContext ) :
						jQuery.event,

				// Deferreds
				deferred = jQuery.Deferred(),
				completeDeferred = jQuery.Callbacks( "once memory" ),

				// Status-dependent callbacks
				statusCode = s.statusCode || {},

				// Headers (they are sent all at once)
				requestHeaders = {},
				requestHeadersNames = {},

				// Default abort message
				strAbort = "canceled",

				// Fake xhr
				jqXHR = {
					readyState: 0,

					// Builds headers hashtable if needed
					getResponseHeader: function( key ) {
						var match;
						if ( completed ) {
							if ( !responseHeaders ) {
								responseHeaders = {};
								while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
									responseHeaders[ match[ 1 ].toLowerCase() ] = match[ 2 ];
								}
							}
							match = responseHeaders[ key.toLowerCase() ];
						}
						return match == null ? null : match;
					},

					// Raw string
					getAllResponseHeaders: function() {
						return completed ? responseHeadersString : null;
					},

					// Caches the header
					setRequestHeader: function( name, value ) {
						if ( completed == null ) {
							name = requestHeadersNames[ name.toLowerCase() ] =
								requestHeadersNames[ name.toLowerCase() ] || name;
							requestHeaders[ name ] = value;
						}
						return this;
					},

					// Overrides response content-type header
					overrideMimeType: function( type ) {
						if ( completed == null ) {
							s.mimeType = type;
						}
						return this;
					},

					// Status-dependent callbacks
					statusCode: function( map ) {
						var code;
						if ( map ) {
							if ( completed ) {

								// Execute the appropriate callbacks
								jqXHR.always( map[ jqXHR.status ] );
							} else {

								// Lazy-add the new callbacks in a way that preserves old ones
								for ( code in map ) {
									statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
								}
							}
						}
						return this;
					},

					// Cancel the request
					abort: function( statusText ) {
						var finalText = statusText || strAbort;
						if ( transport ) {
							transport.abort( finalText );
						}
						done( 0, finalText );
						return this;
					}
				};

			// Attach deferreds
			deferred.promise( jqXHR );

			// Add protocol if not provided (prefilters might expect it)
			// Handle falsy url in the settings object (#10093: consistency with old signature)
			// We also use the url parameter if available
			s.url = ( ( url || s.url || location.href ) + "" )
				.replace( rprotocol, location.protocol + "//" );

			// Alias method option to type as per ticket #12004
			s.type = options.method || options.type || s.method || s.type;

			// Extract dataTypes list
			s.dataTypes = ( s.dataType || "*" ).toLowerCase().match( rnothtmlwhite ) || [ "" ];

			// A cross-domain request is in order when the origin doesn't match the current origin.
			if ( s.crossDomain == null ) {
				urlAnchor = document.createElement( "a" );

				// Support: IE <=8 - 11, Edge 12 - 15
				// IE throws exception on accessing the href property if url is malformed,
				// e.g. http://example.com:80x/
				try {
					urlAnchor.href = s.url;

					// Support: IE <=8 - 11 only
					// Anchor's host property isn't correctly set when s.url is relative
					urlAnchor.href = urlAnchor.href;
					s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
						urlAnchor.protocol + "//" + urlAnchor.host;
				} catch ( e ) {

					// If there is an error parsing the URL, assume it is crossDomain,
					// it can be rejected by the transport if it is invalid
					s.crossDomain = true;
				}
			}

			// Convert data if not already a string
			if ( s.data && s.processData && typeof s.data !== "string" ) {
				s.data = jQuery.param( s.data, s.traditional );
			}

			// Apply prefilters
			inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

			// If request was aborted inside a prefilter, stop there
			if ( completed ) {
				return jqXHR;
			}

			// We can fire global events as of now if asked to
			// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
			fireGlobals = jQuery.event && s.global;

			// Watch for a new set of requests
			if ( fireGlobals && jQuery.active++ === 0 ) {
				jQuery.event.trigger( "ajaxStart" );
			}

			// Uppercase the type
			s.type = s.type.toUpperCase();

			// Determine if request has content
			s.hasContent = !rnoContent.test( s.type );

			// Save the URL in case we're toying with the If-Modified-Since
			// and/or If-None-Match header later on
			// Remove hash to simplify url manipulation
			cacheURL = s.url.replace( rhash, "" );

			// More options handling for requests with no content
			if ( !s.hasContent ) {

				// Remember the hash so we can put it back
				uncached = s.url.slice( cacheURL.length );

				// If data is available and should be processed, append data to url
				if ( s.data && ( s.processData || typeof s.data === "string" ) ) {
					cacheURL += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data;

					// #9682: remove data so that it's not used in an eventual retry
					delete s.data;
				}

				// Add or update anti-cache param if needed
				if ( s.cache === false ) {
					cacheURL = cacheURL.replace( rantiCache, "$1" );
					uncached = ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + ( nonce++ ) + uncached;
				}

				// Put hash and anti-cache on the URL that will be requested (gh-1732)
				s.url = cacheURL + uncached;

			// Change '%20' to '+' if this is encoded form body content (gh-2658)
			} else if ( s.data && s.processData &&
				( s.contentType || "" ).indexOf( "application/x-www-form-urlencoded" ) === 0 ) {
				s.data = s.data.replace( r20, "+" );
			}

			// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
			if ( s.ifModified ) {
				if ( jQuery.lastModified[ cacheURL ] ) {
					jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
				}
				if ( jQuery.etag[ cacheURL ] ) {
					jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
				}
			}

			// Set the correct header, if data is being sent
			if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
				jqXHR.setRequestHeader( "Content-Type", s.contentType );
			}

			// Set the Accepts header for the server, depending on the dataType
			jqXHR.setRequestHeader(
				"Accept",
				s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?
					s.accepts[ s.dataTypes[ 0 ] ] +
						( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
					s.accepts[ "*" ]
			);

			// Check for headers option
			for ( i in s.headers ) {
				jqXHR.setRequestHeader( i, s.headers[ i ] );
			}

			// Allow custom headers/mimetypes and early abort
			if ( s.beforeSend &&
				( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {

				// Abort if not done already and return
				return jqXHR.abort();
			}

			// Aborting is no longer a cancellation
			strAbort = "abort";

			// Install callbacks on deferreds
			completeDeferred.add( s.complete );
			jqXHR.done( s.success );
			jqXHR.fail( s.error );

			// Get transport
			transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

			// If no transport, we auto-abort
			if ( !transport ) {
				done( -1, "No Transport" );
			} else {
				jqXHR.readyState = 1;

				// Send global event
				if ( fireGlobals ) {
					globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
				}

				// If request was aborted inside ajaxSend, stop there
				if ( completed ) {
					return jqXHR;
				}

				// Timeout
				if ( s.async && s.timeout > 0 ) {
					timeoutTimer = window.setTimeout( function() {
						jqXHR.abort( "timeout" );
					}, s.timeout );
				}

				try {
					completed = false;
					transport.send( requestHeaders, done );
				} catch ( e ) {

					// Rethrow post-completion exceptions
					if ( completed ) {
						throw e;
					}

					// Propagate others as results
					done( -1, e );
				}
			}

			// Callback for when everything is done
			function done( status, nativeStatusText, responses, headers ) {
				var isSuccess, success, error, response, modified,
					statusText = nativeStatusText;

				// Ignore repeat invocations
				if ( completed ) {
					return;
				}

				completed = true;

				// Clear timeout if it exists
				if ( timeoutTimer ) {
					window.clearTimeout( timeoutTimer );
				}

				// Dereference transport for early garbage collection
				// (no matter how long the jqXHR object will be used)
				transport = undefined;

				// Cache response headers
				responseHeadersString = headers || "";

				// Set readyState
				jqXHR.readyState = status > 0 ? 4 : 0;

				// Determine if successful
				isSuccess = status >= 200 && status < 300 || status === 304;

				// Get response data
				if ( responses ) {
					response = ajaxHandleResponses( s, jqXHR, responses );
				}

				// Convert no matter what (that way responseXXX fields are always set)
				response = ajaxConvert( s, response, jqXHR, isSuccess );

				// If successful, handle type chaining
				if ( isSuccess ) {

					// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
					if ( s.ifModified ) {
						modified = jqXHR.getResponseHeader( "Last-Modified" );
						if ( modified ) {
							jQuery.lastModified[ cacheURL ] = modified;
						}
						modified = jqXHR.getResponseHeader( "etag" );
						if ( modified ) {
							jQuery.etag[ cacheURL ] = modified;
						}
					}

					// if no content
					if ( status === 204 || s.type === "HEAD" ) {
						statusText = "nocontent";

					// if not modified
					} else if ( status === 304 ) {
						statusText = "notmodified";

					// If we have data, let's convert it
					} else {
						statusText = response.state;
						success = response.data;
						error = response.error;
						isSuccess = !error;
					}
				} else {

					// Extract error from statusText and normalize for non-aborts
					error = statusText;
					if ( status || !statusText ) {
						statusText = "error";
						if ( status < 0 ) {
							status = 0;
						}
					}
				}

				// Set data for the fake xhr object
				jqXHR.status = status;
				jqXHR.statusText = ( nativeStatusText || statusText ) + "";

				// Success/Error
				if ( isSuccess ) {
					deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
				} else {
					deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
				}

				// Status-dependent callbacks
				jqXHR.statusCode( statusCode );
				statusCode = undefined;

				if ( fireGlobals ) {
					globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
						[ jqXHR, s, isSuccess ? success : error ] );
				}

				// Complete
				completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

				if ( fireGlobals ) {
					globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );

					// Handle the global AJAX counter
					if ( !( --jQuery.active ) ) {
						jQuery.event.trigger( "ajaxStop" );
					}
				}
			}

			return jqXHR;
		},

		getJSON: function( url, data, callback ) {
			return jQuery.get( url, data, callback, "json" );
		},

		getScript: function( url, callback ) {
			return jQuery.get( url, undefined, callback, "script" );
		}
	} );

	jQuery.each( [ "get", "post" ], function( i, method ) {
		jQuery[ method ] = function( url, data, callback, type ) {

			// Shift arguments if data argument was omitted
			if ( isFunction( data ) ) {
				type = type || callback;
				callback = data;
				data = undefined;
			}

			// The url can be an options object (which then must have .url)
			return jQuery.ajax( jQuery.extend( {
				url: url,
				type: method,
				dataType: type,
				data: data,
				success: callback
			}, jQuery.isPlainObject( url ) && url ) );
		};
	} );


	jQuery._evalUrl = function( url ) {
		return jQuery.ajax( {
			url: url,

			// Make this explicit, since user can override this through ajaxSetup (#11264)
			type: "GET",
			dataType: "script",
			cache: true,
			async: false,
			global: false,
			"throws": true
		} );
	};


	jQuery.fn.extend( {
		wrapAll: function( html ) {
			var wrap;

			if ( this[ 0 ] ) {
				if ( isFunction( html ) ) {
					html = html.call( this[ 0 ] );
				}

				// The elements to wrap the target around
				wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

				if ( this[ 0 ].parentNode ) {
					wrap.insertBefore( this[ 0 ] );
				}

				wrap.map( function() {
					var elem = this;

					while ( elem.firstElementChild ) {
						elem = elem.firstElementChild;
					}

					return elem;
				} ).append( this );
			}

			return this;
		},

		wrapInner: function( html ) {
			if ( isFunction( html ) ) {
				return this.each( function( i ) {
					jQuery( this ).wrapInner( html.call( this, i ) );
				} );
			}

			return this.each( function() {
				var self = jQuery( this ),
					contents = self.contents();

				if ( contents.length ) {
					contents.wrapAll( html );

				} else {
					self.append( html );
				}
			} );
		},

		wrap: function( html ) {
			var htmlIsFunction = isFunction( html );

			return this.each( function( i ) {
				jQuery( this ).wrapAll( htmlIsFunction ? html.call( this, i ) : html );
			} );
		},

		unwrap: function( selector ) {
			this.parent( selector ).not( "body" ).each( function() {
				jQuery( this ).replaceWith( this.childNodes );
			} );
			return this;
		}
	} );


	jQuery.expr.pseudos.hidden = function( elem ) {
		return !jQuery.expr.pseudos.visible( elem );
	};
	jQuery.expr.pseudos.visible = function( elem ) {
		return !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );
	};




	jQuery.ajaxSettings.xhr = function() {
		try {
			return new window.XMLHttpRequest();
		} catch ( e ) {}
	};

	var xhrSuccessStatus = {

			// File protocol always yields status code 0, assume 200
			0: 200,

			// Support: IE <=9 only
			// #1450: sometimes IE returns 1223 when it should be 204
			1223: 204
		},
		xhrSupported = jQuery.ajaxSettings.xhr();

	support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
	support.ajax = xhrSupported = !!xhrSupported;

	jQuery.ajaxTransport( function( options ) {
		var callback, errorCallback;

		// Cross domain only allowed if supported through XMLHttpRequest
		if ( support.cors || xhrSupported && !options.crossDomain ) {
			return {
				send: function( headers, complete ) {
					var i,
						xhr = options.xhr();

					xhr.open(
						options.type,
						options.url,
						options.async,
						options.username,
						options.password
					);

					// Apply custom fields if provided
					if ( options.xhrFields ) {
						for ( i in options.xhrFields ) {
							xhr[ i ] = options.xhrFields[ i ];
						}
					}

					// Override mime type if needed
					if ( options.mimeType && xhr.overrideMimeType ) {
						xhr.overrideMimeType( options.mimeType );
					}

					// X-Requested-With header
					// For cross-domain requests, seeing as conditions for a preflight are
					// akin to a jigsaw puzzle, we simply never set it to be sure.
					// (it can always be set on a per-request basis or even using ajaxSetup)
					// For same-domain requests, won't change header if already provided.
					if ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {
						headers[ "X-Requested-With" ] = "XMLHttpRequest";
					}

					// Set headers
					for ( i in headers ) {
						xhr.setRequestHeader( i, headers[ i ] );
					}

					// Callback
					callback = function( type ) {
						return function() {
							if ( callback ) {
								callback = errorCallback = xhr.onload =
									xhr.onerror = xhr.onabort = xhr.ontimeout =
										xhr.onreadystatechange = null;

								if ( type === "abort" ) {
									xhr.abort();
								} else if ( type === "error" ) {

									// Support: IE <=9 only
									// On a manual native abort, IE9 throws
									// errors on any property access that is not readyState
									if ( typeof xhr.status !== "number" ) {
										complete( 0, "error" );
									} else {
										complete(

											// File: protocol always yields status 0; see #8605, #14207
											xhr.status,
											xhr.statusText
										);
									}
								} else {
									complete(
										xhrSuccessStatus[ xhr.status ] || xhr.status,
										xhr.statusText,

										// Support: IE <=9 only
										// IE9 has no XHR2 but throws on binary (trac-11426)
										// For XHR2 non-text, let the caller handle it (gh-2498)
										( xhr.responseType || "text" ) !== "text"  ||
										typeof xhr.responseText !== "string" ?
											{ binary: xhr.response } :
											{ text: xhr.responseText },
										xhr.getAllResponseHeaders()
									);
								}
							}
						};
					};

					// Listen to events
					xhr.onload = callback();
					errorCallback = xhr.onerror = xhr.ontimeout = callback( "error" );

					// Support: IE 9 only
					// Use onreadystatechange to replace onabort
					// to handle uncaught aborts
					if ( xhr.onabort !== undefined ) {
						xhr.onabort = errorCallback;
					} else {
						xhr.onreadystatechange = function() {

							// Check readyState before timeout as it changes
							if ( xhr.readyState === 4 ) {

								// Allow onerror to be called first,
								// but that will not handle a native abort
								// Also, save errorCallback to a variable
								// as xhr.onerror cannot be accessed
								window.setTimeout( function() {
									if ( callback ) {
										errorCallback();
									}
								} );
							}
						};
					}

					// Create the abort callback
					callback = callback( "abort" );

					try {

						// Do send the request (this may raise an exception)
						xhr.send( options.hasContent && options.data || null );
					} catch ( e ) {

						// #14683: Only rethrow if this hasn't been notified as an error yet
						if ( callback ) {
							throw e;
						}
					}
				},

				abort: function() {
					if ( callback ) {
						callback();
					}
				}
			};
		}
	} );




	// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)
	jQuery.ajaxPrefilter( function( s ) {
		if ( s.crossDomain ) {
			s.contents.script = false;
		}
	} );

	// Install script dataType
	jQuery.ajaxSetup( {
		accepts: {
			script: "text/javascript, application/javascript, " +
				"application/ecmascript, application/x-ecmascript"
		},
		contents: {
			script: /\b(?:java|ecma)script\b/
		},
		converters: {
			"text script": function( text ) {
				jQuery.globalEval( text );
				return text;
			}
		}
	} );

	// Handle cache's special case and crossDomain
	jQuery.ajaxPrefilter( "script", function( s ) {
		if ( s.cache === undefined ) {
			s.cache = false;
		}
		if ( s.crossDomain ) {
			s.type = "GET";
		}
	} );

	// Bind script tag hack transport
	jQuery.ajaxTransport( "script", function( s ) {

		// This transport only deals with cross domain requests
		if ( s.crossDomain ) {
			var script, callback;
			return {
				send: function( _, complete ) {
					script = jQuery( "<script>" ).prop( {
						charset: s.scriptCharset,
						src: s.url
					} ).on(
						"load error",
						callback = function( evt ) {
							script.remove();
							callback = null;
							if ( evt ) {
								complete( evt.type === "error" ? 404 : 200, evt.type );
							}
						}
					);

					// Use native DOM manipulation to avoid our domManip AJAX trickery
					document.head.appendChild( script[ 0 ] );
				},
				abort: function() {
					if ( callback ) {
						callback();
					}
				}
			};
		}
	} );




	var oldCallbacks = [],
		rjsonp = /(=)\?(?=&|$)|\?\?/;

	// Default jsonp settings
	jQuery.ajaxSetup( {
		jsonp: "callback",
		jsonpCallback: function() {
			var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
			this[ callback ] = true;
			return callback;
		}
	} );

	// Detect, normalize options and install callbacks for jsonp requests
	jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

		var callbackName, overwritten, responseContainer,
			jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
				"url" :
				typeof s.data === "string" &&
					( s.contentType || "" )
						.indexOf( "application/x-www-form-urlencoded" ) === 0 &&
					rjsonp.test( s.data ) && "data"
			);

		// Handle iff the expected data type is "jsonp" or we have a parameter to set
		if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

			// Get callback name, remembering preexisting value associated with it
			callbackName = s.jsonpCallback = isFunction( s.jsonpCallback ) ?
				s.jsonpCallback() :
				s.jsonpCallback;

			// Insert callback into url or form data
			if ( jsonProp ) {
				s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
			} else if ( s.jsonp !== false ) {
				s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
			}

			// Use data converter to retrieve json after script execution
			s.converters[ "script json" ] = function() {
				if ( !responseContainer ) {
					jQuery.error( callbackName + " was not called" );
				}
				return responseContainer[ 0 ];
			};

			// Force json dataType
			s.dataTypes[ 0 ] = "json";

			// Install callback
			overwritten = window[ callbackName ];
			window[ callbackName ] = function() {
				responseContainer = arguments;
			};

			// Clean-up function (fires after converters)
			jqXHR.always( function() {

				// If previous value didn't exist - remove it
				if ( overwritten === undefined ) {
					jQuery( window ).removeProp( callbackName );

				// Otherwise restore preexisting value
				} else {
					window[ callbackName ] = overwritten;
				}

				// Save back as free
				if ( s[ callbackName ] ) {

					// Make sure that re-using the options doesn't screw things around
					s.jsonpCallback = originalSettings.jsonpCallback;

					// Save the callback name for future use
					oldCallbacks.push( callbackName );
				}

				// Call if it was a function and we have a response
				if ( responseContainer && isFunction( overwritten ) ) {
					overwritten( responseContainer[ 0 ] );
				}

				responseContainer = overwritten = undefined;
			} );

			// Delegate to script
			return "script";
		}
	} );




	// Support: Safari 8 only
	// In Safari 8 documents created via document.implementation.createHTMLDocument
	// collapse sibling forms: the second one becomes a child of the first one.
	// Because of that, this security measure has to be disabled in Safari 8.
	// https://bugs.webkit.org/show_bug.cgi?id=137337
	support.createHTMLDocument = ( function() {
		var body = document.implementation.createHTMLDocument( "" ).body;
		body.innerHTML = "<form></form><form></form>";
		return body.childNodes.length === 2;
	} )();


	// Argument "data" should be string of html
	// context (optional): If specified, the fragment will be created in this context,
	// defaults to document
	// keepScripts (optional): If true, will include scripts passed in the html string
	jQuery.parseHTML = function( data, context, keepScripts ) {
		if ( typeof data !== "string" ) {
			return [];
		}
		if ( typeof context === "boolean" ) {
			keepScripts = context;
			context = false;
		}

		var base, parsed, scripts;

		if ( !context ) {

			// Stop scripts or inline event handlers from being executed immediately
			// by using document.implementation
			if ( support.createHTMLDocument ) {
				context = document.implementation.createHTMLDocument( "" );

				// Set the base href for the created document
				// so any parsed elements with URLs
				// are based on the document's URL (gh-2965)
				base = context.createElement( "base" );
				base.href = document.location.href;
				context.head.appendChild( base );
			} else {
				context = document;
			}
		}

		parsed = rsingleTag.exec( data );
		scripts = !keepScripts && [];

		// Single tag
		if ( parsed ) {
			return [ context.createElement( parsed[ 1 ] ) ];
		}

		parsed = buildFragment( [ data ], context, scripts );

		if ( scripts && scripts.length ) {
			jQuery( scripts ).remove();
		}

		return jQuery.merge( [], parsed.childNodes );
	};


	/**
	 * Load a url into a page
	 */
	jQuery.fn.load = function( url, params, callback ) {
		var selector, type, response,
			self = this,
			off = url.indexOf( " " );

		if ( off > -1 ) {
			selector = stripAndCollapse( url.slice( off ) );
			url = url.slice( 0, off );
		}

		// If it's a function
		if ( isFunction( params ) ) {

			// We assume that it's the callback
			callback = params;
			params = undefined;

		// Otherwise, build a param string
		} else if ( params && typeof params === "object" ) {
			type = "POST";
		}

		// If we have elements to modify, make the request
		if ( self.length > 0 ) {
			jQuery.ajax( {
				url: url,

				// If "type" variable is undefined, then "GET" method will be used.
				// Make value of this field explicit since
				// user can override it through ajaxSetup method
				type: type || "GET",
				dataType: "html",
				data: params
			} ).done( function( responseText ) {

				// Save response for use in complete callback
				response = arguments;

				self.html( selector ?

					// If a selector was specified, locate the right elements in a dummy div
					// Exclude scripts to avoid IE 'Permission Denied' errors
					jQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :

					// Otherwise use the full result
					responseText );

			// If the request succeeds, this function gets "data", "status", "jqXHR"
			// but they are ignored because response was set above.
			// If it fails, this function gets "jqXHR", "status", "error"
			} ).always( callback && function( jqXHR, status ) {
				self.each( function() {
					callback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );
				} );
			} );
		}

		return this;
	};




	// Attach a bunch of functions for handling common AJAX events
	jQuery.each( [
		"ajaxStart",
		"ajaxStop",
		"ajaxComplete",
		"ajaxError",
		"ajaxSuccess",
		"ajaxSend"
	], function( i, type ) {
		jQuery.fn[ type ] = function( fn ) {
			return this.on( type, fn );
		};
	} );




	jQuery.expr.pseudos.animated = function( elem ) {
		return jQuery.grep( jQuery.timers, function( fn ) {
			return elem === fn.elem;
		} ).length;
	};




	jQuery.offset = {
		setOffset: function( elem, options, i ) {
			var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
				position = jQuery.css( elem, "position" ),
				curElem = jQuery( elem ),
				props = {};

			// Set position first, in-case top/left are set even on static elem
			if ( position === "static" ) {
				elem.style.position = "relative";
			}

			curOffset = curElem.offset();
			curCSSTop = jQuery.css( elem, "top" );
			curCSSLeft = jQuery.css( elem, "left" );
			calculatePosition = ( position === "absolute" || position === "fixed" ) &&
				( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;

			// Need to be able to calculate position if either
			// top or left is auto and position is either absolute or fixed
			if ( calculatePosition ) {
				curPosition = curElem.position();
				curTop = curPosition.top;
				curLeft = curPosition.left;

			} else {
				curTop = parseFloat( curCSSTop ) || 0;
				curLeft = parseFloat( curCSSLeft ) || 0;
			}

			if ( isFunction( options ) ) {

				// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
				options = options.call( elem, i, jQuery.extend( {}, curOffset ) );
			}

			if ( options.top != null ) {
				props.top = ( options.top - curOffset.top ) + curTop;
			}
			if ( options.left != null ) {
				props.left = ( options.left - curOffset.left ) + curLeft;
			}

			if ( "using" in options ) {
				options.using.call( elem, props );

			} else {
				curElem.css( props );
			}
		}
	};

	jQuery.fn.extend( {

		// offset() relates an element's border box to the document origin
		offset: function( options ) {

			// Preserve chaining for setter
			if ( arguments.length ) {
				return options === undefined ?
					this :
					this.each( function( i ) {
						jQuery.offset.setOffset( this, options, i );
					} );
			}

			var rect, win,
				elem = this[ 0 ];

			if ( !elem ) {
				return;
			}

			// Return zeros for disconnected and hidden (display: none) elements (gh-2310)
			// Support: IE <=11 only
			// Running getBoundingClientRect on a
			// disconnected node in IE throws an error
			if ( !elem.getClientRects().length ) {
				return { top: 0, left: 0 };
			}

			// Get document-relative position by adding viewport scroll to viewport-relative gBCR
			rect = elem.getBoundingClientRect();
			win = elem.ownerDocument.defaultView;
			return {
				top: rect.top + win.pageYOffset,
				left: rect.left + win.pageXOffset
			};
		},

		// position() relates an element's margin box to its offset parent's padding box
		// This corresponds to the behavior of CSS absolute positioning
		position: function() {
			if ( !this[ 0 ] ) {
				return;
			}

			var offsetParent, offset, doc,
				elem = this[ 0 ],
				parentOffset = { top: 0, left: 0 };

			// position:fixed elements are offset from the viewport, which itself always has zero offset
			if ( jQuery.css( elem, "position" ) === "fixed" ) {

				// Assume position:fixed implies availability of getBoundingClientRect
				offset = elem.getBoundingClientRect();

			} else {
				offset = this.offset();

				// Account for the *real* offset parent, which can be the document or its root element
				// when a statically positioned element is identified
				doc = elem.ownerDocument;
				offsetParent = elem.offsetParent || doc.documentElement;
				while ( offsetParent &&
					( offsetParent === doc.body || offsetParent === doc.documentElement ) &&
					jQuery.css( offsetParent, "position" ) === "static" ) {

					offsetParent = offsetParent.parentNode;
				}
				if ( offsetParent && offsetParent !== elem && offsetParent.nodeType === 1 ) {

					// Incorporate borders into its offset, since they are outside its content origin
					parentOffset = jQuery( offsetParent ).offset();
					parentOffset.top += jQuery.css( offsetParent, "borderTopWidth", true );
					parentOffset.left += jQuery.css( offsetParent, "borderLeftWidth", true );
				}
			}

			// Subtract parent offsets and element margins
			return {
				top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
				left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
			};
		},

		// This method will return documentElement in the following cases:
		// 1) For the element inside the iframe without offsetParent, this method will return
		//    documentElement of the parent window
		// 2) For the hidden or detached element
		// 3) For body or html element, i.e. in case of the html node - it will return itself
		//
		// but those exceptions were never presented as a real life use-cases
		// and might be considered as more preferable results.
		//
		// This logic, however, is not guaranteed and can change at any point in the future
		offsetParent: function() {
			return this.map( function() {
				var offsetParent = this.offsetParent;

				while ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {
					offsetParent = offsetParent.offsetParent;
				}

				return offsetParent || documentElement;
			} );
		}
	} );

	// Create scrollLeft and scrollTop methods
	jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
		var top = "pageYOffset" === prop;

		jQuery.fn[ method ] = function( val ) {
			return access( this, function( elem, method, val ) {

				// Coalesce documents and windows
				var win;
				if ( isWindow( elem ) ) {
					win = elem;
				} else if ( elem.nodeType === 9 ) {
					win = elem.defaultView;
				}

				if ( val === undefined ) {
					return win ? win[ prop ] : elem[ method ];
				}

				if ( win ) {
					win.scrollTo(
						!top ? val : win.pageXOffset,
						top ? val : win.pageYOffset
					);

				} else {
					elem[ method ] = val;
				}
			}, method, val, arguments.length );
		};
	} );

	// Support: Safari <=7 - 9.1, Chrome <=37 - 49
	// Add the top/left cssHooks using jQuery.fn.position
	// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
	// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
	// getComputedStyle returns percent when specified for top/left/bottom/right;
	// rather than make the css module depend on the offset module, just check for it here
	jQuery.each( [ "top", "left" ], function( i, prop ) {
		jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
			function( elem, computed ) {
				if ( computed ) {
					computed = curCSS( elem, prop );

					// If curCSS returns percentage, fallback to offset
					return rnumnonpx.test( computed ) ?
						jQuery( elem ).position()[ prop ] + "px" :
						computed;
				}
			}
		);
	} );


	// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
	jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
		jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name },
			function( defaultExtra, funcName ) {

			// Margin is only for outerHeight, outerWidth
			jQuery.fn[ funcName ] = function( margin, value ) {
				var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
					extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

				return access( this, function( elem, type, value ) {
					var doc;

					if ( isWindow( elem ) ) {

						// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
						return funcName.indexOf( "outer" ) === 0 ?
							elem[ "inner" + name ] :
							elem.document.documentElement[ "client" + name ];
					}

					// Get document width or height
					if ( elem.nodeType === 9 ) {
						doc = elem.documentElement;

						// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
						// whichever is greatest
						return Math.max(
							elem.body[ "scroll" + name ], doc[ "scroll" + name ],
							elem.body[ "offset" + name ], doc[ "offset" + name ],
							doc[ "client" + name ]
						);
					}

					return value === undefined ?

						// Get width or height on the element, requesting but not forcing parseFloat
						jQuery.css( elem, type, extra ) :

						// Set width or height on the element
						jQuery.style( elem, type, value, extra );
				}, type, chainable ? margin : undefined, chainable );
			};
		} );
	} );


	jQuery.each( ( "blur focus focusin focusout resize scroll click dblclick " +
		"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
		"change select submit keydown keypress keyup contextmenu" ).split( " " ),
		function( i, name ) {

		// Handle event binding
		jQuery.fn[ name ] = function( data, fn ) {
			return arguments.length > 0 ?
				this.on( name, null, data, fn ) :
				this.trigger( name );
		};
	} );

	jQuery.fn.extend( {
		hover: function( fnOver, fnOut ) {
			return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
		}
	} );




	jQuery.fn.extend( {

		bind: function( types, data, fn ) {
			return this.on( types, null, data, fn );
		},
		unbind: function( types, fn ) {
			return this.off( types, null, fn );
		},

		delegate: function( selector, types, data, fn ) {
			return this.on( types, selector, data, fn );
		},
		undelegate: function( selector, types, fn ) {

			// ( namespace ) or ( selector, types [, fn] )
			return arguments.length === 1 ?
				this.off( selector, "**" ) :
				this.off( types, selector || "**", fn );
		}
	} );

	// Bind a function to a context, optionally partially applying any
	// arguments.
	// jQuery.proxy is deprecated to promote standards (specifically Function#bind)
	// However, it is not slated for removal any time soon
	jQuery.proxy = function( fn, context ) {
		var tmp, args, proxy;

		if ( typeof context === "string" ) {
			tmp = fn[ context ];
			context = fn;
			fn = tmp;
		}

		// Quick check to determine if target is callable, in the spec
		// this throws a TypeError, but we will just return undefined.
		if ( !isFunction( fn ) ) {
			return undefined;
		}

		// Simulated bind
		args = slice.call( arguments, 2 );
		proxy = function() {
			return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
		};

		// Set the guid of unique handler to the same of original handler, so it can be removed
		proxy.guid = fn.guid = fn.guid || jQuery.guid++;

		return proxy;
	};

	jQuery.holdReady = function( hold ) {
		if ( hold ) {
			jQuery.readyWait++;
		} else {
			jQuery.ready( true );
		}
	};
	jQuery.isArray = Array.isArray;
	jQuery.parseJSON = JSON.parse;
	jQuery.nodeName = nodeName;
	jQuery.isFunction = isFunction;
	jQuery.isWindow = isWindow;
	jQuery.camelCase = camelCase;
	jQuery.type = toType;

	jQuery.now = Date.now;

	jQuery.isNumeric = function( obj ) {

		// As of jQuery 3.0, isNumeric is limited to
		// strings and numbers (primitives or objects)
		// that can be coerced to finite numbers (gh-2662)
		var type = jQuery.type( obj );
		return ( type === "number" || type === "string" ) &&

			// parseFloat NaNs numeric-cast false positives ("")
			// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
			// subtraction forces infinities to NaN
			!isNaN( obj - parseFloat( obj ) );
	};




	// Register as a named AMD module, since jQuery can be concatenated with other
	// files that may use define, but not via a proper concatenation script that
	// understands anonymous AMD modules. A named AMD is safest and most robust
	// way to register. Lowercase jquery is used because AMD module names are
	// derived from file names, and jQuery is normally delivered in a lowercase
	// file name. Do this after creating the global so that if an AMD module wants
	// to call noConflict to hide this version of jQuery, it will work.

	// Note that for maximum portability, libraries that are not jQuery should
	// declare themselves as anonymous modules, and avoid setting a global if an
	// AMD loader is present. jQuery is a special case. For more information, see
	// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

	if ( true ) {
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {
			return jQuery;
		}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	}




	var

		// Map over jQuery in case of overwrite
		_jQuery = window.jQuery,

		// Map over the $ in case of overwrite
		_$ = window.$;

	jQuery.noConflict = function( deep ) {
		if ( window.$ === jQuery ) {
			window.$ = _$;
		}

		if ( deep && window.jQuery === jQuery ) {
			window.jQuery = _jQuery;
		}

		return jQuery;
	};

	// Expose jQuery and $ identifiers, even in AMD
	// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
	// and CommonJS for browser emulators (#13566)
	if ( !noGlobal ) {
		window.jQuery = window.$ = jQuery;
	}




	return jQuery;
	} );


/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';


	// bootstrap
	__webpack_require__(32);
	__webpack_require__(33);

	// bootstrap-datepicker
	__webpack_require__(34);
	__webpack_require__(35);
	__webpack_require__(36);

	// bootstrap-select
	__webpack_require__(37);
	__webpack_require__(38);

	// awesome-font
	__webpack_require__(39);

	// https://icomoon.io/
	// Pixel Perfect Icon Solutions
	__webpack_require__(40);

	// Switcg-css
	__webpack_require__(41);

	//http://daneden.me/animate
	//Just-add-water CSS animations
	__webpack_require__(42);
	__webpack_require__(43); // 讓lib的wow.js中的WOW成為global變數

	//patternlock
	__webpack_require__(44);
	__webpack_require__(45);

	// highcharts

	var highcharts = __webpack_require__(46);
	window.Highcharts = highcharts;
	var goodcharts = __webpack_require__(47);
	window.Goodcharts = goodcharts;
	__webpack_require__(48)(Highcharts);

	// require("highcharts/modules/exporting.js");

	// jquery.searchable
	__webpack_require__(49);

	// autocomplete
	//require("autocomplete/lib/autocomplete.js");

	// owl.carousel
	__webpack_require__(50);
	__webpack_require__(51);

	// sortable.js
	// require("./web/inc/lib/jquery-sortable/jquery-sortable.js");

	// bootstrap tagsinput
	__webpack_require__(52);
	__webpack_require__(53);

	// Sortable
	window.Sortable = __webpack_require__(54);

	// html keyboard
	__webpack_require__(55);
	__webpack_require__(56);
	__webpack_require__(57);

	// 20190814 Format <input> content
	__webpack_require__(58);


	// bootstrap tagsinput
	__webpack_require__(59);

	// noUiSlider
	window.noUiSlider = __webpack_require__(60);
	window.wNumb = __webpack_require__(61);
	__webpack_require__(62);

	// lottie-web
	var lottie=__webpack_require__(63);
	window.lottie=lottie;

/***/ }),
/* 32 */
/***/ (function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ }),
/* 33 */
/***/ (function(module, exports) {

	/*!
	 * Bootstrap v3.4.1 (https://getbootstrap.com/)
	 * Copyright 2011-2019 Twitter, Inc.
	 * Licensed under the MIT license
	 */

	if (typeof jQuery === 'undefined') {
	  throw new Error('Bootstrap\'s JavaScript requires jQuery')
	}

	+function ($) {
	  'use strict';
	  var version = $.fn.jquery.split(' ')[0].split('.')
	  if ((version[0] < 2 && version[1] < 9) || (version[0] == 1 && version[1] == 9 && version[2] < 1) || (version[0] > 3)) {
	    throw new Error('Bootstrap\'s JavaScript requires jQuery version 1.9.1 or higher, but lower than version 4')
	  }
	}(jQuery);

	/* ========================================================================
	 * Bootstrap: transition.js v3.4.1
	 * https://getbootstrap.com/docs/3.4/javascript/#transitions
	 * ========================================================================
	 * Copyright 2011-2019 Twitter, Inc.
	 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
	 * ======================================================================== */


	+function ($) {
	  'use strict';

	  // CSS TRANSITION SUPPORT (Shoutout: https://modernizr.com/)
	  // ============================================================

	  function transitionEnd() {
	    var el = document.createElement('bootstrap')

	    var transEndEventNames = {
	      WebkitTransition : 'webkitTransitionEnd',
	      MozTransition    : 'transitionend',
	      OTransition      : 'oTransitionEnd otransitionend',
	      transition       : 'transitionend'
	    }

	    for (var name in transEndEventNames) {
	      if (el.style[name] !== undefined) {
	        return { end: transEndEventNames[name] }
	      }
	    }

	    return false // explicit for ie8 (  ._.)
	  }

	  // https://blog.alexmaccaw.com/css-transitions
	  $.fn.emulateTransitionEnd = function (duration) {
	    var called = false
	    var $el = this
	    $(this).one('bsTransitionEnd', function () { called = true })
	    var callback = function () { if (!called) $($el).trigger($.support.transition.end) }
	    setTimeout(callback, duration)
	    return this
	  }

	  $(function () {
	    $.support.transition = transitionEnd()

	    if (!$.support.transition) return

	    $.event.special.bsTransitionEnd = {
	      bindType: $.support.transition.end,
	      delegateType: $.support.transition.end,
	      handle: function (e) {
	        if ($(e.target).is(this)) return e.handleObj.handler.apply(this, arguments)
	      }
	    }
	  })

	}(jQuery);

	/* ========================================================================
	 * Bootstrap: alert.js v3.4.1
	 * https://getbootstrap.com/docs/3.4/javascript/#alerts
	 * ========================================================================
	 * Copyright 2011-2019 Twitter, Inc.
	 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
	 * ======================================================================== */


	+function ($) {
	  'use strict';

	  // ALERT CLASS DEFINITION
	  // ======================

	  var dismiss = '[data-dismiss="alert"]'
	  var Alert   = function (el) {
	    $(el).on('click', dismiss, this.close)
	  }

	  Alert.VERSION = '3.4.1'

	  Alert.TRANSITION_DURATION = 150

	  Alert.prototype.close = function (e) {
	    var $this    = $(this)
	    var selector = $this.attr('data-target')

	    if (!selector) {
	      selector = $this.attr('href')
	      selector = selector && selector.replace(/.*(?=#[^\s]*$)/, '') // strip for ie7
	    }

	    selector    = selector === '#' ? [] : selector
	    var $parent = $(document).find(selector)

	    if (e) e.preventDefault()

	    if (!$parent.length) {
	      $parent = $this.closest('.alert')
	    }

	    $parent.trigger(e = $.Event('close.bs.alert'))

	    if (e.isDefaultPrevented()) return

	    $parent.removeClass('in')

	    function removeElement() {
	      // detach from parent, fire event then clean up data
	      $parent.detach().trigger('closed.bs.alert').remove()
	    }

	    $.support.transition && $parent.hasClass('fade') ?
	      $parent
	        .one('bsTransitionEnd', removeElement)
	        .emulateTransitionEnd(Alert.TRANSITION_DURATION) :
	      removeElement()
	  }


	  // ALERT PLUGIN DEFINITION
	  // =======================

	  function Plugin(option) {
	    return this.each(function () {
	      var $this = $(this)
	      var data  = $this.data('bs.alert')

	      if (!data) $this.data('bs.alert', (data = new Alert(this)))
	      if (typeof option == 'string') data[option].call($this)
	    })
	  }

	  var old = $.fn.alert

	  $.fn.alert             = Plugin
	  $.fn.alert.Constructor = Alert


	  // ALERT NO CONFLICT
	  // =================

	  $.fn.alert.noConflict = function () {
	    $.fn.alert = old
	    return this
	  }


	  // ALERT DATA-API
	  // ==============

	  $(document).on('click.bs.alert.data-api', dismiss, Alert.prototype.close)

	}(jQuery);

	/* ========================================================================
	 * Bootstrap: button.js v3.4.1
	 * https://getbootstrap.com/docs/3.4/javascript/#buttons
	 * ========================================================================
	 * Copyright 2011-2019 Twitter, Inc.
	 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
	 * ======================================================================== */


	+function ($) {
	  'use strict';

	  // BUTTON PUBLIC CLASS DEFINITION
	  // ==============================

	  var Button = function (element, options) {
	    this.$element  = $(element)
	    this.options   = $.extend({}, Button.DEFAULTS, options)
	    this.isLoading = false
	  }

	  Button.VERSION  = '3.4.1'

	  Button.DEFAULTS = {
	    loadingText: 'loading...'
	  }

	  Button.prototype.setState = function (state) {
	    var d    = 'disabled'
	    var $el  = this.$element
	    var val  = $el.is('input') ? 'val' : 'html'
	    var data = $el.data()

	    state += 'Text'

	    if (data.resetText == null) $el.data('resetText', $el[val]())

	    // push to event loop to allow forms to submit
	    setTimeout($.proxy(function () {
	      $el[val](data[state] == null ? this.options[state] : data[state])

	      if (state == 'loadingText') {
	        this.isLoading = true
	        $el.addClass(d).attr(d, d).prop(d, true)
	      } else if (this.isLoading) {
	        this.isLoading = false
	        $el.removeClass(d).removeAttr(d).prop(d, false)
	      }
	    }, this), 0)
	  }

	  Button.prototype.toggle = function () {
	    var changed = true
	    var $parent = this.$element.closest('[data-toggle="buttons"]')

	    if ($parent.length) {
	      var $input = this.$element.find('input')
	      if ($input.prop('type') == 'radio') {
	        if ($input.prop('checked')) changed = false
	        $parent.find('.active').removeClass('active')
	        this.$element.addClass('active')
	      } else if ($input.prop('type') == 'checkbox') {
	        if (($input.prop('checked')) !== this.$element.hasClass('active')) changed = false
	        this.$element.toggleClass('active')
	      }
	      $input.prop('checked', this.$element.hasClass('active'))
	      if (changed) $input.trigger('change')
	    } else {
	      this.$element.attr('aria-pressed', !this.$element.hasClass('active'))
	      this.$element.toggleClass('active')
	    }
	  }


	  // BUTTON PLUGIN DEFINITION
	  // ========================

	  function Plugin(option) {
	    return this.each(function () {
	      var $this   = $(this)
	      var data    = $this.data('bs.button')
	      var options = typeof option == 'object' && option

	      if (!data) $this.data('bs.button', (data = new Button(this, options)))

	      if (option == 'toggle') data.toggle()
	      else if (option) data.setState(option)
	    })
	  }

	  var old = $.fn.button

	  $.fn.button             = Plugin
	  $.fn.button.Constructor = Button


	  // BUTTON NO CONFLICT
	  // ==================

	  $.fn.button.noConflict = function () {
	    $.fn.button = old
	    return this
	  }


	  // BUTTON DATA-API
	  // ===============

	  $(document)
	    .on('click.bs.button.data-api', '[data-toggle^="button"]', function (e) {
	      var $btn = $(e.target).closest('.btn')
	      Plugin.call($btn, 'toggle')
	      if (!($(e.target).is('input[type="radio"], input[type="checkbox"]'))) {
	        // Prevent double click on radios, and the double selections (so cancellation) on checkboxes
	        e.preventDefault()
	        // The target component still receive the focus
	        if ($btn.is('input,button')) $btn.trigger('focus')
	        else $btn.find('input:visible,button:visible').first().trigger('focus')
	      }
	    })
	    .on('focus.bs.button.data-api blur.bs.button.data-api', '[data-toggle^="button"]', function (e) {
	      $(e.target).closest('.btn').toggleClass('focus', /^focus(in)?$/.test(e.type))
	    })

	}(jQuery);

	/* ========================================================================
	 * Bootstrap: carousel.js v3.4.1
	 * https://getbootstrap.com/docs/3.4/javascript/#carousel
	 * ========================================================================
	 * Copyright 2011-2019 Twitter, Inc.
	 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
	 * ======================================================================== */


	+function ($) {
	  'use strict';

	  // CAROUSEL CLASS DEFINITION
	  // =========================

	  var Carousel = function (element, options) {
	    this.$element    = $(element)
	    this.$indicators = this.$element.find('.carousel-indicators')
	    this.options     = options
	    this.paused      = null
	    this.sliding     = null
	    this.interval    = null
	    this.$active     = null
	    this.$items      = null

	    this.options.keyboard && this.$element.on('keydown.bs.carousel', $.proxy(this.keydown, this))

	    this.options.pause == 'hover' && !('ontouchstart' in document.documentElement) && this.$element
	      .on('mouseenter.bs.carousel', $.proxy(this.pause, this))
	      .on('mouseleave.bs.carousel', $.proxy(this.cycle, this))
	  }

	  Carousel.VERSION  = '3.4.1'

	  Carousel.TRANSITION_DURATION = 600

	  Carousel.DEFAULTS = {
	    interval: 5000,
	    pause: 'hover',
	    wrap: true,
	    keyboard: true
	  }

	  Carousel.prototype.keydown = function (e) {
	    if (/input|textarea/i.test(e.target.tagName)) return
	    switch (e.which) {
	      case 37: this.prev(); break
	      case 39: this.next(); break
	      default: return
	    }

	    e.preventDefault()
	  }

	  Carousel.prototype.cycle = function (e) {
	    e || (this.paused = false)

	    this.interval && clearInterval(this.interval)

	    this.options.interval
	      && !this.paused
	      && (this.interval = setInterval($.proxy(this.next, this), this.options.interval))

	    return this
	  }

	  Carousel.prototype.getItemIndex = function (item) {
	    this.$items = item.parent().children('.item')
	    return this.$items.index(item || this.$active)
	  }

	  Carousel.prototype.getItemForDirection = function (direction, active) {
	    var activeIndex = this.getItemIndex(active)
	    var willWrap = (direction == 'prev' && activeIndex === 0)
	                || (direction == 'next' && activeIndex == (this.$items.length - 1))
	    if (willWrap && !this.options.wrap) return active
	    var delta = direction == 'prev' ? -1 : 1
	    var itemIndex = (activeIndex + delta) % this.$items.length
	    return this.$items.eq(itemIndex)
	  }

	  Carousel.prototype.to = function (pos) {
	    var that        = this
	    var activeIndex = this.getItemIndex(this.$active = this.$element.find('.item.active'))

	    if (pos > (this.$items.length - 1) || pos < 0) return

	    if (this.sliding)       return this.$element.one('slid.bs.carousel', function () { that.to(pos) }) // yes, "slid"
	    if (activeIndex == pos) return this.pause().cycle()

	    return this.slide(pos > activeIndex ? 'next' : 'prev', this.$items.eq(pos))
	  }

	  Carousel.prototype.pause = function (e) {
	    e || (this.paused = true)

	    if (this.$element.find('.next, .prev').length && $.support.transition) {
	      this.$element.trigger($.support.transition.end)
	      this.cycle(true)
	    }

	    this.interval = clearInterval(this.interval)

	    return this
	  }

	  Carousel.prototype.next = function () {
	    if (this.sliding) return
	    return this.slide('next')
	  }

	  Carousel.prototype.prev = function () {
	    if (this.sliding) return
	    return this.slide('prev')
	  }

	  Carousel.prototype.slide = function (type, next) {
	    var $active   = this.$element.find('.item.active')
	    var $next     = next || this.getItemForDirection(type, $active)
	    var isCycling = this.interval
	    var direction = type == 'next' ? 'left' : 'right'
	    var that      = this

	    if ($next.hasClass('active')) return (this.sliding = false)

	    var relatedTarget = $next[0]
	    var slideEvent = $.Event('slide.bs.carousel', {
	      relatedTarget: relatedTarget,
	      direction: direction
	    })
	    this.$element.trigger(slideEvent)
	    if (slideEvent.isDefaultPrevented()) return

	    this.sliding = true

	    isCycling && this.pause()

	    if (this.$indicators.length) {
	      this.$indicators.find('.active').removeClass('active')
	      var $nextIndicator = $(this.$indicators.children()[this.getItemIndex($next)])
	      $nextIndicator && $nextIndicator.addClass('active')
	    }

	    var slidEvent = $.Event('slid.bs.carousel', { relatedTarget: relatedTarget, direction: direction }) // yes, "slid"
	    if ($.support.transition && this.$element.hasClass('slide')) {
	      $next.addClass(type)
	      if (typeof $next === 'object' && $next.length) {
	        $next[0].offsetWidth // force reflow
	      }
	      $active.addClass(direction)
	      $next.addClass(direction)
	      $active
	        .one('bsTransitionEnd', function () {
	          $next.removeClass([type, direction].join(' ')).addClass('active')
	          $active.removeClass(['active', direction].join(' '))
	          that.sliding = false
	          setTimeout(function () {
	            that.$element.trigger(slidEvent)
	          }, 0)
	        })
	        .emulateTransitionEnd(Carousel.TRANSITION_DURATION)
	    } else {
	      $active.removeClass('active')
	      $next.addClass('active')
	      this.sliding = false
	      this.$element.trigger(slidEvent)
	    }

	    isCycling && this.cycle()

	    return this
	  }


	  // CAROUSEL PLUGIN DEFINITION
	  // ==========================

	  function Plugin(option) {
	    return this.each(function () {
	      var $this   = $(this)
	      var data    = $this.data('bs.carousel')
	      var options = $.extend({}, Carousel.DEFAULTS, $this.data(), typeof option == 'object' && option)
	      var action  = typeof option == 'string' ? option : options.slide

	      if (!data) $this.data('bs.carousel', (data = new Carousel(this, options)))
	      if (typeof option == 'number') data.to(option)
	      else if (action) data[action]()
	      else if (options.interval) data.pause().cycle()
	    })
	  }

	  var old = $.fn.carousel

	  $.fn.carousel             = Plugin
	  $.fn.carousel.Constructor = Carousel


	  // CAROUSEL NO CONFLICT
	  // ====================

	  $.fn.carousel.noConflict = function () {
	    $.fn.carousel = old
	    return this
	  }


	  // CAROUSEL DATA-API
	  // =================

	  var clickHandler = function (e) {
	    var $this   = $(this)
	    var href    = $this.attr('href')
	    if (href) {
	      href = href.replace(/.*(?=#[^\s]+$)/, '') // strip for ie7
	    }

	    var target  = $this.attr('data-target') || href
	    var $target = $(document).find(target)

	    if (!$target.hasClass('carousel')) return

	    var options = $.extend({}, $target.data(), $this.data())
	    var slideIndex = $this.attr('data-slide-to')
	    if (slideIndex) options.interval = false

	    Plugin.call($target, options)

	    if (slideIndex) {
	      $target.data('bs.carousel').to(slideIndex)
	    }

	    e.preventDefault()
	  }

	  $(document)
	    .on('click.bs.carousel.data-api', '[data-slide]', clickHandler)
	    .on('click.bs.carousel.data-api', '[data-slide-to]', clickHandler)

	  $(window).on('load', function () {
	    $('[data-ride="carousel"]').each(function () {
	      var $carousel = $(this)
	      Plugin.call($carousel, $carousel.data())
	    })
	  })

	}(jQuery);

	/* ========================================================================
	 * Bootstrap: collapse.js v3.4.1
	 * https://getbootstrap.com/docs/3.4/javascript/#collapse
	 * ========================================================================
	 * Copyright 2011-2019 Twitter, Inc.
	 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
	 * ======================================================================== */

	/* jshint latedef: false */

	+function ($) {
	  'use strict';

	  // COLLAPSE PUBLIC CLASS DEFINITION
	  // ================================

	  var Collapse = function (element, options) {
	    this.$element      = $(element)
	    this.options       = $.extend({}, Collapse.DEFAULTS, options)
	    this.$trigger      = $('[data-toggle="collapse"][href="#' + element.id + '"],' +
	                           '[data-toggle="collapse"][data-target="#' + element.id + '"]')
	    this.transitioning = null

	    if (this.options.parent) {
	      this.$parent = this.getParent()
	    } else {
	      this.addAriaAndCollapsedClass(this.$element, this.$trigger)
	    }

	    if (this.options.toggle) this.toggle()
	  }

	  Collapse.VERSION  = '3.4.1'

	  Collapse.TRANSITION_DURATION = 350

	  Collapse.DEFAULTS = {
	    toggle: true
	  }

	  Collapse.prototype.dimension = function () {
	    var hasWidth = this.$element.hasClass('width')
	    return hasWidth ? 'width' : 'height'
	  }

	  Collapse.prototype.show = function () {
	    if (this.transitioning || this.$element.hasClass('in')) return

	    var activesData
	    var actives = this.$parent && this.$parent.children('.panel').children('.in, .collapsing')

	    if (actives && actives.length) {
	      activesData = actives.data('bs.collapse')
	      if (activesData && activesData.transitioning) return
	    }

	    var startEvent = $.Event('show.bs.collapse')
	    this.$element.trigger(startEvent)
	    if (startEvent.isDefaultPrevented()) return

	    if (actives && actives.length) {
	      Plugin.call(actives, 'hide')
	      activesData || actives.data('bs.collapse', null)
	    }

	    var dimension = this.dimension()

	    this.$element
	      .removeClass('collapse')
	      .addClass('collapsing')[dimension](0)
	      .attr('aria-expanded', true)

	    this.$trigger
	      .removeClass('collapsed')
	      .attr('aria-expanded', true)

	    this.transitioning = 1

	    var complete = function () {
	      this.$element
	        .removeClass('collapsing')
	        .addClass('collapse in')[dimension]('')
	      this.transitioning = 0
	      this.$element
	        .trigger('shown.bs.collapse')
	    }

	    if (!$.support.transition) return complete.call(this)

	    var scrollSize = $.camelCase(['scroll', dimension].join('-'))

	    this.$element
	      .one('bsTransitionEnd', $.proxy(complete, this))
	      .emulateTransitionEnd(Collapse.TRANSITION_DURATION)[dimension](this.$element[0][scrollSize])
	  }

	  Collapse.prototype.hide = function () {
	    if (this.transitioning || !this.$element.hasClass('in')) return

	    var startEvent = $.Event('hide.bs.collapse')
	    this.$element.trigger(startEvent)
	    if (startEvent.isDefaultPrevented()) return

	    var dimension = this.dimension()

	    this.$element[dimension](this.$element[dimension]())[0].offsetHeight

	    this.$element
	      .addClass('collapsing')
	      .removeClass('collapse in')
	      .attr('aria-expanded', false)

	    this.$trigger
	      .addClass('collapsed')
	      .attr('aria-expanded', false)

	    this.transitioning = 1

	    var complete = function () {
	      this.transitioning = 0
	      this.$element
	        .removeClass('collapsing')
	        .addClass('collapse')
	        .trigger('hidden.bs.collapse')
	    }

	    if (!$.support.transition) return complete.call(this)

	    this.$element
	      [dimension](0)
	      .one('bsTransitionEnd', $.proxy(complete, this))
	      .emulateTransitionEnd(Collapse.TRANSITION_DURATION)
	  }

	  Collapse.prototype.toggle = function () {
	    this[this.$element.hasClass('in') ? 'hide' : 'show']()
	  }

	  Collapse.prototype.getParent = function () {
	    return $(document).find(this.options.parent)
	      .find('[data-toggle="collapse"][data-parent="' + this.options.parent + '"]')
	      .each($.proxy(function (i, element) {
	        var $element = $(element)
	        this.addAriaAndCollapsedClass(getTargetFromTrigger($element), $element)
	      }, this))
	      .end()
	  }

	  Collapse.prototype.addAriaAndCollapsedClass = function ($element, $trigger) {
	    var isOpen = $element.hasClass('in')

	    $element.attr('aria-expanded', isOpen)
	    $trigger
	      .toggleClass('collapsed', !isOpen)
	      .attr('aria-expanded', isOpen)
	  }

	  function getTargetFromTrigger($trigger) {
	    var href
	    var target = $trigger.attr('data-target')
	      || (href = $trigger.attr('href')) && href.replace(/.*(?=#[^\s]+$)/, '') // strip for ie7

	    return $(document).find(target)
	  }


	  // COLLAPSE PLUGIN DEFINITION
	  // ==========================

	  function Plugin(option) {
	    return this.each(function () {
	      var $this   = $(this)
	      var data    = $this.data('bs.collapse')
	      var options = $.extend({}, Collapse.DEFAULTS, $this.data(), typeof option == 'object' && option)

	      if (!data && options.toggle && /show|hide/.test(option)) options.toggle = false
	      if (!data) $this.data('bs.collapse', (data = new Collapse(this, options)))
	      if (typeof option == 'string') data[option]()
	    })
	  }

	  var old = $.fn.collapse

	  $.fn.collapse             = Plugin
	  $.fn.collapse.Constructor = Collapse


	  // COLLAPSE NO CONFLICT
	  // ====================

	  $.fn.collapse.noConflict = function () {
	    $.fn.collapse = old
	    return this
	  }


	  // COLLAPSE DATA-API
	  // =================

	  $(document).on('click.bs.collapse.data-api', '[data-toggle="collapse"]', function (e) {
	    var $this   = $(this)

	    if (!$this.attr('data-target')) e.preventDefault()

	    var $target = getTargetFromTrigger($this)
	    var data    = $target.data('bs.collapse')
	    var option  = data ? 'toggle' : $this.data()

	    Plugin.call($target, option)
	  })

	}(jQuery);

	/* ========================================================================
	 * Bootstrap: dropdown.js v3.4.1
	 * https://getbootstrap.com/docs/3.4/javascript/#dropdowns
	 * ========================================================================
	 * Copyright 2011-2019 Twitter, Inc.
	 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
	 * ======================================================================== */


	+function ($) {
	  'use strict';

	  // DROPDOWN CLASS DEFINITION
	  // =========================

	  var backdrop = '.dropdown-backdrop'
	  var toggle   = '[data-toggle="dropdown"]'
	  var Dropdown = function (element) {
	    $(element).on('click.bs.dropdown', this.toggle)
	  }

	  Dropdown.VERSION = '3.4.1'

	  function getParent($this) {
	    var selector = $this.attr('data-target')

	    if (!selector) {
	      selector = $this.attr('href')
	      selector = selector && /#[A-Za-z]/.test(selector) && selector.replace(/.*(?=#[^\s]*$)/, '') // strip for ie7
	    }

	    var $parent = selector !== '#' ? $(document).find(selector) : null

	    return $parent && $parent.length ? $parent : $this.parent()
	  }

	  function clearMenus(e) {
	    if (e && e.which === 3) return
	    $(backdrop).remove()
	    $(toggle).each(function () {
	      var $this         = $(this)
	      var $parent       = getParent($this)
	      var relatedTarget = { relatedTarget: this }

	      if (!$parent.hasClass('open')) return

	      if (e && e.type == 'click' && /input|textarea/i.test(e.target.tagName) && $.contains($parent[0], e.target)) return

	      $parent.trigger(e = $.Event('hide.bs.dropdown', relatedTarget))

	      if (e.isDefaultPrevented()) return

	      $this.attr('aria-expanded', 'false')
	      $parent.removeClass('open').trigger($.Event('hidden.bs.dropdown', relatedTarget))
	    })
	  }

	  Dropdown.prototype.toggle = function (e) {
	    var $this = $(this)

	    if ($this.is('.disabled, :disabled')) return

	    var $parent  = getParent($this)
	    var isActive = $parent.hasClass('open')

	    clearMenus()

	    if (!isActive) {
	      if ('ontouchstart' in document.documentElement && !$parent.closest('.navbar-nav').length) {
	        // if mobile we use a backdrop because click events don't delegate
	        $(document.createElement('div'))
	          .addClass('dropdown-backdrop')
	          .insertAfter($(this))
	          .on('click', clearMenus)
	      }

	      var relatedTarget = { relatedTarget: this }
	      $parent.trigger(e = $.Event('show.bs.dropdown', relatedTarget))

	      if (e.isDefaultPrevented()) return

	      $this
	        .trigger('focus')
	        .attr('aria-expanded', 'true')

	      $parent
	        .toggleClass('open')
	        .trigger($.Event('shown.bs.dropdown', relatedTarget))
	    }

	    return false
	  }

	  Dropdown.prototype.keydown = function (e) {
	    if (!/(38|40|27|32)/.test(e.which) || /input|textarea/i.test(e.target.tagName)) return

	    var $this = $(this)

	    e.preventDefault()
	    e.stopPropagation()

	    if ($this.is('.disabled, :disabled')) return

	    var $parent  = getParent($this)
	    var isActive = $parent.hasClass('open')

	    if (!isActive && e.which != 27 || isActive && e.which == 27) {
	      if (e.which == 27) $parent.find(toggle).trigger('focus')
	      return $this.trigger('click')
	    }

	    var desc = ' li:not(.disabled):visible a'
	    var $items = $parent.find('.dropdown-menu' + desc)

	    if (!$items.length) return

	    var index = $items.index(e.target)

	    if (e.which == 38 && index > 0)                 index--         // up
	    if (e.which == 40 && index < $items.length - 1) index++         // down
	    if (!~index)                                    index = 0

	    $items.eq(index).trigger('focus')
	  }


	  // DROPDOWN PLUGIN DEFINITION
	  // ==========================

	  function Plugin(option) {
	    return this.each(function () {
	      var $this = $(this)
	      var data  = $this.data('bs.dropdown')

	      if (!data) $this.data('bs.dropdown', (data = new Dropdown(this)))
	      if (typeof option == 'string') data[option].call($this)
	    })
	  }

	  var old = $.fn.dropdown

	  $.fn.dropdown             = Plugin
	  $.fn.dropdown.Constructor = Dropdown


	  // DROPDOWN NO CONFLICT
	  // ====================

	  $.fn.dropdown.noConflict = function () {
	    $.fn.dropdown = old
	    return this
	  }


	  // APPLY TO STANDARD DROPDOWN ELEMENTS
	  // ===================================

	  $(document)
	    .on('click.bs.dropdown.data-api', clearMenus)
	    .on('click.bs.dropdown.data-api', '.dropdown form', function (e) { e.stopPropagation() })
	    .on('click.bs.dropdown.data-api', toggle, Dropdown.prototype.toggle)
	    .on('keydown.bs.dropdown.data-api', toggle, Dropdown.prototype.keydown)
	    .on('keydown.bs.dropdown.data-api', '.dropdown-menu', Dropdown.prototype.keydown)

	}(jQuery);

	/* ========================================================================
	 * Bootstrap: modal.js v3.4.1
	 * https://getbootstrap.com/docs/3.4/javascript/#modals
	 * ========================================================================
	 * Copyright 2011-2019 Twitter, Inc.
	 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
	 * ======================================================================== */


	+function ($) {
	  'use strict';

	  // MODAL CLASS DEFINITION
	  // ======================

	  var Modal = function (element, options) {
	    this.options = options
	    this.$body = $(document.body)
	    this.$element = $(element)
	    this.$dialog = this.$element.find('.modal-dialog')
	    this.$backdrop = null
	    this.isShown = null
	    this.originalBodyPad = null
	    this.scrollbarWidth = 0
	    this.ignoreBackdropClick = false
	    this.fixedContent = '.navbar-fixed-top, .navbar-fixed-bottom'

	    if (this.options.remote) {
	      this.$element
	        .find('.modal-content')
	        .load(this.options.remote, $.proxy(function () {
	          this.$element.trigger('loaded.bs.modal')
	        }, this))
	    }
	  }

	  Modal.VERSION = '3.4.1'

	  Modal.TRANSITION_DURATION = 300
	  Modal.BACKDROP_TRANSITION_DURATION = 150

	  Modal.DEFAULTS = {
	    backdrop: true,
	    keyboard: true,
	    show: true
	  }

	  Modal.prototype.toggle = function (_relatedTarget) {
	    return this.isShown ? this.hide() : this.show(_relatedTarget)
	  }

	  Modal.prototype.show = function (_relatedTarget) {
	    var that = this
	    var e = $.Event('show.bs.modal', { relatedTarget: _relatedTarget })

	    this.$element.trigger(e)

	    if (this.isShown || e.isDefaultPrevented()) return

	    this.isShown = true

	    this.checkScrollbar()
	    this.setScrollbar()
	    this.$body.addClass('modal-open')

	    this.escape()
	    this.resize()

	    this.$element.on('click.dismiss.bs.modal', '[data-dismiss="modal"]', $.proxy(this.hide, this))

	    this.$dialog.on('mousedown.dismiss.bs.modal', function () {
	      that.$element.one('mouseup.dismiss.bs.modal', function (e) {
	        if ($(e.target).is(that.$element)) that.ignoreBackdropClick = true
	      })
	    })

	    this.backdrop(function () {
	      var transition = $.support.transition && that.$element.hasClass('fade')

	      if (!that.$element.parent().length) {
	        that.$element.appendTo(that.$body) // don't move modals dom position
	      }

	      that.$element
	        .show()
	        .scrollTop(0)

	      that.adjustDialog()

	      if (transition) {
	        that.$element[0].offsetWidth // force reflow
	      }

	      that.$element.addClass('in')

	      that.enforceFocus()

	      var e = $.Event('shown.bs.modal', { relatedTarget: _relatedTarget })

	      transition ?
	        that.$dialog // wait for modal to slide in
	          .one('bsTransitionEnd', function () {
	            that.$element.trigger('focus').trigger(e)
	          })
	          .emulateTransitionEnd(Modal.TRANSITION_DURATION) :
	        that.$element.trigger('focus').trigger(e)
	    })
	  }

	  Modal.prototype.hide = function (e) {
	    if (e) e.preventDefault()

	    e = $.Event('hide.bs.modal')

	    this.$element.trigger(e)

	    if (!this.isShown || e.isDefaultPrevented()) return

	    this.isShown = false

	    this.escape()
	    this.resize()

	    $(document).off('focusin.bs.modal')

	    this.$element
	      .removeClass('in')
	      .off('click.dismiss.bs.modal')
	      .off('mouseup.dismiss.bs.modal')

	    this.$dialog.off('mousedown.dismiss.bs.modal')

	    $.support.transition && this.$element.hasClass('fade') ?
	      this.$element
	        .one('bsTransitionEnd', $.proxy(this.hideModal, this))
	        .emulateTransitionEnd(Modal.TRANSITION_DURATION) :
	      this.hideModal()
	  }

	  Modal.prototype.enforceFocus = function () {
	    $(document)
	      .off('focusin.bs.modal') // guard against infinite focus loop
	      .on('focusin.bs.modal', $.proxy(function (e) {
	        if (document !== e.target &&
	          this.$element[0] !== e.target &&
	          !this.$element.has(e.target).length) {
	          this.$element.trigger('focus')
	        }
	      }, this))
	  }

	  Modal.prototype.escape = function () {
	    if (this.isShown && this.options.keyboard) {
	      this.$element.on('keydown.dismiss.bs.modal', $.proxy(function (e) {
	        e.which == 27 && this.hide()
	      }, this))
	    } else if (!this.isShown) {
	      this.$element.off('keydown.dismiss.bs.modal')
	    }
	  }

	  Modal.prototype.resize = function () {
	    if (this.isShown) {
	      $(window).on('resize.bs.modal', $.proxy(this.handleUpdate, this))
	    } else {
	      $(window).off('resize.bs.modal')
	    }
	  }

	  Modal.prototype.hideModal = function () {
	    var that = this
	    this.$element.hide()
	    this.backdrop(function () {
	      that.$body.removeClass('modal-open')
	      that.resetAdjustments()
	      that.resetScrollbar()
	      that.$element.trigger('hidden.bs.modal')
	    })
	  }

	  Modal.prototype.removeBackdrop = function () {
	    this.$backdrop && this.$backdrop.remove()
	    this.$backdrop = null
	  }

	  Modal.prototype.backdrop = function (callback) {
	    var that = this
	    var animate = this.$element.hasClass('fade') ? 'fade' : ''

	    if (this.isShown && this.options.backdrop) {
	      var doAnimate = $.support.transition && animate

	      this.$backdrop = $(document.createElement('div'))
	        .addClass('modal-backdrop ' + animate)
	        .appendTo(this.$body)

	      this.$element.on('click.dismiss.bs.modal', $.proxy(function (e) {
	        if (this.ignoreBackdropClick) {
	          this.ignoreBackdropClick = false
	          return
	        }
	        if (e.target !== e.currentTarget) return
	        this.options.backdrop == 'static'
	          ? this.$element[0].focus()
	          : this.hide()
	      }, this))

	      if (doAnimate) this.$backdrop[0].offsetWidth // force reflow

	      this.$backdrop.addClass('in')

	      if (!callback) return

	      doAnimate ?
	        this.$backdrop
	          .one('bsTransitionEnd', callback)
	          .emulateTransitionEnd(Modal.BACKDROP_TRANSITION_DURATION) :
	        callback()

	    } else if (!this.isShown && this.$backdrop) {
	      this.$backdrop.removeClass('in')

	      var callbackRemove = function () {
	        that.removeBackdrop()
	        callback && callback()
	      }
	      $.support.transition && this.$element.hasClass('fade') ?
	        this.$backdrop
	          .one('bsTransitionEnd', callbackRemove)
	          .emulateTransitionEnd(Modal.BACKDROP_TRANSITION_DURATION) :
	        callbackRemove()

	    } else if (callback) {
	      callback()
	    }
	  }

	  // these following methods are used to handle overflowing modals

	  Modal.prototype.handleUpdate = function () {
	    this.adjustDialog()
	  }

	  Modal.prototype.adjustDialog = function () {
	    var modalIsOverflowing = this.$element[0].scrollHeight > document.documentElement.clientHeight

	    this.$element.css({
	      paddingLeft: !this.bodyIsOverflowing && modalIsOverflowing ? this.scrollbarWidth : '',
	      paddingRight: this.bodyIsOverflowing && !modalIsOverflowing ? this.scrollbarWidth : ''
	    })
	  }

	  Modal.prototype.resetAdjustments = function () {
	    this.$element.css({
	      paddingLeft: '',
	      paddingRight: ''
	    })
	  }

	  Modal.prototype.checkScrollbar = function () {
	    var fullWindowWidth = window.innerWidth
	    if (!fullWindowWidth) { // workaround for missing window.innerWidth in IE8
	      var documentElementRect = document.documentElement.getBoundingClientRect()
	      fullWindowWidth = documentElementRect.right - Math.abs(documentElementRect.left)
	    }
	    this.bodyIsOverflowing = document.body.clientWidth < fullWindowWidth
	    this.scrollbarWidth = this.measureScrollbar()
	  }

	  Modal.prototype.setScrollbar = function () {
	    var bodyPad = parseInt((this.$body.css('padding-right') || 0), 10)
	    this.originalBodyPad = document.body.style.paddingRight || ''
	    var scrollbarWidth = this.scrollbarWidth
	    if (this.bodyIsOverflowing) {
	      this.$body.css('padding-right', bodyPad + scrollbarWidth)
	      $(this.fixedContent).each(function (index, element) {
	        var actualPadding = element.style.paddingRight
	        var calculatedPadding = $(element).css('padding-right')
	        $(element)
	          .data('padding-right', actualPadding)
	          .css('padding-right', parseFloat(calculatedPadding) + scrollbarWidth + 'px')
	      })
	    }
	  }

	  Modal.prototype.resetScrollbar = function () {
	    this.$body.css('padding-right', this.originalBodyPad)
	    $(this.fixedContent).each(function (index, element) {
	      var padding = $(element).data('padding-right')
	      $(element).removeData('padding-right')
	      element.style.paddingRight = padding ? padding : ''
	    })
	  }

	  Modal.prototype.measureScrollbar = function () { // thx walsh
	    var scrollDiv = document.createElement('div')
	    scrollDiv.className = 'modal-scrollbar-measure'
	    this.$body.append(scrollDiv)
	    var scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth
	    this.$body[0].removeChild(scrollDiv)
	    return scrollbarWidth
	  }


	  // MODAL PLUGIN DEFINITION
	  // =======================

	  function Plugin(option, _relatedTarget) {
	    return this.each(function () {
	      var $this = $(this)
	      var data = $this.data('bs.modal')
	      var options = $.extend({}, Modal.DEFAULTS, $this.data(), typeof option == 'object' && option)

	      if (!data) $this.data('bs.modal', (data = new Modal(this, options)))
	      if (typeof option == 'string') data[option](_relatedTarget)
	      else if (options.show) data.show(_relatedTarget)
	    })
	  }

	  var old = $.fn.modal

	  $.fn.modal = Plugin
	  $.fn.modal.Constructor = Modal


	  // MODAL NO CONFLICT
	  // =================

	  $.fn.modal.noConflict = function () {
	    $.fn.modal = old
	    return this
	  }


	  // MODAL DATA-API
	  // ==============

	  $(document).on('click.bs.modal.data-api', '[data-toggle="modal"]', function (e) {
	    var $this = $(this)
	    var href = $this.attr('href')
	    var target = $this.attr('data-target') ||
	      (href && href.replace(/.*(?=#[^\s]+$)/, '')) // strip for ie7

	    var $target = $(document).find(target)
	    var option = $target.data('bs.modal') ? 'toggle' : $.extend({ remote: !/#/.test(href) && href }, $target.data(), $this.data())

	    if ($this.is('a')) e.preventDefault()

	    $target.one('show.bs.modal', function (showEvent) {
	      if (showEvent.isDefaultPrevented()) return // only register focus restorer if modal will actually get shown
	      $target.one('hidden.bs.modal', function () {
	        $this.is(':visible') && $this.trigger('focus')
	      })
	    })
	    Plugin.call($target, option, this)
	  })

	}(jQuery);

	/* ========================================================================
	 * Bootstrap: tooltip.js v3.4.1
	 * https://getbootstrap.com/docs/3.4/javascript/#tooltip
	 * Inspired by the original jQuery.tipsy by Jason Frame
	 * ========================================================================
	 * Copyright 2011-2019 Twitter, Inc.
	 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
	 * ======================================================================== */

	+function ($) {
	  'use strict';

	  var DISALLOWED_ATTRIBUTES = ['sanitize', 'whiteList', 'sanitizeFn']

	  var uriAttrs = [
	    'background',
	    'cite',
	    'href',
	    'itemtype',
	    'longdesc',
	    'poster',
	    'src',
	    'xlink:href'
	  ]

	  var ARIA_ATTRIBUTE_PATTERN = /^aria-[\w-]*$/i

	  var DefaultWhitelist = {
	    // Global attributes allowed on any supplied element below.
	    '*': ['class', 'dir', 'id', 'lang', 'role', ARIA_ATTRIBUTE_PATTERN],
	    a: ['target', 'href', 'title', 'rel'],
	    area: [],
	    b: [],
	    br: [],
	    col: [],
	    code: [],
	    div: [],
	    em: [],
	    hr: [],
	    h1: [],
	    h2: [],
	    h3: [],
	    h4: [],
	    h5: [],
	    h6: [],
	    i: [],
	    img: ['src', 'alt', 'title', 'width', 'height'],
	    li: [],
	    ol: [],
	    p: [],
	    pre: [],
	    s: [],
	    small: [],
	    span: [],
	    sub: [],
	    sup: [],
	    strong: [],
	    u: [],
	    ul: []
	  }

	  /**
	   * A pattern that recognizes a commonly useful subset of URLs that are safe.
	   *
	   * Shoutout to Angular 7 https://github.com/angular/angular/blob/7.2.4/packages/core/src/sanitization/url_sanitizer.ts
	   */
	  var SAFE_URL_PATTERN = /^(?:(?:https?|mailto|ftp|tel|file):|[^&:/?#]*(?:[/?#]|$))/gi

	  /**
	   * A pattern that matches safe data URLs. Only matches image, video and audio types.
	   *
	   * Shoutout to Angular 7 https://github.com/angular/angular/blob/7.2.4/packages/core/src/sanitization/url_sanitizer.ts
	   */
	  var DATA_URL_PATTERN = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[a-z0-9+/]+=*$/i

	  function allowedAttribute(attr, allowedAttributeList) {
	    var attrName = attr.nodeName.toLowerCase()

	    if ($.inArray(attrName, allowedAttributeList) !== -1) {
	      if ($.inArray(attrName, uriAttrs) !== -1) {
	        return Boolean(attr.nodeValue.match(SAFE_URL_PATTERN) || attr.nodeValue.match(DATA_URL_PATTERN))
	      }

	      return true
	    }

	    var regExp = $(allowedAttributeList).filter(function (index, value) {
	      return value instanceof RegExp
	    })

	    // Check if a regular expression validates the attribute.
	    for (var i = 0, l = regExp.length; i < l; i++) {
	      if (attrName.match(regExp[i])) {
	        return true
	      }
	    }

	    return false
	  }

	  function sanitizeHtml(unsafeHtml, whiteList, sanitizeFn) {
	    if (unsafeHtml.length === 0) {
	      return unsafeHtml
	    }

	    if (sanitizeFn && typeof sanitizeFn === 'function') {
	      return sanitizeFn(unsafeHtml)
	    }

	    // IE 8 and below don't support createHTMLDocument
	    if (!document.implementation || !document.implementation.createHTMLDocument) {
	      return unsafeHtml
	    }

	    var createdDocument = document.implementation.createHTMLDocument('sanitization')
	    createdDocument.body.innerHTML = unsafeHtml

	    var whitelistKeys = $.map(whiteList, function (el, i) { return i })
	    var elements = $(createdDocument.body).find('*')

	    for (var i = 0, len = elements.length; i < len; i++) {
	      var el = elements[i]
	      var elName = el.nodeName.toLowerCase()

	      if ($.inArray(elName, whitelistKeys) === -1) {
	        el.parentNode.removeChild(el)

	        continue
	      }

	      var attributeList = $.map(el.attributes, function (el) { return el })
	      var whitelistedAttributes = [].concat(whiteList['*'] || [], whiteList[elName] || [])

	      for (var j = 0, len2 = attributeList.length; j < len2; j++) {
	        if (!allowedAttribute(attributeList[j], whitelistedAttributes)) {
	          el.removeAttribute(attributeList[j].nodeName)
	        }
	      }
	    }

	    return createdDocument.body.innerHTML
	  }

	  // TOOLTIP PUBLIC CLASS DEFINITION
	  // ===============================

	  var Tooltip = function (element, options) {
	    this.type       = null
	    this.options    = null
	    this.enabled    = null
	    this.timeout    = null
	    this.hoverState = null
	    this.$element   = null
	    this.inState    = null

	    this.init('tooltip', element, options)
	  }

	  Tooltip.VERSION  = '3.4.1'

	  Tooltip.TRANSITION_DURATION = 150

	  Tooltip.DEFAULTS = {
	    animation: true,
	    placement: 'top',
	    selector: false,
	    template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
	    trigger: 'hover focus',
	    title: '',
	    delay: 0,
	    html: false,
	    container: false,
	    viewport: {
	      selector: 'body',
	      padding: 0
	    },
	    sanitize : true,
	    sanitizeFn : null,
	    whiteList : DefaultWhitelist
	  }

	  Tooltip.prototype.init = function (type, element, options) {
	    this.enabled   = true
	    this.type      = type
	    this.$element  = $(element)
	    this.options   = this.getOptions(options)
	    this.$viewport = this.options.viewport && $(document).find($.isFunction(this.options.viewport) ? this.options.viewport.call(this, this.$element) : (this.options.viewport.selector || this.options.viewport))
	    this.inState   = { click: false, hover: false, focus: false }

	    if (this.$element[0] instanceof document.constructor && !this.options.selector) {
	      throw new Error('`selector` option must be specified when initializing ' + this.type + ' on the window.document object!')
	    }

	    var triggers = this.options.trigger.split(' ')

	    for (var i = triggers.length; i--;) {
	      var trigger = triggers[i]

	      if (trigger == 'click') {
	        this.$element.on('click.' + this.type, this.options.selector, $.proxy(this.toggle, this))
	      } else if (trigger != 'manual') {
	        var eventIn  = trigger == 'hover' ? 'mouseenter' : 'focusin'
	        var eventOut = trigger == 'hover' ? 'mouseleave' : 'focusout'

	        this.$element.on(eventIn  + '.' + this.type, this.options.selector, $.proxy(this.enter, this))
	        this.$element.on(eventOut + '.' + this.type, this.options.selector, $.proxy(this.leave, this))
	      }
	    }

	    this.options.selector ?
	      (this._options = $.extend({}, this.options, { trigger: 'manual', selector: '' })) :
	      this.fixTitle()
	  }

	  Tooltip.prototype.getDefaults = function () {
	    return Tooltip.DEFAULTS
	  }

	  Tooltip.prototype.getOptions = function (options) {
	    var dataAttributes = this.$element.data()

	    for (var dataAttr in dataAttributes) {
	      if (dataAttributes.hasOwnProperty(dataAttr) && $.inArray(dataAttr, DISALLOWED_ATTRIBUTES) !== -1) {
	        delete dataAttributes[dataAttr]
	      }
	    }

	    options = $.extend({}, this.getDefaults(), dataAttributes, options)

	    if (options.delay && typeof options.delay == 'number') {
	      options.delay = {
	        show: options.delay,
	        hide: options.delay
	      }
	    }

	    if (options.sanitize) {
	      options.template = sanitizeHtml(options.template, options.whiteList, options.sanitizeFn)
	    }

	    return options
	  }

	  Tooltip.prototype.getDelegateOptions = function () {
	    var options  = {}
	    var defaults = this.getDefaults()

	    this._options && $.each(this._options, function (key, value) {
	      if (defaults[key] != value) options[key] = value
	    })

	    return options
	  }

	  Tooltip.prototype.enter = function (obj) {
	    var self = obj instanceof this.constructor ?
	      obj : $(obj.currentTarget).data('bs.' + this.type)

	    if (!self) {
	      self = new this.constructor(obj.currentTarget, this.getDelegateOptions())
	      $(obj.currentTarget).data('bs.' + this.type, self)
	    }

	    if (obj instanceof $.Event) {
	      self.inState[obj.type == 'focusin' ? 'focus' : 'hover'] = true
	    }

	    if (self.tip().hasClass('in') || self.hoverState == 'in') {
	      self.hoverState = 'in'
	      return
	    }

	    clearTimeout(self.timeout)

	    self.hoverState = 'in'

	    if (!self.options.delay || !self.options.delay.show) return self.show()

	    self.timeout = setTimeout(function () {
	      if (self.hoverState == 'in') self.show()
	    }, self.options.delay.show)
	  }

	  Tooltip.prototype.isInStateTrue = function () {
	    for (var key in this.inState) {
	      if (this.inState[key]) return true
	    }

	    return false
	  }

	  Tooltip.prototype.leave = function (obj) {
	    var self = obj instanceof this.constructor ?
	      obj : $(obj.currentTarget).data('bs.' + this.type)

	    if (!self) {
	      self = new this.constructor(obj.currentTarget, this.getDelegateOptions())
	      $(obj.currentTarget).data('bs.' + this.type, self)
	    }

	    if (obj instanceof $.Event) {
	      self.inState[obj.type == 'focusout' ? 'focus' : 'hover'] = false
	    }

	    if (self.isInStateTrue()) return

	    clearTimeout(self.timeout)

	    self.hoverState = 'out'

	    if (!self.options.delay || !self.options.delay.hide) return self.hide()

	    self.timeout = setTimeout(function () {
	      if (self.hoverState == 'out') self.hide()
	    }, self.options.delay.hide)
	  }

	  Tooltip.prototype.show = function () {
	    var e = $.Event('show.bs.' + this.type)

	    if (this.hasContent() && this.enabled) {
	      this.$element.trigger(e)

	      var inDom = $.contains(this.$element[0].ownerDocument.documentElement, this.$element[0])
	      if (e.isDefaultPrevented() || !inDom) return
	      var that = this

	      var $tip = this.tip()

	      var tipId = this.getUID(this.type)

	      this.setContent()
	      $tip.attr('id', tipId)
	      this.$element.attr('aria-describedby', tipId)

	      if (this.options.animation) $tip.addClass('fade')

	      var placement = typeof this.options.placement == 'function' ?
	        this.options.placement.call(this, $tip[0], this.$element[0]) :
	        this.options.placement

	      var autoToken = /\s?auto?\s?/i
	      var autoPlace = autoToken.test(placement)
	      if (autoPlace) placement = placement.replace(autoToken, '') || 'top'

	      $tip
	        .detach()
	        .css({ top: 0, left: 0, display: 'block' })
	        .addClass(placement)
	        .data('bs.' + this.type, this)

	      this.options.container ? $tip.appendTo($(document).find(this.options.container)) : $tip.insertAfter(this.$element)
	      this.$element.trigger('inserted.bs.' + this.type)

	      var pos          = this.getPosition()
	      var actualWidth  = $tip[0].offsetWidth
	      var actualHeight = $tip[0].offsetHeight

	      if (autoPlace) {
	        var orgPlacement = placement
	        var viewportDim = this.getPosition(this.$viewport)

	        placement = placement == 'bottom' && pos.bottom + actualHeight > viewportDim.bottom ? 'top'    :
	                    placement == 'top'    && pos.top    - actualHeight < viewportDim.top    ? 'bottom' :
	                    placement == 'right'  && pos.right  + actualWidth  > viewportDim.width  ? 'left'   :
	                    placement == 'left'   && pos.left   - actualWidth  < viewportDim.left   ? 'right'  :
	                    placement

	        $tip
	          .removeClass(orgPlacement)
	          .addClass(placement)
	      }

	      var calculatedOffset = this.getCalculatedOffset(placement, pos, actualWidth, actualHeight)

	      this.applyPlacement(calculatedOffset, placement)

	      var complete = function () {
	        var prevHoverState = that.hoverState
	        that.$element.trigger('shown.bs.' + that.type)
	        that.hoverState = null

	        if (prevHoverState == 'out') that.leave(that)
	      }

	      $.support.transition && this.$tip.hasClass('fade') ?
	        $tip
	          .one('bsTransitionEnd', complete)
	          .emulateTransitionEnd(Tooltip.TRANSITION_DURATION) :
	        complete()
	    }
	  }

	  Tooltip.prototype.applyPlacement = function (offset, placement) {
	    var $tip   = this.tip()
	    var width  = $tip[0].offsetWidth
	    var height = $tip[0].offsetHeight

	    // manually read margins because getBoundingClientRect includes difference
	    var marginTop = parseInt($tip.css('margin-top'), 10)
	    var marginLeft = parseInt($tip.css('margin-left'), 10)

	    // we must check for NaN for ie 8/9
	    if (isNaN(marginTop))  marginTop  = 0
	    if (isNaN(marginLeft)) marginLeft = 0

	    offset.top  += marginTop
	    offset.left += marginLeft

	    // $.fn.offset doesn't round pixel values
	    // so we use setOffset directly with our own function B-0
	    $.offset.setOffset($tip[0], $.extend({
	      using: function (props) {
	        $tip.css({
	          top: Math.round(props.top),
	          left: Math.round(props.left)
	        })
	      }
	    }, offset), 0)

	    $tip.addClass('in')

	    // check to see if placing tip in new offset caused the tip to resize itself
	    var actualWidth  = $tip[0].offsetWidth
	    var actualHeight = $tip[0].offsetHeight

	    if (placement == 'top' && actualHeight != height) {
	      offset.top = offset.top + height - actualHeight
	    }

	    var delta = this.getViewportAdjustedDelta(placement, offset, actualWidth, actualHeight)

	    if (delta.left) offset.left += delta.left
	    else offset.top += delta.top

	    var isVertical          = /top|bottom/.test(placement)
	    var arrowDelta          = isVertical ? delta.left * 2 - width + actualWidth : delta.top * 2 - height + actualHeight
	    var arrowOffsetPosition = isVertical ? 'offsetWidth' : 'offsetHeight'

	    $tip.offset(offset)
	    this.replaceArrow(arrowDelta, $tip[0][arrowOffsetPosition], isVertical)
	  }

	  Tooltip.prototype.replaceArrow = function (delta, dimension, isVertical) {
	    this.arrow()
	      .css(isVertical ? 'left' : 'top', 50 * (1 - delta / dimension) + '%')
	      .css(isVertical ? 'top' : 'left', '')
	  }

	  Tooltip.prototype.setContent = function () {
	    var $tip  = this.tip()
	    var title = this.getTitle()

	    if (this.options.html) {
	      if (this.options.sanitize) {
	        title = sanitizeHtml(title, this.options.whiteList, this.options.sanitizeFn)
	      }

	      $tip.find('.tooltip-inner').html(title)
	    } else {
	      $tip.find('.tooltip-inner').text(title)
	    }

	    $tip.removeClass('fade in top bottom left right')
	  }

	  Tooltip.prototype.hide = function (callback) {
	    var that = this
	    var $tip = $(this.$tip)
	    var e    = $.Event('hide.bs.' + this.type)

	    function complete() {
	      if (that.hoverState != 'in') $tip.detach()
	      if (that.$element) { // TODO: Check whether guarding this code with this `if` is really necessary.
	        that.$element
	          .removeAttr('aria-describedby')
	          .trigger('hidden.bs.' + that.type)
	      }
	      callback && callback()
	    }

	    this.$element.trigger(e)

	    if (e.isDefaultPrevented()) return

	    $tip.removeClass('in')

	    $.support.transition && $tip.hasClass('fade') ?
	      $tip
	        .one('bsTransitionEnd', complete)
	        .emulateTransitionEnd(Tooltip.TRANSITION_DURATION) :
	      complete()

	    this.hoverState = null

	    return this
	  }

	  Tooltip.prototype.fixTitle = function () {
	    var $e = this.$element
	    if ($e.attr('title') || typeof $e.attr('data-original-title') != 'string') {
	      $e.attr('data-original-title', $e.attr('title') || '').attr('title', '')
	    }
	  }

	  Tooltip.prototype.hasContent = function () {
	    return this.getTitle()
	  }

	  Tooltip.prototype.getPosition = function ($element) {
	    $element   = $element || this.$element

	    var el     = $element[0]
	    var isBody = el.tagName == 'BODY'

	    var elRect    = el.getBoundingClientRect()
	    if (elRect.width == null) {
	      // width and height are missing in IE8, so compute them manually; see https://github.com/twbs/bootstrap/issues/14093
	      elRect = $.extend({}, elRect, { width: elRect.right - elRect.left, height: elRect.bottom - elRect.top })
	    }
	    var isSvg = window.SVGElement && el instanceof window.SVGElement
	    // Avoid using $.offset() on SVGs since it gives incorrect results in jQuery 3.
	    // See https://github.com/twbs/bootstrap/issues/20280
	    var elOffset  = isBody ? { top: 0, left: 0 } : (isSvg ? null : $element.offset())
	    var scroll    = { scroll: isBody ? document.documentElement.scrollTop || document.body.scrollTop : $element.scrollTop() }
	    var outerDims = isBody ? { width: $(window).width(), height: $(window).height() } : null

	    return $.extend({}, elRect, scroll, outerDims, elOffset)
	  }

	  Tooltip.prototype.getCalculatedOffset = function (placement, pos, actualWidth, actualHeight) {
	    return placement == 'bottom' ? { top: pos.top + pos.height,   left: pos.left + pos.width / 2 - actualWidth / 2 } :
	           placement == 'top'    ? { top: pos.top - actualHeight, left: pos.left + pos.width / 2 - actualWidth / 2 } :
	           placement == 'left'   ? { top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left - actualWidth } :
	        /* placement == 'right' */ { top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left + pos.width }

	  }

	  Tooltip.prototype.getViewportAdjustedDelta = function (placement, pos, actualWidth, actualHeight) {
	    var delta = { top: 0, left: 0 }
	    if (!this.$viewport) return delta

	    var viewportPadding = this.options.viewport && this.options.viewport.padding || 0
	    var viewportDimensions = this.getPosition(this.$viewport)

	    if (/right|left/.test(placement)) {
	      var topEdgeOffset    = pos.top - viewportPadding - viewportDimensions.scroll
	      var bottomEdgeOffset = pos.top + viewportPadding - viewportDimensions.scroll + actualHeight
	      if (topEdgeOffset < viewportDimensions.top) { // top overflow
	        delta.top = viewportDimensions.top - topEdgeOffset
	      } else if (bottomEdgeOffset > viewportDimensions.top + viewportDimensions.height) { // bottom overflow
	        delta.top = viewportDimensions.top + viewportDimensions.height - bottomEdgeOffset
	      }
	    } else {
	      var leftEdgeOffset  = pos.left - viewportPadding
	      var rightEdgeOffset = pos.left + viewportPadding + actualWidth
	      if (leftEdgeOffset < viewportDimensions.left) { // left overflow
	        delta.left = viewportDimensions.left - leftEdgeOffset
	      } else if (rightEdgeOffset > viewportDimensions.right) { // right overflow
	        delta.left = viewportDimensions.left + viewportDimensions.width - rightEdgeOffset
	      }
	    }

	    return delta
	  }

	  Tooltip.prototype.getTitle = function () {
	    var title
	    var $e = this.$element
	    var o  = this.options

	    title = $e.attr('data-original-title')
	      || (typeof o.title == 'function' ? o.title.call($e[0]) :  o.title)

	    return title
	  }

	  Tooltip.prototype.getUID = function (prefix) {
	    do prefix += ~~(Math.random() * 1000000)
	    while (document.getElementById(prefix))
	    return prefix
	  }

	  Tooltip.prototype.tip = function () {
	    if (!this.$tip) {
	      this.$tip = $(this.options.template)
	      if (this.$tip.length != 1) {
	        throw new Error(this.type + ' `template` option must consist of exactly 1 top-level element!')
	      }
	    }
	    return this.$tip
	  }

	  Tooltip.prototype.arrow = function () {
	    return (this.$arrow = this.$arrow || this.tip().find('.tooltip-arrow'))
	  }

	  Tooltip.prototype.enable = function () {
	    this.enabled = true
	  }

	  Tooltip.prototype.disable = function () {
	    this.enabled = false
	  }

	  Tooltip.prototype.toggleEnabled = function () {
	    this.enabled = !this.enabled
	  }

	  Tooltip.prototype.toggle = function (e) {
	    var self = this
	    if (e) {
	      self = $(e.currentTarget).data('bs.' + this.type)
	      if (!self) {
	        self = new this.constructor(e.currentTarget, this.getDelegateOptions())
	        $(e.currentTarget).data('bs.' + this.type, self)
	      }
	    }

	    if (e) {
	      self.inState.click = !self.inState.click
	      if (self.isInStateTrue()) self.enter(self)
	      else self.leave(self)
	    } else {
	      self.tip().hasClass('in') ? self.leave(self) : self.enter(self)
	    }
	  }

	  Tooltip.prototype.destroy = function () {
	    var that = this
	    clearTimeout(this.timeout)
	    this.hide(function () {
	      that.$element.off('.' + that.type).removeData('bs.' + that.type)
	      if (that.$tip) {
	        that.$tip.detach()
	      }
	      that.$tip = null
	      that.$arrow = null
	      that.$viewport = null
	      that.$element = null
	    })
	  }

	  Tooltip.prototype.sanitizeHtml = function (unsafeHtml) {
	    return sanitizeHtml(unsafeHtml, this.options.whiteList, this.options.sanitizeFn)
	  }

	  // TOOLTIP PLUGIN DEFINITION
	  // =========================

	  function Plugin(option) {
	    return this.each(function () {
	      var $this   = $(this)
	      var data    = $this.data('bs.tooltip')
	      var options = typeof option == 'object' && option

	      if (!data && /destroy|hide/.test(option)) return
	      if (!data) $this.data('bs.tooltip', (data = new Tooltip(this, options)))
	      if (typeof option == 'string') data[option]()
	    })
	  }

	  var old = $.fn.tooltip

	  $.fn.tooltip             = Plugin
	  $.fn.tooltip.Constructor = Tooltip


	  // TOOLTIP NO CONFLICT
	  // ===================

	  $.fn.tooltip.noConflict = function () {
	    $.fn.tooltip = old
	    return this
	  }

	}(jQuery);

	/* ========================================================================
	 * Bootstrap: popover.js v3.4.1
	 * https://getbootstrap.com/docs/3.4/javascript/#popovers
	 * ========================================================================
	 * Copyright 2011-2019 Twitter, Inc.
	 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
	 * ======================================================================== */


	+function ($) {
	  'use strict';

	  // POPOVER PUBLIC CLASS DEFINITION
	  // ===============================

	  var Popover = function (element, options) {
	    this.init('popover', element, options)
	  }

	  if (!$.fn.tooltip) throw new Error('Popover requires tooltip.js')

	  Popover.VERSION  = '3.4.1'

	  Popover.DEFAULTS = $.extend({}, $.fn.tooltip.Constructor.DEFAULTS, {
	    placement: 'right',
	    trigger: 'click',
	    content: '',
	    template: '<div class="popover" role="tooltip"><div class="arrow"></div><h3 class="popover-title"></h3><div class="popover-content"></div></div>'
	  })


	  // NOTE: POPOVER EXTENDS tooltip.js
	  // ================================

	  Popover.prototype = $.extend({}, $.fn.tooltip.Constructor.prototype)

	  Popover.prototype.constructor = Popover

	  Popover.prototype.getDefaults = function () {
	    return Popover.DEFAULTS
	  }

	  Popover.prototype.setContent = function () {
	    var $tip    = this.tip()
	    var title   = this.getTitle()
	    var content = this.getContent()

	    if (this.options.html) {
	      var typeContent = typeof content

	      if (this.options.sanitize) {
	        title = this.sanitizeHtml(title)

	        if (typeContent === 'string') {
	          content = this.sanitizeHtml(content)
	        }
	      }

	      $tip.find('.popover-title').html(title)
	      $tip.find('.popover-content').children().detach().end()[
	        typeContent === 'string' ? 'html' : 'append'
	      ](content)
	    } else {
	      $tip.find('.popover-title').text(title)
	      $tip.find('.popover-content').children().detach().end().text(content)
	    }

	    $tip.removeClass('fade top bottom left right in')

	    // IE8 doesn't accept hiding via the `:empty` pseudo selector, we have to do
	    // this manually by checking the contents.
	    if (!$tip.find('.popover-title').html()) $tip.find('.popover-title').hide()
	  }

	  Popover.prototype.hasContent = function () {
	    return this.getTitle() || this.getContent()
	  }

	  Popover.prototype.getContent = function () {
	    var $e = this.$element
	    var o  = this.options

	    return $e.attr('data-content')
	      || (typeof o.content == 'function' ?
	        o.content.call($e[0]) :
	        o.content)
	  }

	  Popover.prototype.arrow = function () {
	    return (this.$arrow = this.$arrow || this.tip().find('.arrow'))
	  }


	  // POPOVER PLUGIN DEFINITION
	  // =========================

	  function Plugin(option) {
	    return this.each(function () {
	      var $this   = $(this)
	      var data    = $this.data('bs.popover')
	      var options = typeof option == 'object' && option

	      if (!data && /destroy|hide/.test(option)) return
	      if (!data) $this.data('bs.popover', (data = new Popover(this, options)))
	      if (typeof option == 'string') data[option]()
	    })
	  }

	  var old = $.fn.popover

	  $.fn.popover             = Plugin
	  $.fn.popover.Constructor = Popover


	  // POPOVER NO CONFLICT
	  // ===================

	  $.fn.popover.noConflict = function () {
	    $.fn.popover = old
	    return this
	  }

	}(jQuery);

	/* ========================================================================
	 * Bootstrap: scrollspy.js v3.4.1
	 * https://getbootstrap.com/docs/3.4/javascript/#scrollspy
	 * ========================================================================
	 * Copyright 2011-2019 Twitter, Inc.
	 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
	 * ======================================================================== */


	+function ($) {
	  'use strict';

	  // SCROLLSPY CLASS DEFINITION
	  // ==========================

	  function ScrollSpy(element, options) {
	    this.$body          = $(document.body)
	    this.$scrollElement = $(element).is(document.body) ? $(window) : $(element)
	    this.options        = $.extend({}, ScrollSpy.DEFAULTS, options)
	    this.selector       = (this.options.target || '') + ' .nav li > a'
	    this.offsets        = []
	    this.targets        = []
	    this.activeTarget   = null
	    this.scrollHeight   = 0

	    this.$scrollElement.on('scroll.bs.scrollspy', $.proxy(this.process, this))
	    this.refresh()
	    this.process()
	  }

	  ScrollSpy.VERSION  = '3.4.1'

	  ScrollSpy.DEFAULTS = {
	    offset: 10
	  }

	  ScrollSpy.prototype.getScrollHeight = function () {
	    return this.$scrollElement[0].scrollHeight || Math.max(this.$body[0].scrollHeight, document.documentElement.scrollHeight)
	  }

	  ScrollSpy.prototype.refresh = function () {
	    var that          = this
	    var offsetMethod  = 'offset'
	    var offsetBase    = 0

	    this.offsets      = []
	    this.targets      = []
	    this.scrollHeight = this.getScrollHeight()

	    if (!$.isWindow(this.$scrollElement[0])) {
	      offsetMethod = 'position'
	      offsetBase   = this.$scrollElement.scrollTop()
	    }

	    this.$body
	      .find(this.selector)
	      .map(function () {
	        var $el   = $(this)
	        var href  = $el.data('target') || $el.attr('href')
	        var $href = /^#./.test(href) && $(href)

	        return ($href
	          && $href.length
	          && $href.is(':visible')
	          && [[$href[offsetMethod]().top + offsetBase, href]]) || null
	      })
	      .sort(function (a, b) { return a[0] - b[0] })
	      .each(function () {
	        that.offsets.push(this[0])
	        that.targets.push(this[1])
	      })
	  }

	  ScrollSpy.prototype.process = function () {
	    var scrollTop    = this.$scrollElement.scrollTop() + this.options.offset
	    var scrollHeight = this.getScrollHeight()
	    var maxScroll    = this.options.offset + scrollHeight - this.$scrollElement.height()
	    var offsets      = this.offsets
	    var targets      = this.targets
	    var activeTarget = this.activeTarget
	    var i

	    if (this.scrollHeight != scrollHeight) {
	      this.refresh()
	    }

	    if (scrollTop >= maxScroll) {
	      return activeTarget != (i = targets[targets.length - 1]) && this.activate(i)
	    }

	    if (activeTarget && scrollTop < offsets[0]) {
	      this.activeTarget = null
	      return this.clear()
	    }

	    for (i = offsets.length; i--;) {
	      activeTarget != targets[i]
	        && scrollTop >= offsets[i]
	        && (offsets[i + 1] === undefined || scrollTop < offsets[i + 1])
	        && this.activate(targets[i])
	    }
	  }

	  ScrollSpy.prototype.activate = function (target) {
	    this.activeTarget = target

	    this.clear()

	    var selector = this.selector +
	      '[data-target="' + target + '"],' +
	      this.selector + '[href="' + target + '"]'

	    var active = $(selector)
	      .parents('li')
	      .addClass('active')

	    if (active.parent('.dropdown-menu').length) {
	      active = active
	        .closest('li.dropdown')
	        .addClass('active')
	    }

	    active.trigger('activate.bs.scrollspy')
	  }

	  ScrollSpy.prototype.clear = function () {
	    $(this.selector)
	      .parentsUntil(this.options.target, '.active')
	      .removeClass('active')
	  }


	  // SCROLLSPY PLUGIN DEFINITION
	  // ===========================

	  function Plugin(option) {
	    return this.each(function () {
	      var $this   = $(this)
	      var data    = $this.data('bs.scrollspy')
	      var options = typeof option == 'object' && option

	      if (!data) $this.data('bs.scrollspy', (data = new ScrollSpy(this, options)))
	      if (typeof option == 'string') data[option]()
	    })
	  }

	  var old = $.fn.scrollspy

	  $.fn.scrollspy             = Plugin
	  $.fn.scrollspy.Constructor = ScrollSpy


	  // SCROLLSPY NO CONFLICT
	  // =====================

	  $.fn.scrollspy.noConflict = function () {
	    $.fn.scrollspy = old
	    return this
	  }


	  // SCROLLSPY DATA-API
	  // ==================

	  $(window).on('load.bs.scrollspy.data-api', function () {
	    $('[data-spy="scroll"]').each(function () {
	      var $spy = $(this)
	      Plugin.call($spy, $spy.data())
	    })
	  })

	}(jQuery);

	/* ========================================================================
	 * Bootstrap: tab.js v3.4.1
	 * https://getbootstrap.com/docs/3.4/javascript/#tabs
	 * ========================================================================
	 * Copyright 2011-2019 Twitter, Inc.
	 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
	 * ======================================================================== */


	+function ($) {
	  'use strict';

	  // TAB CLASS DEFINITION
	  // ====================

	  var Tab = function (element) {
	    // jscs:disable requireDollarBeforejQueryAssignment
	    this.element = $(element)
	    // jscs:enable requireDollarBeforejQueryAssignment
	  }

	  Tab.VERSION = '3.4.1'

	  Tab.TRANSITION_DURATION = 150

	  Tab.prototype.show = function () {
	    var $this    = this.element
	    var $ul      = $this.closest('ul:not(.dropdown-menu)')
	    var selector = $this.data('target')

	    if (!selector) {
	      selector = $this.attr('href')
	      selector = selector && selector.replace(/.*(?=#[^\s]*$)/, '') // strip for ie7
	    }

	    if ($this.parent('li').hasClass('active')) return

	    var $previous = $ul.find('.active:last a')
	    var hideEvent = $.Event('hide.bs.tab', {
	      relatedTarget: $this[0]
	    })
	    var showEvent = $.Event('show.bs.tab', {
	      relatedTarget: $previous[0]
	    })

	    $previous.trigger(hideEvent)
	    $this.trigger(showEvent)

	    if (showEvent.isDefaultPrevented() || hideEvent.isDefaultPrevented()) return

	    var $target = $(document).find(selector)

	    this.activate($this.closest('li'), $ul)
	    this.activate($target, $target.parent(), function () {
	      $previous.trigger({
	        type: 'hidden.bs.tab',
	        relatedTarget: $this[0]
	      })
	      $this.trigger({
	        type: 'shown.bs.tab',
	        relatedTarget: $previous[0]
	      })
	    })
	  }

	  Tab.prototype.activate = function (element, container, callback) {
	    var $active    = container.find('> .active')
	    var transition = callback
	      && $.support.transition
	      && ($active.length && $active.hasClass('fade') || !!container.find('> .fade').length)

	    function next() {
	      $active
	        .removeClass('active')
	        .find('> .dropdown-menu > .active')
	        .removeClass('active')
	        .end()
	        .find('[data-toggle="tab"]')
	        .attr('aria-expanded', false)

	      element
	        .addClass('active')
	        .find('[data-toggle="tab"]')
	        .attr('aria-expanded', true)

	      if (transition) {
	        element[0].offsetWidth // reflow for transition
	        element.addClass('in')
	      } else {
	        element.removeClass('fade')
	      }

	      if (element.parent('.dropdown-menu').length) {
	        element
	          .closest('li.dropdown')
	          .addClass('active')
	          .end()
	          .find('[data-toggle="tab"]')
	          .attr('aria-expanded', true)
	      }

	      callback && callback()
	    }

	    $active.length && transition ?
	      $active
	        .one('bsTransitionEnd', next)
	        .emulateTransitionEnd(Tab.TRANSITION_DURATION) :
	      next()

	    $active.removeClass('in')
	  }


	  // TAB PLUGIN DEFINITION
	  // =====================

	  function Plugin(option) {
	    return this.each(function () {
	      var $this = $(this)
	      var data  = $this.data('bs.tab')

	      if (!data) $this.data('bs.tab', (data = new Tab(this)))
	      if (typeof option == 'string') data[option]()
	    })
	  }

	  var old = $.fn.tab

	  $.fn.tab             = Plugin
	  $.fn.tab.Constructor = Tab


	  // TAB NO CONFLICT
	  // ===============

	  $.fn.tab.noConflict = function () {
	    $.fn.tab = old
	    return this
	  }


	  // TAB DATA-API
	  // ============

	  var clickHandler = function (e) {
	    e.preventDefault()
	    Plugin.call($(this), 'show')
	  }

	  $(document)
	    .on('click.bs.tab.data-api', '[data-toggle="tab"]', clickHandler)
	    .on('click.bs.tab.data-api', '[data-toggle="pill"]', clickHandler)

	}(jQuery);

	/* ========================================================================
	 * Bootstrap: affix.js v3.4.1
	 * https://getbootstrap.com/docs/3.4/javascript/#affix
	 * ========================================================================
	 * Copyright 2011-2019 Twitter, Inc.
	 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
	 * ======================================================================== */


	+function ($) {
	  'use strict';

	  // AFFIX CLASS DEFINITION
	  // ======================

	  var Affix = function (element, options) {
	    this.options = $.extend({}, Affix.DEFAULTS, options)

	    var target = this.options.target === Affix.DEFAULTS.target ? $(this.options.target) : $(document).find(this.options.target)

	    this.$target = target
	      .on('scroll.bs.affix.data-api', $.proxy(this.checkPosition, this))
	      .on('click.bs.affix.data-api',  $.proxy(this.checkPositionWithEventLoop, this))

	    this.$element     = $(element)
	    this.affixed      = null
	    this.unpin        = null
	    this.pinnedOffset = null

	    this.checkPosition()
	  }

	  Affix.VERSION  = '3.4.1'

	  Affix.RESET    = 'affix affix-top affix-bottom'

	  Affix.DEFAULTS = {
	    offset: 0,
	    target: window
	  }

	  Affix.prototype.getState = function (scrollHeight, height, offsetTop, offsetBottom) {
	    var scrollTop    = this.$target.scrollTop()
	    var position     = this.$element.offset()
	    var targetHeight = this.$target.height()

	    if (offsetTop != null && this.affixed == 'top') return scrollTop < offsetTop ? 'top' : false

	    if (this.affixed == 'bottom') {
	      if (offsetTop != null) return (scrollTop + this.unpin <= position.top) ? false : 'bottom'
	      return (scrollTop + targetHeight <= scrollHeight - offsetBottom) ? false : 'bottom'
	    }

	    var initializing   = this.affixed == null
	    var colliderTop    = initializing ? scrollTop : position.top
	    var colliderHeight = initializing ? targetHeight : height

	    if (offsetTop != null && scrollTop <= offsetTop) return 'top'
	    if (offsetBottom != null && (colliderTop + colliderHeight >= scrollHeight - offsetBottom)) return 'bottom'

	    return false
	  }

	  Affix.prototype.getPinnedOffset = function () {
	    if (this.pinnedOffset) return this.pinnedOffset
	    this.$element.removeClass(Affix.RESET).addClass('affix')
	    var scrollTop = this.$target.scrollTop()
	    var position  = this.$element.offset()
	    return (this.pinnedOffset = position.top - scrollTop)
	  }

	  Affix.prototype.checkPositionWithEventLoop = function () {
	    setTimeout($.proxy(this.checkPosition, this), 1)
	  }

	  Affix.prototype.checkPosition = function () {
	    if (!this.$element.is(':visible')) return

	    var height       = this.$element.height()
	    var offset       = this.options.offset
	    var offsetTop    = offset.top
	    var offsetBottom = offset.bottom
	    var scrollHeight = Math.max($(document).height(), $(document.body).height())

	    if (typeof offset != 'object')         offsetBottom = offsetTop = offset
	    if (typeof offsetTop == 'function')    offsetTop    = offset.top(this.$element)
	    if (typeof offsetBottom == 'function') offsetBottom = offset.bottom(this.$element)

	    var affix = this.getState(scrollHeight, height, offsetTop, offsetBottom)

	    if (this.affixed != affix) {
	      if (this.unpin != null) this.$element.css('top', '')

	      var affixType = 'affix' + (affix ? '-' + affix : '')
	      var e         = $.Event(affixType + '.bs.affix')

	      this.$element.trigger(e)

	      if (e.isDefaultPrevented()) return

	      this.affixed = affix
	      this.unpin = affix == 'bottom' ? this.getPinnedOffset() : null

	      this.$element
	        .removeClass(Affix.RESET)
	        .addClass(affixType)
	        .trigger(affixType.replace('affix', 'affixed') + '.bs.affix')
	    }

	    if (affix == 'bottom') {
	      this.$element.offset({
	        top: scrollHeight - height - offsetBottom
	      })
	    }
	  }


	  // AFFIX PLUGIN DEFINITION
	  // =======================

	  function Plugin(option) {
	    return this.each(function () {
	      var $this   = $(this)
	      var data    = $this.data('bs.affix')
	      var options = typeof option == 'object' && option

	      if (!data) $this.data('bs.affix', (data = new Affix(this, options)))
	      if (typeof option == 'string') data[option]()
	    })
	  }

	  var old = $.fn.affix

	  $.fn.affix             = Plugin
	  $.fn.affix.Constructor = Affix


	  // AFFIX NO CONFLICT
	  // =================

	  $.fn.affix.noConflict = function () {
	    $.fn.affix = old
	    return this
	  }


	  // AFFIX DATA-API
	  // ==============

	  $(window).on('load', function () {
	    $('[data-spy="affix"]').each(function () {
	      var $spy = $(this)
	      var data = $spy.data()

	      data.offset = data.offset || {}

	      if (data.offsetBottom != null) data.offset.bottom = data.offsetBottom
	      if (data.offsetTop    != null) data.offset.top    = data.offsetTop

	      Plugin.call($spy, data)
	    })
	  })

	}(jQuery);


/***/ }),
/* 34 */
/***/ (function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * Datepicker for Bootstrap v1.8.0 (https://github.com/uxsolutions/bootstrap-datepicker)
	 *
	 * Licensed under the Apache License v2.0 (http://www.apache.org/licenses/LICENSE-2.0)
	 */

	!function(a){ true?!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(28)], __WEBPACK_AMD_DEFINE_FACTORY__ = (a), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)):a("object"==typeof exports?require("jquery"):jQuery)}(function(a,b){function c(){return new Date(Date.UTC.apply(Date,arguments))}function d(){var a=new Date;return c(a.getFullYear(),a.getMonth(),a.getDate())}function e(a,b){return a.getUTCFullYear()===b.getUTCFullYear()&&a.getUTCMonth()===b.getUTCMonth()&&a.getUTCDate()===b.getUTCDate()}function f(c,d){return function(){return d!==b&&a.fn.datepicker.deprecated(d),this[c].apply(this,arguments)}}function g(a){return a&&!isNaN(a.getTime())}function h(b,c){function d(a,b){return b.toLowerCase()}var e,f=a(b).data(),g={},h=new RegExp("^"+c.toLowerCase()+"([A-Z])");c=new RegExp("^"+c.toLowerCase());for(var i in f)c.test(i)&&(e=i.replace(h,d),g[e]=f[i]);return g}function i(b){var c={};if(q[b]||(b=b.split("-")[0],q[b])){var d=q[b];return a.each(p,function(a,b){b in d&&(c[b]=d[b])}),c}}var j=function(){var b={get:function(a){return this.slice(a)[0]},contains:function(a){for(var b=a&&a.valueOf(),c=0,d=this.length;c<d;c++)if(0<=this[c].valueOf()-b&&this[c].valueOf()-b<864e5)return c;return-1},remove:function(a){this.splice(a,1)},replace:function(b){b&&(a.isArray(b)||(b=[b]),this.clear(),this.push.apply(this,b))},clear:function(){this.length=0},copy:function(){var a=new j;return a.replace(this),a}};return function(){var c=[];return c.push.apply(c,arguments),a.extend(c,b),c}}(),k=function(b,c){a.data(b,"datepicker",this),this._process_options(c),this.dates=new j,this.viewDate=this.o.defaultViewDate,this.focusDate=null,this.element=a(b),this.isInput=this.element.is("input"),this.inputField=this.isInput?this.element:this.element.find("input"),this.component=!!this.element.hasClass("date")&&this.element.find(".add-on, .input-group-addon, .btn"),this.component&&0===this.component.length&&(this.component=!1),this.isInline=!this.component&&this.element.is("div"),this.picker=a(r.template),this._check_template(this.o.templates.leftArrow)&&this.picker.find(".prev").html(this.o.templates.leftArrow),this._check_template(this.o.templates.rightArrow)&&this.picker.find(".next").html(this.o.templates.rightArrow),this._buildEvents(),this._attachEvents(),this.isInline?this.picker.addClass("datepicker-inline").appendTo(this.element):this.picker.addClass("datepicker-dropdown dropdown-menu"),this.o.rtl&&this.picker.addClass("datepicker-rtl"),this.o.calendarWeeks&&this.picker.find(".datepicker-days .datepicker-switch, thead .datepicker-title, tfoot .today, tfoot .clear").attr("colspan",function(a,b){return Number(b)+1}),this._process_options({startDate:this._o.startDate,endDate:this._o.endDate,daysOfWeekDisabled:this.o.daysOfWeekDisabled,daysOfWeekHighlighted:this.o.daysOfWeekHighlighted,datesDisabled:this.o.datesDisabled}),this._allow_update=!1,this.setViewMode(this.o.startView),this._allow_update=!0,this.fillDow(),this.fillMonths(),this.update(),this.isInline&&this.show()};k.prototype={constructor:k,_resolveViewName:function(b){return a.each(r.viewModes,function(c,d){if(b===c||a.inArray(b,d.names)!==-1)return b=c,!1}),b},_resolveDaysOfWeek:function(b){return a.isArray(b)||(b=b.split(/[,\s]*/)),a.map(b,Number)},_check_template:function(c){try{if(c===b||""===c)return!1;if((c.match(/[<>]/g)||[]).length<=0)return!0;var d=a(c);return d.length>0}catch(a){return!1}},_process_options:function(b){this._o=a.extend({},this._o,b);var e=this.o=a.extend({},this._o),f=e.language;q[f]||(f=f.split("-")[0],q[f]||(f=o.language)),e.language=f,e.startView=this._resolveViewName(e.startView),e.minViewMode=this._resolveViewName(e.minViewMode),e.maxViewMode=this._resolveViewName(e.maxViewMode),e.startView=Math.max(this.o.minViewMode,Math.min(this.o.maxViewMode,e.startView)),e.multidate!==!0&&(e.multidate=Number(e.multidate)||!1,e.multidate!==!1&&(e.multidate=Math.max(0,e.multidate))),e.multidateSeparator=String(e.multidateSeparator),e.weekStart%=7,e.weekEnd=(e.weekStart+6)%7;var g=r.parseFormat(e.format);e.startDate!==-(1/0)&&(e.startDate?e.startDate instanceof Date?e.startDate=this._local_to_utc(this._zero_time(e.startDate)):e.startDate=r.parseDate(e.startDate,g,e.language,e.assumeNearbyYear):e.startDate=-(1/0)),e.endDate!==1/0&&(e.endDate?e.endDate instanceof Date?e.endDate=this._local_to_utc(this._zero_time(e.endDate)):e.endDate=r.parseDate(e.endDate,g,e.language,e.assumeNearbyYear):e.endDate=1/0),e.daysOfWeekDisabled=this._resolveDaysOfWeek(e.daysOfWeekDisabled||[]),e.daysOfWeekHighlighted=this._resolveDaysOfWeek(e.daysOfWeekHighlighted||[]),e.datesDisabled=e.datesDisabled||[],a.isArray(e.datesDisabled)||(e.datesDisabled=e.datesDisabled.split(",")),e.datesDisabled=a.map(e.datesDisabled,function(a){return r.parseDate(a,g,e.language,e.assumeNearbyYear)});var h=String(e.orientation).toLowerCase().split(/\s+/g),i=e.orientation.toLowerCase();if(h=a.grep(h,function(a){return/^auto|left|right|top|bottom$/.test(a)}),e.orientation={x:"auto",y:"auto"},i&&"auto"!==i)if(1===h.length)switch(h[0]){case"top":case"bottom":e.orientation.y=h[0];break;case"left":case"right":e.orientation.x=h[0]}else i=a.grep(h,function(a){return/^left|right$/.test(a)}),e.orientation.x=i[0]||"auto",i=a.grep(h,function(a){return/^top|bottom$/.test(a)}),e.orientation.y=i[0]||"auto";else;if(e.defaultViewDate instanceof Date||"string"==typeof e.defaultViewDate)e.defaultViewDate=r.parseDate(e.defaultViewDate,g,e.language,e.assumeNearbyYear);else if(e.defaultViewDate){var j=e.defaultViewDate.year||(new Date).getFullYear(),k=e.defaultViewDate.month||0,l=e.defaultViewDate.day||1;e.defaultViewDate=c(j,k,l)}else e.defaultViewDate=d()},_events:[],_secondaryEvents:[],_applyEvents:function(a){for(var c,d,e,f=0;f<a.length;f++)c=a[f][0],2===a[f].length?(d=b,e=a[f][1]):3===a[f].length&&(d=a[f][1],e=a[f][2]),c.on(e,d)},_unapplyEvents:function(a){for(var c,d,e,f=0;f<a.length;f++)c=a[f][0],2===a[f].length?(e=b,d=a[f][1]):3===a[f].length&&(e=a[f][1],d=a[f][2]),c.off(d,e)},_buildEvents:function(){var b={keyup:a.proxy(function(b){a.inArray(b.keyCode,[27,37,39,38,40,32,13,9])===-1&&this.update()},this),keydown:a.proxy(this.keydown,this),paste:a.proxy(this.paste,this)};this.o.showOnFocus===!0&&(b.focus=a.proxy(this.show,this)),this.isInput?this._events=[[this.element,b]]:this.component&&this.inputField.length?this._events=[[this.inputField,b],[this.component,{click:a.proxy(this.show,this)}]]:this._events=[[this.element,{click:a.proxy(this.show,this),keydown:a.proxy(this.keydown,this)}]],this._events.push([this.element,"*",{blur:a.proxy(function(a){this._focused_from=a.target},this)}],[this.element,{blur:a.proxy(function(a){this._focused_from=a.target},this)}]),this.o.immediateUpdates&&this._events.push([this.element,{"changeYear changeMonth":a.proxy(function(a){this.update(a.date)},this)}]),this._secondaryEvents=[[this.picker,{click:a.proxy(this.click,this)}],[this.picker,".prev, .next",{click:a.proxy(this.navArrowsClick,this)}],[this.picker,".day:not(.disabled)",{click:a.proxy(this.dayCellClick,this)}],[a(window),{resize:a.proxy(this.place,this)}],[a(document),{"mousedown touchstart":a.proxy(function(a){this.element.is(a.target)||this.element.find(a.target).length||this.picker.is(a.target)||this.picker.find(a.target).length||this.isInline||this.hide()},this)}]]},_attachEvents:function(){this._detachEvents(),this._applyEvents(this._events)},_detachEvents:function(){this._unapplyEvents(this._events)},_attachSecondaryEvents:function(){this._detachSecondaryEvents(),this._applyEvents(this._secondaryEvents)},_detachSecondaryEvents:function(){this._unapplyEvents(this._secondaryEvents)},_trigger:function(b,c){var d=c||this.dates.get(-1),e=this._utc_to_local(d);this.element.trigger({type:b,date:e,viewMode:this.viewMode,dates:a.map(this.dates,this._utc_to_local),format:a.proxy(function(a,b){0===arguments.length?(a=this.dates.length-1,b=this.o.format):"string"==typeof a&&(b=a,a=this.dates.length-1),b=b||this.o.format;var c=this.dates.get(a);return r.formatDate(c,b,this.o.language)},this)})},show:function(){if(!(this.inputField.prop("disabled")||this.inputField.prop("readonly")&&this.o.enableOnReadonly===!1))return this.isInline||this.picker.appendTo(this.o.container),this.place(),this.picker.show(),this._attachSecondaryEvents(),this._trigger("show"),(window.navigator.msMaxTouchPoints||"ontouchstart"in document)&&this.o.disableTouchKeyboard&&a(this.element).blur(),this},hide:function(){return this.isInline||!this.picker.is(":visible")?this:(this.focusDate=null,this.picker.hide().detach(),this._detachSecondaryEvents(),this.setViewMode(this.o.startView),this.o.forceParse&&this.inputField.val()&&this.setValue(),this._trigger("hide"),this)},destroy:function(){return this.hide(),this._detachEvents(),this._detachSecondaryEvents(),this.picker.remove(),delete this.element.data().datepicker,this.isInput||delete this.element.data().date,this},paste:function(b){var c;if(b.originalEvent.clipboardData&&b.originalEvent.clipboardData.types&&a.inArray("text/plain",b.originalEvent.clipboardData.types)!==-1)c=b.originalEvent.clipboardData.getData("text/plain");else{if(!window.clipboardData)return;c=window.clipboardData.getData("Text")}this.setDate(c),this.update(),b.preventDefault()},_utc_to_local:function(a){if(!a)return a;var b=new Date(a.getTime()+6e4*a.getTimezoneOffset());return b.getTimezoneOffset()!==a.getTimezoneOffset()&&(b=new Date(a.getTime()+6e4*b.getTimezoneOffset())),b},_local_to_utc:function(a){return a&&new Date(a.getTime()-6e4*a.getTimezoneOffset())},_zero_time:function(a){return a&&new Date(a.getFullYear(),a.getMonth(),a.getDate())},_zero_utc_time:function(a){return a&&c(a.getUTCFullYear(),a.getUTCMonth(),a.getUTCDate())},getDates:function(){return a.map(this.dates,this._utc_to_local)},getUTCDates:function(){return a.map(this.dates,function(a){return new Date(a)})},getDate:function(){return this._utc_to_local(this.getUTCDate())},getUTCDate:function(){var a=this.dates.get(-1);return a!==b?new Date(a):null},clearDates:function(){this.inputField.val(""),this.update(),this._trigger("changeDate"),this.o.autoclose&&this.hide()},setDates:function(){var b=a.isArray(arguments[0])?arguments[0]:arguments;return this.update.apply(this,b),this._trigger("changeDate"),this.setValue(),this},setUTCDates:function(){var b=a.isArray(arguments[0])?arguments[0]:arguments;return this.setDates.apply(this,a.map(b,this._utc_to_local)),this},setDate:f("setDates"),setUTCDate:f("setUTCDates"),remove:f("destroy","Method `remove` is deprecated and will be removed in version 2.0. Use `destroy` instead"),setValue:function(){var a=this.getFormattedDate();return this.inputField.val(a),this},getFormattedDate:function(c){c===b&&(c=this.o.format);var d=this.o.language;return a.map(this.dates,function(a){return r.formatDate(a,c,d)}).join(this.o.multidateSeparator)},getStartDate:function(){return this.o.startDate},setStartDate:function(a){return this._process_options({startDate:a}),this.update(),this.updateNavArrows(),this},getEndDate:function(){return this.o.endDate},setEndDate:function(a){return this._process_options({endDate:a}),this.update(),this.updateNavArrows(),this},setDaysOfWeekDisabled:function(a){return this._process_options({daysOfWeekDisabled:a}),this.update(),this},setDaysOfWeekHighlighted:function(a){return this._process_options({daysOfWeekHighlighted:a}),this.update(),this},setDatesDisabled:function(a){return this._process_options({datesDisabled:a}),this.update(),this},place:function(){if(this.isInline)return this;var b=this.picker.outerWidth(),c=this.picker.outerHeight(),d=10,e=a(this.o.container),f=e.width(),g="body"===this.o.container?a(document).scrollTop():e.scrollTop(),h=e.offset(),i=[0];this.element.parents().each(function(){var b=a(this).css("z-index");"auto"!==b&&0!==Number(b)&&i.push(Number(b))});var j=Math.max.apply(Math,i)+this.o.zIndexOffset,k=this.component?this.component.parent().offset():this.element.offset(),l=this.component?this.component.outerHeight(!0):this.element.outerHeight(!1),m=this.component?this.component.outerWidth(!0):this.element.outerWidth(!1),n=k.left-h.left,o=k.top-h.top;"body"!==this.o.container&&(o+=g),this.picker.removeClass("datepicker-orient-top datepicker-orient-bottom datepicker-orient-right datepicker-orient-left"),"auto"!==this.o.orientation.x?(this.picker.addClass("datepicker-orient-"+this.o.orientation.x),"right"===this.o.orientation.x&&(n-=b-m)):k.left<0?(this.picker.addClass("datepicker-orient-left"),n-=k.left-d):n+b>f?(this.picker.addClass("datepicker-orient-right"),n+=m-b):this.o.rtl?this.picker.addClass("datepicker-orient-right"):this.picker.addClass("datepicker-orient-left");var p,q=this.o.orientation.y;if("auto"===q&&(p=-g+o-c,q=p<0?"bottom":"top"),this.picker.addClass("datepicker-orient-"+q),"top"===q?o-=c+parseInt(this.picker.css("padding-top")):o+=l,this.o.rtl){var r=f-(n+m);this.picker.css({top:o,right:r,zIndex:j})}else this.picker.css({top:o,left:n,zIndex:j});return this},_allow_update:!0,update:function(){if(!this._allow_update)return this;var b=this.dates.copy(),c=[],d=!1;return arguments.length?(a.each(arguments,a.proxy(function(a,b){b instanceof Date&&(b=this._local_to_utc(b)),c.push(b)},this)),d=!0):(c=this.isInput?this.element.val():this.element.data("date")||this.inputField.val(),c=c&&this.o.multidate?c.split(this.o.multidateSeparator):[c],delete this.element.data().date),c=a.map(c,a.proxy(function(a){return r.parseDate(a,this.o.format,this.o.language,this.o.assumeNearbyYear)},this)),c=a.grep(c,a.proxy(function(a){return!this.dateWithinRange(a)||!a},this),!0),this.dates.replace(c),this.o.updateViewDate&&(this.dates.length?this.viewDate=new Date(this.dates.get(-1)):this.viewDate<this.o.startDate?this.viewDate=new Date(this.o.startDate):this.viewDate>this.o.endDate?this.viewDate=new Date(this.o.endDate):this.viewDate=this.o.defaultViewDate),d?(this.setValue(),this.element.change()):this.dates.length&&String(b)!==String(this.dates)&&d&&(this._trigger("changeDate"),this.element.change()),!this.dates.length&&b.length&&(this._trigger("clearDate"),this.element.change()),this.fill(),this},fillDow:function(){if(this.o.showWeekDays){var b=this.o.weekStart,c="<tr>";for(this.o.calendarWeeks&&(c+='<th class="cw">&#160;</th>');b<this.o.weekStart+7;)c+='<th class="dow',a.inArray(b,this.o.daysOfWeekDisabled)!==-1&&(c+=" disabled"),c+='">'+q[this.o.language].daysMin[b++%7]+"</th>";c+="</tr>",this.picker.find(".datepicker-days thead").append(c)}},fillMonths:function(){for(var a,b=this._utc_to_local(this.viewDate),c="",d=0;d<12;d++)a=b&&b.getMonth()===d?" focused":"",c+='<span class="month'+a+'">'+q[this.o.language].monthsShort[d]+"</span>";this.picker.find(".datepicker-months td").html(c)},setRange:function(b){b&&b.length?this.range=a.map(b,function(a){return a.valueOf()}):delete this.range,this.fill()},getClassNames:function(b){var c=[],f=this.viewDate.getUTCFullYear(),g=this.viewDate.getUTCMonth(),h=d();return b.getUTCFullYear()<f||b.getUTCFullYear()===f&&b.getUTCMonth()<g?c.push("old"):(b.getUTCFullYear()>f||b.getUTCFullYear()===f&&b.getUTCMonth()>g)&&c.push("new"),this.focusDate&&b.valueOf()===this.focusDate.valueOf()&&c.push("focused"),this.o.todayHighlight&&e(b,h)&&c.push("today"),this.dates.contains(b)!==-1&&c.push("active"),this.dateWithinRange(b)||c.push("disabled"),this.dateIsDisabled(b)&&c.push("disabled","disabled-date"),a.inArray(b.getUTCDay(),this.o.daysOfWeekHighlighted)!==-1&&c.push("highlighted"),this.range&&(b>this.range[0]&&b<this.range[this.range.length-1]&&c.push("range"),a.inArray(b.valueOf(),this.range)!==-1&&c.push("selected"),b.valueOf()===this.range[0]&&c.push("range-start"),b.valueOf()===this.range[this.range.length-1]&&c.push("range-end")),c},_fill_yearsView:function(c,d,e,f,g,h,i){for(var j,k,l,m="",n=e/10,o=this.picker.find(c),p=Math.floor(f/e)*e,q=p+9*n,r=Math.floor(this.viewDate.getFullYear()/n)*n,s=a.map(this.dates,function(a){return Math.floor(a.getUTCFullYear()/n)*n}),t=p-n;t<=q+n;t+=n)j=[d],k=null,t===p-n?j.push("old"):t===q+n&&j.push("new"),a.inArray(t,s)!==-1&&j.push("active"),(t<g||t>h)&&j.push("disabled"),t===r&&j.push("focused"),i!==a.noop&&(l=i(new Date(t,0,1)),l===b?l={}:"boolean"==typeof l?l={enabled:l}:"string"==typeof l&&(l={classes:l}),l.enabled===!1&&j.push("disabled"),l.classes&&(j=j.concat(l.classes.split(/\s+/))),l.tooltip&&(k=l.tooltip)),m+='<span class="'+j.join(" ")+'"'+(k?' title="'+k+'"':"")+">"+t+"</span>";o.find(".datepicker-switch").text(p+"-"+q),o.find("td").html(m)},fill:function(){var d,e,f=new Date(this.viewDate),g=f.getUTCFullYear(),h=f.getUTCMonth(),i=this.o.startDate!==-(1/0)?this.o.startDate.getUTCFullYear():-(1/0),j=this.o.startDate!==-(1/0)?this.o.startDate.getUTCMonth():-(1/0),k=this.o.endDate!==1/0?this.o.endDate.getUTCFullYear():1/0,l=this.o.endDate!==1/0?this.o.endDate.getUTCMonth():1/0,m=q[this.o.language].today||q.en.today||"",n=q[this.o.language].clear||q.en.clear||"",o=q[this.o.language].titleFormat||q.en.titleFormat;if(!isNaN(g)&&!isNaN(h)){this.picker.find(".datepicker-days .datepicker-switch").text(r.formatDate(f,o,this.o.language)),this.picker.find("tfoot .today").text(m).css("display",this.o.todayBtn===!0||"linked"===this.o.todayBtn?"table-cell":"none"),this.picker.find("tfoot .clear").text(n).css("display",this.o.clearBtn===!0?"table-cell":"none"),this.picker.find("thead .datepicker-title").text(this.o.title).css("display","string"==typeof this.o.title&&""!==this.o.title?"table-cell":"none"),this.updateNavArrows(),this.fillMonths();var p=c(g,h,0),s=p.getUTCDate();p.setUTCDate(s-(p.getUTCDay()-this.o.weekStart+7)%7);var t=new Date(p);p.getUTCFullYear()<100&&t.setUTCFullYear(p.getUTCFullYear()),t.setUTCDate(t.getUTCDate()+42),t=t.valueOf();for(var u,v,w=[];p.valueOf()<t;){if(u=p.getUTCDay(),u===this.o.weekStart&&(w.push("<tr>"),this.o.calendarWeeks)){var x=new Date(+p+(this.o.weekStart-u-7)%7*864e5),y=new Date(Number(x)+(11-x.getUTCDay())%7*864e5),z=new Date(Number(z=c(y.getUTCFullYear(),0,1))+(11-z.getUTCDay())%7*864e5),A=(y-z)/864e5/7+1;w.push('<td class="cw">'+A+"</td>")}v=this.getClassNames(p),v.push("day");var B=p.getUTCDate();this.o.beforeShowDay!==a.noop&&(e=this.o.beforeShowDay(this._utc_to_local(p)),e===b?e={}:"boolean"==typeof e?e={enabled:e}:"string"==typeof e&&(e={classes:e}),e.enabled===!1&&v.push("disabled"),e.classes&&(v=v.concat(e.classes.split(/\s+/))),e.tooltip&&(d=e.tooltip),e.content&&(B=e.content)),v=a.isFunction(a.uniqueSort)?a.uniqueSort(v):a.unique(v),w.push('<td class="'+v.join(" ")+'"'+(d?' title="'+d+'"':"")+' data-date="'+p.getTime().toString()+'">'+B+"</td>"),d=null,u===this.o.weekEnd&&w.push("</tr>"),p.setUTCDate(p.getUTCDate()+1)}this.picker.find(".datepicker-days tbody").html(w.join(""));var C=q[this.o.language].monthsTitle||q.en.monthsTitle||"Months",D=this.picker.find(".datepicker-months").find(".datepicker-switch").text(this.o.maxViewMode<2?C:g).end().find("tbody span").removeClass("active");if(a.each(this.dates,function(a,b){b.getUTCFullYear()===g&&D.eq(b.getUTCMonth()).addClass("active")}),(g<i||g>k)&&D.addClass("disabled"),g===i&&D.slice(0,j).addClass("disabled"),g===k&&D.slice(l+1).addClass("disabled"),this.o.beforeShowMonth!==a.noop){var E=this;a.each(D,function(c,d){var e=new Date(g,c,1),f=E.o.beforeShowMonth(e);f===b?f={}:"boolean"==typeof f?f={enabled:f}:"string"==typeof f&&(f={classes:f}),f.enabled!==!1||a(d).hasClass("disabled")||a(d).addClass("disabled"),f.classes&&a(d).addClass(f.classes),f.tooltip&&a(d).prop("title",f.tooltip)})}this._fill_yearsView(".datepicker-years","year",10,g,i,k,this.o.beforeShowYear),this._fill_yearsView(".datepicker-decades","decade",100,g,i,k,this.o.beforeShowDecade),this._fill_yearsView(".datepicker-centuries","century",1e3,g,i,k,this.o.beforeShowCentury)}},updateNavArrows:function(){if(this._allow_update){var a,b,c=new Date(this.viewDate),d=c.getUTCFullYear(),e=c.getUTCMonth(),f=this.o.startDate!==-(1/0)?this.o.startDate.getUTCFullYear():-(1/0),g=this.o.startDate!==-(1/0)?this.o.startDate.getUTCMonth():-(1/0),h=this.o.endDate!==1/0?this.o.endDate.getUTCFullYear():1/0,i=this.o.endDate!==1/0?this.o.endDate.getUTCMonth():1/0,j=1;switch(this.viewMode){case 4:j*=10;case 3:j*=10;case 2:j*=10;case 1:a=Math.floor(d/j)*j<f,b=Math.floor(d/j)*j+j>h;break;case 0:a=d<=f&&e<g,b=d>=h&&e>i}this.picker.find(".prev").toggleClass("disabled",a),this.picker.find(".next").toggleClass("disabled",b)}},click:function(b){b.preventDefault(),b.stopPropagation();var e,f,g,h;e=a(b.target),e.hasClass("datepicker-switch")&&this.viewMode!==this.o.maxViewMode&&this.setViewMode(this.viewMode+1),e.hasClass("today")&&!e.hasClass("day")&&(this.setViewMode(0),this._setDate(d(),"linked"===this.o.todayBtn?null:"view")),e.hasClass("clear")&&this.clearDates(),e.hasClass("disabled")||(e.hasClass("month")||e.hasClass("year")||e.hasClass("decade")||e.hasClass("century"))&&(this.viewDate.setUTCDate(1),f=1,1===this.viewMode?(h=e.parent().find("span").index(e),g=this.viewDate.getUTCFullYear(),this.viewDate.setUTCMonth(h)):(h=0,g=Number(e.text()),this.viewDate.setUTCFullYear(g)),this._trigger(r.viewModes[this.viewMode-1].e,this.viewDate),this.viewMode===this.o.minViewMode?this._setDate(c(g,h,f)):(this.setViewMode(this.viewMode-1),this.fill())),this.picker.is(":visible")&&this._focused_from&&this._focused_from.focus(),delete this._focused_from},dayCellClick:function(b){var c=a(b.currentTarget),d=c.data("date"),e=new Date(d);this.o.updateViewDate&&(e.getUTCFullYear()!==this.viewDate.getUTCFullYear()&&this._trigger("changeYear",this.viewDate),e.getUTCMonth()!==this.viewDate.getUTCMonth()&&this._trigger("changeMonth",this.viewDate)),this._setDate(e)},navArrowsClick:function(b){var c=a(b.currentTarget),d=c.hasClass("prev")?-1:1;0!==this.viewMode&&(d*=12*r.viewModes[this.viewMode].navStep),this.viewDate=this.moveMonth(this.viewDate,d),this._trigger(r.viewModes[this.viewMode].e,this.viewDate),this.fill()},_toggle_multidate:function(a){var b=this.dates.contains(a);if(a||this.dates.clear(),b!==-1?(this.o.multidate===!0||this.o.multidate>1||this.o.toggleActive)&&this.dates.remove(b):this.o.multidate===!1?(this.dates.clear(),this.dates.push(a)):this.dates.push(a),"number"==typeof this.o.multidate)for(;this.dates.length>this.o.multidate;)this.dates.remove(0)},_setDate:function(a,b){b&&"date"!==b||this._toggle_multidate(a&&new Date(a)),(!b&&this.o.updateViewDate||"view"===b)&&(this.viewDate=a&&new Date(a)),this.fill(),this.setValue(),b&&"view"===b||this._trigger("changeDate"),this.inputField.trigger("change"),!this.o.autoclose||b&&"date"!==b||this.hide()},moveDay:function(a,b){var c=new Date(a);return c.setUTCDate(a.getUTCDate()+b),c},moveWeek:function(a,b){return this.moveDay(a,7*b)},moveMonth:function(a,b){if(!g(a))return this.o.defaultViewDate;if(!b)return a;var c,d,e=new Date(a.valueOf()),f=e.getUTCDate(),h=e.getUTCMonth(),i=Math.abs(b);if(b=b>0?1:-1,1===i)d=b===-1?function(){return e.getUTCMonth()===h}:function(){return e.getUTCMonth()!==c},c=h+b,e.setUTCMonth(c),c=(c+12)%12;else{for(var j=0;j<i;j++)e=this.moveMonth(e,b);c=e.getUTCMonth(),e.setUTCDate(f),d=function(){return c!==e.getUTCMonth()}}for(;d();)e.setUTCDate(--f),e.setUTCMonth(c);return e},moveYear:function(a,b){return this.moveMonth(a,12*b)},moveAvailableDate:function(a,b,c){do{if(a=this[c](a,b),!this.dateWithinRange(a))return!1;c="moveDay"}while(this.dateIsDisabled(a));return a},weekOfDateIsDisabled:function(b){return a.inArray(b.getUTCDay(),this.o.daysOfWeekDisabled)!==-1},dateIsDisabled:function(b){return this.weekOfDateIsDisabled(b)||a.grep(this.o.datesDisabled,function(a){return e(b,a)}).length>0},dateWithinRange:function(a){return a>=this.o.startDate&&a<=this.o.endDate},keydown:function(a){if(!this.picker.is(":visible"))return void(40!==a.keyCode&&27!==a.keyCode||(this.show(),a.stopPropagation()));var b,c,d=!1,e=this.focusDate||this.viewDate;switch(a.keyCode){case 27:this.focusDate?(this.focusDate=null,this.viewDate=this.dates.get(-1)||this.viewDate,this.fill()):this.hide(),a.preventDefault(),a.stopPropagation();break;case 37:case 38:case 39:case 40:if(!this.o.keyboardNavigation||7===this.o.daysOfWeekDisabled.length)break;b=37===a.keyCode||38===a.keyCode?-1:1,0===this.viewMode?a.ctrlKey?(c=this.moveAvailableDate(e,b,"moveYear"),c&&this._trigger("changeYear",this.viewDate)):a.shiftKey?(c=this.moveAvailableDate(e,b,"moveMonth"),c&&this._trigger("changeMonth",this.viewDate)):37===a.keyCode||39===a.keyCode?c=this.moveAvailableDate(e,b,"moveDay"):this.weekOfDateIsDisabled(e)||(c=this.moveAvailableDate(e,b,"moveWeek")):1===this.viewMode?(38!==a.keyCode&&40!==a.keyCode||(b*=4),c=this.moveAvailableDate(e,b,"moveMonth")):2===this.viewMode&&(38!==a.keyCode&&40!==a.keyCode||(b*=4),c=this.moveAvailableDate(e,b,"moveYear")),c&&(this.focusDate=this.viewDate=c,this.setValue(),this.fill(),a.preventDefault());break;case 13:if(!this.o.forceParse)break;e=this.focusDate||this.dates.get(-1)||this.viewDate,this.o.keyboardNavigation&&(this._toggle_multidate(e),d=!0),this.focusDate=null,this.viewDate=this.dates.get(-1)||this.viewDate,this.setValue(),this.fill(),this.picker.is(":visible")&&(a.preventDefault(),a.stopPropagation(),this.o.autoclose&&this.hide());break;case 9:this.focusDate=null,this.viewDate=this.dates.get(-1)||this.viewDate,this.fill(),this.hide()}d&&(this.dates.length?this._trigger("changeDate"):this._trigger("clearDate"),this.inputField.trigger("change"))},setViewMode:function(a){this.viewMode=a,this.picker.children("div").hide().filter(".datepicker-"+r.viewModes[this.viewMode].clsName).show(),this.updateNavArrows(),this._trigger("changeViewMode",new Date(this.viewDate))}};var l=function(b,c){a.data(b,"datepicker",this),this.element=a(b),this.inputs=a.map(c.inputs,function(a){return a.jquery?a[0]:a}),delete c.inputs,this.keepEmptyValues=c.keepEmptyValues,delete c.keepEmptyValues,n.call(a(this.inputs),c).on("changeDate",a.proxy(this.dateUpdated,this)),this.pickers=a.map(this.inputs,function(b){return a.data(b,"datepicker")}),this.updateDates()};l.prototype={updateDates:function(){this.dates=a.map(this.pickers,function(a){return a.getUTCDate()}),this.updateRanges()},updateRanges:function(){var b=a.map(this.dates,function(a){return a.valueOf()});a.each(this.pickers,function(a,c){c.setRange(b)})},clearDates:function(){a.each(this.pickers,function(a,b){b.clearDates()})},dateUpdated:function(c){if(!this.updating){this.updating=!0;var d=a.data(c.target,"datepicker");if(d!==b){var e=d.getUTCDate(),f=this.keepEmptyValues,g=a.inArray(c.target,this.inputs),h=g-1,i=g+1,j=this.inputs.length;if(g!==-1){if(a.each(this.pickers,function(a,b){b.getUTCDate()||b!==d&&f||b.setUTCDate(e)}),e<this.dates[h])for(;h>=0&&e<this.dates[h];)this.pickers[h--].setUTCDate(e);else if(e>this.dates[i])for(;i<j&&e>this.dates[i];)this.pickers[i++].setUTCDate(e);this.updateDates(),delete this.updating}}}},destroy:function(){a.map(this.pickers,function(a){a.destroy()}),a(this.inputs).off("changeDate",this.dateUpdated),delete this.element.data().datepicker},remove:f("destroy","Method `remove` is deprecated and will be removed in version 2.0. Use `destroy` instead")};var m=a.fn.datepicker,n=function(c){var d=Array.apply(null,arguments);d.shift();var e;if(this.each(function(){var b=a(this),f=b.data("datepicker"),g="object"==typeof c&&c;if(!f){var j=h(this,"date"),m=a.extend({},o,j,g),n=i(m.language),p=a.extend({},o,n,j,g);b.hasClass("input-daterange")||p.inputs?(a.extend(p,{inputs:p.inputs||b.find("input").toArray()}),f=new l(this,p)):f=new k(this,p),b.data("datepicker",f)}"string"==typeof c&&"function"==typeof f[c]&&(e=f[c].apply(f,d))}),e===b||e instanceof k||e instanceof l)return this;if(this.length>1)throw new Error("Using only allowed for the collection of a single element ("+c+" function)");return e};a.fn.datepicker=n;var o=a.fn.datepicker.defaults={assumeNearbyYear:!1,autoclose:!1,beforeShowDay:a.noop,beforeShowMonth:a.noop,beforeShowYear:a.noop,beforeShowDecade:a.noop,beforeShowCentury:a.noop,calendarWeeks:!1,clearBtn:!1,toggleActive:!1,daysOfWeekDisabled:[],daysOfWeekHighlighted:[],datesDisabled:[],endDate:1/0,forceParse:!0,format:"mm/dd/yyyy",keepEmptyValues:!1,keyboardNavigation:!0,language:"en",minViewMode:0,maxViewMode:4,multidate:!1,multidateSeparator:",",orientation:"auto",rtl:!1,startDate:-(1/0),startView:0,todayBtn:!1,todayHighlight:!1,updateViewDate:!0,weekStart:0,disableTouchKeyboard:!1,enableOnReadonly:!0,showOnFocus:!0,zIndexOffset:10,container:"body",immediateUpdates:!1,title:"",templates:{leftArrow:"&#x00AB;",rightArrow:"&#x00BB;"},showWeekDays:!0},p=a.fn.datepicker.locale_opts=["format","rtl","weekStart"];a.fn.datepicker.Constructor=k;var q=a.fn.datepicker.dates={en:{days:["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],daysShort:["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],daysMin:["Su","Mo","Tu","We","Th","Fr","Sa"],months:["January","February","March","April","May","June","July","August","September","October","November","December"],monthsShort:["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],today:"Today",clear:"Clear",titleFormat:"MM yyyy"}},r={viewModes:[{names:["days","month"],clsName:"days",e:"changeMonth"},{names:["months","year"],clsName:"months",e:"changeYear",navStep:1},{names:["years","decade"],clsName:"years",e:"changeDecade",navStep:10},{names:["decades","century"],clsName:"decades",e:"changeCentury",navStep:100},{names:["centuries","millennium"],clsName:"centuries",e:"changeMillennium",navStep:1e3}],validParts:/dd?|DD?|mm?|MM?|yy(?:yy)?/g,nonpunctuation:/[^ -\/:-@\u5e74\u6708\u65e5\[-`{-~\t\n\r]+/g,parseFormat:function(a){if("function"==typeof a.toValue&&"function"==typeof a.toDisplay)return a;var b=a.replace(this.validParts,"\0").split("\0"),c=a.match(this.validParts);if(!b||!b.length||!c||0===c.length)throw new Error("Invalid date format.");return{separators:b,parts:c}},parseDate:function(c,e,f,g){function h(a,b){return b===!0&&(b=10),a<100&&(a+=2e3,a>(new Date).getFullYear()+b&&(a-=100)),a}function i(){var a=this.slice(0,j[n].length),b=j[n].slice(0,a.length);return a.toLowerCase()===b.toLowerCase()}if(!c)return b;if(c instanceof Date)return c;if("string"==typeof e&&(e=r.parseFormat(e)),e.toValue)return e.toValue(c,e,f);var j,l,m,n,o,p={d:"moveDay",m:"moveMonth",w:"moveWeek",y:"moveYear"},s={yesterday:"-1d",today:"+0d",tomorrow:"+1d"};if(c in s&&(c=s[c]),/^[\-+]\d+[dmwy]([\s,]+[\-+]\d+[dmwy])*$/i.test(c)){for(j=c.match(/([\-+]\d+)([dmwy])/gi),c=new Date,n=0;n<j.length;n++)l=j[n].match(/([\-+]\d+)([dmwy])/i),m=Number(l[1]),o=p[l[2].toLowerCase()],c=k.prototype[o](c,m);return k.prototype._zero_utc_time(c)}j=c&&c.match(this.nonpunctuation)||[];var t,u,v={},w=["yyyy","yy","M","MM","m","mm","d","dd"],x={yyyy:function(a,b){return a.setUTCFullYear(g?h(b,g):b)},m:function(a,b){if(isNaN(a))return a;for(b-=1;b<0;)b+=12;for(b%=12,a.setUTCMonth(b);a.getUTCMonth()!==b;)a.setUTCDate(a.getUTCDate()-1);return a},d:function(a,b){return a.setUTCDate(b)}};x.yy=x.yyyy,x.M=x.MM=x.mm=x.m,x.dd=x.d,c=d();var y=e.parts.slice();if(j.length!==y.length&&(y=a(y).filter(function(b,c){return a.inArray(c,w)!==-1}).toArray()),j.length===y.length){var z;for(n=0,z=y.length;n<z;n++){if(t=parseInt(j[n],10),l=y[n],isNaN(t))switch(l){case"MM":u=a(q[f].months).filter(i),t=a.inArray(u[0],q[f].months)+1;break;case"M":u=a(q[f].monthsShort).filter(i),t=a.inArray(u[0],q[f].monthsShort)+1}v[l]=t}var A,B;for(n=0;n<w.length;n++)B=w[n],B in v&&!isNaN(v[B])&&(A=new Date(c),x[B](A,v[B]),isNaN(A)||(c=A))}return c},formatDate:function(b,c,d){if(!b)return"";if("string"==typeof c&&(c=r.parseFormat(c)),c.toDisplay)return c.toDisplay(b,c,d);var e={d:b.getUTCDate(),D:q[d].daysShort[b.getUTCDay()],DD:q[d].days[b.getUTCDay()],m:b.getUTCMonth()+1,M:q[d].monthsShort[b.getUTCMonth()],MM:q[d].months[b.getUTCMonth()],yy:b.getUTCFullYear().toString().substring(2),yyyy:b.getUTCFullYear()};e.dd=(e.d<10?"0":"")+e.d,e.mm=(e.m<10?"0":"")+e.m,b=[];for(var f=a.extend([],c.separators),g=0,h=c.parts.length;g<=h;g++)f.length&&b.push(f.shift()),b.push(e[c.parts[g]]);return b.join("")},headTemplate:'<thead><tr><th colspan="7" class="datepicker-title"></th></tr><tr><th class="prev">'+o.templates.leftArrow+'</th><th colspan="5" class="datepicker-switch"></th><th class="next">'+o.templates.rightArrow+"</th></tr></thead>",
	contTemplate:'<tbody><tr><td colspan="7"></td></tr></tbody>',footTemplate:'<tfoot><tr><th colspan="7" class="today"></th></tr><tr><th colspan="7" class="clear"></th></tr></tfoot>'};r.template='<div class="datepicker"><div class="datepicker-days"><table class="table-condensed">'+r.headTemplate+"<tbody></tbody>"+r.footTemplate+'</table></div><div class="datepicker-months"><table class="table-condensed">'+r.headTemplate+r.contTemplate+r.footTemplate+'</table></div><div class="datepicker-years"><table class="table-condensed">'+r.headTemplate+r.contTemplate+r.footTemplate+'</table></div><div class="datepicker-decades"><table class="table-condensed">'+r.headTemplate+r.contTemplate+r.footTemplate+'</table></div><div class="datepicker-centuries"><table class="table-condensed">'+r.headTemplate+r.contTemplate+r.footTemplate+"</table></div></div>",a.fn.datepicker.DPGlobal=r,a.fn.datepicker.noConflict=function(){return a.fn.datepicker=m,this},a.fn.datepicker.version="1.8.0",a.fn.datepicker.deprecated=function(a){var b=window.console;b&&b.warn&&b.warn("DEPRECATED: "+a)},a(document).on("focus.datepicker.data-api click.datepicker.data-api",'[data-provide="datepicker"]',function(b){var c=a(this);c.data("datepicker")||(b.preventDefault(),n.call(c,"show"))}),a(function(){n.call(a('[data-provide="datepicker-inline"]'))})});

/***/ }),
/* 36 */
/***/ (function(module, exports) {

	!function(a){a.fn.datepicker.dates["zh-TW"]={days:["星期日","星期一","星期二","星期三","星期四","星期五","星期六"],daysShort:["週日","週一","週二","週三","週四","週五","週六"],daysMin:["日","一","二","三","四","五","六"],months:["一月","二月","三月","四月","五月","六月","七月","八月","九月","十月","十一月","十二月"],monthsShort:["1月","2月","3月","4月","5月","6月","7月","8月","9月","10月","11月","12月"],today:"今天",format:"yyyy年mm月dd日",weekStart:1,clear:"清除"}}(jQuery);

/***/ }),
/* 37 */
/***/ (function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * Bootstrap-select v1.13.7 (https://developer.snapappointments.com/bootstrap-select)
	 *
	 * Copyright 2012-2019 SnapAppointments, LLC
	 * Licensed under MIT (https://github.com/snapappointments/bootstrap-select/blob/master/LICENSE)
	 */

	!function(e,t){void 0===e&&void 0!==window&&(e=window), true?!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(28)], __WEBPACK_AMD_DEFINE_RESULT__ = function(e){return t(e)}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)):"object"==typeof module&&module.exports?module.exports=t(require("jquery")):t(e.jQuery)}(this,function(e){!function(z){"use strict";var d=["sanitize","whiteList","sanitizeFn"],r=["background","cite","href","itemtype","longdesc","poster","src","xlink:href"],e={"*":["class","dir","id","lang","role","tabindex","style",/^aria-[\w-]*$/i],a:["target","href","title","rel"],area:[],b:[],br:[],col:[],code:[],div:[],em:[],hr:[],h1:[],h2:[],h3:[],h4:[],h5:[],h6:[],i:[],img:["src","alt","title","width","height"],li:[],ol:[],p:[],pre:[],s:[],small:[],span:[],sub:[],sup:[],strong:[],u:[],ul:[]},l=/^(?:(?:https?|mailto|ftp|tel|file):|[^&:/?#]*(?:[/?#]|$))/gi,a=/^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[a-z0-9+/]+=*$/i;function v(e,t){var i=e.nodeName.toLowerCase();if(-1!==z.inArray(i,t))return-1===z.inArray(i,r)||Boolean(e.nodeValue.match(l)||e.nodeValue.match(a));for(var n=z(t).filter(function(e,t){return t instanceof RegExp}),s=0,o=n.length;s<o;s++)if(i.match(n[s]))return!0;return!1}function P(e,t,i){if(i&&"function"==typeof i)return i(e);for(var n=Object.keys(t),s=0,o=e.length;s<o;s++)for(var r=e[s].querySelectorAll("*"),l=0,a=r.length;l<a;l++){var c=r[l],d=c.nodeName.toLowerCase();if(-1!==n.indexOf(d))for(var h=[].slice.call(c.attributes),p=[].concat(t["*"]||[],t[d]||[]),u=0,f=h.length;u<f;u++){var m=h[u];v(m,p)||c.removeAttribute(m.nodeName)}else c.parentNode.removeChild(c)}}"classList"in document.createElement("_")||function(e){if("Element"in e){var t="classList",i="prototype",n=e.Element[i],s=Object,o=function(){var i=z(this);return{add:function(e){return e=Array.prototype.slice.call(arguments).join(" "),i.addClass(e)},remove:function(e){return e=Array.prototype.slice.call(arguments).join(" "),i.removeClass(e)},toggle:function(e,t){return i.toggleClass(e,t)},contains:function(e){return i.hasClass(e)}}};if(s.defineProperty){var r={get:o,enumerable:!0,configurable:!0};try{s.defineProperty(n,t,r)}catch(e){void 0!==e.number&&-2146823252!==e.number||(r.enumerable=!1,s.defineProperty(n,t,r))}}else s[i].__defineGetter__&&n.__defineGetter__(t,o)}}(window);var t,c,i,n=document.createElement("_");if(n.classList.add("c1","c2"),!n.classList.contains("c2")){var s=DOMTokenList.prototype.add,o=DOMTokenList.prototype.remove;DOMTokenList.prototype.add=function(){Array.prototype.forEach.call(arguments,s.bind(this))},DOMTokenList.prototype.remove=function(){Array.prototype.forEach.call(arguments,o.bind(this))}}if(n.classList.toggle("c3",!1),n.classList.contains("c3")){var h=DOMTokenList.prototype.toggle;DOMTokenList.prototype.toggle=function(e,t){return 1 in arguments&&!this.contains(e)==!t?t:h.call(this,e)}}function S(e){var t,i=[],n=e.selectedOptions;if(e.multiple)for(var s=0,o=n.length;s<o;s++)t=n[s],i.push(t.value||t.text);else i=e.value;return i}n=null,String.prototype.startsWith||(t=function(){try{var e={},t=Object.defineProperty,i=t(e,e,e)&&t}catch(e){}return i}(),c={}.toString,i=function(e){if(null==this)throw new TypeError;var t=String(this);if(e&&"[object RegExp]"==c.call(e))throw new TypeError;var i=t.length,n=String(e),s=n.length,o=1<arguments.length?arguments[1]:void 0,r=o?Number(o):0;r!=r&&(r=0);var l=Math.min(Math.max(r,0),i);if(i<s+l)return!1;for(var a=-1;++a<s;)if(t.charCodeAt(l+a)!=n.charCodeAt(a))return!1;return!0},t?t(String.prototype,"startsWith",{value:i,configurable:!0,writable:!0}):String.prototype.startsWith=i),Object.keys||(Object.keys=function(e,t,i){for(t in i=[],e)i.hasOwnProperty.call(e,t)&&i.push(t);return i}),HTMLSelectElement.prototype.hasOwnProperty("selectedOptions")||Object.defineProperty(HTMLSelectElement.prototype,"selectedOptions",{get:function(){return this.querySelectorAll(":checked")}});var p={useDefault:!1,_set:z.valHooks.select.set};z.valHooks.select.set=function(e,t){return t&&!p.useDefault&&z(e).data("selected",!0),p._set.apply(this,arguments)};var E=null,u=function(){try{return new Event("change"),!0}catch(e){return!1}}();function $(e,t,i,n){for(var s=["content","subtext","tokens"],o=!1,r=0;r<s.length;r++){var l=s[r],a=e[l];if(a&&(a=a.toString(),"content"===l&&(a=a.replace(/<[^>]+>/g,"")),n&&(a=w(a)),a=a.toUpperCase(),o="contains"===i?0<=a.indexOf(t):a.startsWith(t)))break}return o}function L(e){return parseInt(e,10)||0}z.fn.triggerNative=function(e){var t,i=this[0];i.dispatchEvent?(u?t=new Event(e,{bubbles:!0}):(t=document.createEvent("Event")).initEvent(e,!0,!1),i.dispatchEvent(t)):i.fireEvent?((t=document.createEventObject()).eventType=e,i.fireEvent("on"+e,t)):this.trigger(e)};var f={"\xc0":"A","\xc1":"A","\xc2":"A","\xc3":"A","\xc4":"A","\xc5":"A","\xe0":"a","\xe1":"a","\xe2":"a","\xe3":"a","\xe4":"a","\xe5":"a","\xc7":"C","\xe7":"c","\xd0":"D","\xf0":"d","\xc8":"E","\xc9":"E","\xca":"E","\xcb":"E","\xe8":"e","\xe9":"e","\xea":"e","\xeb":"e","\xcc":"I","\xcd":"I","\xce":"I","\xcf":"I","\xec":"i","\xed":"i","\xee":"i","\xef":"i","\xd1":"N","\xf1":"n","\xd2":"O","\xd3":"O","\xd4":"O","\xd5":"O","\xd6":"O","\xd8":"O","\xf2":"o","\xf3":"o","\xf4":"o","\xf5":"o","\xf6":"o","\xf8":"o","\xd9":"U","\xda":"U","\xdb":"U","\xdc":"U","\xf9":"u","\xfa":"u","\xfb":"u","\xfc":"u","\xdd":"Y","\xfd":"y","\xff":"y","\xc6":"Ae","\xe6":"ae","\xde":"Th","\xfe":"th","\xdf":"ss","\u0100":"A","\u0102":"A","\u0104":"A","\u0101":"a","\u0103":"a","\u0105":"a","\u0106":"C","\u0108":"C","\u010a":"C","\u010c":"C","\u0107":"c","\u0109":"c","\u010b":"c","\u010d":"c","\u010e":"D","\u0110":"D","\u010f":"d","\u0111":"d","\u0112":"E","\u0114":"E","\u0116":"E","\u0118":"E","\u011a":"E","\u0113":"e","\u0115":"e","\u0117":"e","\u0119":"e","\u011b":"e","\u011c":"G","\u011e":"G","\u0120":"G","\u0122":"G","\u011d":"g","\u011f":"g","\u0121":"g","\u0123":"g","\u0124":"H","\u0126":"H","\u0125":"h","\u0127":"h","\u0128":"I","\u012a":"I","\u012c":"I","\u012e":"I","\u0130":"I","\u0129":"i","\u012b":"i","\u012d":"i","\u012f":"i","\u0131":"i","\u0134":"J","\u0135":"j","\u0136":"K","\u0137":"k","\u0138":"k","\u0139":"L","\u013b":"L","\u013d":"L","\u013f":"L","\u0141":"L","\u013a":"l","\u013c":"l","\u013e":"l","\u0140":"l","\u0142":"l","\u0143":"N","\u0145":"N","\u0147":"N","\u014a":"N","\u0144":"n","\u0146":"n","\u0148":"n","\u014b":"n","\u014c":"O","\u014e":"O","\u0150":"O","\u014d":"o","\u014f":"o","\u0151":"o","\u0154":"R","\u0156":"R","\u0158":"R","\u0155":"r","\u0157":"r","\u0159":"r","\u015a":"S","\u015c":"S","\u015e":"S","\u0160":"S","\u015b":"s","\u015d":"s","\u015f":"s","\u0161":"s","\u0162":"T","\u0164":"T","\u0166":"T","\u0163":"t","\u0165":"t","\u0167":"t","\u0168":"U","\u016a":"U","\u016c":"U","\u016e":"U","\u0170":"U","\u0172":"U","\u0169":"u","\u016b":"u","\u016d":"u","\u016f":"u","\u0171":"u","\u0173":"u","\u0174":"W","\u0175":"w","\u0176":"Y","\u0177":"y","\u0178":"Y","\u0179":"Z","\u017b":"Z","\u017d":"Z","\u017a":"z","\u017c":"z","\u017e":"z","\u0132":"IJ","\u0133":"ij","\u0152":"Oe","\u0153":"oe","\u0149":"'n","\u017f":"s"},m=/[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g,g=RegExp("[\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff\\u1ab0-\\u1aff\\u1dc0-\\u1dff]","g");function b(e){return f[e]}function w(e){return(e=e.toString())&&e.replace(m,b).replace(g,"")}var x,I,k,y,C,U=(x={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#x27;","`":"&#x60;"},I=function(e){return x[e]},k="(?:"+Object.keys(x).join("|")+")",y=RegExp(k),C=RegExp(k,"g"),function(e){return e=null==e?"":""+e,y.test(e)?e.replace(C,I):e}),O={32:" ",48:"0",49:"1",50:"2",51:"3",52:"4",53:"5",54:"6",55:"7",56:"8",57:"9",59:";",65:"A",66:"B",67:"C",68:"D",69:"E",70:"F",71:"G",72:"H",73:"I",74:"J",75:"K",76:"L",77:"M",78:"N",79:"O",80:"P",81:"Q",82:"R",83:"S",84:"T",85:"U",86:"V",87:"W",88:"X",89:"Y",90:"Z",96:"0",97:"1",98:"2",99:"3",100:"4",101:"5",102:"6",103:"7",104:"8",105:"9"},T=27,A=13,H=32,D=9,N=38,R=40,W={success:!1,major:"3"};try{W.full=(z.fn.dropdown.Constructor.VERSION||"").split(" ")[0].split("."),W.major=W.full[0],W.success=!0}catch(e){console.warn("There was an issue retrieving Bootstrap's version. Ensure Bootstrap is being loaded before bootstrap-select and there is no namespace collision. If loading Bootstrap asynchronously, the version may need to be manually specified via $.fn.selectpicker.Constructor.BootstrapVersion.",e)}var B=0,M=".bs.select",j={DISABLED:"disabled",DIVIDER:"divider",SHOW:"open",DROPUP:"dropup",MENU:"dropdown-menu",MENURIGHT:"dropdown-menu-right",MENULEFT:"dropdown-menu-left",BUTTONCLASS:"btn-default",POPOVERHEADER:"popover-title"},V={MENU:"."+j.MENU};"4"===W.major&&(j.DIVIDER="dropdown-divider",j.SHOW="show",j.BUTTONCLASS="btn-light",j.POPOVERHEADER="popover-header");var F={span:document.createElement("span"),i:document.createElement("i"),subtext:document.createElement("small"),a:document.createElement("a"),li:document.createElement("li"),whitespace:document.createTextNode("\xa0"),fragment:document.createDocumentFragment()};F.a.setAttribute("role","option"),F.subtext.className="text-muted",F.text=F.span.cloneNode(!1),F.text.className="text";var _=new RegExp(N+"|"+R),q=new RegExp("^"+D+"$|"+T),G=function(e,t,i){var n=F.li.cloneNode(!1);return e&&(1===e.nodeType||11===e.nodeType?n.appendChild(e):n.innerHTML=e),void 0!==t&&""!==t&&(n.className=t),null!=i&&n.classList.add("optgroup-"+i),n},K=function(e,t,i){var n=F.a.cloneNode(!0);return e&&(11===e.nodeType?n.appendChild(e):n.insertAdjacentHTML("beforeend",e)),void 0!==t&&""!==t&&(n.className=t),"4"===W.major&&n.classList.add("dropdown-item"),i&&n.setAttribute("style",i),n},Y=function(e,t){var i,n,s=F.text.cloneNode(!1);if(e.optionContent)s.innerHTML=e.optionContent;else{if(s.textContent=e.text,e.optionIcon){var o=F.whitespace.cloneNode(!1);(n=(!0===t?F.i:F.span).cloneNode(!1)).className=e.iconBase+" "+e.optionIcon,F.fragment.appendChild(n),F.fragment.appendChild(o)}e.optionSubtext&&((i=F.subtext.cloneNode(!1)).textContent=e.optionSubtext,s.appendChild(i))}if(!0===t)for(;0<s.childNodes.length;)F.fragment.appendChild(s.childNodes[0]);else F.fragment.appendChild(s);return F.fragment},Z=function(e){var t,i,n=F.text.cloneNode(!1);if(n.innerHTML=e.labelEscaped,e.labelIcon){var s=F.whitespace.cloneNode(!1);(i=F.span.cloneNode(!1)).className=e.iconBase+" "+e.labelIcon,F.fragment.appendChild(i),F.fragment.appendChild(s)}return e.labelSubtext&&((t=F.subtext.cloneNode(!1)).textContent=e.labelSubtext,n.appendChild(t)),F.fragment.appendChild(n),F.fragment},J=function(e,t){var i=this;p.useDefault||(z.valHooks.select.set=p._set,p.useDefault=!0),this.$element=z(e),this.$newElement=null,this.$button=null,this.$menu=null,this.options=t,this.selectpicker={main:{map:{newIndex:{},originalIndex:{}}},current:{map:{}},search:{map:{}},view:{},keydown:{keyHistory:"",resetKeyHistory:{start:function(){return setTimeout(function(){i.selectpicker.keydown.keyHistory=""},800)}}}},null===this.options.title&&(this.options.title=this.$element.attr("title"));var n=this.options.windowPadding;"number"==typeof n&&(this.options.windowPadding=[n,n,n,n]),this.val=J.prototype.val,this.render=J.prototype.render,this.refresh=J.prototype.refresh,this.setStyle=J.prototype.setStyle,this.selectAll=J.prototype.selectAll,this.deselectAll=J.prototype.deselectAll,this.destroy=J.prototype.destroy,this.remove=J.prototype.remove,this.show=J.prototype.show,this.hide=J.prototype.hide,this.init()};function Q(e){var l,a=arguments,c=e;if([].shift.apply(a),!W.success){try{W.full=(z.fn.dropdown.Constructor.VERSION||"").split(" ")[0].split(".")}catch(e){W.full=J.BootstrapVersion.split(" ")[0].split(".")}W.major=W.full[0],W.success=!0,"4"===W.major&&(j.DIVIDER="dropdown-divider",j.SHOW="show",j.BUTTONCLASS="btn-light",J.DEFAULTS.style=j.BUTTONCLASS="btn-light",j.POPOVERHEADER="popover-header")}var t=this.each(function(){var e=z(this);if(e.is("select")){var t=e.data("selectpicker"),i="object"==typeof c&&c;if(t){if(i)for(var n in i)i.hasOwnProperty(n)&&(t.options[n]=i[n])}else{var s=e.data();for(var o in s)s.hasOwnProperty(o)&&-1!==z.inArray(o,d)&&delete s[o];var r=z.extend({},J.DEFAULTS,z.fn.selectpicker.defaults||{},s,i);r.template=z.extend({},J.DEFAULTS.template,z.fn.selectpicker.defaults?z.fn.selectpicker.defaults.template:{},s.template,i.template),e.data("selectpicker",t=new J(this,r))}"string"==typeof c&&(l=t[c]instanceof Function?t[c].apply(t,a):t.options[c])}});return void 0!==l?l:t}J.VERSION="1.13.7",J.BootstrapVersion=W.major,J.DEFAULTS={noneSelectedText:"Nothing selected",noneResultsText:"No results matched {0}",countSelectedText:function(e,t){return 1==e?"{0} item selected":"{0} items selected"},maxOptionsText:function(e,t){return[1==e?"Limit reached ({n} item max)":"Limit reached ({n} items max)",1==t?"Group limit reached ({n} item max)":"Group limit reached ({n} items max)"]},selectAllText:"Select All",deselectAllText:"Deselect All",doneButton:!1,doneButtonText:"Close",multipleSeparator:", ",styleBase:"btn",style:j.BUTTONCLASS,size:"auto",title:null,selectedTextFormat:"values",width:!1,container:!1,hideDisabled:!1,showSubtext:!1,showIcon:!0,showContent:!0,dropupAuto:!0,header:!1,liveSearch:!1,liveSearchPlaceholder:null,liveSearchNormalize:!1,liveSearchStyle:"contains",actionsBox:!1,iconBase:"glyphicon",tickIcon:"glyphicon-ok",showTick:!1,template:{caret:'<span class="caret"></span>'},maxOptions:!1,mobile:!1,selectOnTab:!1,dropdownAlignRight:!1,windowPadding:0,virtualScroll:600,display:!1,sanitize:!0,sanitizeFn:null,whiteList:e},"4"===W.major&&(J.DEFAULTS.style="btn-light",J.DEFAULTS.iconBase="",J.DEFAULTS.tickIcon="bs-ok-default"),J.prototype={constructor:J,init:function(){var i=this,e=this.$element.attr("id");this.selectId=B++,this.$element[0].classList.add("bs-select-hidden"),this.multiple=this.$element.prop("multiple"),this.autofocus=this.$element.prop("autofocus"),this.$newElement=this.createDropdown(),this.$element.after(this.$newElement).prependTo(this.$newElement),this.$button=this.$newElement.children("button"),this.$menu=this.$newElement.children(V.MENU),this.$menuInner=this.$menu.children(".inner"),this.$searchbox=this.$menu.find("input"),this.$element[0].classList.remove("bs-select-hidden"),!0===this.options.dropdownAlignRight&&this.$menu[0].classList.add(j.MENURIGHT),void 0!==e&&this.$button.attr("data-id",e),this.checkDisabled(),this.clickListener(),this.options.liveSearch&&this.liveSearchListener(),this.setStyle(),this.render(),this.setWidth(),this.options.container?this.selectPosition():this.$element.on("hide"+M,function(){if(i.isVirtual()){var e=i.$menuInner[0],t=e.firstChild.cloneNode(!1);e.replaceChild(t,e.firstChild),e.scrollTop=0}}),this.$menu.data("this",this),this.$newElement.data("this",this),this.options.mobile&&this.mobile(),this.$newElement.on({"hide.bs.dropdown":function(e){i.$menuInner.attr("aria-expanded",!1),i.$element.trigger("hide"+M,e)},"hidden.bs.dropdown":function(e){i.$element.trigger("hidden"+M,e)},"show.bs.dropdown":function(e){i.$menuInner.attr("aria-expanded",!0),i.$element.trigger("show"+M,e)},"shown.bs.dropdown":function(e){i.$element.trigger("shown"+M,e)}}),i.$element[0].hasAttribute("required")&&this.$element.on("invalid",function(){i.$button[0].classList.add("bs-invalid"),i.$element.on("shown"+M+".invalid",function(){i.$element.val(i.$element.val()).off("shown"+M+".invalid")}).on("rendered"+M,function(){this.validity.valid&&i.$button[0].classList.remove("bs-invalid"),i.$element.off("rendered"+M)}),i.$button.on("blur"+M,function(){i.$element.trigger("focus").trigger("blur"),i.$button.off("blur"+M)})}),setTimeout(function(){i.createLi(),i.$element.trigger("loaded"+M)})},createDropdown:function(){var e,t=this.multiple||this.options.showTick?" show-tick":"",i=this.autofocus?" autofocus":"",n="",s="",o="",r="";return this.options.header&&(n='<div class="'+j.POPOVERHEADER+'"><button type="button" class="close" aria-hidden="true">&times;</button>'+this.options.header+"</div>"),this.options.liveSearch&&(s='<div class="bs-searchbox"><input type="text" class="form-control" autocomplete="off"'+(null===this.options.liveSearchPlaceholder?"":' placeholder="'+U(this.options.liveSearchPlaceholder)+'"')+' role="textbox" aria-label="Search"></div>'),this.multiple&&this.options.actionsBox&&(o='<div class="bs-actionsbox"><div class="btn-group btn-group-sm btn-block"><button type="button" class="actions-btn bs-select-all btn '+j.BUTTONCLASS+'">'+this.options.selectAllText+'</button><button type="button" class="actions-btn bs-deselect-all btn '+j.BUTTONCLASS+'">'+this.options.deselectAllText+"</button></div></div>"),this.multiple&&this.options.doneButton&&(r='<div class="bs-donebutton"><div class="btn-group btn-block"><button type="button" class="btn btn-sm '+j.BUTTONCLASS+'">'+this.options.doneButtonText+"</button></div></div>"),e='<div class="dropdown bootstrap-select'+t+'"><button type="button" class="'+this.options.styleBase+' dropdown-toggle" '+("static"===this.options.display?'data-display="static"':"")+'data-toggle="dropdown"'+i+' role="button"><div class="filter-option"><div class="filter-option-inner"><div class="filter-option-inner-inner"></div></div> </div>'+("4"===W.major?"":'<span class="bs-caret">'+this.options.template.caret+"</span>")+'</button><div class="'+j.MENU+" "+("4"===W.major?"":j.SHOW)+'" role="combobox">'+n+s+o+'<div class="inner '+j.SHOW+'" role="listbox" aria-expanded="false" tabindex="-1"><ul class="'+j.MENU+" inner "+("4"===W.major?j.SHOW:"")+'"></ul></div>'+r+"</div></div>",z(e)},setPositionData:function(){this.selectpicker.view.canHighlight=[];for(var e=0;e<this.selectpicker.current.data.length;e++){var t=this.selectpicker.current.data[e],i=!0;"divider"===t.type?(i=!1,t.height=this.sizeInfo.dividerHeight):"optgroup-label"===t.type?(i=!1,t.height=this.sizeInfo.dropdownHeaderHeight):t.height=this.sizeInfo.liHeight,t.disabled&&(i=!1),this.selectpicker.view.canHighlight.push(i),t.position=(0===e?0:this.selectpicker.current.data[e-1].position)+t.height}},isVirtual:function(){return!1!==this.options.virtualScroll&&this.selectpicker.main.elements.length>=this.options.virtualScroll||!0===this.options.virtualScroll},createView:function(T,e){e=e||0;var A=this;this.selectpicker.current=T?this.selectpicker.search:this.selectpicker.main;var H,D,N=[];function i(e,t){var i,n,s,o,r,l,a,c,d,h,p=A.selectpicker.current.elements.length,u=[],f=!0,m=A.isVirtual();A.selectpicker.view.scrollTop=e,!0===m&&A.sizeInfo.hasScrollBar&&A.$menu[0].offsetWidth>A.sizeInfo.totalMenuWidth&&(A.sizeInfo.menuWidth=A.$menu[0].offsetWidth,A.sizeInfo.totalMenuWidth=A.sizeInfo.menuWidth+A.sizeInfo.scrollBarWidth,A.$menu.css("min-width",A.sizeInfo.menuWidth)),i=Math.ceil(A.sizeInfo.menuInnerHeight/A.sizeInfo.liHeight*1.5),n=Math.round(p/i)||1;for(var v=0;v<n;v++){var g=(v+1)*i;if(v===n-1&&(g=p),u[v]=[v*i+(v?1:0),g],!p)break;void 0===r&&e<=A.selectpicker.current.data[g-1].position-A.sizeInfo.menuInnerHeight&&(r=v)}if(void 0===r&&(r=0),l=[A.selectpicker.view.position0,A.selectpicker.view.position1],s=Math.max(0,r-1),o=Math.min(n-1,r+1),A.selectpicker.view.position0=Math.max(0,u[s][0])||0,A.selectpicker.view.position1=Math.min(p,u[o][1])||0,a=l[0]!==A.selectpicker.view.position0||l[1]!==A.selectpicker.view.position1,void 0!==A.activeIndex&&(D=A.selectpicker.current.elements[A.selectpicker.current.map.newIndex[A.prevActiveIndex]],N=A.selectpicker.current.elements[A.selectpicker.current.map.newIndex[A.activeIndex]],H=A.selectpicker.current.elements[A.selectpicker.current.map.newIndex[A.selectedIndex]],t&&(A.activeIndex!==A.selectedIndex&&N&&N.length&&(N.classList.remove("active"),N.firstChild&&N.firstChild.classList.remove("active")),A.activeIndex=void 0),A.activeIndex&&A.activeIndex!==A.selectedIndex&&H&&H.length&&(H.classList.remove("active"),H.firstChild&&H.firstChild.classList.remove("active"))),void 0!==A.prevActiveIndex&&A.prevActiveIndex!==A.activeIndex&&A.prevActiveIndex!==A.selectedIndex&&D&&D.length&&(D.classList.remove("active"),D.firstChild&&D.firstChild.classList.remove("active")),(t||a)&&(c=A.selectpicker.view.visibleElements?A.selectpicker.view.visibleElements.slice():[],A.selectpicker.view.visibleElements=A.selectpicker.current.elements.slice(A.selectpicker.view.position0,A.selectpicker.view.position1),A.setOptionStatus(),(T||!1===m&&t)&&(d=c,h=A.selectpicker.view.visibleElements,f=!(d.length===h.length&&d.every(function(e,t){return e===h[t]}))),(t||!0===m)&&f)){var b,w,x=A.$menuInner[0],I=document.createDocumentFragment(),k=x.firstChild.cloneNode(!1),$=!0===m?A.selectpicker.view.visibleElements:A.selectpicker.current.elements,y=[];x.replaceChild(k,x.firstChild);v=0;for(var S=$.length;v<S;v++){var E,C,O=$[v];A.options.sanitize&&(E=O.lastChild)&&(C=A.selectpicker.current.data[v+A.selectpicker.view.position0].data)&&C.content&&!C.sanitized&&(y.push(E),C.sanitized=!0),I.appendChild(O)}A.options.sanitize&&y.length&&P(y,A.options.whiteList,A.options.sanitizeFn),!0===m&&(b=0===A.selectpicker.view.position0?0:A.selectpicker.current.data[A.selectpicker.view.position0-1].position,w=A.selectpicker.view.position1>p-1?0:A.selectpicker.current.data[p-1].position-A.selectpicker.current.data[A.selectpicker.view.position1-1].position,x.firstChild.style.marginTop=b+"px",x.firstChild.style.marginBottom=w+"px"),x.firstChild.appendChild(I)}if(A.prevActiveIndex=A.activeIndex,A.options.liveSearch){if(T&&t){var z,L=0;A.selectpicker.view.canHighlight[L]||(L=1+A.selectpicker.view.canHighlight.slice(1).indexOf(!0)),z=A.selectpicker.view.visibleElements[L],A.selectpicker.view.currentActive&&(A.selectpicker.view.currentActive.classList.remove("active"),A.selectpicker.view.currentActive.firstChild&&A.selectpicker.view.currentActive.firstChild.classList.remove("active")),z&&(z.classList.add("active"),z.firstChild&&z.firstChild.classList.add("active")),A.activeIndex=A.selectpicker.current.map.originalIndex[L]}}else A.$menuInner.trigger("focus")}this.setPositionData(),i(e,!0),this.$menuInner.off("scroll.createView").on("scroll.createView",function(e,t){A.noScroll||i(this.scrollTop,t),A.noScroll=!1}),z(window).off("resize"+M+"."+this.selectId+".createView").on("resize"+M+"."+this.selectId+".createView",function(){A.$newElement.hasClass(j.SHOW)&&i(A.$menuInner[0].scrollTop)})},setPlaceholder:function(){var e=!1;if(this.options.title&&!this.multiple){this.selectpicker.view.titleOption||(this.selectpicker.view.titleOption=document.createElement("option")),e=!0;var t=this.$element[0],i=!1,n=!this.selectpicker.view.titleOption.parentNode;if(n)this.selectpicker.view.titleOption.className="bs-title-option",this.selectpicker.view.titleOption.value="",i=void 0===z(t.options[t.selectedIndex]).attr("selected")&&void 0===this.$element.data("selected");(n||0!==this.selectpicker.view.titleOption.index)&&t.insertBefore(this.selectpicker.view.titleOption,t.firstChild),i&&(t.selectedIndex=0)}return e},createLi:function(){var e,t,i=this,n=i.options.iconBase,s=':not([hidden]):not([data-hidden="true"])',o=[],r=0,l=[],a=0,c=0,d=-1;this.options.hideDisabled&&(s+=":not(:disabled)"),(i.options.showTick||i.multiple)&&((e=F.span.cloneNode(!1)).className=n+" "+i.options.tickIcon+" check-mark",F.a.appendChild(e)),this.setPlaceholder()&&d--;for(var h=this.$element[0].options,p=0,u=h.length;p<u;p++){var f=h[p];if(d++,!f.classList.contains("bs-title-option")){var m,v,g,b,w={content:f.getAttribute("data-content"),tokens:f.getAttribute("data-tokens"),subtext:f.getAttribute("data-subtext"),icon:f.getAttribute("data-icon"),hidden:"true"===f.getAttribute("data-hidden"),divider:"true"===f.getAttribute("data-divider")},x=f.className||"",I=f.style.cssText,k=I?U(I):"",$=w.content,y=f.textContent,S=f.parentNode,E=f.nextElementSibling,C=f.previousElementSibling,O="OPTGROUP"===S.tagName,z=O&&S.disabled,L=f.disabled||z,T=C&&"OPTGROUP"===C.tagName,A={hidden:"true"===S.getAttribute("data-hidden")};if(!0===w.hidden||f.hidden||O&&(!0===A.hidden||S.hidden)||i.options.hideDisabled&&(L||z))m=f.prevHiddenIndex,E&&(E.prevHiddenIndex=void 0!==m?m:p),d--;else{if(E&&void 0!==E.prevHiddenIndex&&(E.prevHiddenIndex=void 0),O&&!0!==w.divider){var H=" "+S.className||"",D=f.previousElementSibling;if(void 0!==(m=f.prevHiddenIndex)&&(D=h[m].previousElementSibling),!D){a+=1,A.subtext=S.getAttribute("data-subtext"),A.icon=S.getAttribute("data-icon");var N=S.label,P=U(N),R=A.subtext,W=A.icon;0!==p&&0<o.length&&(d++,o.push(G(!1,j.DIVIDER,a+"div")),l.push({type:"divider",optID:a})),d++,g=Z({labelEscaped:P,labelSubtext:R,labelIcon:W,iconBase:n}),o.push(G(g,"dropdown-header"+H,a)),l.push({content:P,subtext:R,type:"optgroup-label",optID:a}),c=d-1}v=Y({text:y,optionContent:$,optionSubtext:w.subtext,optionIcon:w.icon,iconBase:n}),o.push(G(K(v,"opt "+x+H,k),"",a)),l.push({content:$||y,subtext:w.subtext,tokens:w.tokens,type:"option",optID:a,headerIndex:c,lastIndex:c+S.querySelectorAll("option"+s).length,originalIndex:p,data:w})}else if(!0===w.divider)o.push(G(!1,j.DIVIDER)),l.push({type:"divider",originalIndex:p,data:w});else{if(i.options.hideDisabled)if(T)C.querySelectorAll("option:disabled").length===C.children.length&&(T=!1);else if(void 0!==(m=f.prevHiddenIndex))if((b=h[m].previousElementSibling)&&"OPTGROUP"===b.tagName&&!b.disabled)b.querySelectorAll("option:disabled").length<b.children.length&&(T=!0);T&&l.length&&"divider"!==l[l.length-1].type&&(d++,o.push(G(!1,j.DIVIDER,a+"div")),l.push({type:"divider",optID:a})),v=Y({text:y,optionContent:$,optionSubtext:w.subtext,optionIcon:w.icon,iconBase:n}),o.push(G(K(v,x,k))),l.push({content:$||y,subtext:w.subtext,tokens:w.tokens,type:"option",originalIndex:p,data:w})}i.selectpicker.main.map.newIndex[p]=d,i.selectpicker.main.map.originalIndex[d]=p;var B=l[l.length-1];B.disabled=L;var M=0;B.content&&(M+=B.content.length),B.subtext&&(M+=B.subtext.length),w.icon&&(M+=1),r<M&&(r=M,t=o[o.length-1])}}}this.selectpicker.main.elements=o,this.selectpicker.main.data=l,this.selectpicker.current=this.selectpicker.main,this.selectpicker.view.widestOption=t},findLis:function(){return this.$menuInner.find(".inner > li")},render:function(){this.setPlaceholder();var e,t,i=this,n=this.$element[0].selectedOptions,s=n.length,o=this.$button[0],r=o.querySelector(".filter-option-inner-inner"),l=document.createTextNode(this.options.multipleSeparator),a=F.fragment.cloneNode(!1),c=!1;if(this.togglePlaceholder(),this.tabIndex(),"static"===this.options.selectedTextFormat)a=Y({text:this.options.title},!0);else if((e=this.multiple&&-1!==this.options.selectedTextFormat.indexOf("count")&&1<s)&&(e=1<(t=this.options.selectedTextFormat.split(">")).length&&s>t[1]||1===t.length&&2<=s),!1===e){for(var d=0;d<s&&d<50;d++){var h=n[d],p={},u={content:h.getAttribute("data-content"),subtext:h.getAttribute("data-subtext"),icon:h.getAttribute("data-icon")};this.multiple&&0<d&&a.appendChild(l.cloneNode(!1)),h.title?p.text=h.title:u.content&&i.options.showContent?(p.optionContent=u.content.toString(),c=!0):(i.options.showIcon&&(p.optionIcon=u.icon,p.iconBase=this.options.iconBase),i.options.showSubtext&&!i.multiple&&u.subtext&&(p.optionSubtext=" "+u.subtext),p.text=h.textContent.trim()),a.appendChild(Y(p,!0))}49<s&&a.appendChild(document.createTextNode("..."))}else{var f=':not([hidden]):not([data-hidden="true"]):not([data-divider="true"])';this.options.hideDisabled&&(f+=":not(:disabled)");var m=this.$element[0].querySelectorAll("select > option"+f+", optgroup"+f+" option"+f).length,v="function"==typeof this.options.countSelectedText?this.options.countSelectedText(s,m):this.options.countSelectedText;a=Y({text:v.replace("{0}",s.toString()).replace("{1}",m.toString())},!0)}if(null==this.options.title&&(this.options.title=this.$element.attr("title")),a.childNodes.length||(a=Y({text:void 0!==this.options.title?this.options.title:this.options.noneSelectedText},!0)),o.title=a.textContent.replace(/<[^>]*>?/g,"").trim(),this.options.sanitize&&c&&P([a],i.options.whiteList,i.options.sanitizeFn),r.innerHTML="",r.appendChild(a),W.major<4&&this.$newElement[0].parentNode.classList.contains("input-group")){var g=o.querySelector(".filter-expand"),b=r.cloneNode(!0);b.className="filter-expand",g?o.replaceChild(b,g):o.appendChild(b)}this.$element.trigger("rendered"+M)},setStyle:function(e,t){var i,n=this.$button[0],s=this.options.style.split(" ");this.$element.attr("class")&&this.$newElement.addClass(this.$element.attr("class").replace(/selectpicker|mobile-device|bs-select-hidden|validate\[.*\]/gi,"")),W.major<4&&this.$newElement[0].classList.add("bs3"),i=e?e.split(" "):s,"add"==t?n.classList.add.apply(n.classList,i):"remove"==t?n.classList.remove.apply(n.classList,i):(n.classList.remove.apply(n.classList,s),n.classList.add.apply(n.classList,i))},liHeight:function(e){if(e||!1!==this.options.size&&!this.sizeInfo){this.sizeInfo||(this.sizeInfo={});var t=document.createElement("div"),i=document.createElement("div"),n=document.createElement("div"),s=document.createElement("ul"),o=document.createElement("li"),r=document.createElement("li"),l=document.createElement("li"),a=document.createElement("a"),c=document.createElement("span"),d=this.options.header&&0<this.$menu.find("."+j.POPOVERHEADER).length?this.$menu.find("."+j.POPOVERHEADER)[0].cloneNode(!0):null,h=this.options.liveSearch?document.createElement("div"):null,p=this.options.actionsBox&&this.multiple&&0<this.$menu.find(".bs-actionsbox").length?this.$menu.find(".bs-actionsbox")[0].cloneNode(!0):null,u=this.options.doneButton&&this.multiple&&0<this.$menu.find(".bs-donebutton").length?this.$menu.find(".bs-donebutton")[0].cloneNode(!0):null,f=this.$element.find("option")[0];if(this.sizeInfo.selectWidth=this.$newElement[0].offsetWidth,c.className="text",a.className="dropdown-item "+(f?f.className:""),t.className=this.$menu[0].parentNode.className+" "+j.SHOW,t.style.width=this.sizeInfo.selectWidth+"px","auto"===this.options.width&&(i.style.minWidth=0),i.className=j.MENU+" "+j.SHOW,n.className="inner "+j.SHOW,s.className=j.MENU+" inner "+("4"===W.major?j.SHOW:""),o.className=j.DIVIDER,r.className="dropdown-header",c.appendChild(document.createTextNode("\u200b")),a.appendChild(c),l.appendChild(a),r.appendChild(c.cloneNode(!0)),this.selectpicker.view.widestOption&&s.appendChild(this.selectpicker.view.widestOption.cloneNode(!0)),s.appendChild(l),s.appendChild(o),s.appendChild(r),d&&i.appendChild(d),h){var m=document.createElement("input");h.className="bs-searchbox",m.className="form-control",h.appendChild(m),i.appendChild(h)}p&&i.appendChild(p),n.appendChild(s),i.appendChild(n),u&&i.appendChild(u),t.appendChild(i),document.body.appendChild(t);var v,g=a.offsetHeight,b=r?r.offsetHeight:0,w=d?d.offsetHeight:0,x=h?h.offsetHeight:0,I=p?p.offsetHeight:0,k=u?u.offsetHeight:0,$=z(o).outerHeight(!0),y=!!window.getComputedStyle&&window.getComputedStyle(i),S=i.offsetWidth,E=y?null:z(i),C={vert:L(y?y.paddingTop:E.css("paddingTop"))+L(y?y.paddingBottom:E.css("paddingBottom"))+L(y?y.borderTopWidth:E.css("borderTopWidth"))+L(y?y.borderBottomWidth:E.css("borderBottomWidth")),horiz:L(y?y.paddingLeft:E.css("paddingLeft"))+L(y?y.paddingRight:E.css("paddingRight"))+L(y?y.borderLeftWidth:E.css("borderLeftWidth"))+L(y?y.borderRightWidth:E.css("borderRightWidth"))},O={vert:C.vert+L(y?y.marginTop:E.css("marginTop"))+L(y?y.marginBottom:E.css("marginBottom"))+2,horiz:C.horiz+L(y?y.marginLeft:E.css("marginLeft"))+L(y?y.marginRight:E.css("marginRight"))+2};n.style.overflowY="scroll",v=i.offsetWidth-S,document.body.removeChild(t),this.sizeInfo.liHeight=g,this.sizeInfo.dropdownHeaderHeight=b,this.sizeInfo.headerHeight=w,this.sizeInfo.searchHeight=x,this.sizeInfo.actionsHeight=I,this.sizeInfo.doneButtonHeight=k,this.sizeInfo.dividerHeight=$,this.sizeInfo.menuPadding=C,this.sizeInfo.menuExtras=O,this.sizeInfo.menuWidth=S,this.sizeInfo.totalMenuWidth=this.sizeInfo.menuWidth,this.sizeInfo.scrollBarWidth=v,this.sizeInfo.selectHeight=this.$newElement[0].offsetHeight,this.setPositionData()}},getSelectPosition:function(){var e,t=z(window),i=this.$newElement.offset(),n=z(this.options.container);this.options.container&&n.length&&!n.is("body")?((e=n.offset()).top+=parseInt(n.css("borderTopWidth")),e.left+=parseInt(n.css("borderLeftWidth"))):e={top:0,left:0};var s=this.options.windowPadding;this.sizeInfo.selectOffsetTop=i.top-e.top-t.scrollTop(),this.sizeInfo.selectOffsetBot=t.height()-this.sizeInfo.selectOffsetTop-this.sizeInfo.selectHeight-e.top-s[2],this.sizeInfo.selectOffsetLeft=i.left-e.left-t.scrollLeft(),this.sizeInfo.selectOffsetRight=t.width()-this.sizeInfo.selectOffsetLeft-this.sizeInfo.selectWidth-e.left-s[1],this.sizeInfo.selectOffsetTop-=s[0],this.sizeInfo.selectOffsetLeft-=s[3]},setMenuSize:function(e){this.getSelectPosition();var t,i,n,s,o,r,l,a=this.sizeInfo.selectWidth,c=this.sizeInfo.liHeight,d=this.sizeInfo.headerHeight,h=this.sizeInfo.searchHeight,p=this.sizeInfo.actionsHeight,u=this.sizeInfo.doneButtonHeight,f=this.sizeInfo.dividerHeight,m=this.sizeInfo.menuPadding,v=0;if(this.options.dropupAuto&&(l=c*this.selectpicker.current.elements.length+m.vert,this.$newElement.toggleClass(j.DROPUP,this.sizeInfo.selectOffsetTop-this.sizeInfo.selectOffsetBot>this.sizeInfo.menuExtras.vert&&l+this.sizeInfo.menuExtras.vert+50>this.sizeInfo.selectOffsetBot)),"auto"===this.options.size)s=3<this.selectpicker.current.elements.length?3*this.sizeInfo.liHeight+this.sizeInfo.menuExtras.vert-2:0,i=this.sizeInfo.selectOffsetBot-this.sizeInfo.menuExtras.vert,n=s+d+h+p+u,r=Math.max(s-m.vert,0),this.$newElement.hasClass(j.DROPUP)&&(i=this.sizeInfo.selectOffsetTop-this.sizeInfo.menuExtras.vert),t=(o=i)-d-h-p-u-m.vert;else if(this.options.size&&"auto"!=this.options.size&&this.selectpicker.current.elements.length>this.options.size){for(var g=0;g<this.options.size;g++)"divider"===this.selectpicker.current.data[g].type&&v++;t=(i=c*this.options.size+v*f+m.vert)-m.vert,o=i+d+h+p+u,n=r=""}"auto"===this.options.dropdownAlignRight&&this.$menu.toggleClass(j.MENURIGHT,this.sizeInfo.selectOffsetLeft>this.sizeInfo.selectOffsetRight&&this.sizeInfo.selectOffsetRight<this.sizeInfo.totalMenuWidth-a),this.$menu.css({"max-height":o+"px",overflow:"hidden","min-height":n+"px"}),this.$menuInner.css({"max-height":t+"px","overflow-y":"auto","min-height":r+"px"}),this.sizeInfo.menuInnerHeight=Math.max(t,1),this.selectpicker.current.data.length&&this.selectpicker.current.data[this.selectpicker.current.data.length-1].position>this.sizeInfo.menuInnerHeight&&(this.sizeInfo.hasScrollBar=!0,this.sizeInfo.totalMenuWidth=this.sizeInfo.menuWidth+this.sizeInfo.scrollBarWidth,this.$menu.css("min-width",this.sizeInfo.totalMenuWidth)),this.dropdown&&this.dropdown._popper&&this.dropdown._popper.update()},setSize:function(e){if(this.liHeight(e),this.options.header&&this.$menu.css("padding-top",0),!1!==this.options.size){var t,i=this,n=z(window),s=0;this.setMenuSize(),this.options.liveSearch&&this.$searchbox.off("input.setMenuSize propertychange.setMenuSize").on("input.setMenuSize propertychange.setMenuSize",function(){return i.setMenuSize()}),"auto"===this.options.size?n.off("resize"+M+"."+this.selectId+".setMenuSize scroll"+M+"."+this.selectId+".setMenuSize").on("resize"+M+"."+this.selectId+".setMenuSize scroll"+M+"."+this.selectId+".setMenuSize",function(){return i.setMenuSize()}):this.options.size&&"auto"!=this.options.size&&this.selectpicker.current.elements.length>this.options.size&&n.off("resize"+M+"."+this.selectId+".setMenuSize scroll"+M+"."+this.selectId+".setMenuSize"),e?s=this.$menuInner[0].scrollTop:i.multiple||"number"==typeof(t=i.selectpicker.main.map.newIndex[i.$element[0].selectedIndex])&&!1!==i.options.size&&(s=(s=i.sizeInfo.liHeight*t)-i.sizeInfo.menuInnerHeight/2+i.sizeInfo.liHeight/2),i.createView(!1,s)}},setWidth:function(){var i=this;"auto"===this.options.width?requestAnimationFrame(function(){i.$menu.css("min-width","0"),i.$element.on("loaded"+M,function(){i.liHeight(),i.setMenuSize();var e=i.$newElement.clone().appendTo("body"),t=e.css("width","auto").children("button").outerWidth();e.remove(),i.sizeInfo.selectWidth=Math.max(i.sizeInfo.totalMenuWidth,t),i.$newElement.css("width",i.sizeInfo.selectWidth+"px")})}):"fit"===this.options.width?(this.$menu.css("min-width",""),this.$newElement.css("width","").addClass("fit-width")):this.options.width?(this.$menu.css("min-width",""),this.$newElement.css("width",this.options.width)):(this.$menu.css("min-width",""),this.$newElement.css("width","")),this.$newElement.hasClass("fit-width")&&"fit"!==this.options.width&&this.$newElement[0].classList.remove("fit-width")},selectPosition:function(){this.$bsContainer=z('<div class="bs-container" />');var n,s,o,r=this,l=z(this.options.container),e=function(e){var t={},i=r.options.display||!!z.fn.dropdown.Constructor.Default&&z.fn.dropdown.Constructor.Default.display;r.$bsContainer.addClass(e.attr("class").replace(/form-control|fit-width/gi,"")).toggleClass(j.DROPUP,e.hasClass(j.DROPUP)),n=e.offset(),l.is("body")?s={top:0,left:0}:((s=l.offset()).top+=parseInt(l.css("borderTopWidth"))-l.scrollTop(),s.left+=parseInt(l.css("borderLeftWidth"))-l.scrollLeft()),o=e.hasClass(j.DROPUP)?0:e[0].offsetHeight,(W.major<4||"static"===i)&&(t.top=n.top-s.top+o,t.left=n.left-s.left),t.width=e[0].offsetWidth,r.$bsContainer.css(t)};this.$button.on("click.bs.dropdown.data-api",function(){r.isDisabled()||(e(r.$newElement),r.$bsContainer.appendTo(r.options.container).toggleClass(j.SHOW,!r.$button.hasClass(j.SHOW)).append(r.$menu))}),z(window).off("resize"+M+"."+this.selectId+" scroll"+M+"."+this.selectId).on("resize"+M+"."+this.selectId+" scroll"+M+"."+this.selectId,function(){r.$newElement.hasClass(j.SHOW)&&e(r.$newElement)}),this.$element.on("hide"+M,function(){r.$menu.data("height",r.$menu.height()),r.$bsContainer.detach()})},setOptionStatus:function(){var e=this,t=this.$element[0].options;if(e.noScroll=!1,e.selectpicker.view.visibleElements&&e.selectpicker.view.visibleElements.length)for(var i=0;i<e.selectpicker.view.visibleElements.length;i++){var n=e.selectpicker.current.map.originalIndex[i+e.selectpicker.view.position0],s=t[n];if(s){var o=this.selectpicker.main.map.newIndex[n],r=this.selectpicker.main.elements[o];e.setDisabled(n,s.disabled||"OPTGROUP"===s.parentNode.tagName&&s.parentNode.disabled,o,r),e.setSelected(n,s.selected,o,r)}}},setSelected:function(e,t,i,n){var s,o,r,l=void 0!==this.activeIndex,a=this.activeIndex===e||t&&!this.multiple&&!l;i||(i=this.selectpicker.main.map.newIndex[e]),n||(n=this.selectpicker.main.elements[i]),r=n.firstChild,t&&(this.selectedIndex=e),n.classList.toggle("selected",t),n.classList.toggle("active",a),a&&(this.selectpicker.view.currentActive=n,this.activeIndex=e),r&&(r.classList.toggle("selected",t),r.classList.toggle("active",a),r.setAttribute("aria-selected",t)),a||!l&&t&&void 0!==this.prevActiveIndex&&(s=this.selectpicker.main.map.newIndex[this.prevActiveIndex],(o=this.selectpicker.main.elements[s]).classList.remove("active"),o.firstChild&&o.firstChild.classList.remove("active"))},setDisabled:function(e,t,i,n){var s;i||(i=this.selectpicker.main.map.newIndex[e]),n||(n=this.selectpicker.main.elements[i]),s=n.firstChild,n.classList.toggle(j.DISABLED,t),s&&("4"===W.major&&s.classList.toggle(j.DISABLED,t),s.setAttribute("aria-disabled",t),t?s.setAttribute("tabindex",-1):s.setAttribute("tabindex",0))},isDisabled:function(){return this.$element[0].disabled},checkDisabled:function(){var e=this;this.isDisabled()?(this.$newElement[0].classList.add(j.DISABLED),this.$button.addClass(j.DISABLED).attr("tabindex",-1).attr("aria-disabled",!0)):(this.$button[0].classList.contains(j.DISABLED)&&(this.$newElement[0].classList.remove(j.DISABLED),this.$button.removeClass(j.DISABLED).attr("aria-disabled",!1)),-1!=this.$button.attr("tabindex")||this.$element.data("tabindex")||this.$button.removeAttr("tabindex")),this.$button.on("click",function(){return!e.isDisabled()})},togglePlaceholder:function(){var e=this.$element[0],t=e.selectedIndex,i=-1===t;i||e.options[t].value||(i=!0),this.$button.toggleClass("bs-placeholder",i)},tabIndex:function(){this.$element.data("tabindex")!==this.$element.attr("tabindex")&&-98!==this.$element.attr("tabindex")&&"-98"!==this.$element.attr("tabindex")&&(this.$element.data("tabindex",this.$element.attr("tabindex")),this.$button.attr("tabindex",this.$element.data("tabindex"))),this.$element.attr("tabindex",-98)},clickListener:function(){var y=this,t=z(document);function e(){y.options.liveSearch?y.$searchbox.trigger("focus"):y.$menuInner.trigger("focus")}function i(){y.dropdown&&y.dropdown._popper&&y.dropdown._popper.state.isCreated?e():requestAnimationFrame(i)}t.data("spaceSelect",!1),this.$button.on("keyup",function(e){/(32)/.test(e.keyCode.toString(10))&&t.data("spaceSelect")&&(e.preventDefault(),t.data("spaceSelect",!1))}),this.$newElement.on("show.bs.dropdown",function(){3<W.major&&!y.dropdown&&(y.dropdown=y.$button.data("bs.dropdown"),y.dropdown._menu=y.$menu[0])}),this.$button.on("click.bs.dropdown.data-api",function(){y.$newElement.hasClass(j.SHOW)||y.setSize()}),this.$element.on("shown"+M,function(){y.$menuInner[0].scrollTop!==y.selectpicker.view.scrollTop&&(y.$menuInner[0].scrollTop=y.selectpicker.view.scrollTop),3<W.major?requestAnimationFrame(i):e()}),this.$menuInner.on("click","li a",function(e,t){var i=z(this),n=y.isVirtual()?y.selectpicker.view.position0:0,s=y.selectpicker.current.map.originalIndex[i.parent().index()+n],o=S(y.$element[0]),r=y.$element.prop("selectedIndex"),l=!0;if(y.multiple&&1!==y.options.maxOptions&&e.stopPropagation(),e.preventDefault(),!y.isDisabled()&&!i.parent().hasClass(j.DISABLED)){var a=y.$element.find("option"),c=a.eq(s),d=c.prop("selected"),h=c.parent("optgroup"),p=h.find("option"),u=y.options.maxOptions,f=h.data("maxOptions")||!1;if(s===y.activeIndex&&(t=!0),t||(y.prevActiveIndex=y.activeIndex,y.activeIndex=void 0),y.multiple){if(c.prop("selected",!d),y.setSelected(s,!d),i.trigger("blur"),!1!==u||!1!==f){var m=u<a.filter(":selected").length,v=f<h.find("option:selected").length;if(u&&m||f&&v)if(u&&1==u){a.prop("selected",!1),c.prop("selected",!0);for(var g=0;g<a.length;g++)y.setSelected(g,!1);y.setSelected(s,!0)}else if(f&&1==f){h.find("option:selected").prop("selected",!1),c.prop("selected",!0);for(g=0;g<p.length;g++){var b=p[g];y.setSelected(a.index(b),!1)}y.setSelected(s,!0)}else{var w="string"==typeof y.options.maxOptionsText?[y.options.maxOptionsText,y.options.maxOptionsText]:y.options.maxOptionsText,x="function"==typeof w?w(u,f):w,I=x[0].replace("{n}",u),k=x[1].replace("{n}",f),$=z('<div class="notify"></div>');x[2]&&(I=I.replace("{var}",x[2][1<u?0:1]),k=k.replace("{var}",x[2][1<f?0:1])),c.prop("selected",!1),y.$menu.append($),u&&m&&($.append(z("<div>"+I+"</div>")),l=!1,y.$element.trigger("maxReached"+M)),f&&v&&($.append(z("<div>"+k+"</div>")),l=!1,y.$element.trigger("maxReachedGrp"+M)),setTimeout(function(){y.setSelected(s,!1)},10),$.delay(750).fadeOut(300,function(){z(this).remove()})}}}else a.prop("selected",!1),c.prop("selected",!0),y.setSelected(s,!0);!y.multiple||y.multiple&&1===y.options.maxOptions?y.$button.trigger("focus"):y.options.liveSearch&&y.$searchbox.trigger("focus"),l&&(o!=S(y.$element[0])&&y.multiple||r!=y.$element.prop("selectedIndex")&&!y.multiple)&&(E=[s,c.prop("selected"),o],y.$element.triggerNative("change"))}}),this.$menu.on("click","li."+j.DISABLED+" a, ."+j.POPOVERHEADER+", ."+j.POPOVERHEADER+" :not(.close)",function(e){e.currentTarget==this&&(e.preventDefault(),e.stopPropagation(),y.options.liveSearch&&!z(e.target).hasClass("close")?y.$searchbox.trigger("focus"):y.$button.trigger("focus"))}),this.$menuInner.on("click",".divider, .dropdown-header",function(e){e.preventDefault(),e.stopPropagation(),y.options.liveSearch?y.$searchbox.trigger("focus"):y.$button.trigger("focus")}),this.$menu.on("click","."+j.POPOVERHEADER+" .close",function(){y.$button.trigger("click")}),this.$searchbox.on("click",function(e){e.stopPropagation()}),this.$menu.on("click",".actions-btn",function(e){y.options.liveSearch?y.$searchbox.trigger("focus"):y.$button.trigger("focus"),e.preventDefault(),e.stopPropagation(),z(this).hasClass("bs-select-all")?y.selectAll():y.deselectAll()}),this.$element.on({change:function(){y.render(),y.$element.trigger("changed"+M,E),E=null},focus:function(){y.options.mobile||y.$button.trigger("focus")}})},liveSearchListener:function(){var u=this,f=document.createElement("li");this.$button.on("click.bs.dropdown.data-api",function(){u.$searchbox.val()&&u.$searchbox.val("")}),this.$searchbox.on("click.bs.dropdown.data-api focus.bs.dropdown.data-api touchend.bs.dropdown.data-api",function(e){e.stopPropagation()}),this.$searchbox.on("input propertychange",function(){var e=u.$searchbox.val();if(u.selectpicker.search.map.newIndex={},u.selectpicker.search.map.originalIndex={},u.selectpicker.search.elements=[],u.selectpicker.search.data=[],e){var t=[],i=e.toUpperCase(),n={},s=[],o=u._searchStyle(),r=u.options.liveSearchNormalize;r&&(i=w(i)),u._$lisSelected=u.$menuInner.find(".selected");for(var l=0;l<u.selectpicker.main.data.length;l++){var a=u.selectpicker.main.data[l];n[l]||(n[l]=$(a,i,o,r)),n[l]&&void 0!==a.headerIndex&&-1===s.indexOf(a.headerIndex)&&(0<a.headerIndex&&(n[a.headerIndex-1]=!0,s.push(a.headerIndex-1)),n[a.headerIndex]=!0,s.push(a.headerIndex),n[a.lastIndex+1]=!0),n[l]&&"optgroup-label"!==a.type&&s.push(l)}l=0;for(var c=s.length;l<c;l++){var d=s[l],h=s[l-1],p=(a=u.selectpicker.main.data[d],u.selectpicker.main.data[h]);("divider"!==a.type||"divider"===a.type&&p&&"divider"!==p.type&&c-1!==l)&&(u.selectpicker.search.data.push(a),t.push(u.selectpicker.main.elements[d]),a.hasOwnProperty("originalIndex")&&(u.selectpicker.search.map.newIndex[a.originalIndex]=t.length-1,u.selectpicker.search.map.originalIndex[t.length-1]=a.originalIndex))}u.activeIndex=void 0,u.noScroll=!0,u.$menuInner.scrollTop(0),u.selectpicker.search.elements=t,u.createView(!0),t.length||(f.className="no-results",f.innerHTML=u.options.noneResultsText.replace("{0}",'"'+U(e)+'"'),u.$menuInner[0].firstChild.appendChild(f))}else u.$menuInner.scrollTop(0),u.createView(!1)})},_searchStyle:function(){return this.options.liveSearchStyle||"contains"},val:function(e){return void 0!==e?(this.$element.val(e).trigger("changed"+M,E),this.render(),E=null,this.$element):this.$element.val()},changeAll:function(e){if(this.multiple){void 0===e&&(e=!0);var t=this.$element[0],i=t.options,n=0,s=0,o=S(t);t.classList.add("bs-select-hidden");for(var r=0,l=this.selectpicker.current.elements.length;r<l;r++){var a=this.selectpicker.current.data[r],c=i[this.selectpicker.current.map.originalIndex[r]];c&&!c.disabled&&"divider"!==a.type&&(c.selected&&n++,(c.selected=e)&&s++)}t.classList.remove("bs-select-hidden"),n!==s&&(this.setOptionStatus(),this.togglePlaceholder(),E=[null,null,o],this.$element.triggerNative("change"))}},selectAll:function(){return this.changeAll(!0)},deselectAll:function(){return this.changeAll(!1)},toggle:function(e){(e=e||window.event)&&e.stopPropagation(),this.$button.trigger("click.bs.dropdown.data-api")},keydown:function(e){var t,i,n,s,o,r=z(this),l=r.hasClass("dropdown-toggle"),a=(l?r.closest(".dropdown"):r.closest(V.MENU)).data("this"),c=a.findLis(),d=!1,h=e.which===D&&!l&&!a.options.selectOnTab,p=_.test(e.which)||h,u=a.$menuInner[0].scrollTop,f=a.isVirtual(),m=!0===f?a.selectpicker.view.position0:0;if(!(i=a.$newElement.hasClass(j.SHOW))&&(p||48<=e.which&&e.which<=57||96<=e.which&&e.which<=105||65<=e.which&&e.which<=90)&&(a.$button.trigger("click.bs.dropdown.data-api"),a.options.liveSearch))a.$searchbox.trigger("focus");else{if(e.which===T&&i&&(e.preventDefault(),a.$button.trigger("click.bs.dropdown.data-api").trigger("focus")),p){if(!c.length)return;void 0===(t=!0===f?c.index(c.filter(".active")):a.selectpicker.current.map.newIndex[a.activeIndex])&&(t=-1),-1!==t&&((n=a.selectpicker.current.elements[t+m]).classList.remove("active"),n.firstChild&&n.firstChild.classList.remove("active")),e.which===N?(-1!==t&&t--,t+m<0&&(t+=c.length),a.selectpicker.view.canHighlight[t+m]||-1===(t=a.selectpicker.view.canHighlight.slice(0,t+m).lastIndexOf(!0)-m)&&(t=c.length-1)):(e.which===R||h)&&(++t+m>=a.selectpicker.view.canHighlight.length&&(t=0),a.selectpicker.view.canHighlight[t+m]||(t=t+1+a.selectpicker.view.canHighlight.slice(t+m+1).indexOf(!0))),e.preventDefault();var v=m+t;e.which===N?0===m&&t===c.length-1?(a.$menuInner[0].scrollTop=a.$menuInner[0].scrollHeight,v=a.selectpicker.current.elements.length-1):d=(o=(s=a.selectpicker.current.data[v]).position-s.height)<u:(e.which===R||h)&&(0===t?v=a.$menuInner[0].scrollTop=0:d=u<(o=(s=a.selectpicker.current.data[v]).position-a.sizeInfo.menuInnerHeight)),(n=a.selectpicker.current.elements[v])&&(n.classList.add("active"),n.firstChild&&n.firstChild.classList.add("active")),a.activeIndex=a.selectpicker.current.map.originalIndex[v],a.selectpicker.view.currentActive=n,d&&(a.$menuInner[0].scrollTop=o),a.options.liveSearch?a.$searchbox.trigger("focus"):r.trigger("focus")}else if(!r.is("input")&&!q.test(e.which)||e.which===H&&a.selectpicker.keydown.keyHistory){var g,b,w=[];e.preventDefault(),a.selectpicker.keydown.keyHistory+=O[e.which],a.selectpicker.keydown.resetKeyHistory.cancel&&clearTimeout(a.selectpicker.keydown.resetKeyHistory.cancel),a.selectpicker.keydown.resetKeyHistory.cancel=a.selectpicker.keydown.resetKeyHistory.start(),b=a.selectpicker.keydown.keyHistory,/^(.)\1+$/.test(b)&&(b=b.charAt(0));for(var x=0;x<a.selectpicker.current.data.length;x++){var I=a.selectpicker.current.data[x];$(I,b,"startsWith",!0)&&a.selectpicker.view.canHighlight[x]&&(I.index=x,w.push(I.originalIndex))}if(w.length){var k=0;c.removeClass("active").find("a").removeClass("active"),1===b.length&&(-1===(k=w.indexOf(a.activeIndex))||k===w.length-1?k=0:k++),g=a.selectpicker.current.map.newIndex[w[k]],d=0<u-(s=a.selectpicker.current.data[g]).position?(o=s.position-s.height,!0):(o=s.position-a.sizeInfo.menuInnerHeight,s.position>u+a.sizeInfo.menuInnerHeight),(n=a.selectpicker.current.elements[g]).classList.add("active"),n.firstChild&&n.firstChild.classList.add("active"),a.activeIndex=w[k],n.firstChild.focus(),d&&(a.$menuInner[0].scrollTop=o),r.trigger("focus")}}i&&(e.which===H&&!a.selectpicker.keydown.keyHistory||e.which===A||e.which===D&&a.options.selectOnTab)&&(e.which!==H&&e.preventDefault(),a.options.liveSearch&&e.which===H||(a.$menuInner.find(".active a").trigger("click",!0),r.trigger("focus"),a.options.liveSearch||(e.preventDefault(),z(document).data("spaceSelect",!0))))}},mobile:function(){this.$element[0].classList.add("mobile-device")},refresh:function(){var e=z.extend({},this.options,this.$element.data());this.options=e,this.selectpicker.main.map.newIndex={},this.selectpicker.main.map.originalIndex={},this.checkDisabled(),this.setStyle(),this.render(),this.createLi(),this.setWidth(),this.setSize(!0),this.$element.trigger("refreshed"+M)},hide:function(){this.$newElement.hide()},show:function(){this.$newElement.show()},remove:function(){this.$newElement.remove(),this.$element.remove()},destroy:function(){this.$newElement.before(this.$element).remove(),this.$bsContainer?this.$bsContainer.remove():this.$menu.remove(),this.$element.off(M).removeData("selectpicker").removeClass("bs-select-hidden selectpicker"),z(window).off(M+"."+this.selectId)}};var X=z.fn.selectpicker;z.fn.selectpicker=Q,z.fn.selectpicker.Constructor=J,z.fn.selectpicker.noConflict=function(){return z.fn.selectpicker=X,this},z(document).off("keydown.bs.dropdown.data-api").on("keydown"+M,'.bootstrap-select [data-toggle="dropdown"], .bootstrap-select [role="listbox"], .bootstrap-select .bs-searchbox input',J.prototype.keydown).on("focusin.modal",'.bootstrap-select [data-toggle="dropdown"], .bootstrap-select [role="listbox"], .bootstrap-select .bs-searchbox input',function(e){e.stopPropagation()}),z(window).on("load"+M+".data-api",function(){z(".selectpicker").each(function(){var e=z(this);Q.call(e,e.data())})})}(e)});
	//# sourceMappingURL=bootstrap-select.min.js.map

/***/ }),
/* 39 */
/***/ (function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ }),
/* 40 */
/***/ (function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ }),
/* 41 */
/***/ (function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ }),
/* 42 */
/***/ (function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ }),
/* 43 */
/***/ (function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	(function() {

	/*! WOW - v1.0.3 - 2015-01-14
	* Copyright (c) 2015 Matthieu Aussaguel; Licensed MIT */(function(){var a,b,c,d,e,f=function(a,b){return function(){return a.apply(b,arguments)}},g=[].indexOf||function(a){for(var b=0,c=this.length;c>b;b++)if(b in this&&this[b]===a)return b;return-1};b=function(){function a(){}return a.prototype.extend=function(a,b){var c,d;for(c in b)d=b[c],null==a[c]&&(a[c]=d);return a},a.prototype.isMobile=function(a){return/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(a)},a.prototype.addEvent=function(a,b,c){return null!=a.addEventListener?a.addEventListener(b,c,!1):null!=a.attachEvent?a.attachEvent("on"+b,c):a[b]=c},a.prototype.removeEvent=function(a,b,c){return null!=a.removeEventListener?a.removeEventListener(b,c,!1):null!=a.detachEvent?a.detachEvent("on"+b,c):delete a[b]},a.prototype.innerHeight=function(){return"innerHeight"in window?window.innerHeight:document.documentElement.clientHeight},a}(),c=this.WeakMap||this.MozWeakMap||(c=function(){function a(){this.keys=[],this.values=[]}return a.prototype.get=function(a){var b,c,d,e,f;for(f=this.keys,b=d=0,e=f.length;e>d;b=++d)if(c=f[b],c===a)return this.values[b]},a.prototype.set=function(a,b){var c,d,e,f,g;for(g=this.keys,c=e=0,f=g.length;f>e;c=++e)if(d=g[c],d===a)return void(this.values[c]=b);return this.keys.push(a),this.values.push(b)},a}()),a=this.MutationObserver||this.WebkitMutationObserver||this.MozMutationObserver||(a=function(){function a(){"undefined"!=typeof console&&null!==console&&console.warn("MutationObserver is not supported by your browser."),"undefined"!=typeof console&&null!==console&&console.warn("WOW.js cannot detect dom mutations, please call .sync() after loading new content.")}return a.notSupported=!0,a.prototype.observe=function(){},a}()),d=this.getComputedStyle||function(a){return this.getPropertyValue=function(b){var c;return"float"===b&&(b="styleFloat"),e.test(b)&&b.replace(e,function(a,b){return b.toUpperCase()}),(null!=(c=a.currentStyle)?c[b]:void 0)||null},this},e=/(\-([a-z]){1})/g,this.WOW=function(){function e(a){null==a&&(a={}),this.scrollCallback=f(this.scrollCallback,this),this.scrollHandler=f(this.scrollHandler,this),this.start=f(this.start,this),this.scrolled=!0,this.config=this.util().extend(a,this.defaults),this.animationNameCache=new c}return e.prototype.defaults={boxClass:"wow",animateClass:"animated",offset:0,mobile:!0,live:!0,callback:null},e.prototype.init=function(){var a;return this.element=window.document.documentElement,"interactive"===(a=document.readyState)||"complete"===a?this.start():this.util().addEvent(document,"DOMContentLoaded",this.start),this.finished=[]},e.prototype.start=function(){var b,c,d,e;if(this.stopped=!1,this.boxes=function(){var a,c,d,e;for(d=this.element.querySelectorAll("."+this.config.boxClass),e=[],a=0,c=d.length;c>a;a++)b=d[a],e.push(b);return e}.call(this),this.all=function(){var a,c,d,e;for(d=this.boxes,e=[],a=0,c=d.length;c>a;a++)b=d[a],e.push(b);return e}.call(this),this.boxes.length)if(this.disabled())this.resetStyle();else for(e=this.boxes,c=0,d=e.length;d>c;c++)b=e[c],this.applyStyle(b,!0);return this.disabled()||(this.util().addEvent(window,"scroll",this.scrollHandler),this.util().addEvent(window,"resize",this.scrollHandler),this.interval=setInterval(this.scrollCallback,50)),this.config.live?new a(function(a){return function(b){var c,d,e,f,g;for(g=[],e=0,f=b.length;f>e;e++)d=b[e],g.push(function(){var a,b,e,f;for(e=d.addedNodes||[],f=[],a=0,b=e.length;b>a;a++)c=e[a],f.push(this.doSync(c));return f}.call(a));return g}}(this)).observe(document.body,{childList:!0,subtree:!0}):void 0},e.prototype.stop=function(){return this.stopped=!0,this.util().removeEvent(window,"scroll",this.scrollHandler),this.util().removeEvent(window,"resize",this.scrollHandler),null!=this.interval?clearInterval(this.interval):void 0},e.prototype.sync=function(){return a.notSupported?this.doSync(this.element):void 0},e.prototype.doSync=function(a){var b,c,d,e,f;if(null==a&&(a=this.element),1===a.nodeType){for(a=a.parentNode||a,e=a.querySelectorAll("."+this.config.boxClass),f=[],c=0,d=e.length;d>c;c++)b=e[c],g.call(this.all,b)<0?(this.boxes.push(b),this.all.push(b),this.stopped||this.disabled()?this.resetStyle():this.applyStyle(b,!0),f.push(this.scrolled=!0)):f.push(void 0);return f}},e.prototype.show=function(a){return this.applyStyle(a),a.className=""+a.className+" "+this.config.animateClass,null!=this.config.callback?this.config.callback(a):void 0},e.prototype.applyStyle=function(a,b){var c,d,e;return d=a.getAttribute("data-wow-duration"),c=a.getAttribute("data-wow-delay"),e=a.getAttribute("data-wow-iteration"),this.animate(function(f){return function(){return f.customStyle(a,b,d,c,e)}}(this))},e.prototype.animate=function(){return"requestAnimationFrame"in window?function(a){return window.requestAnimationFrame(a)}:function(a){return a()}}(),e.prototype.resetStyle=function(){var a,b,c,d,e;for(d=this.boxes,e=[],b=0,c=d.length;c>b;b++)a=d[b],e.push(a.style.visibility="visible");return e},e.prototype.customStyle=function(a,b,c,d,e){return b&&this.cacheAnimationName(a),a.style.visibility=b?"hidden":"visible",c&&this.vendorSet(a.style,{animationDuration:c}),d&&this.vendorSet(a.style,{animationDelay:d}),e&&this.vendorSet(a.style,{animationIterationCount:e}),this.vendorSet(a.style,{animationName:b?"none":this.cachedAnimationName(a)}),a},e.prototype.vendors=["moz","webkit"],e.prototype.vendorSet=function(a,b){var c,d,e,f;f=[];for(c in b)d=b[c],a[""+c]=d,f.push(function(){var b,f,g,h;for(g=this.vendors,h=[],b=0,f=g.length;f>b;b++)e=g[b],h.push(a[""+e+c.charAt(0).toUpperCase()+c.substr(1)]=d);return h}.call(this));return f},e.prototype.vendorCSS=function(a,b){var c,e,f,g,h,i;for(e=d(a),c=e.getPropertyCSSValue(b),i=this.vendors,g=0,h=i.length;h>g;g++)f=i[g],c=c||e.getPropertyCSSValue("-"+f+"-"+b);return c},e.prototype.animationName=function(a){var b;try{b=this.vendorCSS(a,"animation-name").cssText}catch(c){b=d(a).getPropertyValue("animation-name")}return"none"===b?"":b},e.prototype.cacheAnimationName=function(a){return this.animationNameCache.set(a,this.animationName(a))},e.prototype.cachedAnimationName=function(a){return this.animationNameCache.get(a)},e.prototype.scrollHandler=function(){return this.scrolled=!0},e.prototype.scrollCallback=function(){var a;return!this.scrolled||(this.scrolled=!1,this.boxes=function(){var b,c,d,e;for(d=this.boxes,e=[],b=0,c=d.length;c>b;b++)a=d[b],a&&(this.isVisible(a)?this.show(a):e.push(a));return e}.call(this),this.boxes.length||this.config.live)?void 0:this.stop()},e.prototype.offsetTop=function(a){for(var b;void 0===a.offsetTop;)a=a.parentNode;for(b=a.offsetTop;a=a.offsetParent;)b+=a.offsetTop;return b},e.prototype.isVisible=function(a){var b,c,d,e,f;return c=a.getAttribute("data-wow-offset")||this.config.offset,f=window.pageYOffset,e=f+Math.min(this.element.clientHeight,this.util().innerHeight())-c,d=this.offsetTop(a),b=d+a.clientHeight,e>=d&&b>=f},e.prototype.util=function(){return null!=this._util?this._util:this._util=new b},e.prototype.disabled=function(){return!this.config.mobile&&this.util().isMobile(navigator.userAgent)},e}()}).call(this);
	}.call(window));

/***/ }),
/* 44 */
/***/ (function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	    patternLock.js v 1.0.2
	    Author: Sudhanshu Yadav
	    Copyright (c) 2015,2016 Sudhanshu Yadav - ignitersworld.com , released under the MIT license.
	    Demo on: ignitersworld.com/lab/patternLock.html
	*/
	!function(t){var e=Function("return this")()||(42,eval)("this"); true?!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(28)], __WEBPACK_AMD_DEFINE_RESULT__ = function(n){return e.PatternLock=t(n,e)}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)):"object"==typeof module&&module.exports?module.exports=e.document?t(require("jquery"),e):function(e){if(!e.document)throw new Error("patternLock requires a window with a document");return t(require("jquery")(e),e)}:e.PatternLock=t(e.jQuery,e)}(function(t,e,n){"use strict";function i(t){for(var e=t.holder,n=t.option,i=n.matrix,r=n.margin,a=n.radius,o=['<ul class="patt-wrap" style="padding:'+r+'px">'],s=0,l=i[0]*i[1];l>s;s++)o.push('<li class="patt-circ" style="margin:'+r+"px; width : "+2*a+"px; height : "+2*a+"px; -webkit-border-radius: "+a+"px; -moz-border-radius: "+a+"px; border-radius: "+a+'px; "><div class="patt-dots"></div></li>');o.push("</ul>"),e.html(o.join("")).css({width:i[1]*(2*a+2*r)+2*r+"px",height:i[0]*(2*a+2*r)+2*r+"px"}),t.pattCircle=t.holder.find(".patt-circ")}function r(t,e,n,i){var r=e-t,a=i-n;return{length:Math.ceil(Math.sqrt(r*r+a*a)),angle:Math.round(180*Math.atan2(a,r)/Math.PI)}}function a(){}function o(e,n){var r=this,s=r.token=Math.random(),u=d[s]=new a,c=u.holder=t(e);if(0!==c.length){u.object=r,n=n||{};var h={onDraw:l},f=n.matrix;f&&f[0]*f[1]>9&&(h.delimiter=","),n=u.option=t.extend({},o.defaults,h,n),i(u),c.addClass("patt-holder"),"static"==c.css("position")&&c.css("position","relative"),c.on("touchstart mousedown",function(t){p.call(this,t,r)});var m=n.mapper;"object"==typeof m?u.mapperFunc=function(t){return m[t]}:"function"==typeof m?u.mapperFunc=m:u.mapperFunc=l,u.option.mapper=null}}var s=e.document,l=function(){},d={},p=function(e,n){e.preventDefault();var i=d[n.token];if(!i.disabled){i.option.patternVisible||i.holder.addClass("patt-hidden");var r="touchstart"==e.type?"touchmove":"mousemove",a="touchstart"==e.type?"touchend":"mouseup";t(this).on(r+".pattern-move",function(t){u.call(this,t,n)}),t(s).one(a,function(){c.call(this,e,n)});var o=i.holder.find(".patt-wrap"),l=o[0].getBoundingClientRect();i.wrapTop=l.top,i.wrapLeft=l.left,n.reset()}},u=function(e,n){e.preventDefault();var i=e.clientX||e.originalEvent.touches[0].clientX,a=e.clientY||e.originalEvent.touches[0].clientY,o=d[n.token],s=o.option,l=o.pattCircle,p=o.patternAry,u=o.getIdxFromPoint(i,a),c=u.idx,h=o.mapperFunc(c)||c;if(p.length>0){var f=r(o.lineX1,u.x,o.lineY1,u.y);o.line.css({width:f.length+10+"px",transform:"rotate("+f.angle+"deg)"})}if(c&&(s.allowRepeat&&p[p.length-1]!==h||-1===p.indexOf(h))){var m=t(l[c-1]);if(o.lastPosObj)for(var v=o.lastPosObj,g=v.i,x=v.j,j=u.i-v.i>0?1:-1,w=u.j-v.j>0?1:-1,b=Math.abs(u.i-g),y=Math.abs(u.j-x);0===b&&y>1||0===y&&b>1||y==b&&y>1;){g=b?g+j:g,x=y?x+w:x,b=Math.abs(u.i-g),y=Math.abs(u.j-x);var P=(x-1)*s.matrix[1]+g,k=o.mapperFunc(P)||P;(s.allowRepeat||-1==p.indexOf(k))&&(o.addDirectionClass({i:g,j:x}),o.markPoint(t(l[k-1]),k),o.addLine({i:g,j:x}))}o.lastPosObj&&o.addDirectionClass(u),o.markPoint(m,h),o.addLine(u),o.lastPosObj=u}},c=function(t,e){t.preventDefault();var n=d[e.token],i=n.option,r=n.patternAry.join(i.delimiter);n.holder.off(".pattern-move").removeClass("patt-hidden"),r&&(i.onDraw(r),n.line.remove(),n.rightPattern&&(r==n.rightPattern?n.onSuccess():(n.onError(),e.error())))};return a.prototype={constructor:a,getIdxFromPoint:function(t,e){var n=this.option,i=n.matrix,r=t-this.wrapLeft,a=e-this.wrapTop,o=null,s=n.margin,l=2*n.radius+2*s,d=Math.ceil(r/l),p=Math.ceil(a/l),u=r%l,c=a%l;return d<=i[1]&&p<=i[0]&&u>2*s&&c>2*s&&(o=(p-1)*i[1]+d),{idx:o,i:d,j:p,x:r,y:a}},markPoint:function(t,e){t.addClass("hovered"),this.patternAry.push(e),this.lastElm=t},addLine:function(e){var n=this,i=n.patternAry,a=n.option,o=a.lineOnMove,s=a.margin,l=a.radius,d=(e.i-1)*(2*s+2*l)+2*s+l,p=(e.j-1)*(2*s+2*l)+2*s+l;if(i.length>1){var u=r(n.lineX1,d,n.lineY1,p);n.line.css({width:u.length+10+"px",transform:"rotate("+u.angle+"deg)"}),o||n.line.show()}var c=t('<div class="patt-lines" style="top:'+(p-5)+"px; left:"+(d-5)+'px"></div>');n.line=c,n.lineX1=d,n.lineY1=p,n.holder.append(c),o||n.line.hide()},addDirectionClass:function(t){var e=this.lastElm,n=this.line,i=this.lastPosObj,r=[];t.j-i.j>0?r.push("s"):t.j-i.j<0?r.push("n"):0,t.i-i.i>0?r.push("e"):t.i-i.i<0?r.push("w"):0,r=r.join("-"),r&&e.add(n).addClass(r+" dir")}},o.prototype={constructor:o,option:function(t,e){var r=d[this.token],a=r.option;return e===n?a[t]:(a[t]=e,void(("margin"==t||"matrix"==t||"radius"==t)&&i(r)))},getPattern:function(){var t=d[this.token];return(t.patternAry||[]).join(t.option.delimiter)},setPattern:function(t){var e=d[this.token],n=e.option,i=n.matrix,r=n.margin,a=n.radius;if(n.enableSetPattern){"string"==typeof t&&(t=t.split(n.delimiter)),this.reset(),e.wrapLeft=0,e.wrapTop=0;for(var o=0;o<t.length;o++){var s=t[o]-1,p=s%i[1],c=Math.floor(s/i[1]),h=p*(2*r+2*a)+2*r+a,f=c*(2*r+2*a)+2*r+a;u.call(null,{clientX:h,clientY:f,preventDefault:l},this)}}},enable:function(){var t=d[this.token];t.disabled=!1},disable:function(){var t=d[this.token];t.disabled=!0},reset:function(){var t=d[this.token];t.pattCircle.removeClass("hovered dir s n w e s-w s-e n-w n-e"),t.holder.find(".patt-lines").remove(),t.patternAry=[],t.lastPosObj=null,t.holder.removeClass("patt-error")},error:function(){d[this.token].holder.addClass("patt-error")},checkForPattern:function(t,e,n){var i=d[this.token];i.rightPattern=t,i.onSuccess=e||l,i.onError=n||l}},o.defaults={matrix:[3,3],margin:20,radius:25,patternVisible:!0,lineOnMove:!0,delimiter:"",enableSetPattern:!1,allowRepeat:!1},o});


/***/ }),
/* 46 */
/***/ (function(module, exports) {

	/**
	 * @license Highcharts JS v5.0.14 (2017-07-28)
	 *
	 * (c) 2009-2016 Torstein Honsi
	 *
	 * License: www.highcharts.com/license
	 */
	//modified version 0928
	'use strict';
	(function(root, factory) {
	    if (typeof module === 'object' && module.exports) {
	        module.exports = root.document ?
	            factory(root) :
	            factory;
	    } else {
	        root.Highcharts = factory(root);
	    }
	}(typeof window !== 'undefined' ? window : this, function(win) {
	    var Highcharts = (function() {
	        /**
	         * (c) 2010-2017 Torstein Honsi
	         *
	         * License: www.highcharts.com/license
	         */
	        /* global window */
	        var win = window,
	            doc = win.document;

	        var SVG_NS = 'http://www.w3.org/2000/svg',
	            userAgent = (win.navigator && win.navigator.userAgent) || '',
	            svg = doc && doc.createElementNS && !!doc.createElementNS(SVG_NS, 'svg').createSVGRect,
	            isMS = /(edge|msie|trident)/i.test(userAgent) && !window.opera,
	            vml = !svg,
	            isFirefox = /Firefox/.test(userAgent),
	            hasBidiBug = isFirefox && parseInt(userAgent.split('Firefox/')[1], 10) < 4; // issue #38

	        var Highcharts = win.Highcharts ? win.Highcharts.error(16, true) : {
	            product: 'Highcharts',
	            version: '5.0.14',
	            deg2rad: Math.PI * 2 / 360,
	            doc: doc,
	            hasBidiBug: hasBidiBug,
	            hasTouch: doc && doc.documentElement.ontouchstart !== undefined,
	            isMS: isMS,
	            isWebKit: /AppleWebKit/.test(userAgent),
	            isFirefox: isFirefox,
	            isTouchDevice: /(Mobile|Android|Windows Phone)/.test(userAgent),
	            SVG_NS: SVG_NS,
	            chartCount: 0,
	            seriesTypes: {},
	            symbolSizes: {},
	            svg: svg,
	            vml: vml,
	            win: win,
	            marginNames: ['plotTop', 'marginRight', 'marginBottom', 'plotLeft'],
	            noop: function() {
	                return undefined;
	            },
	            /**
	             * An array containing the current chart objects in the page. A chart's
	             * position in the array is preserved throughout the page's lifetime. When
	             * a chart is destroyed, the array item becomes `undefined`.
	             * @type {Array.<Highcharts.Chart>}
	             * @memberOf Highcharts
	             */
	            charts: []
	        };
	        return Highcharts;
	    }());
	    (function(H) {
	        /**
	         * (c) 2010-2017 Torstein Honsi
	         *
	         * License: www.highcharts.com/license
	         */
	        /* eslint max-len: ["warn", 80, 4] */

	        /**
	         * The Highcharts object is the placeholder for all other members, and various
	         * utility functions. The most important member of the namespace would be the
	         * chart constructor.
	         *
	         * @example
	         * var chart = Highcharts.chart('container', { ... });
	         * 
	         * @namespace Highcharts
	         */

	        var timers = [];

	        var charts = H.charts,
	            doc = H.doc,
	            win = H.win;

	        /**
	         * Provide error messages for debugging, with links to online explanation. This
	         * function can be overridden to provide custom error handling.
	         *
	         * @function #error
	         * @memberOf Highcharts
	         * @param {Number|String} code - The error code. See [errors.xml]{@link 
	         *     https://github.com/highcharts/highcharts/blob/master/errors/errors.xml}
	         *     for available codes. If it is a string, the error message is printed
	         *     directly in the console.
	         * @param {Boolean} [stop=false] - Whether to throw an error or just log a 
	         *     warning in the console.
	         *
	         * @sample highcharts/chart/highcharts-error/ Custom error handler
	         */
	        H.error = function(code, stop) {
	            var msg = H.isNumber(code) ?
	                'Highcharts error #' + code + ': www.highcharts.com/errors/' + code :
	                code;
	            if (stop) {
	                throw new Error(msg);
	            }
	            // else ...
	            if (win.console) {
	                console.log(msg); // eslint-disable-line no-console
	            }
	        };

	        /**
	         * An animator object used internally. One instance applies to one property
	         * (attribute or style prop) on one element. Animation is always initiated
	         * through {@link SVGElement#animate}.
	         *
	         * @constructor Fx
	         * @memberOf Highcharts
	         * @param {HTMLDOMElement|SVGElement} elem - The element to animate.
	         * @param {AnimationOptions} options - Animation options.
	         * @param {string} prop - The single attribute or CSS property to animate.
	         * @private
	         *
	         * @example
	         * var rect = renderer.rect(0, 0, 10, 10).add();
	         * rect.animate({ width: 100 });
	         */
	        H.Fx = function(elem, options, prop) {
	            this.options = options;
	            this.elem = elem;
	            this.prop = prop;
	        };
	        H.Fx.prototype = {

	            /**
	             * Set the current step of a path definition on SVGElement.
	             *
	             * @function #dSetter
	             * @memberOf Highcharts.Fx
	             */
	            dSetter: function() {
	                var start = this.paths[0],
	                    end = this.paths[1],
	                    ret = [],
	                    now = this.now,
	                    i = start.length,
	                    startVal;

	                // Land on the final path without adjustment points appended in the ends
	                if (now === 1) {
	                    ret = this.toD;

	                } else if (i === end.length && now < 1) {
	                    while (i--) {
	                        startVal = parseFloat(start[i]);
	                        ret[i] =
	                            isNaN(startVal) ? // a letter instruction like M or L
	                            start[i] :
	                            now * (parseFloat(end[i] - startVal)) + startVal;

	                    }
	                    // If animation is finished or length not matching, land on right value
	                } else {
	                    ret = end;
	                }
	                this.elem.attr('d', ret, null, true);
	            },

	            /**
	             * Update the element with the current animation step.
	             *
	             * @function #update
	             * @memberOf Highcharts.Fx
	             */
	            update: function() {
	                var elem = this.elem,
	                    prop = this.prop, // if destroyed, it is null
	                    now = this.now,
	                    step = this.options.step;

	                // Animation setter defined from outside
	                if (this[prop + 'Setter']) {
	                    this[prop + 'Setter']();

	                    // Other animations on SVGElement
	                } else if (elem.attr) {
	                    if (elem.element) {
	                        elem.attr(prop, now, null, true);
	                    }

	                    // HTML styles, raw HTML content like container size
	                } else {
	                    elem.style[prop] = now + this.unit;
	                }

	                if (step) {
	                    step.call(elem, now, this);
	                }

	            },

	            /**
	             * Run an animation.
	             *
	             * @function #run
	             * @memberOf Highcharts.Fx
	             * @param {Number} from - The current value, value to start from.
	             * @param {Number} to - The end value, value to land on.
	             * @param {String} [unit] - The property unit, for example `px`.
	             * 
	             */
	            run: function(from, to, unit) {
	                var self = this,
	                    timer = function(gotoEnd) {
	                        return timer.stopped ? false : self.step(gotoEnd);
	                    },
	                    i;

	                this.startTime = +new Date();
	                this.start = from;
	                this.end = to;
	                this.unit = unit;
	                this.now = this.start;
	                this.pos = 0;

	                timer.elem = this.elem;
	                timer.prop = this.prop;

	                if (timer() && timers.push(timer) === 1) {
	                    timer.timerId = setInterval(function() {

	                        for (i = 0; i < timers.length; i++) {
	                            if (!timers[i]()) {
	                                timers.splice(i--, 1);
	                            }
	                        }

	                        if (!timers.length) {
	                            clearInterval(timer.timerId);
	                        }
	                    }, 13);
	                }
	            },

	            /**
	             * Run a single step in the animation.
	             *
	             * @function #step
	             * @memberOf Highcharts.Fx
	             * @param   {Boolean} [gotoEnd] - Whether to go to the endpoint of the
	             *     animation after abort.
	             * @returns {Boolean} Returns `true` if animation continues.
	             */
	            step: function(gotoEnd) {
	                var t = +new Date(),
	                    ret,
	                    done,
	                    options = this.options,
	                    elem = this.elem,
	                    complete = options.complete,
	                    duration = options.duration,
	                    curAnim = options.curAnim;

	                if (elem.attr && !elem.element) { // #2616, element is destroyed
	                    ret = false;

	                } else if (gotoEnd || t >= duration + this.startTime) {
	                    this.now = this.end;
	                    this.pos = 1;
	                    this.update();

	                    curAnim[this.prop] = true;

	                    done = true;

	                    H.objectEach(curAnim, function(val) {
	                        if (val !== true) {
	                            done = false;
	                        }
	                    });

	                    if (done && complete) {
	                        complete.call(elem);
	                    }
	                    ret = false;

	                } else {
	                    this.pos = options.easing((t - this.startTime) / duration);
	                    this.now = this.start + ((this.end - this.start) * this.pos);
	                    this.update();
	                    ret = true;
	                }
	                return ret;
	            },

	            /**
	             * Prepare start and end values so that the path can be animated one to one.
	             *
	             * @function #initPath
	             * @memberOf Highcharts.Fx
	             * @param {SVGElement} elem - The SVGElement item.
	             * @param {String} fromD - Starting path definition.
	             * @param {Array} toD - Ending path definition.
	             * @returns {Array} An array containing start and end paths in array form
	             * so that they can be animated in parallel.
	             */
	            initPath: function(elem, fromD, toD) {
	                fromD = fromD || '';
	                var shift,
	                    startX = elem.startX,
	                    endX = elem.endX,
	                    bezier = fromD.indexOf('C') > -1,
	                    numParams = bezier ? 7 : 3,
	                    fullLength,
	                    slice,
	                    i,
	                    start = fromD.split(' '),
	                    end = toD.slice(), // copy
	                    isArea = elem.isArea,
	                    positionFactor = isArea ? 2 : 1,
	                    reverse;

	                /**
	                 * In splines make moveTo and lineTo points have six parameters like
	                 * bezier curves, to allow animation one-to-one.
	                 */
	                function sixify(arr) {
	                    var isOperator,
	                        nextIsOperator;
	                    i = arr.length;
	                    while (i--) {

	                        // Fill in dummy coordinates only if the next operator comes
	                        // three places behind (#5788)
	                        isOperator = arr[i] === 'M' || arr[i] === 'L';
	                        nextIsOperator = /[a-zA-Z]/.test(arr[i + 3]);
	                        if (isOperator && nextIsOperator) {
	                            arr.splice(
	                                i + 1, 0,
	                                arr[i + 1], arr[i + 2],
	                                arr[i + 1], arr[i + 2]
	                            );
	                        }
	                    }
	                }

	                /**
	                 * Insert an array at the given position of another array
	                 */
	                function insertSlice(arr, subArr, index) {
	                    [].splice.apply(
	                        arr, [index, 0].concat(subArr)
	                    );
	                }

	                /**
	                 * If shifting points, prepend a dummy point to the end path. 
	                 */
	                function prepend(arr, other) {
	                    while (arr.length < fullLength) {

	                        // Move to, line to or curve to?
	                        arr[0] = other[fullLength - arr.length];

	                        // Prepend a copy of the first point
	                        insertSlice(arr, arr.slice(0, numParams), 0);

	                        // For areas, the bottom path goes back again to the left, so we
	                        // need to append a copy of the last point.
	                        if (isArea) {
	                            insertSlice(
	                                arr,
	                                arr.slice(arr.length - numParams), arr.length
	                            );
	                            i--;
	                        }
	                    }
	                    arr[0] = 'M';
	                }

	                /**
	                 * Copy and append last point until the length matches the end length
	                 */
	                function append(arr, other) {
	                    var i = (fullLength - arr.length) / numParams;
	                    while (i > 0 && i--) {

	                        // Pull out the slice that is going to be appended or inserted.
	                        // In a line graph, the positionFactor is 1, and the last point
	                        // is sliced out. In an area graph, the positionFactor is 2,
	                        // causing the middle two points to be sliced out, since an area
	                        // path starts at left, follows the upper path then turns and
	                        // follows the bottom back. 
	                        slice = arr.slice().splice(
	                            (arr.length / positionFactor) - numParams,
	                            numParams * positionFactor
	                        );

	                        // Move to, line to or curve to?
	                        slice[0] = other[fullLength - numParams - (i * numParams)];

	                        // Disable first control point
	                        if (bezier) {
	                            slice[numParams - 6] = slice[numParams - 2];
	                            slice[numParams - 5] = slice[numParams - 1];
	                        }

	                        // Now insert the slice, either in the middle (for areas) or at
	                        // the end (for lines)
	                        insertSlice(arr, slice, arr.length / positionFactor);

	                        if (isArea) {
	                            i--;
	                        }
	                    }
	                }

	                if (bezier) {
	                    sixify(start);
	                    sixify(end);
	                }

	                // For sideways animation, find out how much we need to shift to get the
	                // start path Xs to match the end path Xs.
	                if (startX && endX) {
	                    for (i = 0; i < startX.length; i++) {
	                        // Moving left, new points coming in on right
	                        if (startX[i] === endX[0]) {
	                            shift = i;
	                            break;
	                            // Moving right
	                        } else if (startX[0] ===
	                            endX[endX.length - startX.length + i]) {
	                            shift = i;
	                            reverse = true;
	                            break;
	                        }
	                    }
	                    if (shift === undefined) {
	                        start = [];
	                    }
	                }

	                if (start.length && H.isNumber(shift)) {

	                    // The common target length for the start and end array, where both 
	                    // arrays are padded in opposite ends
	                    fullLength = end.length + shift * positionFactor * numParams;

	                    if (!reverse) {
	                        prepend(end, start);
	                        append(start, end);
	                    } else {
	                        prepend(start, end);
	                        append(end, start);
	                    }
	                }

	                return [start, end];
	            }
	        }; // End of Fx prototype

	        /**
	         * Handle animation of the color attributes directly.
	         */
	        H.Fx.prototype.fillSetter =
	            H.Fx.prototype.strokeSetter = function() {
	                this.elem.attr(
	                    this.prop,
	                    H.color(this.start).tweenTo(H.color(this.end), this.pos),
	                    null,
	                    true
	                );
	            };


	        /**
	         * Utility function to extend an object with the members of another.
	         *
	         * @function #extend
	         * @memberOf Highcharts
	         * @param {Object} a - The object to be extended.
	         * @param {Object} b - The object to add to the first one.
	         * @returns {Object} Object a, the original object.
	         */
	        H.extend = function(a, b) {
	            var n;
	            if (!a) {
	                a = {};
	            }
	            for (n in b) {
	                a[n] = b[n];
	            }
	            return a;
	        };

	        /**
	         * Utility function to deep merge two or more objects and return a third object.
	         * If the first argument is true, the contents of the second object is copied
	         * into the first object. The merge function can also be used with a single 
	         * object argument to create a deep copy of an object.
	         *
	         * @function #merge
	         * @memberOf Highcharts
	         * @param {Boolean} [extend] - Whether to extend the left-side object (a) or
	                  return a whole new object.
	         * @param {Object} a - The first object to extend. When only this is given, the
	                  function returns a deep copy.
	         * @param {...Object} [n] - An object to merge into the previous one.
	         * @returns {Object} - The merged object. If the first argument is true, the 
	         * return is the same as the second argument.
	         */
	        H.merge = function() {
	            var i,
	                args = arguments,
	                len,
	                ret = {},
	                doCopy = function(copy, original) {
	                    // An object is replacing a primitive
	                    if (typeof copy !== 'object') {
	                        copy = {};
	                    }

	                    H.objectEach(original, function(value, key) {

	                        // Copy the contents of objects, but not arrays or DOM nodes
	                        if (
	                            H.isObject(value, true) &&
	                            !H.isClass(value) &&
	                            !H.isDOMElement(value)
	                        ) {
	                            copy[key] = doCopy(copy[key] || {}, value);

	                            // Primitives and arrays are copied over directly
	                        } else {
	                            copy[key] = original[key];
	                        }
	                    });
	                    return copy;
	                };

	            // If first argument is true, copy into the existing object. Used in
	            // setOptions.
	            if (args[0] === true) {
	                ret = args[1];
	                args = Array.prototype.slice.call(args, 2);
	            }

	            // For each argument, extend the return
	            len = args.length;
	            for (i = 0; i < len; i++) {
	                ret = doCopy(ret, args[i]);
	            }

	            return ret;
	        };

	        /**
	         * Shortcut for parseInt
	         * @ignore
	         * @param {Object} s
	         * @param {Number} mag Magnitude
	         */
	        H.pInt = function(s, mag) {
	            return parseInt(s, mag || 10);
	        };

	        /**
	         * Utility function to check for string type.
	         *
	         * @function #isString
	         * @memberOf Highcharts
	         * @param {Object} s - The item to check.
	         * @returns {Boolean} - True if the argument is a string.
	         */
	        H.isString = function(s) {
	            return typeof s === 'string';
	        };

	        /**
	         * Utility function to check if an item is an array.
	         *
	         * @function #isArray
	         * @memberOf Highcharts
	         * @param {Object} obj - The item to check.
	         * @returns {Boolean} - True if the argument is an array.
	         */
	        H.isArray = function(obj) {
	            var str = Object.prototype.toString.call(obj);
	            return str === '[object Array]' || str === '[object Array Iterator]';
	        };

	        /**
	         * Utility function to check if an item is of type object.
	         *
	         * @function #isObject
	         * @memberOf Highcharts
	         * @param {Object} obj - The item to check.
	         * @param {Boolean} [strict=false] - Also checks that the object is not an
	         *    array.
	         * @returns {Boolean} - True if the argument is an object.
	         */
	        H.isObject = function(obj, strict) {
	            return !!obj && typeof obj === 'object' && (!strict || !H.isArray(obj));
	        };

	        /**
	         * Utility function to check if an Object is a HTML Element.
	         *
	         * @function #isDOMElement
	         * @memberOf Highcharts
	         * @param {Object} obj - The item to check.
	         * @returns {Boolean} - True if the argument is a HTML Element.
	         */
	        H.isDOMElement = function(obj) {
	            return H.isObject(obj) && typeof obj.nodeType === 'number';
	        };

	        /**
	         * Utility function to check if an Object is an class.
	         *
	         * @function #isClass
	         * @memberOf Highcharts
	         * @param {Object} obj - The item to check.
	         * @returns {Boolean} - True if the argument is an class.
	         */
	        H.isClass = function(obj) {
	            var c = obj && obj.constructor;
	            return !!(
	                H.isObject(obj, true) &&
	                !H.isDOMElement(obj) &&
	                (c && c.name && c.name !== 'Object')
	            );
	        };

	        /**
	         * Utility function to check if an item is of type number.
	         *
	         * @function #isNumber
	         * @memberOf Highcharts
	         * @param {Object} n - The item to check.
	         * @returns {Boolean} - True if the item is a number and is not NaN.
	         */
	        H.isNumber = function(n) {
	            return typeof n === 'number' && !isNaN(n);
	        };

	        /**
	         * Remove the last occurence of an item from an array.
	         *
	         * @function #erase
	         * @memberOf Highcharts
	         * @param {Array} arr - The array.
	         * @param {*} item - The item to remove.
	         */
	        H.erase = function(arr, item) {
	            var i = arr.length;
	            while (i--) {
	                if (arr[i] === item) {
	                    arr.splice(i, 1);
	                    break;
	                }
	            }
	        };

	        /**
	         * Check if an object is null or undefined.
	         *
	         * @function #defined
	         * @memberOf Highcharts
	         * @param {Object} obj - The object to check.
	         * @returns {Boolean} - False if the object is null or undefined, otherwise
	         *        true.
	         */
	        H.defined = function(obj) {
	            return obj !== undefined && obj !== null;
	        };

	        /**
	         * Set or get an attribute or an object of attributes. To use as a setter, pass
	         * a key and a value, or let the second argument be a collection of keys and
	         * values. To use as a getter, pass only a string as the second argument.
	         *
	         * @function #attr
	         * @memberOf Highcharts
	         * @param {Object} elem - The DOM element to receive the attribute(s).
	         * @param {String|Object} [prop] - The property or an object of key-value pairs.
	         * @param {String} [value] - The value if a single property is set.
	         * @returns {*} When used as a getter, return the value.
	         */
	        H.attr = function(elem, prop, value) {
	            var ret;

	            // if the prop is a string
	            if (H.isString(prop)) {
	                // set the value
	                if (H.defined(value)) {
	                    elem.setAttribute(prop, value);

	                    // get the value
	                } else if (elem && elem.getAttribute) {
	                    ret = elem.getAttribute(prop);
	                }

	                // else if prop is defined, it is a hash of key/value pairs
	            } else if (H.defined(prop) && H.isObject(prop)) {
	                H.objectEach(prop, function(val, key) {
	                    elem.setAttribute(key, val);
	                });
	            }
	            return ret;
	        };

	        /**
	         * Check if an element is an array, and if not, make it into an array.
	         *
	         * @function #splat
	         * @memberOf Highcharts
	         * @param obj {*} - The object to splat.
	         * @returns {Array} The produced or original array.
	         */
	        H.splat = function(obj) {
	            return H.isArray(obj) ? obj : [obj];
	        };

	        /**
	         * Set a timeout if the delay is given, otherwise perform the function
	         * synchronously.
	         *
	         * @function #syncTimeout
	         * @memberOf Highcharts
	         * @param   {Function} fn - The function callback.
	         * @param   {Number}   delay - Delay in milliseconds.
	         * @param   {Object}   [context] - The context.
	         * @returns {Number} An identifier for the timeout that can later be cleared
	         * with clearTimeout.
	         */
	        H.syncTimeout = function(fn, delay, context) {
	            if (delay) {
	                return setTimeout(fn, delay, context);
	            }
	            fn.call(0, context);
	        };


	        /**
	         * Return the first value that is not null or undefined.
	         *
	         * @function #pick
	         * @memberOf Highcharts
	         * @param {...*} items - Variable number of arguments to inspect.
	         * @returns {*} The value of the first argument that is not null or undefined.
	         */
	        H.pick = function() {
	            var args = arguments,
	                i,
	                arg,
	                length = args.length;
	            for (i = 0; i < length; i++) {
	                arg = args[i];
	                if (arg !== undefined && arg !== null) {
	                    return arg;
	                }
	            }
	        };

	        /**
	         * @typedef {Object} CSSObject - A style object with camel case property names.
	         * The properties can be whatever styles are supported on the given SVG or HTML
	         * element.
	         * @example
	         * {
	         *    fontFamily: 'monospace',
	         *    fontSize: '1.2em'
	         * }
	         */
	        /**
	         * Set CSS on a given element.
	         *
	         * @function #css
	         * @memberOf Highcharts
	         * @param {HTMLDOMElement} el - A HTML DOM element.
	         * @param {CSSObject} styles - Style object with camel case property names.
	         * 
	         */
	        H.css = function(el, styles) {
	            if (H.isMS && !H.svg) { // #2686
	                if (styles && styles.opacity !== undefined) {
	                    styles.filter = 'alpha(opacity=' + (styles.opacity * 100) + ')';
	                }
	            }
	            H.extend(el.style, styles);
	        };

	        /**
	         * A HTML DOM element.
	         * @typedef {Object} HTMLDOMElement
	         */

	        /**
	         * Utility function to create an HTML element with attributes and styles.
	         *
	         * @function #createElement
	         * @memberOf Highcharts
	         * @param {String} tag - The HTML tag.
	         * @param {Object} [attribs] - Attributes as an object of key-value pairs.
	         * @param {CSSObject} [styles] - Styles as an object of key-value pairs.
	         * @param {Object} [parent] - The parent HTML object.
	         * @param {Boolean} [nopad=false] - If true, remove all padding, border and
	         *    margin.
	         * @returns {HTMLDOMElement} The created DOM element.
	         */
	        H.createElement = function(tag, attribs, styles, parent, nopad) {
	            var el = doc.createElement(tag),
	                css = H.css;
	            if (attribs) {
	                H.extend(el, attribs);
	            }
	            if (nopad) {
	                css(el, {
	                    padding: 0,
	                    border: 'none',
	                    margin: 0
	                });
	            }
	            if (styles) {
	                css(el, styles);
	            }
	            if (parent) {
	                parent.appendChild(el);
	            }
	            return el;
	        };

	        /**
	         * Extend a prototyped class by new members.
	         *
	         * @function #extendClass
	         * @memberOf Highcharts
	         * @param {Object} parent - The parent prototype to inherit.
	         * @param {Object} members - A collection of prototype members to add or
	         *        override compared to the parent prototype.
	         * @returns {Object} A new prototype.
	         */
	        H.extendClass = function(parent, members) {
	            var object = function() {};
	            object.prototype = new parent(); // eslint-disable-line new-cap
	            H.extend(object.prototype, members);
	            return object;
	        };

	        /**
	         * Left-pad a string to a given length by adding a character repetetively.
	         *
	         * @function #pad
	         * @memberOf Highcharts
	         * @param {Number} number - The input string or number.
	         * @param {Number} length - The desired string length.
	         * @param {String} [padder=0] - The character to pad with.
	         * @returns {String} The padded string.
	         */
	        H.pad = function(number, length, padder) {
	            return new Array((length || 2) + 1 -
	                String(number).length).join(padder || 0) + number;
	        };

	        /**
	         * @typedef {Number|String} RelativeSize - If a number is given, it defines the
	         *    pixel length. If a percentage string is given, like for example `'50%'`,
	         *    the setting defines a length relative to a base size, for example the size
	         *    of a container.
	         */
	        /**
	         * Return a length based on either the integer value, or a percentage of a base.
	         *
	         * @function #relativeLength
	         * @memberOf Highcharts
	         * @param  {RelativeSize} value
	         *         A percentage string or a number.
	         * @param  {number} base
	         *         The full length that represents 100%.
	         * @param  {number} [offset=0]
	         *         A pixel offset to apply for percentage values. Used internally in 
	         *         axis positioning.
	         * @return {number}
	         *         The computed length.
	         */
	        H.relativeLength = function(value, base, offset) {
	            return (/%$/).test(value) ?
	                (base * parseFloat(value) / 100) + (offset || 0) :
	                parseFloat(value);
	        };

	        /**
	         * Wrap a method with extended functionality, preserving the original function.
	         *
	         * @function #wrap
	         * @memberOf Highcharts
	         * @param {Object} obj - The context object that the method belongs to. In real
	         *        cases, this is often a prototype.
	         * @param {String} method - The name of the method to extend.
	         * @param {Function} func - A wrapper function callback. This function is called
	         *        with the same arguments as the original function, except that the
	         *        original function is unshifted and passed as the first argument.
	         * 
	         */
	        H.wrap = function(obj, method, func) {
	            var proceed = obj[method];
	            obj[method] = function() {
	                var args = Array.prototype.slice.call(arguments),
	                    outerArgs = arguments,
	                    ctx = this,
	                    ret;
	                ctx.proceed = function() {
	                    proceed.apply(ctx, arguments.length ? arguments : outerArgs);
	                };
	                args.unshift(proceed);
	                ret = func.apply(this, args);
	                ctx.proceed = null;
	                return ret;
	            };
	        };

	        /**
	         * Get the time zone offset based on the current timezone information as set in
	         * the global options.
	         *
	         * @function #getTZOffset
	         * @memberOf Highcharts
	         * @param  {Number} timestamp - The JavaScript timestamp to inspect.
	         * @return {Number} - The timezone offset in minutes compared to UTC.
	         */
	        H.getTZOffset = function(timestamp) {
	            var d = H.Date;
	            return ((d.hcGetTimezoneOffset && d.hcGetTimezoneOffset(timestamp)) ||
	                d.hcTimezoneOffset || 0) * 60000;
	        };

	        /**
	         * Formats a JavaScript date timestamp (milliseconds since Jan 1st 1970) into a
	         * human readable date string. The format is a subset of the formats for PHP's
	         * [strftime]{@link
	         * http://www.php.net/manual/en/function.strftime.php} function. Additional
	         * formats can be given in the {@link Highcharts.dateFormats} hook.
	         *
	         * @function #dateFormat
	         * @memberOf Highcharts
	         * @param {String} format - The desired format where various time
	         *        representations are prefixed with %.
	         * @param {Number} timestamp - The JavaScript timestamp.
	         * @param {Boolean} [capitalize=false] - Upper case first letter in the return.
	         * @returns {String} The formatted date.
	         */
	        H.dateFormat = function(format, timestamp, capitalize) {
	            if (!H.defined(timestamp) || isNaN(timestamp)) {
	                return H.defaultOptions.lang.invalidDate || '';
	            }
	            format = H.pick(format, '%Y-%m-%d %H:%M:%S');

	            var D = H.Date,
	                date = new D(timestamp - H.getTZOffset(timestamp)),
	                // get the basic time values
	                hours = date[D.hcGetHours](),
	                day = date[D.hcGetDay](),
	                dayOfMonth = date[D.hcGetDate](),
	                month = date[D.hcGetMonth](),
	                fullYear = date[D.hcGetFullYear](),
	                lang = H.defaultOptions.lang,
	                langWeekdays = lang.weekdays,
	                shortWeekdays = lang.shortWeekdays,
	                pad = H.pad,

	                // List all format keys. Custom formats can be added from the outside. 
	                replacements = H.extend({

	                        //-- Day
	                        // Short weekday, like 'Mon'
	                        'a': shortWeekdays ?
	                            shortWeekdays[day] : langWeekdays[day].substr(0, 3),
	                        // Long weekday, like 'Monday'
	                        'A': langWeekdays[day],
	                        // Two digit day of the month, 01 to 31
	                        'd': pad(dayOfMonth),
	                        // Day of the month, 1 through 31
	                        'e': pad(dayOfMonth, 2, ' '),
	                        'w': day,

	                        // Week (none implemented)
	                        //'W': weekNumber(),

	                        //-- Month
	                        // Short month, like 'Jan'
	                        'b': lang.shortMonths[month],
	                        // Long month, like 'January'
	                        'B': lang.months[month],
	                        // Two digit month number, 01 through 12
	                        'm': pad(month + 1),

	                        //-- Year
	                        // Two digits year, like 09 for 2009
	                        'y': fullYear.toString().substr(2, 2),
	                        // Four digits year, like 2009
	                        'Y': fullYear,

	                        //-- Time
	                        // Two digits hours in 24h format, 00 through 23
	                        'H': pad(hours),
	                        // Hours in 24h format, 0 through 23
	                        'k': hours,
	                        // Two digits hours in 12h format, 00 through 11
	                        'I': pad((hours % 12) || 12),
	                        // Hours in 12h format, 1 through 12
	                        'l': (hours % 12) || 12,
	                        // Two digits minutes, 00 through 59
	                        'M': pad(date[D.hcGetMinutes]()),
	                        // Upper case AM or PM
	                        'p': hours < 12 ? 'AM' : 'PM',
	                        // Lower case AM or PM
	                        'P': hours < 12 ? 'am' : 'pm',
	                        // Two digits seconds, 00 through  59
	                        'S': pad(date.getSeconds()),
	                        // Milliseconds (naming from Ruby)
	                        'L': pad(Math.round(timestamp % 1000), 3)
	                    },

	                    /**
	                     * A hook for defining additional date format specifiers. New
	                     * specifiers are defined as key-value pairs by using the specifier
	                     * as key, and a function which takes the timestamp as value. This
	                     * function returns the formatted portion of the date.
	                     *
	                     * @type {Object}
	                     * @name dateFormats
	                     * @memberOf Highcharts
	                     * @sample highcharts/global/dateformats/ Adding support for week
	                     * number
	                     */
	                    H.dateFormats
	                );


	            // Do the replaces
	            H.objectEach(replacements, function(val, key) {
	                // Regex would do it in one line, but this is faster
	                while (format.indexOf('%' + key) !== -1) {
	                    format = format.replace(
	                        '%' + key,
	                        typeof val === 'function' ? val(timestamp) : val
	                    );
	                }

	            });

	            // Optionally capitalize the string and return
	            return capitalize ?
	                format.substr(0, 1).toUpperCase() + format.substr(1) :
	                format;
	        };

	        /**
	         * Format a single variable. Similar to sprintf, without the % prefix.
	         *
	         * @example
	         * formatSingle('.2f', 5); // => '5.00'.
	         *
	         * @function #formatSingle
	         * @memberOf Highcharts
	         * @param {String} format The format string.
	         * @param {*} val The value.
	         * @returns {String} The formatted representation of the value.
	         */
	        H.formatSingle = function(format, val) {
	            var floatRegex = /f$/,
	                decRegex = /\.([0-9])/,
	                lang = H.defaultOptions.lang,
	                decimals;

	            if (floatRegex.test(format)) { // float
	                decimals = format.match(decRegex);
	                decimals = decimals ? decimals[1] : -1;
	                if (val !== null) {
	                    val = H.numberFormat(
	                        val,
	                        decimals,
	                        lang.decimalPoint,
	                        format.indexOf(',') > -1 ? lang.thousandsSep : ''
	                    );
	                }
	            } else {
	                val = H.dateFormat(format, val);
	            }
	            return val;
	        };

	        /**
	         * Format a string according to a subset of the rules of Python's String.format
	         * method.
	         *
	         * @function #format
	         * @memberOf Highcharts
	         * @param {String} str The string to format.
	         * @param {Object} ctx The context, a collection of key-value pairs where each
	         *        key is replaced by its value.
	         * @returns {String} The formatted string.
	         *
	         * @example
	         * var s = Highcharts.format(
	         *     'The {color} fox was {len:.2f} feet long',
	         *     { color: 'red', len: Math.PI }
	         * );
	         * // => The red fox was 3.14 feet long
	         */
	        H.format = function(str, ctx) {
	            var splitter = '{',
	                isInside = false,
	                segment,
	                valueAndFormat,
	                path,
	                i,
	                len,
	                ret = [],
	                val,
	                index;

	            while (str) {
	                index = str.indexOf(splitter);
	                if (index === -1) {
	                    break;
	                }

	                segment = str.slice(0, index);
	                if (isInside) { // we're on the closing bracket looking back

	                    valueAndFormat = segment.split(':');
	                    path = valueAndFormat.shift().split('.'); // get first and leave
	                    len = path.length;
	                    val = ctx;

	                    // Assign deeper paths
	                    for (i = 0; i < len; i++) {
	                        val = val[path[i]];
	                    }

	                    // Format the replacement
	                    if (valueAndFormat.length) {
	                        val = H.formatSingle(valueAndFormat.join(':'), val);
	                    }

	                    // Push the result and advance the cursor
	                    ret.push(val);

	                } else {
	                    ret.push(segment);

	                }
	                str = str.slice(index + 1); // the rest
	                isInside = !isInside; // toggle
	                splitter = isInside ? '}' : '{'; // now look for next matching bracket
	            }
	            ret.push(str);
	            return ret.join('');
	        };

	        /**
	         * Get the magnitude of a number.
	         *
	         * @function #getMagnitude
	         * @memberOf Highcharts
	         * @param {Number} number The number.
	         * @returns {Number} The magnitude, where 1-9 are magnitude 1, 10-99 magnitude 2
	         *        etc.
	         */
	        H.getMagnitude = function(num) {
	            return Math.pow(10, Math.floor(Math.log(num) / Math.LN10));
	        };

	        /**
	         * Take an interval and normalize it to multiples of round numbers.
	         *
	         * @todo  Move this function to the Axis prototype. It is here only for
	         *        historical reasons.
	         * @function #normalizeTickInterval
	         * @memberOf Highcharts
	         * @param {Number} interval - The raw, un-rounded interval.
	         * @param {Array} [multiples] - Allowed multiples.
	         * @param {Number} [magnitude] - The magnitude of the number.
	         * @param {Boolean} [allowDecimals] - Whether to allow decimals.
	         * @param {Boolean} [hasTickAmount] - If it has tickAmount, avoid landing
	         *        on tick intervals lower than original.
	         * @returns {Number} The normalized interval.
	         */
	        H.normalizeTickInterval = function(interval, multiples, magnitude,
	            allowDecimals, hasTickAmount) {
	            var normalized,
	                i,
	                retInterval = interval;

	            // round to a tenfold of 1, 2, 2.5 or 5
	            magnitude = H.pick(magnitude, 1);
	            normalized = interval / magnitude;

	            // multiples for a linear scale
	            if (!multiples) {
	                multiples = hasTickAmount ?
	                    // Finer grained ticks when the tick amount is hard set, including
	                    // when alignTicks is true on multiple axes (#4580).
	                    [1, 1.2, 1.5, 2, 2.5, 3, 4, 5, 6, 8, 10] :

	                    // Else, let ticks fall on rounder numbers
	                    [1, 2, 2.5, 5, 10];


	                // the allowDecimals option
	                if (allowDecimals === false) {
	                    if (magnitude === 1) {
	                        multiples = H.grep(multiples, function(num) {
	                            return num % 1 === 0;
	                        });
	                    } else if (magnitude <= 0.1) {
	                        multiples = [1 / magnitude];
	                    }
	                }
	            }

	            // normalize the interval to the nearest multiple
	            for (i = 0; i < multiples.length; i++) {
	                retInterval = multiples[i];
	                // only allow tick amounts smaller than natural
	                if ((hasTickAmount && retInterval * magnitude >= interval) ||
	                    (!hasTickAmount && (normalized <= (multiples[i] +
	                        (multiples[i + 1] || multiples[i])) / 2))) {
	                    break;
	                }
	            }

	            // Multiply back to the correct magnitude. Correct floats to appropriate 
	            // precision (#6085).
	            retInterval = H.correctFloat(
	                retInterval * magnitude, -Math.round(Math.log(0.001) / Math.LN10)
	            );

	            return retInterval;
	        };


	        /**
	         * Sort an object array and keep the order of equal items. The ECMAScript
	         * standard does not specify the behaviour when items are equal.
	         *
	         * @function #stableSort
	         * @memberOf Highcharts
	         * @param {Array} arr - The array to sort.
	         * @param {Function} sortFunction - The function to sort it with, like with 
	         *        regular Array.prototype.sort.
	         * 
	         */
	        H.stableSort = function(arr, sortFunction) {
	            var length = arr.length,
	                sortValue,
	                i;

	            // Add index to each item
	            for (i = 0; i < length; i++) {
	                arr[i].safeI = i; // stable sort index
	            }

	            arr.sort(function(a, b) {
	                sortValue = sortFunction(a, b);
	                return sortValue === 0 ? a.safeI - b.safeI : sortValue;
	            });

	            // Remove index from items
	            for (i = 0; i < length; i++) {
	                delete arr[i].safeI; // stable sort index
	            }
	        };

	        /**
	         * Non-recursive method to find the lowest member of an array. `Math.min` raises
	         * a maximum call stack size exceeded error in Chrome when trying to apply more
	         * than 150.000 points. This method is slightly slower, but safe.
	         *
	         * @function #arrayMin
	         * @memberOf  Highcharts
	         * @param {Array} data An array of numbers.
	         * @returns {Number} The lowest number.
	         */
	        H.arrayMin = function(data) {
	            var i = data.length,
	                min = data[0];

	            while (i--) {
	                if (data[i] < min) {
	                    min = data[i];
	                }
	            }
	            return min;
	        };

	        /**
	         * Non-recursive method to find the lowest member of an array. `Math.max` raises
	         * a maximum call stack size exceeded error in Chrome when trying to apply more
	         * than 150.000 points. This method is slightly slower, but safe.
	         *
	         * @function #arrayMax
	         * @memberOf  Highcharts
	         * @param {Array} data - An array of numbers.
	         * @returns {Number} The highest number.
	         */
	        H.arrayMax = function(data) {
	            var i = data.length,
	                max = data[0];

	            while (i--) {
	                if (data[i] > max) {
	                    max = data[i];
	                }
	            }
	            return max;
	        };

	        /**
	         * Utility method that destroys any SVGElement instances that are properties on
	         * the given object. It loops all properties and invokes destroy if there is a
	         * destroy method. The property is then delete.
	         *
	         * @function #destroyObjectProperties
	         * @memberOf Highcharts
	         * @param {Object} obj - The object to destroy properties on.
	         * @param {Object} [except] - Exception, do not destroy this property, only
	         *    delete it.
	         * 
	         */
	        H.destroyObjectProperties = function(obj, except) {
	            H.objectEach(obj, function(val, n) {
	                // If the object is non-null and destroy is defined
	                if (val && val !== except && val.destroy) {
	                    // Invoke the destroy
	                    val.destroy();
	                }

	                // Delete the property from the object.
	                delete obj[n];
	            });
	        };


	        /**
	         * Discard a HTML element by moving it to the bin and delete.
	         *
	         * @function #discardElement
	         * @memberOf Highcharts
	         * @param {HTMLDOMElement} element - The HTML node to discard.
	         * 
	         */
	        H.discardElement = function(element) {
	            var garbageBin = H.garbageBin;
	            // create a garbage bin element, not part of the DOM
	            if (!garbageBin) {
	                garbageBin = H.createElement('div');
	            }

	            // move the node and empty bin
	            if (element) {
	                garbageBin.appendChild(element);
	            }
	            garbageBin.innerHTML = '';
	        };

	        /**
	         * Fix JS round off float errors.
	         *
	         * @function #correctFloat
	         * @memberOf Highcharts
	         * @param {Number} num - A float number to fix.
	         * @param {Number} [prec=14] - The precision.
	         * @returns {Number} The corrected float number.
	         */
	        H.correctFloat = function(num, prec) {
	            return parseFloat(
	                num.toPrecision(prec || 14)
	            );
	        };

	        /**
	         * Set the global animation to either a given value, or fall back to the given
	         * chart's animation option.
	         *
	         * @function #setAnimation
	         * @memberOf Highcharts
	         * @param {Boolean|Animation} animation - The animation object.
	         * @param {Object} chart - The chart instance.
	         * 
	         * @todo This function always relates to a chart, and sets a property on the
	         *        renderer, so it should be moved to the SVGRenderer.
	         */
	        H.setAnimation = function(animation, chart) {
	            chart.renderer.globalAnimation = H.pick(
	                animation,
	                chart.options.chart.animation,
	                true
	            );
	        };

	        /**
	         * Get the animation in object form, where a disabled animation is always
	         * returned as `{ duration: 0 }`.
	         *
	         * @function #animObject
	         * @memberOf Highcharts
	         * @param {Boolean|AnimationOptions} animation - An animation setting. Can be an
	         *        object with duration, complete and easing properties, or a boolean to
	         *        enable or disable.
	         * @returns {AnimationOptions} An object with at least a duration property.
	         */
	        H.animObject = function(animation) {
	            return H.isObject(animation) ?
	                H.merge(animation) : {
	                    duration: 0
	                };
	        };

	        /**
	         * The time unit lookup
	         */
	        H.timeUnits = {
	            millisecond: 1,
	            second: 1000,
	            minute: 60000,
	            hour: 3600000,
	            day: 24 * 3600000,
	            week: 7 * 24 * 3600000,
	            month: 28 * 24 * 3600000,
	            year: 364 * 24 * 3600000
	        };

	        /**
	         * Format a number and return a string based on input settings.
	         *
	         * @function #numberFormat
	         * @memberOf Highcharts
	         * @param {Number} number - The input number to format.
	         * @param {Number} decimals - The amount of decimals. A value of -1 preserves
	         *        the amount in the input number.
	         * @param {String} [decimalPoint] - The decimal point, defaults to the one given
	         *        in the lang options, or a dot.
	         * @param {String} [thousandsSep] - The thousands separator, defaults to the one
	         *        given in the lang options, or a space character.
	         * @returns {String} The formatted number.
	         *
	         * @sample members/highcharts-numberformat/ Custom number format
	         */
	        H.numberFormat = function(number, decimals, decimalPoint, thousandsSep) {
	            number = +number || 0;
	            decimals = +decimals;

	            var lang = H.defaultOptions.lang,
	                origDec = (number.toString().split('.')[1] || '').split('e')[0].length,
	                strinteger,
	                thousands,
	                ret,
	                roundedNumber,
	                exponent = number.toString().split('e');

	            if (decimals === -1) {
	                // Preserve decimals. Not huge numbers (#3793).
	                decimals = Math.min(origDec, 20);
	            } else if (!H.isNumber(decimals)) {
	                decimals = 2;
	            }

	            // Add another decimal to avoid rounding errors of float numbers. (#4573)
	            // Then use toFixed to handle rounding.
	            roundedNumber = (
	                Math.abs(exponent[1] ? exponent[0] : number) +
	                Math.pow(10, -Math.max(decimals, origDec) - 1)
	            ).toFixed(decimals);

	            // A string containing the positive integer component of the number
	            strinteger = String(H.pInt(roundedNumber));

	            // Leftover after grouping into thousands. Can be 0, 1 or 3.
	            thousands = strinteger.length > 3 ? strinteger.length % 3 : 0;

	            // Language
	            decimalPoint = H.pick(decimalPoint, lang.decimalPoint);
	            thousandsSep = H.pick(thousandsSep, lang.thousandsSep);

	            // Start building the return
	            ret = number < 0 ? '-' : '';

	            // Add the leftover after grouping into thousands. For example, in the
	            // number 42 000 000, this line adds 42.
	            ret += thousands ? strinteger.substr(0, thousands) + thousandsSep : '';

	            // Add the remaining thousands groups, joined by the thousands separator
	            ret += strinteger
	                .substr(thousands)
	                .replace(/(\d{3})(?=\d)/g, '$1' + thousandsSep);

	            // Add the decimal point and the decimal component
	            if (decimals) {
	                // Get the decimal component
	                ret += decimalPoint + roundedNumber.slice(-decimals);
	            }

	            if (exponent[1]) {
	                ret += 'e' + exponent[1];
	            }

	            return ret;
	        };

	        /**
	         * Easing definition
	         * @ignore
	         * @param   {Number} pos Current position, ranging from 0 to 1.
	         */
	        Math.easeInOutSine = function(pos) {
	            return -0.5 * (Math.cos(Math.PI * pos) - 1);
	        };

	        /**
	         * Get the computed CSS value for given element and property, only for numerical
	         * properties. For width and height, the dimension of the inner box (excluding
	         * padding) is returned. Used for fitting the chart within the container.
	         *
	         * @function #getStyle
	         * @memberOf Highcharts
	         * @param {HTMLDOMElement} el - A HTML element.
	         * @param {String} prop - The property name.
	         * @param {Boolean} [toInt=true] - Parse to integer.
	         * @returns {Number} - The numeric value.
	         */
	        H.getStyle = function(el, prop, toInt) {

	            var style;

	            // For width and height, return the actual inner pixel size (#4913)
	            if (prop === 'width') {
	                return Math.min(el.offsetWidth, el.scrollWidth) -
	                    H.getStyle(el, 'padding-left') -
	                    H.getStyle(el, 'padding-right');
	            } else if (prop === 'height') {
	                return Math.min(el.offsetHeight, el.scrollHeight) -
	                    H.getStyle(el, 'padding-top') -
	                    H.getStyle(el, 'padding-bottom');
	            }

	            // Otherwise, get the computed style
	            style = win.getComputedStyle(el, undefined);
	            if (style) {
	                style = style.getPropertyValue(prop);
	                if (H.pick(toInt, true)) {
	                    style = H.pInt(style);
	                }
	            }
	            return style;
	        };

	        /**
	         * Search for an item in an array.
	         *
	         * @function #inArray
	         * @memberOf Highcharts
	         * @param {*} item - The item to search for.
	         * @param {arr} arr - The array or node collection to search in.
	         * @returns {Number} - The index within the array, or -1 if not found.
	         */
	        H.inArray = function(item, arr) {
	            return arr.indexOf ? arr.indexOf(item) : [].indexOf.call(arr, item);
	        };

	        /**
	         * Filter an array by a callback.
	         *
	         * @function #grep
	         * @memberOf Highcharts
	         * @param {Array} arr - The array to filter.
	         * @param {Function} callback - The callback function. The function receives the
	         *        item as the first argument. Return `true` if the item is to be
	         *        preserved.
	         * @returns {Array} - A new, filtered array.
	         */
	        H.grep = function(arr, callback) {
	            return [].filter.call(arr, callback);
	        };

	        /**
	         * Return the value of the first element in the array that satisfies the 
	         * provided testing function.
	         *
	         * @function #find
	         * @memberOf Highcharts
	         * @param {Array} arr - The array to test.
	         * @param {Function} callback - The callback function. The function receives the
	         *        item as the first argument. Return `true` if this item satisfies the
	         *        condition.
	         * @returns {Mixed} - The value of the element.
	         */
	        H.find = function(arr, callback) {
	            return [].find.call(arr, callback);
	        };

	        /**
	         * Map an array by a callback.
	         *
	         * @function #map
	         * @memberOf Highcharts
	         * @param {Array} arr - The array to map.
	         * @param {Function} fn - The callback function. Return the new value for the 
	         *        new array.
	         * @returns {Array} - A new array item with modified items.
	         */
	        H.map = function(arr, fn) {
	            var results = [],
	                i = 0,
	                len = arr.length;

	            for (; i < len; i++) {
	                results[i] = fn.call(arr[i], arr[i], i, arr);
	            }

	            return results;
	        };

	        /**
	         * Get the element's offset position, corrected for `overflow: auto`.
	         *
	         * @function #offset
	         * @memberOf Highcharts
	         * @param {HTMLDOMElement} el - The HTML element.
	         * @returns {Object} An object containing `left` and `top` properties for the
	         * position in the page.
	         */
	        H.offset = function(el) {
	            var docElem = doc.documentElement,
	                box = el.getBoundingClientRect();

	            return {
	                top: box.top + (win.pageYOffset || docElem.scrollTop) -
	                    (docElem.clientTop || 0),
	                left: box.left + (win.pageXOffset || docElem.scrollLeft) -
	                    (docElem.clientLeft || 0)
	            };
	        };

	        /**
	         * Stop running animation.
	         *
	         * @todo A possible extension to this would be to stop a single property, when
	         * we want to continue animating others. Then assign the prop to the timer
	         * in the Fx.run method, and check for the prop here. This would be an
	         * improvement in all cases where we stop the animation from .attr. Instead of
	         * stopping everything, we can just stop the actual attributes we're setting.
	         *
	         * @function #stop
	         * @memberOf Highcharts
	         * @param {SVGElement} el - The SVGElement to stop animation on.
	         * @param {string} [prop] - The property to stop animating. If given, the stop
	         *    method will stop a single property from animating, while others continue.
	         * 
	         */
	        H.stop = function(el, prop) {

	            var i = timers.length;

	            // Remove timers related to this element (#4519)
	            while (i--) {
	                if (timers[i].elem === el && (!prop || prop === timers[i].prop)) {
	                    timers[i].stopped = true; // #4667
	                }
	            }
	        };

	        /**
	         * Iterate over an array.
	         *
	         * @function #each
	         * @memberOf Highcharts
	         * @param {Array} arr - The array to iterate over.
	         * @param {Function} fn - The iterator callback. It passes three arguments:
	         * * item - The array item.
	         * * index - The item's index in the array.
	         * * arr - The array that each is being applied to.
	         * @param {Object} [ctx] The context.
	         */
	        H.each = function(arr, fn, ctx) { // modern browsers
	            return Array.prototype.forEach.call(arr, fn, ctx);
	        };

	        /**
	         * Iterate over object key pairs in an object.
	         *
	         * @function #objectEach
	         * @memberOf Highcharts
	         * @param  {Object}   obj - The object to iterate over.
	         * @param  {Function} fn  - The iterator callback. It passes three arguments:
	         * * value - The property value.
	         * * key - The property key.
	         * * obj - The object that objectEach is being applied to.
	         * @param  {Object}   ctx The context
	         */
	        H.objectEach = function(obj, fn, ctx) {
	            for (var key in obj) {
	                if (obj.hasOwnProperty(key)) {
	                    fn.call(ctx, obj[key], key, obj);
	                }
	            }
	        };

	        /**
	         * Add an event listener.
	         *
	         * @function #addEvent
	         * @memberOf Highcharts
	         * @param {Object} el - The element or object to add a listener to. It can be a
	         *        {@link HTMLDOMElement}, an {@link SVGElement} or any other object.
	         * @param {String} type - The event type.
	         * @param {Function} fn - The function callback to execute when the event is 
	         *        fired.
	         * @returns {Function} A callback function to remove the added event.
	         */
	        H.addEvent = function(el, type, fn) {

	            var events = el.hcEvents = el.hcEvents || {};

	            function wrappedFn(e) {
	                e.target = e.srcElement || win; // #2820
	                fn.call(el, e);
	            }

	            // Handle DOM events in modern browsers
	            if (el.addEventListener) {
	                el.addEventListener(type, fn, false);

	                // Handle old IE implementation
	            } else if (el.attachEvent) {

	                if (!el.hcEventsIE) {
	                    el.hcEventsIE = {};
	                }

	                // unique function string (#6746)
	                if (!fn.hcGetKey) {
	                    fn.hcGetKey = H.uniqueKey();
	                }

	                // Link wrapped fn with original fn, so we can get this in removeEvent
	                el.hcEventsIE[fn.hcGetKey] = wrappedFn;

	                el.attachEvent('on' + type, wrappedFn);
	            }

	            if (!events[type]) {
	                events[type] = [];
	            }

	            events[type].push(fn);

	            // Return a function that can be called to remove this event.
	            return function() {
	                H.removeEvent(el, type, fn);
	            };
	        };

	        /**
	         * Remove an event that was added with {@link Highcharts#addEvent}.
	         *
	         * @function #removeEvent
	         * @memberOf Highcharts
	         * @param {Object} el - The element to remove events on.
	         * @param {String} [type] - The type of events to remove. If undefined, all
	         *        events are removed from the element.
	         * @param {Function} [fn] - The specific callback to remove. If undefined, all
	         *        events that match the element and optionally the type are removed.
	         * 
	         */
	        H.removeEvent = function(el, type, fn) {

	            var events,
	                hcEvents = el.hcEvents,
	                index;

	            function removeOneEvent(type, fn) {
	                if (el.removeEventListener) {
	                    el.removeEventListener(type, fn, false);
	                } else if (el.attachEvent) {
	                    fn = el.hcEventsIE[fn.hcGetKey];
	                    el.detachEvent('on' + type, fn);
	                }
	            }

	            function removeAllEvents() {
	                var types,
	                    len;

	                if (!el.nodeName) {
	                    return; // break on non-DOM events
	                }

	                if (type) {
	                    types = {};
	                    types[type] = true;
	                } else {
	                    types = hcEvents;
	                }

	                H.objectEach(types, function(val, n) {
	                    if (hcEvents[n]) {
	                        len = hcEvents[n].length;
	                        while (len--) {
	                            removeOneEvent(n, hcEvents[n][len]);
	                        }
	                    }
	                });
	            }

	            if (hcEvents) {
	                if (type) {
	                    events = hcEvents[type] || [];
	                    if (fn) {
	                        index = H.inArray(fn, events);
	                        if (index > -1) {
	                            events.splice(index, 1);
	                            hcEvents[type] = events;
	                        }
	                        removeOneEvent(type, fn);

	                    } else {
	                        removeAllEvents();
	                        hcEvents[type] = [];
	                    }
	                } else {
	                    removeAllEvents();
	                    el.hcEvents = {};
	                }
	            }
	        };

	        /**
	         * Fire an event that was registered with {@link Highcharts#addEvent}.
	         *
	         * @function #fireEvent
	         * @memberOf Highcharts
	         * @param {Object} el - The object to fire the event on. It can be a
	         *        {@link HTMLDOMElement}, an {@link SVGElement} or any other object.
	         * @param {String} type - The type of event.
	         * @param {Object} [eventArguments] - Custom event arguments that are passed on
	         *        as an argument to the event handler.
	         * @param {Function} [defaultFunction] - The default function to execute if the 
	         *        other listeners haven't returned false.
	         * 
	         */
	        H.fireEvent = function(el, type, eventArguments, defaultFunction) {
	            var e,
	                hcEvents = el.hcEvents,
	                events,
	                len,
	                i,
	                fn;

	            eventArguments = eventArguments || {};

	            if (doc.createEvent && (el.dispatchEvent || el.fireEvent)) {
	                e = doc.createEvent('Events');
	                e.initEvent(type, true, true);
	                //e.target = el;

	                H.extend(e, eventArguments);

	                if (el.dispatchEvent) {
	                    el.dispatchEvent(e);
	                } else {
	                    el.fireEvent(type, e);
	                }

	            } else if (hcEvents) {

	                events = hcEvents[type] || [];
	                len = events.length;

	                if (!eventArguments.target) { // We're running a custom event

	                    H.extend(eventArguments, {
	                        // Attach a simple preventDefault function to skip default
	                        // handler if called. The built-in defaultPrevented property is
	                        // not overwritable (#5112)
	                        preventDefault: function() {
	                            eventArguments.defaultPrevented = true;
	                        },
	                        // Setting target to native events fails with clicking the
	                        // zoom-out button in Chrome.
	                        target: el,
	                        // If the type is not set, we're running a custom event (#2297).
	                        // If it is set, we're running a browser event, and setting it
	                        // will cause en error in IE8 (#2465).      
	                        type: type
	                    });
	                }


	                for (i = 0; i < len; i++) {
	                    fn = events[i];

	                    // If the event handler return false, prevent the default handler
	                    // from executing
	                    if (fn && fn.call(el, eventArguments) === false) {
	                        eventArguments.preventDefault();
	                    }
	                }
	            }

	            // Run the default if not prevented
	            if (defaultFunction && !eventArguments.defaultPrevented) {
	                defaultFunction(eventArguments);
	            }
	        };

	        /**
	         * An animation configuration. Animation configurations can also be defined as
	         * booleans, where `false` turns off animation and `true` defaults to a duration
	         * of 500ms.
	         * @typedef {Object} AnimationOptions
	         * @property {Number} duration - The animation duration in milliseconds.
	         * @property {String} [easing] - The name of an easing function as defined on
	         *     the `Math` object.
	         * @property {Function} [complete] - A callback function to exectute when the
	         *     animation finishes.
	         * @property {Function} [step] - A callback function to execute on each step of
	         *     each attribute or CSS property that's being animated. The first argument
	         *     contains information about the animation and progress.
	         */


	        /**
	         * The global animate method, which uses Fx to create individual animators.
	         *
	         * @function #animate
	         * @memberOf Highcharts
	         * @param {HTMLDOMElement|SVGElement} el - The element to animate.
	         * @param {Object} params - An object containing key-value pairs of the
	         *        properties to animate. Supports numeric as pixel-based CSS properties
	         *        for HTML objects and attributes for SVGElements.
	         * @param {AnimationOptions} [opt] - Animation options.
	         */
	        H.animate = function(el, params, opt) {
	            var start,
	                unit = '',
	                end,
	                fx,
	                args;

	            if (!H.isObject(opt)) { // Number or undefined/null
	                args = arguments;
	                opt = {
	                    duration: args[2],
	                    easing: args[3],
	                    complete: args[4]
	                };
	            }
	            if (!H.isNumber(opt.duration)) {
	                opt.duration = 400;
	            }
	            opt.easing = typeof opt.easing === 'function' ?
	                opt.easing :
	                (Math[opt.easing] || Math.easeInOutSine);
	            opt.curAnim = H.merge(params);

	            H.objectEach(params, function(val, prop) {
	                // Stop current running animation of this property
	                H.stop(el, prop);

	                fx = new H.Fx(el, opt, prop);
	                end = null;

	                if (prop === 'd') {
	                    fx.paths = fx.initPath(
	                        el,
	                        el.d,
	                        params.d
	                    );
	                    fx.toD = params.d;
	                    start = 0;
	                    end = 1;
	                } else if (el.attr) {
	                    start = el.attr(prop);
	                } else {
	                    start = parseFloat(H.getStyle(el, prop)) || 0;
	                    if (prop !== 'opacity') {
	                        unit = 'px';
	                    }
	                }

	                if (!end) {
	                    end = val;
	                }
	                if (end && end.match && end.match('px')) {
	                    end = end.replace(/px/g, ''); // #4351
	                }
	                fx.run(start, end, unit);
	            });
	        };

	        /**
	         * Factory to create new series prototypes.
	         *
	         * @function #seriesType
	         * @memberOf Highcharts
	         *
	         * @param {String} type - The series type name.
	         * @param {String} parent - The parent series type name. Use `line` to inherit
	         *        from the basic {@link Series} object.
	         * @param {Object} options - The additional default options that is merged with
	         *        the parent's options.
	         * @param {Object} props - The properties (functions and primitives) to set on
	         *        the new prototype.
	         * @param {Object} [pointProps] - Members for a series-specific extension of the
	         *        {@link Point} prototype if needed.
	         * @returns {*} - The newly created prototype as extended from {@link Series}
	         * or its derivatives.
	         */
	        // docs: add to API + extending Highcharts
	        H.seriesType = function(type, parent, options, props, pointProps) {
	            var defaultOptions = H.getOptions(),
	                seriesTypes = H.seriesTypes;

	            // Merge the options
	            defaultOptions.plotOptions[type] = H.merge(
	                defaultOptions.plotOptions[parent],
	                options
	            );

	            // Create the class
	            seriesTypes[type] = H.extendClass(seriesTypes[parent] ||
	                function() {}, props);
	            seriesTypes[type].prototype.type = type;

	            // Create the point class if needed
	            if (pointProps) {
	                seriesTypes[type].prototype.pointClass =
	                    H.extendClass(H.Point, pointProps);
	            }

	            return seriesTypes[type];
	        };

	        /**
	         * Get a unique key for using in internal element id's and pointers. The key
	         * is composed of a random hash specific to this Highcharts instance, and a 
	         * counter.
	         * @function #uniqueKey
	         * @memberOf Highcharts
	         * @return {string} The key.
	         * @example
	         * var id = H.uniqueKey(); // => 'highcharts-x45f6hp-0'
	         */
	        H.uniqueKey = (function() {

	            var uniqueKeyHash = Math.random().toString(36).substring(2, 9),
	                idCounter = 0;

	            return function() {
	                return 'highcharts-' + uniqueKeyHash + '-' + idCounter++;
	            };
	        }());

	        /**
	         * Register Highcharts as a plugin in jQuery
	         */
	        if (win.jQuery) {
	            win.jQuery.fn.highcharts = function() {
	                var args = [].slice.call(arguments);

	                if (this[0]) { // this[0] is the renderTo div

	                    // Create the chart
	                    if (args[0]) {
	                        new H[ // eslint-disable-line no-new
	                            // Constructor defaults to Chart
	                            H.isString(args[0]) ? args.shift() : 'Chart'
	                        ](this[0], args[0], args[1]);
	                        return this;
	                    }

	                    // When called without parameters or with the return argument,
	                    // return an existing chart
	                    return charts[H.attr(this[0], 'data-highcharts-chart')];
	                }
	            };
	        }


	        /**
	         * Compatibility section to add support for legacy IE. This can be removed if
	         * old IE support is not needed.
	         */
	        if (doc && !doc.defaultView) {
	            H.getStyle = function(el, prop) {
	                var val,
	                    alias = {
	                        width: 'clientWidth',
	                        height: 'clientHeight'
	                    }[prop];

	                if (el.style[prop]) {
	                    return H.pInt(el.style[prop]);
	                }
	                if (prop === 'opacity') {
	                    prop = 'filter';
	                }

	                // Getting the rendered width and height
	                if (alias) {
	                    el.style.zoom = 1;
	                    return Math.max(el[alias] - 2 * H.getStyle(el, 'padding'), 0);
	                }

	                val = el.currentStyle[prop.replace(/\-(\w)/g, function(a, b) {
	                    return b.toUpperCase();
	                })];
	                if (prop === 'filter') {
	                    val = val.replace(
	                        /alpha\(opacity=([0-9]+)\)/,
	                        function(a, b) {
	                            return b / 100;
	                        }
	                    );
	                }

	                return val === '' ? 1 : H.pInt(val);
	            };
	        }

	        if (!Array.prototype.forEach) {
	            H.each = function(arr, fn, ctx) { // legacy
	                var i = 0,
	                    len = arr.length;
	                for (; i < len; i++) {
	                    if (fn.call(ctx, arr[i], i, arr) === false) {
	                        return i;
	                    }
	                }
	            };
	        }

	        if (!Array.prototype.indexOf) {
	            H.inArray = function(item, arr) {
	                var len,
	                    i = 0;

	                if (arr) {
	                    len = arr.length;

	                    for (; i < len; i++) {
	                        if (arr[i] === item) {
	                            return i;
	                        }
	                    }
	                }

	                return -1;
	            };
	        }

	        if (!Array.prototype.filter) {
	            H.grep = function(elements, fn) {
	                var ret = [],
	                    i = 0,
	                    length = elements.length;

	                for (; i < length; i++) {
	                    if (fn(elements[i], i)) {
	                        ret.push(elements[i]);
	                    }
	                }

	                return ret;
	            };
	        }

	        if (!Array.prototype.find) {
	            H.find = function(arr, fn) {
	                var i,
	                    length = arr.length;

	                for (i = 0; i < length; i++) {
	                    if (fn(arr[i], i)) {
	                        return arr[i];
	                    }
	                }
	            };
	        }

	        //--- End compatibility section ---

	    }(Highcharts));
	    (function(H) {
	        /**
	         * (c) 2010-2017 Torstein Honsi
	         *
	         * License: www.highcharts.com/license
	         */
	        var each = H.each,
	            isNumber = H.isNumber,
	            map = H.map,
	            merge = H.merge,
	            pInt = H.pInt;

	        /**
	         * @typedef {string} ColorString
	         * A valid color to be parsed and handled by Highcharts. Highcharts internally 
	         * supports hex colors like `#ffffff`, rgb colors like `rgb(255,255,255)` and
	         * rgba colors like `rgba(255,255,255,1)`. Other colors may be supported by the
	         * browsers and displayed correctly, but Highcharts is not able to process them
	         * and apply concepts like opacity and brightening.
	         */
	        /**
	         * Handle color operations. The object methods are chainable.
	         * @param {String} input The input color in either rbga or hex format
	         */
	        H.Color = function(input) {
	            // Backwards compatibility, allow instanciation without new
	            if (!(this instanceof H.Color)) {
	                return new H.Color(input);
	            }
	            // Initialize
	            this.init(input);
	        };
	        H.Color.prototype = {

	            // Collection of parsers. This can be extended from the outside by pushing parsers
	            // to Highcharts.Color.prototype.parsers.
	            parsers: [{
	                // RGBA color
	                regex: /rgba\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]?(?:\.[0-9]+)?)\s*\)/,
	                parse: function(result) {
	                    return [pInt(result[1]), pInt(result[2]), pInt(result[3]), parseFloat(result[4], 10)];
	                }
	            }, {
	                // RGB color
	                regex: /rgb\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*\)/,
	                parse: function(result) {
	                    return [pInt(result[1]), pInt(result[2]), pInt(result[3]), 1];
	                }
	            }],

	            // Collection of named colors. Can be extended from the outside by adding
	            // colors to Highcharts.Color.prototype.names.
	            names: {
	                none: 'rgba(255,255,255,0)',
	                white: '#ffffff',
	                black: '#000000'
	            },

	            /**
	             * Parse the input color to rgba array
	             * @param {String} input
	             */
	            init: function(input) {
	                var result,
	                    rgba,
	                    i,
	                    parser,
	                    len;

	                this.input = input = this.names[
	                    input && input.toLowerCase ?
	                    input.toLowerCase() :
	                    ''
	                ] || input;

	                // Gradients
	                if (input && input.stops) {
	                    this.stops = map(input.stops, function(stop) {
	                        return new H.Color(stop[1]);
	                    });

	                    // Solid colors
	                } else {

	                    // Bitmasking as input[0] is not working for legacy IE.
	                    if (input && input.charAt() === '#') {

	                        len = input.length;
	                        input = parseInt(input.substr(1), 16);

	                        // Handle long-form, e.g. #AABBCC
	                        if (len === 7) {

	                            rgba = [
	                                (input & 0xFF0000) >> 16,
	                                (input & 0xFF00) >> 8,
	                                (input & 0xFF),
	                                1
	                            ];

	                            // Handle short-form, e.g. #ABC
	                            // In short form, the value is assumed to be the same 
	                            // for both nibbles for each component. e.g. #ABC = #AABBCC
	                        } else if (len === 4) {

	                            rgba = [
	                                ((input & 0xF00) >> 4) | (input & 0xF00) >> 8,
	                                ((input & 0xF0) >> 4) | (input & 0xF0),
	                                ((input & 0xF) << 4) | (input & 0xF),
	                                1
	                            ];
	                        }
	                    }

	                    // Otherwise, check regex parsers
	                    if (!rgba) {
	                        i = this.parsers.length;
	                        while (i-- && !rgba) {
	                            parser = this.parsers[i];
	                            result = parser.regex.exec(input);
	                            if (result) {
	                                rgba = parser.parse(result);
	                            }
	                        }
	                    }
	                }
	                this.rgba = rgba || [];
	            },

	            /**
	             * Return the color a specified format
	             * @param {String} format
	             */
	            get: function(format) {
	                var input = this.input,
	                    rgba = this.rgba,
	                    ret;

	                if (this.stops) {
	                    ret = merge(input);
	                    ret.stops = [].concat(ret.stops);
	                    each(this.stops, function(stop, i) {
	                        ret.stops[i] = [ret.stops[i][0], stop.get(format)];
	                    });

	                    // it's NaN if gradient colors on a column chart
	                } else if (rgba && isNumber(rgba[0])) {
	                    if (format === 'rgb' || (!format && rgba[3] === 1)) {
	                        ret = 'rgb(' + rgba[0] + ',' + rgba[1] + ',' + rgba[2] + ')';
	                    } else if (format === 'a') {
	                        ret = rgba[3];
	                    } else {
	                        ret = 'rgba(' + rgba.join(',') + ')';
	                    }
	                } else {
	                    ret = input;
	                }
	                return ret;
	            },

	            /**
	             * Brighten the color
	             * @param {Number} alpha
	             */
	            brighten: function(alpha) {
	                var i,
	                    rgba = this.rgba;

	                if (this.stops) {
	                    each(this.stops, function(stop) {
	                        stop.brighten(alpha);
	                    });

	                } else if (isNumber(alpha) && alpha !== 0) {
	                    for (i = 0; i < 3; i++) {
	                        rgba[i] += pInt(alpha * 255);

	                        if (rgba[i] < 0) {
	                            rgba[i] = 0;
	                        }
	                        if (rgba[i] > 255) {
	                            rgba[i] = 255;
	                        }
	                    }
	                }
	                return this;
	            },

	            /**
	             * Set the color's opacity to a given alpha value
	             * @param {Number} alpha
	             */
	            setOpacity: function(alpha) {
	                this.rgba[3] = alpha;
	                return this;
	            },

	            /*
	             * Return an intermediate color between two colors.
	             *
	             * @param  {Highcharts.Color} to
	             *         The color object to tween to.
	             * @param  {Number} pos
	             *         The intermediate position, where 0 is the from color (current
	             *         color item), and 1 is the `to` color.
	             *
	             * @return {String}
	             *         The intermediate color in rgba notation.
	             */
	            tweenTo: function(to, pos) {
	                // Check for has alpha, because rgba colors perform worse due to lack of
	                // support in WebKit.
	                var from = this,
	                    hasAlpha,
	                    ret;

	                // Unsupported color, return to-color (#3920)
	                if (!to.rgba.length) {
	                    ret = to.input || 'none';

	                    // Interpolate
	                } else {
	                    from = from.rgba;
	                    to = to.rgba;
	                    hasAlpha = (to[3] !== 1 || from[3] !== 1);
	                    ret = (hasAlpha ? 'rgba(' : 'rgb(') +
	                        Math.round(to[0] + (from[0] - to[0]) * (1 - pos)) + ',' +
	                        Math.round(to[1] + (from[1] - to[1]) * (1 - pos)) + ',' +
	                        Math.round(to[2] + (from[2] - to[2]) * (1 - pos)) +
	                        (hasAlpha ?
	                            (',' + (to[3] + (from[3] - to[3]) * (1 - pos))) :
	                            '') + ')';
	                }
	                return ret;
	            }
	        };
	        H.color = function(input) {
	            return new H.Color(input);
	        };

	    }(Highcharts));
	    (function(H) {
	        /**
	         * (c) 2010-2017 Torstein Honsi
	         *
	         * License: www.highcharts.com/license
	         */
	        var SVGElement,
	            SVGRenderer,

	            addEvent = H.addEvent,
	            animate = H.animate,
	            attr = H.attr,
	            charts = H.charts,
	            color = H.color,
	            css = H.css,
	            createElement = H.createElement,
	            defined = H.defined,
	            deg2rad = H.deg2rad,
	            destroyObjectProperties = H.destroyObjectProperties,
	            doc = H.doc,
	            each = H.each,
	            extend = H.extend,
	            erase = H.erase,
	            grep = H.grep,
	            hasTouch = H.hasTouch,
	            inArray = H.inArray,
	            isArray = H.isArray,
	            isFirefox = H.isFirefox,
	            isMS = H.isMS,
	            isObject = H.isObject,
	            isString = H.isString,
	            isWebKit = H.isWebKit,
	            merge = H.merge,
	            noop = H.noop,
	            objectEach = H.objectEach,
	            pick = H.pick,
	            pInt = H.pInt,
	            removeEvent = H.removeEvent,
	            splat = H.splat,
	            stop = H.stop,
	            svg = H.svg,
	            SVG_NS = H.SVG_NS,
	            symbolSizes = H.symbolSizes,
	            win = H.win;

	        /**
	         * @typedef {Object} SVGDOMElement - An SVG DOM element.
	         */
	        /**
	         * The SVGElement prototype is a JavaScript wrapper for SVG elements used in the
	         * rendering layer of Highcharts. Combined with the {@link
	         * Highcharts.SVGRenderer} object, these prototypes allow freeform annotation
	         * in the charts or even in HTML pages without instanciating a chart. The
	         * SVGElement can also wrap HTML labels, when `text` or `label` elements are
	         * created with the `useHTML` parameter.
	         *
	         * The SVGElement instances are created through factory functions on the 
	         * {@link Highcharts.SVGRenderer} object, like
	         * [rect]{@link Highcharts.SVGRenderer#rect}, [path]{@link
	         * Highcharts.SVGRenderer#path}, [text]{@link Highcharts.SVGRenderer#text},
	         * [label]{@link Highcharts.SVGRenderer#label}, [g]{@link
	         * Highcharts.SVGRenderer#g} and more.
	         *
	         * @class Highcharts.SVGElement
	         */
	        SVGElement = H.SVGElement = function() {
	            return this;
	        };
	        extend(SVGElement.prototype, /** @lends Highcharts.SVGElement.prototype */ {

	            // Default base for animation
	            opacity: 1,
	            SVG_NS: SVG_NS,

	            /**
	             * For labels, these CSS properties are applied to the `text` node directly.
	             *
	             * @private
	             * @type {Array.<string>}
	             */
	            textProps: ['direction', 'fontSize', 'fontWeight', 'fontFamily',
	                'fontStyle', 'color', 'lineHeight', 'width', 'textAlign',
	                'textDecoration', 'textOverflow', 'textOutline'
	            ],

	            /**
	             * Initialize the SVG renderer. This function only exists to make the
	             * initiation process overridable. It should not be called directly.
	             *
	             * @param  {SVGRenderer} renderer
	             *         The SVGRenderer instance to initialize to.
	             * @param  {String} nodeName
	             *         The SVG node name.
	             * 
	             */
	            init: function(renderer, nodeName) {

	                /** 
	                 * The primary DOM node. Each `SVGElement` instance wraps a main DOM
	                 * node, but may also represent more nodes.
	                 *
	                 * @name  element
	                 * @memberOf SVGElement
	                 * @type {SVGDOMNode|HTMLDOMNode}
	                 */
	                this.element = nodeName === 'span' ?
	                    createElement(nodeName) :
	                    doc.createElementNS(this.SVG_NS, nodeName);

	                /**
	                 * The renderer that the SVGElement belongs to.
	                 *
	                 * @name renderer
	                 * @memberOf SVGElement
	                 * @type {SVGRenderer}
	                 */
	                this.renderer = renderer;
	            },

	            /**
	             * Animate to given attributes or CSS properties.
	             * 
	             * @param {SVGAttributes} params SVG attributes or CSS to animate.
	             * @param {AnimationOptions} [options] Animation options.
	             * @param {Function} [complete] Function to perform at the end of animation.
	             *
	             * @sample highcharts/members/element-on/
	             *         Setting some attributes by animation
	             * 
	             * @returns {SVGElement} Returns the SVGElement for chaining.
	             */
	            animate: function(params, options, complete) {
	                var animOptions = H.animObject(
	                    pick(options, this.renderer.globalAnimation, true)
	                );
	                if (animOptions.duration !== 0) {
	                    // allows using a callback with the global animation without
	                    // overwriting it
	                    if (complete) {
	                        animOptions.complete = complete;
	                    }
	                    animate(this, params, animOptions);
	                } else {
	                    this.attr(params, null, complete);
	                    if (animOptions.step) {
	                        animOptions.step.call(this);
	                    }
	                }
	                return this;
	            },

	            /**
	             * @typedef {Object} GradientOptions
	             * @property {Object} linearGradient Holds an object that defines the start
	             *    position and the end position relative to the shape.
	             * @property {Number} linearGradient.x1 Start horizontal position of the
	             *    gradient. Ranges 0-1.
	             * @property {Number} linearGradient.x2 End horizontal position of the
	             *    gradient. Ranges 0-1.
	             * @property {Number} linearGradient.y1 Start vertical position of the
	             *    gradient. Ranges 0-1.
	             * @property {Number} linearGradient.y2 End vertical position of the
	             *    gradient. Ranges 0-1.
	             * @property {Object} radialGradient Holds an object that defines the center
	             *    position and the radius.
	             * @property {Number} radialGradient.cx Center horizontal position relative
	             *    to the shape. Ranges 0-1.
	             * @property {Number} radialGradient.cy Center vertical position relative
	             *    to the shape. Ranges 0-1.
	             * @property {Number} radialGradient.r Radius relative to the shape. Ranges
	             *    0-1.
	             * @property {Array.<Array>} stops The first item in each tuple is the
	             *    position in the gradient, where 0 is the start of the gradient and 1
	             *    is the end of the gradient. Multiple stops can be applied. The second
	             *    item is the color for each stop. This color can also be given in the
	             *    rgba format.
	             *
	             * @example
	             * // Linear gradient used as a color option
	             * color: {
	             *     linearGradient: { x1: 0, x2: 0, y1: 0, y2: 1 },
	             *         stops: [
	             *             [0, '#003399'], // start
	             *             [0.5, '#ffffff'], // middle
	             *             [1, '#3366AA'] // end
	             *         ]
	             *     }
	             * }
	             */
	            /**
	             * Build and apply an SVG gradient out of a common JavaScript configuration
	             * object. This function is called from the attribute setters.
	             *
	             * @private
	             * @param {GradientOptions} color The gradient options structure.
	             * @param {string} prop The property to apply, can either be `fill` or
	             * `stroke`. 
	             * @param {SVGDOMElement} elem SVG DOM element to apply the gradient on.
	             */
	            colorGradient: function(color, prop, elem) {
	                var renderer = this.renderer,
	                    colorObject,
	                    gradName,
	                    gradAttr,
	                    radAttr,
	                    gradients,
	                    gradientObject,
	                    stops,
	                    stopColor,
	                    stopOpacity,
	                    radialReference,
	                    id,
	                    key = [],
	                    value;

	                // Apply linear or radial gradients
	                if (color.radialGradient) {
	                    gradName = 'radialGradient';
	                } else if (color.linearGradient) {
	                    gradName = 'linearGradient';
	                }

	                if (gradName) {
	                    gradAttr = color[gradName];
	                    gradients = renderer.gradients;
	                    stops = color.stops;
	                    radialReference = elem.radialReference;

	                    // Keep < 2.2 kompatibility
	                    if (isArray(gradAttr)) {
	                        color[gradName] = gradAttr = {
	                            x1: gradAttr[0],
	                            y1: gradAttr[1],
	                            x2: gradAttr[2],
	                            y2: gradAttr[3],
	                            gradientUnits: 'userSpaceOnUse'
	                        };
	                    }

	                    // Correct the radial gradient for the radial reference system
	                    if (
	                        gradName === 'radialGradient' &&
	                        radialReference &&
	                        !defined(gradAttr.gradientUnits)
	                    ) {
	                        radAttr = gradAttr; // Save the radial attributes for updating
	                        gradAttr = merge(
	                            gradAttr,
	                            renderer.getRadialAttr(radialReference, radAttr), {
	                                gradientUnits: 'userSpaceOnUse'
	                            }
	                        );
	                    }

	                    // Build the unique key to detect whether we need to create a new
	                    // element (#1282)
	                    objectEach(gradAttr, function(val, n) {
	                        if (n !== 'id') {
	                            key.push(n, val);
	                        }
	                    });
	                    objectEach(stops, function(val) {
	                        key.push(val);
	                    });
	                    key = key.join(',');

	                    // Check if a gradient object with the same config object is created
	                    // within this renderer
	                    if (gradients[key]) {
	                        id = gradients[key].attr('id');

	                    } else {

	                        // Set the id and create the element
	                        gradAttr.id = id = H.uniqueKey();
	                        gradients[key] = gradientObject =
	                            renderer.createElement(gradName)
	                            .attr(gradAttr)
	                            .add(renderer.defs);

	                        gradientObject.radAttr = radAttr;

	                        // The gradient needs to keep a list of stops to be able to
	                        // destroy them
	                        gradientObject.stops = [];
	                        each(stops, function(stop) {
	                            var stopObject;
	                            if (stop[1].indexOf('rgba') === 0) {
	                                colorObject = H.color(stop[1]);
	                                stopColor = colorObject.get('rgb');
	                                stopOpacity = colorObject.get('a');
	                            } else {
	                                stopColor = stop[1];
	                                stopOpacity = 1;
	                            }
	                            stopObject = renderer.createElement('stop').attr({
	                                offset: stop[0],
	                                'stop-color': stopColor,
	                                'stop-opacity': stopOpacity
	                            }).add(gradientObject);

	                            // Add the stop element to the gradient
	                            gradientObject.stops.push(stopObject);
	                        });
	                    }

	                    // Set the reference to the gradient object
	                    value = 'url(' + renderer.url + '#' + id + ')';
	                    elem.setAttribute(prop, value);
	                    elem.gradient = key;

	                    // Allow the color to be concatenated into tooltips formatters etc.
	                    // (#2995)
	                    color.toString = function() {
	                        return value;
	                    };
	                }
	            },

	            /**
	             * Apply a text outline through a custom CSS property, by copying the text
	             * element and apply stroke to the copy. Used internally. Contrast checks
	             * at http://jsfiddle.net/highcharts/43soe9m1/2/ .
	             *
	             * @private
	             * @param {String} textOutline A custom CSS `text-outline` setting, defined
	             *    by `width color`. 
	             * @example
	             * // Specific color
	             * text.css({
	             *    textOutline: '1px black'
	             * });
	             * // Automatic contrast
	             * text.css({
	             *    color: '#000000', // black text
	             *    textOutline: '1px contrast' // => white outline
	             * });
	             */
	            applyTextOutline: function(textOutline) {
	                var elem = this.element,
	                    tspans,
	                    tspan,
	                    hasContrast = textOutline.indexOf('contrast') !== -1,
	                    styles = {},
	                    color,
	                    strokeWidth,
	                    firstRealChild,
	                    i;

	                // When the text shadow is set to contrast, use dark stroke for light
	                // text and vice versa.
	                if (hasContrast) {
	                    styles.textOutline = textOutline = textOutline.replace(
	                        /contrast/g,
	                        this.renderer.getContrast(elem.style.fill)
	                    );
	                }

	                // Extract the stroke width and color
	                textOutline = textOutline.split(' ');
	                color = textOutline[textOutline.length - 1];
	                strokeWidth = textOutline[0];

	                if (strokeWidth && strokeWidth !== 'none' && H.svg) {

	                    this.fakeTS = true; // Fake text shadow

	                    tspans = [].slice.call(elem.getElementsByTagName('tspan'));

	                    // In order to get the right y position of the clone,
	                    // copy over the y setter
	                    this.ySetter = this.xSetter;

	                    // Since the stroke is applied on center of the actual outline, we
	                    // need to double it to get the correct stroke-width outside the 
	                    // glyphs.
	                    strokeWidth = strokeWidth.replace(
	                        /(^[\d\.]+)(.*?)$/g,
	                        function(match, digit, unit) {
	                            return (2 * digit) + unit;
	                        }
	                    );

	                    // Remove shadows from previous runs. Iterate from the end to
	                    // support removing items inside the cycle (#6472).
	                    i = tspans.length;
	                    while (i--) {
	                        tspan = tspans[i];
	                        if (tspan.getAttribute('class') === 'highcharts-text-outline') {
	                            // Remove then erase
	                            erase(tspans, elem.removeChild(tspan));
	                        }
	                    }

	                    // For each of the tspans, create a stroked copy behind it.
	                    firstRealChild = elem.firstChild;
	                    each(tspans, function(tspan, y) {
	                        var clone;

	                        // Let the first line start at the correct X position
	                        if (y === 0) {
	                            tspan.setAttribute('x', elem.getAttribute('x'));
	                            y = elem.getAttribute('y');
	                            tspan.setAttribute('y', y || 0);
	                            if (y === null) {
	                                elem.setAttribute('y', 0);
	                            }
	                        }

	                        // Create the clone and apply outline properties
	                        clone = tspan.cloneNode(1);
	                        attr(clone, {
	                            'class': 'highcharts-text-outline',
	                            'fill': color,
	                            'stroke': color,
	                            'stroke-width': strokeWidth,
	                            'stroke-linejoin': 'round'
	                        });
	                        elem.insertBefore(clone, firstRealChild);
	                    });
	                }
	            },

	            /**
	             *
	             * @typedef {Object} SVGAttributes An object of key-value pairs for SVG
	             *   attributes. Attributes in Highcharts elements for the most parts
	             *   correspond to SVG, but some are specific to Highcharts, like `zIndex`,
	             *   `rotation`, `translateX`, `translateY`, `scaleX` and `scaleY`. SVG
	             *   attributes containing a hyphen are _not_ camel-cased, they should be
	             *   quoted to preserve the hyphen.
	             * @example
	             * {
	             *     'stroke': '#ff0000', // basic
	             *     'stroke-width': 2, // hyphenated
	             *     'rotation': 45 // custom
	             *     'd': ['M', 10, 10, 'L', 30, 30, 'z'] // path definition, note format
	             * }
	             */
	            /**
	             * Apply native and custom attributes to the SVG elements.
	             * 
	             * In order to set the rotation center for rotation, set x and y to 0 and
	             * use `translateX` and `translateY` attributes to position the element
	             * instead.
	             *
	             * Attributes frequently used in Highcharts are `fill`, `stroke`,
	             * `stroke-width`.
	             *
	             * @param {SVGAttributes|String} hash - The native and custom SVG
	             *    attributes. 
	             * @param {string} [val] - If the type of the first argument is `string`, 
	             *    the second can be a value, which will serve as a single attribute
	             *    setter. If the first argument is a string and the second is undefined,
	             *    the function serves as a getter and the current value of the property
	             *    is returned.
	             * @param {Function} [complete] - A callback function to execute after
	             *    setting the attributes. This makes the function compliant and
	             *    interchangeable with the {@link SVGElement#animate} function.
	             * @param {boolean} [continueAnimation=true] Used internally when `.attr` is
	             *    called as part of an animation step. Otherwise, calling `.attr` for an
	             *    attribute will stop animation for that attribute.
	             *    
	             * @returns {SVGElement|string|number} If used as a setter, it returns the 
	             *    current {@link SVGElement} so the calls can be chained. If used as a 
	             *    getter, the current value of the attribute is returned.
	             *
	             * @sample highcharts/members/renderer-rect/
	             *         Setting some attributes
	             * 
	             * @example
	             * // Set multiple attributes
	             * element.attr({
	             *     stroke: 'red',
	             *     fill: 'blue',
	             *     x: 10,
	             *     y: 10
	             * });
	             *
	             * // Set a single attribute
	             * element.attr('stroke', 'red');
	             *
	             * // Get an attribute
	             * element.attr('stroke'); // => 'red'
	             * 
	             */
	            attr: function(hash, val, complete, continueAnimation) {
	                var key,
	                    element = this.element,
	                    hasSetSymbolSize,
	                    ret = this,
	                    skipAttr,
	                    setter;

	                // single key-value pair
	                if (typeof hash === 'string' && val !== undefined) {
	                    key = hash;
	                    hash = {};
	                    hash[key] = val;
	                }

	                // used as a getter: first argument is a string, second is undefined
	                if (typeof hash === 'string') {
	                    ret = (this[hash + 'Getter'] || this._defaultGetter).call(
	                        this,
	                        hash,
	                        element
	                    );

	                    // setter
	                } else {

	                    objectEach(hash, function(val, key) {
	                        skipAttr = false;

	                        // Unless .attr is from the animator update, stop current
	                        // running animation of this property
	                        if (!continueAnimation) {
	                            stop(this, key);
	                        }

	                        // Special handling of symbol attributes
	                        if (
	                            this.symbolName &&
	                            /^(x|y|width|height|r|start|end|innerR|anchorX|anchorY)$/
	                            .test(key)
	                        ) {
	                            if (!hasSetSymbolSize) {
	                                this.symbolAttr(hash);
	                                hasSetSymbolSize = true;
	                            }
	                            skipAttr = true;
	                        }

	                        if (this.rotation && (key === 'x' || key === 'y')) {
	                            this.doTransform = true;
	                        }

	                        if (!skipAttr) {
	                            setter = this[key + 'Setter'] || this._defaultSetter;
	                            setter.call(this, val, key, element);


	                            // Let the shadow follow the main element
	                            if (
	                                this.shadows &&
	                                /^(width|height|visibility|x|y|d|transform|cx|cy|r)$/
	                                .test(key)
	                            ) {
	                                this.updateShadows(key, val, setter);
	                            }

	                        }
	                    }, this);

	                    this.afterSetters();
	                }

	                // In accordance with animate, run a complete callback
	                if (complete) {
	                    complete();
	                }

	                return ret;
	            },

	            /**
	             * This method is executed in the end of `attr()`, after setting all
	             * attributes in the hash. In can be used to efficiently consolidate
	             * multiple attributes in one SVG property -- e.g., translate, rotate and
	             * scale are merged in one "transform" attribute in the SVG node.
	             *
	             * @private
	             */
	            afterSetters: function() {
	                // Update transform. Do this outside the loop to prevent redundant
	                // updating for batch setting of attributes.
	                if (this.doTransform) {
	                    this.updateTransform();
	                    this.doTransform = false;
	                }
	            },


	            /**
	             * Update the shadow elements with new attributes.
	             *
	             * @private
	             * @param {String} key - The attribute name.
	             * @param {String|Number} value - The value of the attribute.
	             * @param {Function} setter - The setter function, inherited from the
	             *   parent wrapper
	             * 
	             */
	            updateShadows: function(key, value, setter) {
	                var shadows = this.shadows,
	                    i = shadows.length;

	                while (i--) {
	                    setter.call(
	                        shadows[i],
	                        key === 'height' ?
	                        Math.max(value - (shadows[i].cutHeight || 0), 0) :
	                        key === 'd' ? this.d : value,
	                        key,
	                        shadows[i]
	                    );
	                }
	            },


	            /**
	             * Add a class name to an element.
	             *
	             * @param {string} className - The new class name to add.
	             * @param {boolean} [replace=false] - When true, the existing class name(s)
	             *    will be overwritten with the new one. When false, the new one is
	             *    added.
	             * @returns {SVGElement} Return the SVG element for chainability.
	             */
	            addClass: function(className, replace) {
	                var currentClassName = this.attr('class') || '';
	                if (currentClassName.indexOf(className) === -1) {
	                    if (!replace) {
	                        className =
	                            (currentClassName + (currentClassName ? ' ' : '') +
	                                className).replace('  ', ' ');
	                    }
	                    this.attr('class', className);
	                }

	                return this;
	            },

	            /**
	             * Check if an element has the given class name.
	             * @param  {string} className
	             *         The class name to check for.
	             * @return {Boolean}
	             *         Whether the class name is found.
	             */
	            hasClass: function(className) {
	                return inArray(
	                    className,
	                    (this.attr('class') || '').split(' ')
	                ) !== -1;
	            },

	            /**
	             * Remove a class name from the element.
	             * @param  {string} className The class name to remove.
	             * @return {SVGElement} Returns the SVG element for chainability.
	             */
	            removeClass: function(className) {
	                return this.attr(
	                    'class',
	                    (this.attr('class') || '').replace(className, '')
	                );
	            },

	            /**
	             * If one of the symbol size affecting parameters are changed,
	             * check all the others only once for each call to an element's
	             * .attr() method
	             * @param {Object} hash - The attributes to set.
	             * @private
	             */
	            symbolAttr: function(hash) {
	                var wrapper = this;

	                each([
	                    'x',
	                    'y',
	                    'r',
	                    'start',
	                    'end',
	                    'width',
	                    'height',
	                    'innerR',
	                    'anchorX',
	                    'anchorY'
	                ], function(key) {
	                    wrapper[key] = pick(hash[key], wrapper[key]);
	                });

	                wrapper.attr({
	                    d: wrapper.renderer.symbols[wrapper.symbolName](
	                        wrapper.x,
	                        wrapper.y,
	                        wrapper.width,
	                        wrapper.height,
	                        wrapper
	                    )
	                });
	            },

	            /**
	             * Apply a clipping rectangle to this element.
	             * 
	             * @param {ClipRect} [clipRect] - The clipping rectangle. If skipped, the
	             *    current clip is removed.
	             * @returns {SVGElement} Returns the SVG element to allow chaining.
	             */
	            clip: function(clipRect) {
	                return this.attr(
	                    'clip-path',
	                    clipRect ?
	                    'url(' + this.renderer.url + '#' + clipRect.id + ')' :
	                    'none'
	                );
	            },

	            /**
	             * Calculate the coordinates needed for drawing a rectangle crisply and
	             * return the calculated attributes.
	             * 
	             * @param {Object} rect - A rectangle.
	             * @param {number} rect.x - The x position.
	             * @param {number} rect.y - The y position.
	             * @param {number} rect.width - The width.
	             * @param {number} rect.height - The height.
	             * @param {number} [strokeWidth] - The stroke width to consider when
	             *    computing crisp positioning. It can also be set directly on the rect
	             *    parameter.
	             *
	             * @returns {{x: Number, y: Number, width: Number, height: Number}} The
	             *    modified rectangle arguments.
	             */
	            crisp: function(rect, strokeWidth) {

	                var wrapper = this,
	                    attribs = {},
	                    normalizer;

	                strokeWidth = strokeWidth || rect.strokeWidth || 0;
	                // Math.round because strokeWidth can sometimes have roundoff errors
	                normalizer = Math.round(strokeWidth) % 2 / 2;

	                // normalize for crisp edges
	                rect.x = Math.floor(rect.x || wrapper.x || 0) + normalizer;
	                rect.y = Math.floor(rect.y || wrapper.y || 0) + normalizer;
	                rect.width = Math.floor(
	                    (rect.width || wrapper.width || 0) - 2 * normalizer
	                );
	                rect.height = Math.floor(
	                    (rect.height || wrapper.height || 0) - 2 * normalizer
	                );
	                if (defined(rect.strokeWidth)) {
	                    rect.strokeWidth = strokeWidth;
	                }

	                objectEach(rect, function(val, key) {
	                    if (wrapper[key] !== val) { // only set attribute if changed
	                        wrapper[key] = attribs[key] = val;
	                    }
	                });

	                return attribs;
	            },

	            /**
	             * Set styles for the element. In addition to CSS styles supported by 
	             * native SVG and HTML elements, there are also some custom made for 
	             * Highcharts, like `width`, `ellipsis` and `textOverflow` for SVG text
	             * elements.
	             * @param {CSSObject} styles The new CSS styles.
	             * @returns {SVGElement} Return the SVG element for chaining.
	             *
	             * @sample highcharts/members/renderer-text-on-chart/
	             *         Styled text
	             */
	            css: function(styles) {
	                var oldStyles = this.styles,
	                    newStyles = {},
	                    elem = this.element,
	                    textWidth,
	                    serializedCss = '',
	                    hyphenate,
	                    hasNew = !oldStyles,
	                    // These CSS properties are interpreted internally by the SVG
	                    // renderer, but are not supported by SVG and should not be added to
	                    // the DOM. In styled mode, no CSS should find its way to the DOM
	                    // whatsoever (#6173, #6474).
	                    svgPseudoProps = ['textOutline', 'textOverflow', 'width'];

	                // convert legacy
	                if (styles && styles.color) {
	                    styles.fill = styles.color;
	                }

	                // Filter out existing styles to increase performance (#2640)
	                if (oldStyles) {
	                    objectEach(styles, function(style, n) {
	                        if (style !== oldStyles[n]) {
	                            newStyles[n] = style;
	                            hasNew = true;
	                        }
	                    });
	                }
	                if (hasNew) {

	                    // Merge the new styles with the old ones
	                    if (oldStyles) {
	                        styles = extend(
	                            oldStyles,
	                            newStyles
	                        );
	                    }

	                    // Get the text width from style
	                    textWidth = this.textWidth = (
	                        styles &&
	                        styles.width &&
	                        styles.width !== 'auto' &&
	                        elem.nodeName.toLowerCase() === 'text' &&
	                        pInt(styles.width)
	                    );

	                    // store object
	                    this.styles = styles;

	                    if (textWidth && (!svg && this.renderer.forExport)) {
	                        delete styles.width;
	                    }

	                    // serialize and set style attribute
	                    if (isMS && !svg) {
	                        css(this.element, styles);
	                    } else {
	                        hyphenate = function(a, b) {
	                            return '-' + b.toLowerCase();
	                        };
	                        objectEach(styles, function(style, n) {
	                            if (inArray(n, svgPseudoProps) === -1) {
	                                serializedCss +=
	                                    n.replace(/([A-Z])/g, hyphenate) + ':' +
	                                    style + ';';
	                            }
	                        });
	                        if (serializedCss) {
	                            attr(elem, 'style', serializedCss); // #1881
	                        }
	                    }


	                    if (this.added) {

	                        // Rebuild text after added. Cache mechanisms in the buildText
	                        // will prevent building if there are no significant changes.
	                        if (this.element.nodeName === 'text') {
	                            this.renderer.buildText(this);
	                        }

	                        // Apply text outline after added
	                        if (styles && styles.textOutline) {
	                            this.applyTextOutline(styles.textOutline);
	                        }
	                    }
	                }

	                return this;
	            },


	            /**
	             * Get the current stroke width. In classic mode, the setter registers it 
	             * directly on the element.
	             * @returns {number} The stroke width in pixels.
	             * @ignore
	             */
	            strokeWidth: function() {
	                return this['stroke-width'] || 0;
	            },


	            /**
	             * Add an event listener. This is a simple setter that replaces all other
	             * events of the same type, opposed to the {@link Highcharts#addEvent}
	             * function.
	             * @param {string} eventType - The event type. If the type is `click`, 
	             *    Highcharts will internally translate it to a `touchstart` event on 
	             *    touch devices, to prevent the browser from waiting for a click event
	             *    from firing.
	             * @param {Function} handler - The handler callback.
	             * @returns {SVGElement} The SVGElement for chaining.
	             *
	             * @sample highcharts/members/element-on/
	             *         A clickable rectangle
	             */
	            on: function(eventType, handler) {
	                var svgElement = this,
	                    element = svgElement.element;

	                // touch
	                if (hasTouch && eventType === 'click') {
	                    element.ontouchstart = function(e) {
	                        svgElement.touchEventFired = Date.now(); // #2269
	                        e.preventDefault();
	                        handler.call(element, e);
	                    };
	                    element.onclick = function(e) {
	                        if (win.navigator.userAgent.indexOf('Android') === -1 ||
	                            Date.now() - (svgElement.touchEventFired || 0) > 1100) {
	                            handler.call(element, e);
	                        }
	                    };
	                } else {
	                    // simplest possible event model for internal use
	                    element['on' + eventType] = handler;
	                }
	                return this;
	            },

	            /**
	             * Set the coordinates needed to draw a consistent radial gradient across
	             * a shape regardless of positioning inside the chart. Used on pie slices
	             * to make all the slices have the same radial reference point.
	             *
	             * @param {Array} coordinates The center reference. The format is
	             *    `[centerX, centerY, diameter]` in pixels.
	             * @returns {SVGElement} Returns the SVGElement for chaining.
	             */
	            setRadialReference: function(coordinates) {
	                var existingGradient = this.renderer.gradients[this.element.gradient];

	                this.element.radialReference = coordinates;

	                // On redrawing objects with an existing gradient, the gradient needs
	                // to be repositioned (#3801)
	                if (existingGradient && existingGradient.radAttr) {
	                    existingGradient.animate(
	                        this.renderer.getRadialAttr(
	                            coordinates,
	                            existingGradient.radAttr
	                        )
	                    );
	                }

	                return this;
	            },

	            /**
	             * Move an object and its children by x and y values.
	             * 
	             * @param {number} x - The x value.
	             * @param {number} y - The y value.
	             */
	            translate: function(x, y) {
	                return this.attr({
	                    translateX: x,
	                    translateY: y
	                });
	            },

	            /**
	             * Invert a group, rotate and flip. This is used internally on inverted 
	             * charts, where the points and graphs are drawn as if not inverted, then
	             * the series group elements are inverted.
	             *
	             * @param  {boolean} inverted
	             *         Whether to invert or not. An inverted shape can be un-inverted by
	             *         setting it to false.
	             * @return {SVGElement}
	             *         Return the SVGElement for chaining.
	             */
	            invert: function(inverted) {
	                var wrapper = this;
	                wrapper.inverted = inverted;
	                wrapper.updateTransform();
	                return wrapper;
	            },

	            /**
	             * Update the transform attribute based on internal properties. Deals with
	             * the custom `translateX`, `translateY`, `rotation`, `scaleX` and `scaleY`
	             * attributes and updates the SVG `transform` attribute.
	             * @private
	             * 
	             */
	            updateTransform: function() {
	                var wrapper = this,
	                    translateX = wrapper.translateX || 0,
	                    translateY = wrapper.translateY || 0,
	                    scaleX = wrapper.scaleX,
	                    scaleY = wrapper.scaleY,
	                    inverted = wrapper.inverted,
	                    rotation = wrapper.rotation,
	                    element = wrapper.element,
	                    transform;

	                // Flipping affects translate as adjustment for flipping around the
	                // group's axis
	                if (inverted) {
	                    translateX += wrapper.width;
	                    translateY += wrapper.height;
	                }

	                // Apply translate. Nearly all transformed elements have translation,
	                // so instead of checking for translate = 0, do it always (#1767,
	                // #1846).
	                transform = ['translate(' + translateX + ',' + translateY + ')'];

	                // apply rotation
	                if (inverted) {
	                    transform.push('rotate(90) scale(-1,1)');
	                } else if (rotation) { // text rotation
	                    transform.push(
	                        'rotate(' + rotation + ' ' + (element.getAttribute('x') || 0) +
	                        ' ' + (element.getAttribute('y') || 0) + ')'
	                    );
	                }

	                // apply scale
	                if (defined(scaleX) || defined(scaleY)) {
	                    transform.push(
	                        'scale(' + pick(scaleX, 1) + ' ' + pick(scaleY, 1) + ')'
	                    );
	                }

	                if (transform.length) {
	                    element.setAttribute('transform', transform.join(' '));
	                }
	            },

	            /**
	             * Bring the element to the front. Alternatively, a new zIndex can be set.
	             *
	             * @returns {SVGElement} Returns the SVGElement for chaining.
	             *
	             * @sample highcharts/members/element-tofront/
	             *         Click an element to bring it to front
	             */
	            toFront: function() {
	                var element = this.element;
	                element.parentNode.appendChild(element);
	                return this;
	            },


	            /**
	             * Align the element relative to the chart or another box.
	             * 
	             * @param {Object} [alignOptions] The alignment options. The function can be
	             *   called without this parameter in order to re-align an element after the
	             *   box has been updated.
	             * @param {string} [alignOptions.align=left] Horizontal alignment. Can be
	             *   one of `left`, `center` and `right`.
	             * @param {string} [alignOptions.verticalAlign=top] Vertical alignment. Can
	             *   be one of `top`, `middle` and `bottom`.
	             * @param {number} [alignOptions.x=0] Horizontal pixel offset from
	             *   alignment.
	             * @param {number} [alignOptions.y=0] Vertical pixel offset from alignment.
	             * @param {Boolean} [alignByTranslate=false] Use the `transform` attribute
	             *   with translateX and translateY custom attributes to align this elements
	             *   rather than `x` and `y` attributes.
	             * @param {String|Object} box The box to align to, needs a width and height.
	             *   When the box is a string, it refers to an object in the Renderer. For
	             *   example, when box is `spacingBox`, it refers to `Renderer.spacingBox`
	             *   which holds `width`, `height`, `x` and `y` properties.
	             * @returns {SVGElement} Returns the SVGElement for chaining.
	             */
	            align: function(alignOptions, alignByTranslate, box) {
	                var align,
	                    vAlign,
	                    x,
	                    y,
	                    attribs = {},
	                    alignTo,
	                    renderer = this.renderer,
	                    alignedObjects = renderer.alignedObjects,
	                    alignFactor,
	                    vAlignFactor;

	                // First call on instanciate
	                if (alignOptions) {
	                    this.alignOptions = alignOptions;
	                    this.alignByTranslate = alignByTranslate;
	                    if (!box || isString(box)) { // boxes other than renderer handle this internally
	                        this.alignTo = alignTo = box || 'renderer';
	                        erase(alignedObjects, this); // prevent duplicates, like legendGroup after resize
	                        alignedObjects.push(this);
	                        box = null; // reassign it below
	                    }

	                    // When called on resize, no arguments are supplied
	                } else {
	                    alignOptions = this.alignOptions;
	                    alignByTranslate = this.alignByTranslate;
	                    alignTo = this.alignTo;
	                }

	                box = pick(box, renderer[alignTo], renderer);

	                // Assign variables
	                align = alignOptions.align;
	                vAlign = alignOptions.verticalAlign;
	                x = (box.x || 0) + (alignOptions.x || 0); // default: left align
	                y = (box.y || 0) + (alignOptions.y || 0); // default: top align

	                // Align
	                if (align === 'right') {
	                    alignFactor = 1;
	                } else if (align === 'center') {
	                    alignFactor = 2;
	                }
	                if (alignFactor) {
	                    x += (box.width - (alignOptions.width || 0)) / alignFactor;
	                }
	                attribs[alignByTranslate ? 'translateX' : 'x'] = Math.round(x);


	                // Vertical align
	                if (vAlign === 'bottom') {
	                    vAlignFactor = 1;
	                } else if (vAlign === 'middle') {
	                    vAlignFactor = 2;
	                }
	                if (vAlignFactor) {
	                    y += (box.height - (alignOptions.height || 0)) / vAlignFactor;
	                }
	                attribs[alignByTranslate ? 'translateY' : 'y'] = Math.round(y);

	                // Animate only if already placed
	                this[this.placed ? 'animate' : 'attr'](attribs);
	                this.placed = true;
	                this.alignAttr = attribs;

	                return this;
	            },

	            /**
	             * Get the bounding box (width, height, x and y) for the element. Generally
	             * used to get rendered text size. Since this is called a lot in charts,
	             * the results are cached based on text properties, in order to save DOM
	             * traffic. The returned bounding box includes the rotation, so for example
	             * a single text line of rotation 90 will report a greater height, and a
	             * width corresponding to the line-height.
	             *
	             * @param {boolean} [reload] Skip the cache and get the updated DOM bouding
	             *   box.
	             * @param {number} [rot] Override the element's rotation. This is internally
	             *   used on axis labels with a value of 0 to find out what the bounding box
	             *   would be have been if it were not rotated.
	             * @returns {Object} The bounding box with `x`, `y`, `width` and `height`
	             * properties.
	             *
	             * @sample highcharts/members/renderer-on-chart/
	             *         Draw a rectangle based on a text's bounding box
	             */
	            getBBox: function(reload, rot) {
	                var wrapper = this,
	                    bBox, // = wrapper.bBox,
	                    renderer = wrapper.renderer,
	                    width,
	                    height,
	                    rotation,
	                    rad,
	                    element = wrapper.element,
	                    styles = wrapper.styles,
	                    fontSize,
	                    textStr = wrapper.textStr,
	                    toggleTextShadowShim,
	                    cache = renderer.cache,
	                    cacheKeys = renderer.cacheKeys,
	                    cacheKey;

	                rotation = pick(rot, wrapper.rotation);
	                rad = rotation * deg2rad;


	                fontSize = styles && styles.fontSize;


	                if (textStr !== undefined) {

	                    cacheKey = textStr.toString();

	                    // Since numbers are monospaced, and numerical labels appear a lot
	                    // in a chart, we assume that a label of n characters has the same
	                    // bounding box as others of the same length. Unless there is inner
	                    // HTML in the label. In that case, leave the numbers as is (#5899).
	                    if (cacheKey.indexOf('<') === -1) {
	                        cacheKey = cacheKey.replace(/[0-9]/g, '0');
	                    }

	                    // Properties that affect bounding box
	                    cacheKey += [
	                            '',
	                            rotation || 0,
	                            fontSize,
	                            styles && styles.width,
	                            styles && styles.textOverflow // #5968
	                        ]
	                        .join(',');

	                }

	                if (cacheKey && !reload) {
	                    bBox = cache[cacheKey];
	                }

	                // No cache found
	                if (!bBox) {

	                    // SVG elements
	                    if (element.namespaceURI === wrapper.SVG_NS || renderer.forExport) {
	                        try { // Fails in Firefox if the container has display: none.

	                            // When the text shadow shim is used, we need to hide the fake shadows
	                            // to get the correct bounding box (#3872)
	                            toggleTextShadowShim = this.fakeTS && function(display) {
	                                each(element.querySelectorAll('.highcharts-text-outline'), function(tspan) {
	                                    tspan.style.display = display;
	                                });
	                            };

	                            // Workaround for #3842, Firefox reporting wrong bounding box for shadows
	                            if (toggleTextShadowShim) {
	                                toggleTextShadowShim('none');
	                            }

	                            bBox = element.getBBox ?
	                                // SVG: use extend because IE9 is not allowed to change width and height in case
	                                // of rotation (below)
	                                extend({}, element.getBBox()) : {

	                                    // Legacy IE in export mode
	                                    width: element.offsetWidth,
	                                    height: element.offsetHeight
	                                };

	                            // #3842
	                            if (toggleTextShadowShim) {
	                                toggleTextShadowShim('');
	                            }
	                        } catch (e) {}

	                        // If the bBox is not set, the try-catch block above failed. The other condition
	                        // is for Opera that returns a width of -Infinity on hidden elements.
	                        if (!bBox || bBox.width < 0) {
	                            bBox = {
	                                width: 0,
	                                height: 0
	                            };
	                        }


	                        // VML Renderer or useHTML within SVG
	                    } else {

	                        bBox = wrapper.htmlGetBBox();

	                    }

	                    // True SVG elements as well as HTML elements in modern browsers using the .useHTML option
	                    // need to compensated for rotation
	                    if (renderer.isSVG) {
	                        width = bBox.width;
	                        height = bBox.height;

	                        // Workaround for wrong bounding box in IE, Edge and Chrome on
	                        // Windows. With Highcharts' default font, IE and Edge report
	                        // a box height of 16.899 and Chrome rounds it to 17. If this 
	                        // stands uncorrected, it results in more padding added below
	                        // the text than above when adding a label border or background.
	                        // Also vertical positioning is affected.
	                        // http://jsfiddle.net/highcharts/em37nvuj/
	                        // (#1101, #1505, #1669, #2568, #6213).
	                        if (
	                            styles &&
	                            styles.fontSize === '11px' &&
	                            Math.round(height) === 17
	                        ) {
	                            bBox.height = height = 14;
	                        }

	                        // Adjust for rotated text
	                        if (rotation) {
	                            bBox.width = Math.abs(height * Math.sin(rad)) + Math.abs(width * Math.cos(rad));
	                            bBox.height = Math.abs(height * Math.cos(rad)) + Math.abs(width * Math.sin(rad));
	                        }
	                    }

	                    // Cache it. When loading a chart in a hidden iframe in Firefox and IE/Edge, the
	                    // bounding box height is 0, so don't cache it (#5620).
	                    if (cacheKey && bBox.height > 0) {

	                        // Rotate (#4681)
	                        while (cacheKeys.length > 250) {
	                            delete cache[cacheKeys.shift()];
	                        }

	                        if (!cache[cacheKey]) {
	                            cacheKeys.push(cacheKey);
	                        }
	                        cache[cacheKey] = bBox;
	                    }
	                }
	                return bBox;
	            },

	            /**
	             * Show the element after it has been hidden. 
	             *
	             * @param {boolean} [inherit=false] Set the visibility attribute to
	             * `inherit` rather than `visible`. The difference is that an element with
	             * `visibility="visible"` will be visible even if the parent is hidden.
	             *
	             * @returns {SVGElement} Returns the SVGElement for chaining.
	             */
	            show: function(inherit) {
	                return this.attr({
	                    visibility: inherit ? 'inherit' : 'visible'
	                });
	            },

	            /**
	             * Hide the element, equivalent to setting the `visibility` attribute to
	             * `hidden`.
	             *
	             * @returns {SVGElement} Returns the SVGElement for chaining.
	             */
	            hide: function() {
	                return this.attr({
	                    visibility: 'hidden'
	                });
	            },

	            /**
	             * Fade out an element by animating its opacity down to 0, and hide it on
	             * complete. Used internally for the tooltip.
	             * 
	             * @param {number} [duration=150] The fade duration in milliseconds.
	             */
	            fadeOut: function(duration) {
	                var elemWrapper = this;
	                elemWrapper.animate({
	                    opacity: 0
	                }, {
	                    duration: duration || 0,
	                    complete: function() {
	                        // #3088, assuming we're only using this for tooltips
	                        elemWrapper.attr({
	                            y: -9999
	                        });
	                    }
	                });
	            },

	            /**
	             * Add the element to the DOM. All elements must be added this way.
	             * 
	             * @param {SVGElement|SVGDOMElement} [parent] The parent item to add it to.
	             *   If undefined, the element is added to the {@link
	             *   Highcharts.SVGRenderer.box}.
	             *
	             * @returns {SVGElement} Returns the SVGElement for chaining.
	             *
	             * @sample highcharts/members/renderer-g - Elements added to a group
	             */
	            add: function(parent) {

	                var renderer = this.renderer,
	                    element = this.element,
	                    inserted;

	                if (parent) {
	                    this.parentGroup = parent;
	                }

	                // mark as inverted
	                this.parentInverted = parent && parent.inverted;

	                // build formatted text
	                if (this.textStr !== undefined) {
	                    renderer.buildText(this);
	                }

	                // Mark as added
	                this.added = true;

	                // If we're adding to renderer root, or other elements in the group
	                // have a z index, we need to handle it
	                if (!parent || parent.handleZ || this.zIndex) {
	                    inserted = this.zIndexSetter();
	                }

	                // If zIndex is not handled, append at the end
	                if (!inserted) {
	                    (parent ? parent.element : renderer.box).appendChild(element);
	                }

	                // fire an event for internal hooks
	                if (this.onAdd) {
	                    this.onAdd();
	                }

	                return this;
	            },

	            /**
	             * Removes an element from the DOM.
	             *
	             * @private
	             * @param {SVGDOMElement|HTMLDOMElement} element The DOM node to remove.
	             */
	            safeRemoveChild: function(element) {
	                var parentNode = element.parentNode;
	                if (parentNode) {
	                    parentNode.removeChild(element);
	                }
	            },

	            /**
	             * Destroy the element and element wrapper and clear up the DOM and event
	             * hooks.
	             *
	             * 
	             */
	            destroy: function() {
	                var wrapper = this,
	                    element = wrapper.element || {},
	                    parentToClean =
	                    wrapper.renderer.isSVG &&
	                    element.nodeName === 'SPAN' &&
	                    wrapper.parentGroup,
	                    grandParent,
	                    ownerSVGElement = element.ownerSVGElement,
	                    i;

	                // remove events
	                element.onclick = element.onmouseout = element.onmouseover =
	                    element.onmousemove = element.point = null;
	                stop(wrapper); // stop running animations

	                if (wrapper.clipPath && ownerSVGElement) {
	                    // Look for existing references to this clipPath and remove them
	                    // before destroying the element (#6196).
	                    each(
	                        ownerSVGElement.querySelectorAll('[clip-path]'),
	                        function(el) {
	                            // Include the closing paranthesis in the test to rule out
	                            // id's from 10 and above (#6550)
	                            if (el.getAttribute('clip-path')
	                                .indexOf(wrapper.clipPath.element.id + ')') > -1) {
	                                el.removeAttribute('clip-path');
	                            }
	                        }
	                    );
	                    wrapper.clipPath = wrapper.clipPath.destroy();
	                }

	                // Destroy stops in case this is a gradient object
	                if (wrapper.stops) {
	                    for (i = 0; i < wrapper.stops.length; i++) {
	                        wrapper.stops[i] = wrapper.stops[i].destroy();
	                    }
	                    wrapper.stops = null;
	                }

	                // remove element
	                wrapper.safeRemoveChild(element);


	                wrapper.destroyShadows();


	                // In case of useHTML, clean up empty containers emulating SVG groups
	                // (#1960, #2393, #2697).
	                while (
	                    parentToClean &&
	                    parentToClean.div &&
	                    parentToClean.div.childNodes.length === 0
	                ) {
	                    grandParent = parentToClean.parentGroup;
	                    wrapper.safeRemoveChild(parentToClean.div);
	                    delete parentToClean.div;
	                    parentToClean = grandParent;
	                }

	                // remove from alignObjects
	                if (wrapper.alignTo) {
	                    erase(wrapper.renderer.alignedObjects, wrapper);
	                }

	                objectEach(wrapper, function(val, key) {
	                    delete wrapper[key];
	                });

	                return null;
	            },


	            /**
	             * @typedef {Object} ShadowOptions
	             * @property {string} [color=#000000] The shadow color.
	             * @property {number} [offsetX=1] The horizontal offset from the element.
	             * @property {number} [offsetY=1] The vertical offset from the element.
	             * @property {number} [opacity=0.15] The shadow opacity.
	             * @property {number} [width=3] The shadow width or distance from the
	             *    element.
	             */
	            /**
	             * Add a shadow to the element. Must be called after the element is added to
	             * the DOM. In styled mode, this method is not used, instead use `defs` and
	             * filters.
	             * 
	             * @param {boolean|ShadowOptions} shadowOptions The shadow options. If
	             *    `true`, the default options are applied. If `false`, the current
	             *    shadow will be removed.
	             * @param {SVGElement} [group] The SVG group element where the shadows will 
	             *    be applied. The default is to add it to the same parent as the current
	             *    element. Internally, this is ised for pie slices, where all the
	             *    shadows are added to an element behind all the slices.
	             * @param {boolean} [cutOff] Used internally for column shadows.
	             *
	             * @returns {SVGElement} Returns the SVGElement for chaining.
	             *
	             * @example
	             * renderer.rect(10, 100, 100, 100)
	             *     .attr({ fill: 'red' })
	             *     .shadow(true);
	             */
	            shadow: function(shadowOptions, group, cutOff) {
	                var shadows = [],
	                    i,
	                    shadow,
	                    element = this.element,
	                    strokeWidth,
	                    shadowWidth,
	                    shadowElementOpacity,

	                    // compensate for inverted plot area
	                    transform;

	                if (!shadowOptions) {
	                    this.destroyShadows();

	                } else if (!this.shadows) {
	                    shadowWidth = pick(shadowOptions.width, 3);
	                    shadowElementOpacity = (shadowOptions.opacity || 0.15) /
	                        shadowWidth;
	                    transform = this.parentInverted ?
	                        '(-1,-1)' :
	                        '(' + pick(shadowOptions.offsetX, 1) + ', ' +
	                        pick(shadowOptions.offsetY, 1) + ')';
	                    for (i = 1; i <= shadowWidth; i++) {
	                        shadow = element.cloneNode(0);
	                        strokeWidth = (shadowWidth * 2) + 1 - (2 * i);
	                        attr(shadow, {
	                            'isShadow': 'true',
	                            'stroke': shadowOptions.color || '#000000',
	                            'stroke-opacity': shadowElementOpacity * i,
	                            'stroke-width': strokeWidth,
	                            'transform': 'translate' + transform,
	                            'fill': 'none'
	                        });
	                        if (cutOff) {
	                            attr(
	                                shadow,
	                                'height',
	                                Math.max(attr(shadow, 'height') - strokeWidth, 0)
	                            );
	                            shadow.cutHeight = strokeWidth;
	                        }

	                        if (group) {
	                            group.element.appendChild(shadow);
	                        } else {
	                            element.parentNode.insertBefore(shadow, element);
	                        }

	                        shadows.push(shadow);
	                    }

	                    this.shadows = shadows;
	                }
	                return this;

	            },

	            /**
	             * Destroy shadows on the element.
	             * @private
	             */
	            destroyShadows: function() {
	                each(this.shadows || [], function(shadow) {
	                    this.safeRemoveChild(shadow);
	                }, this);
	                this.shadows = undefined;
	            },



	            xGetter: function(key) {
	                if (this.element.nodeName === 'circle') {
	                    if (key === 'x') {
	                        key = 'cx';
	                    } else if (key === 'y') {
	                        key = 'cy';
	                    }
	                }
	                return this._defaultGetter(key);
	            },

	            /**
	             * Get the current value of an attribute or pseudo attribute, used mainly
	             * for animation. Called internally from the {@link
	             * Highcharts.SVGRenderer#attr}
	             * function.
	             *
	             * @private
	             */
	            _defaultGetter: function(key) {
	                var ret = pick(
	                    this[key],
	                    this.element ? this.element.getAttribute(key) : null,
	                    0
	                );

	                if (/^[\-0-9\.]+$/.test(ret)) { // is numerical
	                    ret = parseFloat(ret);
	                }
	                return ret;
	            },


	            dSetter: function(value, key, element) {
	                if (value && value.join) { // join path
	                    value = value.join(' ');
	                }
	                if (/(NaN| {2}|^$)/.test(value)) {
	                    value = 'M 0 0';
	                }

	                // Check for cache before resetting. Resetting causes disturbance in the
	                // DOM, causing flickering in some cases in Edge/IE (#6747). Also
	                // possible performance gain.
	                if (this[key] !== value) {
	                    element.setAttribute(key, value);
	                    this[key] = value;
	                }

	            },

	            dashstyleSetter: function(value) {
	                var i,
	                    strokeWidth = this['stroke-width'];

	                // If "inherit", like maps in IE, assume 1 (#4981). With HC5 and the new
	                // strokeWidth function, we should be able to use that instead.
	                if (strokeWidth === 'inherit') {
	                    strokeWidth = 1;
	                }
	                value = value && value.toLowerCase();
	                if (value) {
	                    value = value
	                        .replace('shortdashdotdot', '3,1,1,1,1,1,')
	                        .replace('shortdashdot', '3,1,1,1')
	                        .replace('shortdot', '1,1,')
	                        .replace('shortdash', '3,1,')
	                        .replace('longdash', '8,3,')
	                        .replace('8-4dash', '8,4,')
	                        .replace(/dot/g, '1,3,')
	                        .replace('dash', '4,3,')
	                        .replace(/,$/, '')
	                        .split(','); // ending comma

	                    i = value.length;
	                    while (i--) {
	                        value[i] = pInt(value[i]) * strokeWidth;
	                    }
	                    value = value.join(',')
	                        .replace(/NaN/g, 'none'); // #3226
	                    this.element.setAttribute('stroke-dasharray', value);
	                }
	            },

	            alignSetter: function(value) {
	                var convert = {
	                    left: 'start',
	                    center: 'middle',
	                    right: 'end'
	                };
	                this.element.setAttribute('text-anchor', convert[value]);
	            },
	            opacitySetter: function(value, key, element) {
	                this[key] = value;
	                element.setAttribute(key, value);
	            },
	            titleSetter: function(value) {
	                var titleNode = this.element.getElementsByTagName('title')[0];
	                if (!titleNode) {
	                    titleNode = doc.createElementNS(this.SVG_NS, 'title');
	                    this.element.appendChild(titleNode);
	                }

	                // Remove text content if it exists
	                if (titleNode.firstChild) {
	                    titleNode.removeChild(titleNode.firstChild);
	                }

	                titleNode.appendChild(
	                    doc.createTextNode(
	                        (String(pick(value), '')).replace(/<[^>]*>/g, '') // #3276, #3895
	                    )
	                );
	            },
	            textSetter: function(value) {
	                if (value !== this.textStr) {
	                    // Delete bBox memo when the text changes
	                    delete this.bBox;

	                    this.textStr = value;
	                    if (this.added) {
	                        this.renderer.buildText(this);
	                    }
	                }
	            },
	            fillSetter: function(value, key, element) {
	                if (typeof value === 'string') {
	                    element.setAttribute(key, value);
	                } else if (value) {
	                    this.colorGradient(value, key, element);
	                }
	            },
	            visibilitySetter: function(value, key, element) {
	                // IE9-11 doesn't handle visibilty:inherit well, so we remove the attribute instead (#2881, #3909)
	                if (value === 'inherit') {
	                    element.removeAttribute(key);
	                } else if (this[key] !== value) { // #6747
	                    element.setAttribute(key, value);
	                }
	                this[key] = value;
	            },
	            zIndexSetter: function(value, key) {
	                var renderer = this.renderer,
	                    parentGroup = this.parentGroup,
	                    parentWrapper = parentGroup || renderer,
	                    parentNode = parentWrapper.element || renderer.box,
	                    childNodes,
	                    otherElement,
	                    otherZIndex,
	                    element = this.element,
	                    inserted,
	                    run = this.added,
	                    i;

	                if (defined(value)) {
	                    element.zIndex = value; // So we can read it for other elements in the group
	                    value = +value;
	                    if (this[key] === value) { // Only update when needed (#3865)
	                        run = false;
	                    }
	                    this[key] = value;
	                }

	                // Insert according to this and other elements' zIndex. Before .add() is called,
	                // nothing is done. Then on add, or by later calls to zIndexSetter, the node
	                // is placed on the right place in the DOM.
	                if (run) {
	                    value = this.zIndex;

	                    if (value && parentGroup) {
	                        parentGroup.handleZ = true;
	                    }

	                    childNodes = parentNode.childNodes;
	                    for (i = 0; i < childNodes.length && !inserted; i++) {
	                        otherElement = childNodes[i];
	                        otherZIndex = otherElement.zIndex;
	                        if (otherElement !== element && (
	                                // Insert before the first element with a higher zIndex
	                                pInt(otherZIndex) > value ||
	                                // If no zIndex given, insert before the first element with a zIndex
	                                (!defined(value) && defined(otherZIndex)) ||
	                                // Negative zIndex versus no zIndex:
	                                // On all levels except the highest. If the parent is <svg>,
	                                // then we don't want to put items before <desc> or <defs>
	                                (value < 0 && !defined(otherZIndex) && parentNode !== renderer.box)

	                            )) {
	                            parentNode.insertBefore(element, otherElement);
	                            inserted = true;
	                        }
	                    }
	                    if (!inserted) {
	                        parentNode.appendChild(element);
	                    }
	                }
	                return inserted;
	            },
	            _defaultSetter: function(value, key, element) {
	                element.setAttribute(key, value);
	            }
	        });

	        // Some shared setters and getters
	        SVGElement.prototype.yGetter = SVGElement.prototype.xGetter;
	        SVGElement.prototype.translateXSetter = SVGElement.prototype.translateYSetter =
	            SVGElement.prototype.rotationSetter = SVGElement.prototype.verticalAlignSetter =
	            SVGElement.prototype.scaleXSetter = SVGElement.prototype.scaleYSetter = function(value, key) {
	                this[key] = value;
	                this.doTransform = true;
	            };


	        // WebKit and Batik have problems with a stroke-width of zero, so in this case we remove the 
	        // stroke attribute altogether. #1270, #1369, #3065, #3072.
	        SVGElement.prototype['stroke-widthSetter'] = SVGElement.prototype.strokeSetter = function(value, key, element) {
	            this[key] = value;
	            // Only apply the stroke attribute if the stroke width is defined and larger than 0
	            if (this.stroke && this['stroke-width']) {
	                SVGElement.prototype.fillSetter.call(this, this.stroke, 'stroke', element); // use prototype as instance may be overridden
	                element.setAttribute('stroke-width', this['stroke-width']);
	                this.hasStroke = true;
	            } else if (key === 'stroke-width' && value === 0 && this.hasStroke) {
	                element.removeAttribute('stroke');
	                this.hasStroke = false;
	            }
	        };


	        /**
	         * Allows direct access to the Highcharts rendering layer in order to draw
	         * primitive shapes like circles, rectangles, paths or text directly on a chart,
	         * or independent from any chart. The SVGRenderer represents a wrapper object
	         * for SVGin modern browsers and through the VMLRenderer, for VML in IE < 8.
	         *
	         * An existing chart's renderer can be accessed through {@link Chart.renderer}.
	         * The renderer can also be used completely decoupled from a chart.
	         *
	         * @param {HTMLDOMElement} container - Where to put the SVG in the web page.
	         * @param {number} width - The width of the SVG.
	         * @param {number} height - The height of the SVG.
	         * @param {boolean} [forExport=false] - Whether the rendered content is intended
	         *   for export.
	         * @param {boolean} [allowHTML=true] - Whether the renderer is allowed to
	         *   include HTML text, which will be projected on top of the SVG.
	         *
	         * @example
	         * // Use directly without a chart object.
	         * var renderer = new Highcharts.Renderer(parentNode, 600, 400);
	         *
	         * @sample highcharts/members/renderer-on-chart - Annotating a chart programmatically.
	         * @sample highcharts/members/renderer-basic - Independent SVG drawing.
	         *
	         * @class Highcharts.SVGRenderer
	         */
	        SVGRenderer = H.SVGRenderer = function() {
	            this.init.apply(this, arguments);
	        };
	        extend(SVGRenderer.prototype, /** @lends Highcharts.SVGRenderer.prototype */ {
	            /**
	             * A pointer to the renderer's associated Element class. The VMLRenderer
	             * will have a pointer to VMLElement here.
	             * @type {SVGElement}
	             */
	            Element: SVGElement,
	            SVG_NS: SVG_NS,
	            /**
	             * Initialize the SVGRenderer. Overridable initiator function that takes
	             * the same parameters as the constructor.
	             */
	            init: function(container, width, height, style, forExport, allowHTML) {
	                var renderer = this,
	                    boxWrapper,
	                    element,
	                    desc;

	                boxWrapper = renderer.createElement('svg')
	                    .attr({
	                        'version': '1.1',
	                        'class': 'highcharts-root'
	                    })

	                    .css(this.getStyle(style));
	                element = boxWrapper.element;
	                container.appendChild(element);

	                // For browsers other than IE, add the namespace attribute (#1978)
	                if (container.innerHTML.indexOf('xmlns') === -1) {
	                    attr(element, 'xmlns', this.SVG_NS);
	                }

	                // object properties
	                renderer.isSVG = true;

	                /** 
	                 * The root `svg` node of the renderer.
	                 * @name box
	                 * @memberOf SVGRenderer
	                 * @type {SVGDOMElement}
	                 */
	                this.box = element;
	                /** 
	                 * The wrapper for the root `svg` node of the renderer.
	                 *
	                 * @name boxWrapper
	                 * @memberOf SVGRenderer
	                 * @type {SVGElement}
	                 */
	                this.boxWrapper = boxWrapper;
	                renderer.alignedObjects = [];

	                /**
	                 * Page url used for internal references.
	                 * @type {string}
	                 */
	                // #24, #672, #1070
	                this.url = (isFirefox || isWebKit) && doc.getElementsByTagName('base').length ?
	                    win.location.href
	                    .replace(/#.*?$/, '') // remove the hash
	                    .replace(/<[^>]*>/g, '') // wing cut HTML
	                    .replace(/([\('\)])/g, '\\$1') // escape parantheses and quotes
	                    .replace(/ /g, '%20') : // replace spaces (needed for Safari only)
	                    '';

	                // Add description
	                desc = this.createElement('desc').add();
	                desc.element.appendChild(doc.createTextNode('Created with Highcharts 5.0.14'));

	                /**
	                 * A pointer to the `defs` node of the root SVG.
	                 * @type {SVGElement}
	                 * @name defs
	                 * @memberOf SVGRenderer
	                 */
	                renderer.defs = this.createElement('defs').add();
	                renderer.allowHTML = allowHTML;
	                renderer.forExport = forExport;
	                renderer.gradients = {}; // Object where gradient SvgElements are stored
	                renderer.cache = {}; // Cache for numerical bounding boxes
	                renderer.cacheKeys = [];
	                renderer.imgCount = 0;

	                renderer.setSize(width, height, false);



	                // Issue 110 workaround:
	                // In Firefox, if a div is positioned by percentage, its pixel position may land
	                // between pixels. The container itself doesn't display this, but an SVG element
	                // inside this container will be drawn at subpixel precision. In order to draw
	                // sharp lines, this must be compensated for. This doesn't seem to work inside
	                // iframes though (like in jsFiddle).
	                var subPixelFix, rect;
	                if (isFirefox && container.getBoundingClientRect) {
	                    subPixelFix = function() {
	                        css(container, {
	                            left: 0,
	                            top: 0
	                        });
	                        rect = container.getBoundingClientRect();
	                        css(container, {
	                            left: (Math.ceil(rect.left) - rect.left) + 'px',
	                            top: (Math.ceil(rect.top) - rect.top) + 'px'
	                        });
	                    };

	                    // run the fix now
	                    subPixelFix();

	                    // run it on resize
	                    renderer.unSubPixelFix = addEvent(win, 'resize', subPixelFix);
	                }
	            },



	            /**
	             * Get the global style setting for the renderer.
	             * @private
	             * @param  {CSSObject} style - Style settings.
	             * @return {CSSObject} The style settings mixed with defaults.
	             */
	            getStyle: function(style) {
	                this.style = extend({

	                    fontFamily: '"Lucida Grande", "Lucida Sans Unicode", Arial, Helvetica, sans-serif', // default font
	                    fontSize: '12px'

	                }, style);
	                return this.style;
	            },
	            /**
	             * Apply the global style on the renderer, mixed with the default styles.
	             * 
	             * @param {CSSObject} style - CSS to apply.
	             */
	            setStyle: function(style) {
	                this.boxWrapper.css(this.getStyle(style));
	            },


	            /**
	             * Detect whether the renderer is hidden. This happens when one of the
	             * parent elements has `display: none`. Used internally to detect when we
	             * needto render preliminarily in another div to get the text bounding boxes 
	             * right.
	             *
	             * @returns {boolean} True if it is hidden.
	             */
	            isHidden: function() { // #608
	                return !this.boxWrapper.getBBox().width;
	            },

	            /**
	             * Destroys the renderer and its allocated members.
	             */
	            destroy: function() {
	                var renderer = this,
	                    rendererDefs = renderer.defs;
	                renderer.box = null;
	                renderer.boxWrapper = renderer.boxWrapper.destroy();

	                // Call destroy on all gradient elements
	                destroyObjectProperties(renderer.gradients || {});
	                renderer.gradients = null;

	                // Defs are null in VMLRenderer
	                // Otherwise, destroy them here.
	                if (rendererDefs) {
	                    renderer.defs = rendererDefs.destroy();
	                }

	                // Remove sub pixel fix handler (#982)
	                if (renderer.unSubPixelFix) {
	                    renderer.unSubPixelFix();
	                }

	                renderer.alignedObjects = null;

	                return null;
	            },

	            /**
	             * Create a wrapper for an SVG element. Serves as a factory for 
	             * {@link SVGElement}, but this function is itself mostly called from 
	             * primitive factories like {@link SVGRenderer#path}, {@link
	             * SVGRenderer#rect} or {@link SVGRenderer#text}.
	             * 
	             * @param {string} nodeName - The node name, for example `rect`, `g` etc.
	             * @returns {SVGElement} The generated SVGElement.
	             */
	            createElement: function(nodeName) {
	                var wrapper = new this.Element();
	                wrapper.init(this, nodeName);
	                return wrapper;
	            },

	            /**
	             * Dummy function for plugins, called every time the renderer is updated.
	             * Prior to Highcharts 5, this was used for the canvg renderer.
	             * @function
	             */
	            draw: noop,

	            /**
	             * Get converted radial gradient attributes according to the radial
	             * reference. Used internally from the {@link SVGElement#colorGradient}
	             * function.
	             *
	             * @private
	             */
	            getRadialAttr: function(radialReference, gradAttr) {
	                return {
	                    cx: (radialReference[0] - radialReference[2] / 2) + gradAttr.cx * radialReference[2],
	                    cy: (radialReference[1] - radialReference[2] / 2) + gradAttr.cy * radialReference[2],
	                    r: gradAttr.r * radialReference[2]
	                };
	            },

	            getSpanWidth: function(wrapper, tspan) {
	                var renderer = this,
	                    bBox = wrapper.getBBox(true),
	                    actualWidth = bBox.width;

	                // Old IE cannot measure the actualWidth for SVG elements (#2314)
	                if (!svg && renderer.forExport) {
	                    actualWidth = renderer.measureSpanWidth(tspan.firstChild.data, wrapper.styles);
	                }
	                return actualWidth;
	            },

	            applyEllipsis: function(wrapper, tspan, text, width) {
	                var renderer = this,
	                    rotation = wrapper.rotation,
	                    str = text,
	                    currentIndex,
	                    minIndex = 0,
	                    maxIndex = text.length,
	                    updateTSpan = function(s) {
	                        tspan.removeChild(tspan.firstChild);
	                        if (s) {
	                            tspan.appendChild(doc.createTextNode(s));
	                        }
	                    },
	                    actualWidth,
	                    wasTooLong;
	                wrapper.rotation = 0; // discard rotation when computing box
	                actualWidth = renderer.getSpanWidth(wrapper, tspan);
	                wasTooLong = actualWidth > width;
	                if (wasTooLong) {
	                    while (minIndex <= maxIndex) {
	                        currentIndex = Math.ceil((minIndex + maxIndex) / 2);
	                        str = text.substring(0, currentIndex) + '\u2026';
	                        updateTSpan(str);
	                        actualWidth = renderer.getSpanWidth(wrapper, tspan);
	                        if (minIndex === maxIndex) {
	                            // Complete
	                            minIndex = maxIndex + 1;
	                        } else if (actualWidth > width) {
	                            // Too large. Set max index to current.
	                            maxIndex = currentIndex - 1;
	                        } else {
	                            // Within width. Set min index to current.
	                            minIndex = currentIndex;
	                        }
	                    }
	                    // If max index was 0 it means just ellipsis was also to large.
	                    if (maxIndex === 0) {
	                        // Remove ellipses.
	                        updateTSpan('');
	                    }
	                }
	                wrapper.rotation = rotation; // Apply rotation again.
	                return wasTooLong;
	            },

	            /**
	             * Parse a simple HTML string into SVG tspans. Called internally when text
	             *   is set on an SVGElement. The function supports a subset of HTML tags,
	             *   CSS text features like `width`, `text-overflow`, `white-space`, and
	             *   also attributes like `href` and `style`.
	             * @private
	             * @param {SVGElement} wrapper The parent SVGElement.
	             */
	            buildText: function(wrapper) {
	                var textNode = wrapper.element,
	                    renderer = this,
	                    forExport = renderer.forExport,
	                    textStr = pick(wrapper.textStr, '').toString(),
	                    hasMarkup = textStr.indexOf('<') !== -1,
	                    lines,
	                    childNodes = textNode.childNodes,
	                    clsRegex,
	                    styleRegex,
	                    hrefRegex,
	                    wasTooLong,
	                    parentX = attr(textNode, 'x'),
	                    textStyles = wrapper.styles,
	                    width = wrapper.textWidth,
	                    textLineHeight = textStyles && textStyles.lineHeight,
	                    textOutline = textStyles && textStyles.textOutline,
	                    ellipsis = textStyles && textStyles.textOverflow === 'ellipsis',
	                    noWrap = textStyles && textStyles.whiteSpace === 'nowrap',
	                    fontSize = textStyles && textStyles.fontSize,
	                    textCache,
	                    isSubsequentLine,
	                    i = childNodes.length,
	                    tempParent = width && !wrapper.added && this.box,
	                    getLineHeight = function(tspan) {
	                        var fontSizeStyle;

	                        fontSizeStyle = /(px|em)$/.test(tspan && tspan.style.fontSize) ?
	                            tspan.style.fontSize :
	                            (fontSize || renderer.style.fontSize || 12);


	                        return textLineHeight ?
	                            pInt(textLineHeight) :
	                            renderer.fontMetrics(
	                                fontSizeStyle,
	                                // Get the computed size from parent if not explicit
	                                tspan.getAttribute('style') ? tspan : textNode
	                            ).h;
	                    },
	                    unescapeAngleBrackets = function(inputStr) {
	                        return inputStr.replace(/&lt;/g, '<').replace(/&gt;/g, '>');
	                    };

	                // The buildText code is quite heavy, so if we're not changing something
	                // that affects the text, skip it (#6113).
	                textCache = [
	                    textStr,
	                    ellipsis,
	                    noWrap,
	                    textLineHeight,
	                    textOutline,
	                    fontSize,
	                    width
	                ].join(',');
	                if (textCache === wrapper.textCache) {
	                    return;
	                }
	                wrapper.textCache = textCache;

	                /// remove old text
	                while (i--) {
	                    textNode.removeChild(childNodes[i]);
	                }

	                // Skip tspans, add text directly to text node. The forceTSpan is a hook
	                // used in text outline hack.
	                if (!hasMarkup && !textOutline && !ellipsis && !width && textStr.indexOf(' ') === -1) {
	                    textNode.appendChild(doc.createTextNode(unescapeAngleBrackets(textStr)));

	                    // Complex strings, add more logic
	                } else {

	                    clsRegex = /<.*class="([^"]+)".*>/;
	                    styleRegex = /<.*style="([^"]+)".*>/;
	                    hrefRegex = /<.*href="([^"]+)".*>/;

	                    if (tempParent) {
	                        tempParent.appendChild(textNode); // attach it to the DOM to read offset width
	                    }

	                    if (hasMarkup) {
	                        lines = textStr

	                            .replace(/<(b|strong)>/g, '<span style="font-weight:bold">')
	                            .replace(/<(i|em)>/g, '<span style="font-style:italic">')

	                            .replace(/<a/g, '<span')
	                            .replace(/<\/(b|strong|i|em|a)>/g, '</span>')
	                            .split(/<br.*?>/g);

	                    } else {
	                        lines = [textStr];
	                    }


	                    // Trim empty lines (#5261)
	                    lines = grep(lines, function(line) {
	                        return line !== '';
	                    });


	                    // build the lines
	                    each(lines, function buildTextLines(line, lineNo) {
	                        var spans,
	                            spanNo = 0;
	                        line = line
	                            .replace(/^\s+|\s+$/g, '') // Trim to prevent useless/costly process on the spaces (#5258)
	                            .replace(/<span/g, '|||<span')
	                            .replace(/<\/span>/g, '</span>|||');
	                        spans = line.split('|||');

	                        each(spans, function buildTextSpans(span) {
	                            if (span !== '' || spans.length === 1) {
	                                var attributes = {},
	                                    tspan = doc.createElementNS(renderer.SVG_NS, 'tspan'),
	                                    spanCls,
	                                    spanStyle; // #390
	                                if (clsRegex.test(span)) {
	                                    spanCls = span.match(clsRegex)[1];
	                                    attr(tspan, 'class', spanCls);
	                                }
	                                if (styleRegex.test(span)) {
	                                    spanStyle = span.match(styleRegex)[1].replace(/(;| |^)color([ :])/, '$1fill$2');
	                                    attr(tspan, 'style', spanStyle);
	                                }
	                                if (hrefRegex.test(span) && !forExport) { // Not for export - #1529
	                                    attr(tspan, 'onclick', 'location.href=\"' + span.match(hrefRegex)[1] + '\"');
	                                    css(tspan, {
	                                        cursor: 'pointer'
	                                    });
	                                }

	                                span = unescapeAngleBrackets(span.replace(/<(.|\n)*?>/g, '') || ' ');

	                                // Nested tags aren't supported, and cause crash in Safari (#1596)
	                                if (span !== ' ') {

	                                    // add the text node
	                                    tspan.appendChild(doc.createTextNode(span));

	                                    if (!spanNo) { // first span in a line, align it to the left
	                                        if (lineNo && parentX !== null) {
	                                            attributes.x = parentX;
	                                        }
	                                    } else {
	                                        attributes.dx = 0; // #16
	                                    }

	                                    // add attributes
	                                    attr(tspan, attributes);

	                                    // Append it
	                                    textNode.appendChild(tspan);

	                                    // first span on subsequent line, add the line height
	                                    if (!spanNo && isSubsequentLine) {

	                                        // allow getting the right offset height in exporting in IE
	                                        if (!svg && forExport) {
	                                            css(tspan, {
	                                                display: 'block'
	                                            });
	                                        }

	                                        // Set the line height based on the font size of either
	                                        // the text element or the tspan element
	                                        attr(
	                                            tspan,
	                                            'dy',
	                                            getLineHeight(tspan)
	                                        );
	                                    }

	                                    /*if (width) {
	                                        renderer.breakText(wrapper, width);
	                                    }*/

	                                    // Check width and apply soft breaks or ellipsis
	                                    if (width) {
	                                        var words = span.replace(/([^\^])-/g, '$1- ').split(' '), // #1273
	                                            hasWhiteSpace = spans.length > 1 || lineNo || (words.length > 1 && !noWrap),
	                                            tooLong,
	                                            rest = [],
	                                            actualWidth,
	                                            dy = getLineHeight(tspan),
	                                            rotation = wrapper.rotation;

	                                        if (ellipsis) {
	                                            wasTooLong = renderer.applyEllipsis(wrapper, tspan, span, width);
	                                        }

	                                        while (!ellipsis && hasWhiteSpace && (words.length || rest.length)) {
	                                            wrapper.rotation = 0; // discard rotation when computing box
	                                            actualWidth = renderer.getSpanWidth(wrapper, tspan);
	                                            tooLong = actualWidth > width;

	                                            // For ellipsis, do a binary search for the correct string length
	                                            if (wasTooLong === undefined) {
	                                                wasTooLong = tooLong; // First time
	                                            }

	                                            // Looping down, this is the first word sequence that is not too long,
	                                            // so we can move on to build the next line.
	                                            if (!tooLong || words.length === 1) {
	                                                words = rest;
	                                                rest = [];

	                                                if (words.length && !noWrap) {
	                                                    tspan = doc.createElementNS(SVG_NS, 'tspan');
	                                                    attr(tspan, {
	                                                        dy: dy,
	                                                        x: parentX
	                                                    });
	                                                    if (spanStyle) { // #390
	                                                        attr(tspan, 'style', spanStyle);
	                                                    }
	                                                    textNode.appendChild(tspan);
	                                                }
	                                                if (actualWidth > width) { // a single word is pressing it out
	                                                    width = actualWidth;
	                                                }
	                                            } else { // append to existing line tspan
	                                                tspan.removeChild(tspan.firstChild);
	                                                rest.unshift(words.pop());
	                                            }
	                                            if (words.length) {
	                                                tspan.appendChild(doc.createTextNode(words.join(' ').replace(/- /g, '-')));
	                                            }
	                                        }
	                                        wrapper.rotation = rotation;
	                                    }

	                                    spanNo++;
	                                }
	                            }
	                        });
	                        // To avoid beginning lines that doesn't add to the textNode (#6144)
	                        isSubsequentLine = isSubsequentLine || textNode.childNodes.length;
	                    });

	                    if (wasTooLong) {
	                        wrapper.attr('title', wrapper.textStr);
	                    }
	                    if (tempParent) {
	                        tempParent.removeChild(textNode); // attach it to the DOM to read offset width
	                    }

	                    // Apply the text outline
	                    if (textOutline && wrapper.applyTextOutline) {
	                        wrapper.applyTextOutline(textOutline);
	                    }
	                }
	            },



	            /*
	            breakText: function (wrapper, width) {
	                var bBox = wrapper.getBBox(),
	                    node = wrapper.element,
	                    textLength = node.textContent.length,
	                    pos = Math.round(width * textLength / bBox.width), // try this position first, based on average character width
	                    increment = 0,
	                    finalPos;

	                if (bBox.width > width) {
	                    while (finalPos === undefined) {
	                        textLength = node.getSubStringLength(0, pos);

	                        if (textLength <= width) {
	                            if (increment === -1) {
	                                finalPos = pos;
	                            } else {
	                                increment = 1;
	                            }
	                        } else {
	                            if (increment === 1) {
	                                finalPos = pos - 1;
	                            } else {
	                                increment = -1;
	                            }
	                        }
	                        pos += increment;
	                    }
	                }
	                console.log('width', width, 'stringWidth', node.getSubStringLength(0, finalPos))
	            },
	            */

	            /**
	             * Returns white for dark colors and black for bright colors.
	             *
	             * @param {ColorString} rgba - The color to get the contrast for.
	             * @returns {string} The contrast color, either `#000000` or `#FFFFFF`.
	             */
	            getContrast: function(rgba) {
	                rgba = color(rgba).rgba;

	                // The threshold may be discussed. Here's a proposal for adding
	                // different weight to the color channels (#6216)
	                /*
	        rgba[0] *= 1; // red
	        rgba[1] *= 1.2; // green
	        rgba[2] *= 0.7; // blue
	        */

	                return rgba[0] + rgba[1] + rgba[2] > 2 * 255 ? '#000000' : '#FFFFFF';
	            },

	            /**
	             * Create a button with preset states.
	             * @param {string} text - The text or HTML to draw.
	             * @param {number} x - The x position of the button's left side.
	             * @param {number} y - The y position of the button's top side.
	             * @param {Function} callback - The function to execute on button click or 
	             *    touch.
	             * @param {SVGAttributes} [normalState] - SVG attributes for the normal
	             *    state.
	             * @param {SVGAttributes} [hoverState] - SVG attributes for the hover state.
	             * @param {SVGAttributes} [pressedState] - SVG attributes for the pressed
	             *    state.
	             * @param {SVGAttributes} [disabledState] - SVG attributes for the disabled
	             *    state.
	             * @param {Symbol} [shape=rect] - The shape type.
	             * @returns {SVGRenderer} The button element.
	             */
	            button: function(text, x, y, callback, normalState, hoverState, pressedState, disabledState, shape) {
	                var label = this.label(text, x, y, shape, null, null, null, null, 'button'),
	                    curState = 0;

	                // Default, non-stylable attributes
	                label.attr(merge({
	                    'padding': 8,
	                    'r': 2
	                }, normalState));


	                // Presentational
	                var normalStyle,
	                    hoverStyle,
	                    pressedStyle,
	                    disabledStyle;

	                // Normal state - prepare the attributes
	                normalState = merge({
	                    fill: '#f7f7f7',
	                    stroke: '#cccccc',
	                    'stroke-width': 1,
	                    style: {
	                        color: '#333333',
	                        cursor: 'pointer',
	                        fontWeight: 'normal'
	                    }
	                }, normalState);
	                normalStyle = normalState.style;
	                delete normalState.style;

	                // Hover state
	                hoverState = merge(normalState, {
	                    fill: '#e6e6e6'
	                }, hoverState);
	                hoverStyle = hoverState.style;
	                delete hoverState.style;

	                // Pressed state
	                pressedState = merge(normalState, {
	                    fill: '#e6ebf5',
	                    style: {
	                        color: '#000000',
	                        fontWeight: 'bold'
	                    }
	                }, pressedState);
	                pressedStyle = pressedState.style;
	                delete pressedState.style;

	                // Disabled state
	                disabledState = merge(normalState, {
	                    style: {
	                        color: '#cccccc'
	                    }
	                }, disabledState);
	                disabledStyle = disabledState.style;
	                delete disabledState.style;


	                // Add the events. IE9 and IE10 need mouseover and mouseout to funciton (#667).
	                addEvent(label.element, isMS ? 'mouseover' : 'mouseenter', function() {
	                    if (curState !== 3) {
	                        label.setState(1);
	                    }
	                });
	                addEvent(label.element, isMS ? 'mouseout' : 'mouseleave', function() {
	                    if (curState !== 3) {
	                        label.setState(curState);
	                    }
	                });

	                label.setState = function(state) {
	                    // Hover state is temporary, don't record it
	                    if (state !== 1) {
	                        label.state = curState = state;
	                    }
	                    // Update visuals
	                    label.removeClass(/highcharts-button-(normal|hover|pressed|disabled)/)
	                        .addClass('highcharts-button-' + ['normal', 'hover', 'pressed', 'disabled'][state || 0]);


	                    label.attr([normalState, hoverState, pressedState, disabledState][state || 0])
	                        .css([normalStyle, hoverStyle, pressedStyle, disabledStyle][state || 0]);

	                };



	                // Presentational attributes
	                label
	                    .attr(normalState)
	                    .css(extend({
	                        cursor: 'default'
	                    }, normalStyle));


	                return label
	                    .on('click', function(e) {
	                        if (curState !== 3) {
	                            callback.call(label, e);
	                        }
	                    });
	            },

	            /**
	             * Make a straight line crisper by not spilling out to neighbour pixels.
	             * 
	             * @param {Array} points - The original points on the format `['M', 0, 0,
	             *    'L', 100, 0]`.
	             * @param {number} width - The width of the line.
	             * @returns {Array} The original points array, but modified to render
	             * crisply.
	             */
	            crispLine: function(points, width) {
	                // normalize to a crisp line
	                if (points[1] === points[4]) {
	                    // Substract due to #1129. Now bottom and left axis gridlines behave the same.
	                    points[1] = points[4] = Math.round(points[1]) - (width % 2 / 2);
	                }
	                if (points[2] === points[5]) {
	                    points[2] = points[5] = Math.round(points[2]) + (width % 2 / 2);
	                }
	                return points;
	            },


	            /**
	             * Draw a path, wraps the SVG `path` element.
	             * 
	             * @param {Array} [path] An SVG path definition in array form.
	             * 
	             * @example
	             * var path = renderer.path(['M', 10, 10, 'L', 30, 30, 'z'])
	             *     .attr({ stroke: '#ff00ff' })
	             *     .add();
	             * @returns {SVGElement} The generated wrapper element.
	             *
	             * @sample highcharts/members/renderer-path-on-chart/
	             *         Draw a path in a chart
	             * @sample highcharts/members/renderer-path/
	             *         Draw a path independent from a chart
	             *
	             */
	            /**
	             * Draw a path, wraps the SVG `path` element.
	             * 
	             * @param {SVGAttributes} [attribs] The initial attributes.
	             * @returns {SVGElement} The generated wrapper element.
	             */
	            path: function(path) {
	                var attribs = {

	                    fill: 'none'

	                };
	                if (isArray(path)) {
	                    attribs.d = path;
	                } else if (isObject(path)) { // attributes
	                    extend(attribs, path);
	                }
	                return this.createElement('path').attr(attribs);
	            },

	            /**
	             * Draw a circle, wraps the SVG `circle` element.
	             * 
	             * @param {number} [x] The center x position.
	             * @param {number} [y] The center y position.
	             * @param {number} [r] The radius.
	             * @returns {SVGElement} The generated wrapper element.
	             *
	             * @sample highcharts/members/renderer-circle/ Drawing a circle
	             */
	            /**
	             * Draw a circle, wraps the SVG `circle` element.
	             * 
	             * @param {SVGAttributes} [attribs] The initial attributes.
	             * @returns {SVGElement} The generated wrapper element.
	             */
	            circle: function(x, y, r) {
	                var attribs = isObject(x) ? x : {
	                        x: x,
	                        y: y,
	                        r: r
	                    },
	                    wrapper = this.createElement('circle');

	                // Setting x or y translates to cx and cy
	                wrapper.xSetter = wrapper.ySetter = function(value, key, element) {
	                    element.setAttribute('c' + key, value);
	                };

	                return wrapper.attr(attribs);
	            },

	            /**
	             * Draw and return an arc.
	             * @param {number} [x=0] Center X position.
	             * @param {number} [y=0] Center Y position.
	             * @param {number} [r=0] The outer radius of the arc.
	             * @param {number} [innerR=0] Inner radius like used in donut charts.
	             * @param {number} [start=0] The starting angle of the arc in radians, where
	             *    0 is to the right and `-Math.PI/2` is up.
	             * @param {number} [end=0] The ending angle of the arc in radians, where 0
	             *    is to the right and `-Math.PI/2` is up.
	             * @returns {SVGElement} The generated wrapper element.
	             *
	             * @sample highcharts/members/renderer-arc/
	             *         Drawing an arc
	             */
	            /**
	             * Draw and return an arc. Overloaded function that takes arguments object.
	             * @param {SVGAttributes} attribs Initial SVG attributes.
	             * @returns {SVGElement} The generated wrapper element.
	             */
	            arc: function(x, y, r, innerR, start, end) {
	                var arc,
	                    options;

	                if (isObject(x)) {
	                    options = x;
	                    y = options.y;
	                    r = options.r;
	                    innerR = options.innerR;
	                    start = options.start;
	                    end = options.end;
	                    x = options.x;
	                } else {
	                    options = {
	                        innerR: innerR,
	                        start: start,
	                        end: end
	                    };
	                }

	                // Arcs are defined as symbols for the ability to set
	                // attributes in attr and animate
	                arc = this.symbol('arc', x, y, r, r, options);
	                arc.r = r; // #959
	                return arc;
	            },

	            /**
	             * Draw and return a rectangle.
	             * @param {number} [x] Left position.
	             * @param {number} [y] Top position.
	             * @param {number} [width] Width of the rectangle.
	             * @param {number} [height] Height of the rectangle.
	             * @param {number} [r] Border corner radius.
	             * @param {number} [strokeWidth] A stroke width can be supplied to allow
	             *    crisp drawing.
	             * @returns {SVGElement} The generated wrapper element.
	             */
	            /**
	             * Draw and return a rectangle.
	             * @param  {SVGAttributes} [attributes]
	             *         General SVG attributes for the rectangle.
	             * @return {SVGElement}
	             *         The generated wrapper element.
	             *
	             * @sample highcharts/members/renderer-rect-on-chart/
	             *         Draw a rectangle in a chart
	             * @sample highcharts/members/renderer-rect/
	             *         Draw a rectangle independent from a chart
	             */
	            rect: function(x, y, width, height, r, strokeWidth) {

	                r = isObject(x) ? x.r : r;

	                var wrapper = this.createElement('rect'),
	                    attribs = isObject(x) ? x : x === undefined ? {} : {
	                        x: x,
	                        y: y,
	                        width: Math.max(width, 0),
	                        height: Math.max(height, 0)
	                    };


	                if (strokeWidth !== undefined) {
	                    attribs.strokeWidth = strokeWidth;
	                    attribs = wrapper.crisp(attribs);
	                }
	                attribs.fill = 'none';


	                if (r) {
	                    attribs.r = r;
	                }

	                wrapper.rSetter = function(value, key, element) {
	                    attr(element, {
	                        rx: value,
	                        ry: value
	                    });
	                };

	                return wrapper.attr(attribs);
	            },

	            /**
	             * Resize the {@link SVGRenderer#box} and re-align all aligned child
	             * elements.
	             * @param  {number} width
	             *         The new pixel width.
	             * @param  {number} height
	             *         The new pixel height.
	             * @param  {Boolean|AnimationOptions} [animate=true]
	             *         Whether and how to animate.
	             */
	            setSize: function(width, height, animate) {
	                var renderer = this,
	                    alignedObjects = renderer.alignedObjects,
	                    i = alignedObjects.length;

	                renderer.width = width;
	                renderer.height = height;

	                renderer.boxWrapper.animate({
	                    width: width,
	                    height: height
	                }, {
	                    step: function() {
	                        this.attr({
	                            viewBox: '0 0 ' + this.attr('width') + ' ' + this.attr('height')
	                        });
	                    },
	                    duration: pick(animate, true) ? undefined : 0
	                });

	                while (i--) {
	                    alignedObjects[i].align();
	                }
	            },

	            /**
	             * Create and return an svg group element. Child {@link Highcharts.SVGElement}
	             * objects are added to the group by using the group as the first parameter
	             * in {@link Highcharts.SVGElement#add|add()}.
	             * 
	             * @param {string} [name] The group will be given a class name of
	             * `highcharts-{name}`. This can be used for styling and scripting.
	             * @returns {SVGElement} The generated wrapper element.
	             *
	             * @sample highcharts/members/renderer-g/
	             *         Show and hide grouped objects
	             */
	            g: function(name) {
	                var elem = this.createElement('g');
	                return name ? elem.attr({
	                    'class': 'highcharts-' + name
	                }) : elem;
	            },

	            /**
	             * Display an image.
	             * @param {string} src The image source.
	             * @param {number} [x] The X position.
	             * @param {number} [y] The Y position.
	             * @param {number} [width] The image width. If omitted, it defaults to the 
	             *    image file width.
	             * @param {number} [height] The image height. If omitted it defaults to the
	             *    image file height.
	             * @returns {SVGElement} The generated wrapper element.
	             *
	             * @sample highcharts/members/renderer-image-on-chart/
	             *         Add an image in a chart
	             * @sample highcharts/members/renderer-image/
	             *         Add an image independent of a chart
	             */
	            image: function(src, x, y, width, height) {
	                var attribs = {
	                        preserveAspectRatio: 'none'
	                    },
	                    elemWrapper;

	                // optional properties
	                if (arguments.length > 1) {
	                    extend(attribs, {
	                        x: x,
	                        y: y,
	                        width: width,
	                        height: height
	                    });
	                }

	                elemWrapper = this.createElement('image').attr(attribs);

	                // set the href in the xlink namespace
	                if (elemWrapper.element.setAttributeNS) {
	                    elemWrapper.element.setAttributeNS('http://www.w3.org/1999/xlink',
	                        'href', src);
	                } else {
	                    // could be exporting in IE
	                    // using href throws "not supported" in ie7 and under, requries regex shim to fix later
	                    elemWrapper.element.setAttribute('hc-svg-href', src);
	                }
	                return elemWrapper;
	            },

	            /**
	             * Draw a symbol out of pre-defined shape paths from {@link SVGRenderer#symbols}.
	             * It is used in Highcharts for point makers, which cake a `symbol` option,
	             * and label and button backgrounds like in the tooltip and stock flags.
	             *
	             * @param {Symbol} symbol - The symbol name.
	             * @param {number} x - The X coordinate for the top left position.
	             * @param {number} y - The Y coordinate for the top left position.
	             * @param {number} width - The pixel width.
	             * @param {number} height - The pixel height.
	             * @param {Object} [options] - Additional options, depending on the actual
	             *    symbol drawn. 
	             * @param {number} [options.anchorX] - The anchor X position for the
	             *    `callout` symbol. This is where the chevron points to.
	             * @param {number} [options.anchorY] - The anchor Y position for the
	             *    `callout` symbol. This is where the chevron points to.
	             * @param {number} [options.end] - The end angle of an `arc` symbol.
	             * @param {boolean} [options.open] - Whether to draw `arc` symbol open or
	             *    closed.
	             * @param {number} [options.r] - The radius of an `arc` symbol, or the
	             *    border radius for the `callout` symbol.
	             * @param {number} [options.start] - The start angle of an `arc` symbol.
	             */
	            symbol: function(symbol, x, y, width, height, options) {

	                var ren = this,
	                    obj,
	                    imageRegex = /^url\((.*?)\)$/,
	                    isImage = imageRegex.test(symbol),
	                    sym = !isImage && (this.symbols[symbol] ? symbol : 'circle'),


	                    // get the symbol definition function
	                    symbolFn = sym && this.symbols[sym],

	                    // check if there's a path defined for this symbol
	                    path = defined(x) && symbolFn && symbolFn.call(
	                        this.symbols,
	                        Math.round(x),
	                        Math.round(y),
	                        width,
	                        height,
	                        options
	                    ),
	                    imageSrc,
	                    centerImage;
	                if(sym == "minimize")
	                {
	                    path = defined(x) && symbolFn && symbolFn.call(
	                        this.symbols,
	                        x - 25,
	                        y,
	                        32,
	                        32,
	                        options
	                    );
	                }

	                if (symbolFn) {
	                    obj = this.path(path);


	                    obj.attr('fill', 'none');


	                    // expando properties for use in animate and attr
	                    extend(obj, {
	                        symbolName: sym,
	                        x: x,
	                        y: y,
	                        width: width,
	                        height: height
	                    });
	                    if (options) {
	                        extend(obj, options);
	                    }


	                    // Image symbols
	                } else if (isImage) {


	                    imageSrc = symbol.match(imageRegex)[1];

	                    // Create the image synchronously, add attribs async
	                    obj = this.image(imageSrc);

	                    // The image width is not always the same as the symbol width. The
	                    // image may be centered within the symbol, as is the case when
	                    // image shapes are used as label backgrounds, for example in flags.
	                    obj.imgwidth = pick(
	                        symbolSizes[imageSrc] && symbolSizes[imageSrc].width,
	                        options && options.width
	                    );
	                    obj.imgheight = pick(
	                        symbolSizes[imageSrc] && symbolSizes[imageSrc].height,
	                        options && options.height
	                    );
	                    /**
	                     * Set the size and position
	                     */
	                    centerImage = function() {
	                        obj.attr({
	                            width: obj.width,
	                            height: obj.height
	                        });
	                    };

	                    /**
	                     * Width and height setters that take both the image's physical size
	                     * and the label size into consideration, and translates the image
	                     * to center within the label.
	                     */
	                    each(['width', 'height'], function(key) {
	                        obj[key + 'Setter'] = function(value, key) {
	                            var attribs = {},
	                                imgSize = this['img' + key],
	                                trans = key === 'width' ? 'translateX' : 'translateY';
	                            this[key] = value;
	                            if (defined(imgSize)) {
	                                if (this.element) {
	                                    this.element.setAttribute(key, imgSize);
	                                }
	                                if (!this.alignByTranslate) {
	                                    attribs[trans] = ((this[key] || 0) - imgSize) / 2;
	                                    this.attr(attribs);
	                                }
	                            }
	                        };
	                    });


	                    if (defined(x)) {
	                        obj.attr({
	                            x: x,
	                            y: y
	                        });
	                    }
	                    obj.isImg = true;

	                    if (defined(obj.imgwidth) && defined(obj.imgheight)) {
	                        centerImage();
	                    } else {
	                        // Initialize image to be 0 size so export will still function if there's no cached sizes.
	                        obj.attr({
	                            width: 0,
	                            height: 0
	                        });

	                        // Create a dummy JavaScript image to get the width and height. Due to a bug in IE < 8,
	                        // the created element must be assigned to a variable in order to load (#292).
	                        createElement('img', {
	                            onload: function() {

	                                var chart = charts[ren.chartIndex];

	                                // Special case for SVGs on IE11, the width is not accessible until the image is
	                                // part of the DOM (#2854).
	                                if (this.width === 0) {
	                                    css(this, {
	                                        position: 'absolute',
	                                        top: '-999em'
	                                    });
	                                    doc.body.appendChild(this);
	                                }

	                                // Center the image
	                                symbolSizes[imageSrc] = { // Cache for next 
	                                    width: this.width,
	                                    height: this.height
	                                };
	                                obj.imgwidth = this.width;
	                                obj.imgheight = this.height;

	                                if (obj.element) {
	                                    centerImage();
	                                }

	                                // Clean up after #2854 workaround.
	                                if (this.parentNode) {
	                                    this.parentNode.removeChild(this);
	                                }

	                                // Fire the load event when all external images are loaded
	                                ren.imgCount--;
	                                if (!ren.imgCount && chart && chart.onload) {
	                                    chart.onload();
	                                }
	                            },
	                            src: imageSrc
	                        });
	                        this.imgCount++;
	                    }
	                }
	                return obj;
	            },

	            /**
	             * @typedef {string} Symbol
	             * 
	             * Can be one of `arc`, `callout`, `circle`, `diamond`, `square`,
	             * `triangle`, `triangle-down`. Symbols are used internally for point
	             * markers, button and label borders and backgrounds, or custom shapes.
	             * Extendable by adding to {@link SVGRenderer#symbols}.
	             */
	            /**
	             * An extendable collection of functions for defining symbol paths.
	             */
	            symbols: {
	                'circle': function(x, y, w, h) {
	                    // Return a full arc
	                    return this.arc(x + w / 2, y + h / 2, w / 2, h / 2, {
	                        start: 0,
	                        end: Math.PI * 2,
	                        open: false
	                    });
	                },

	                'square': function(x, y, w, h) {
	                    return [
	                        'M', x, y,
	                        'L', x + w, y,
	                        x + w, y + h,
	                        x, y + h,
	                        'Z'
	                    ];
	                },

	                'triangle': function(x, y, w, h) {
	                    return [
	                        'M', x + w / 2, y,
	                        'L', x + w, y + h,
	                        x, y + h,
	                        'Z'
	                    ];
	                },

	                'triangle-down': function(x, y, w, h) {
	                    return [
	                        'M', x, y,
	                        'L', x + w, y,
	                        x + w / 2, y + h,
	                        'Z'
	                    ];
	                },

	                'minimize' : function(x, y, w, h){
	                    x = x + 16;
	                    return [
	                        'M', x + w, y,
	                        'L',  
	                        x + w / 2 + w / 20, y + h / 2 - h / 20,
	                        x + w / 2 + w / 20, y + h / 8,
	                        x + w / 2 + w / 20, y + h / 2 - h / 20,
	                        x + w - w / 8, y + h / 2 - h / 20,
	                        x + w / 2 + w / 20, y + h / 2 - h / 20,
	                        x + w, y,
	                        'Z',
	                        'M', x, y + h,
	                        'L',  
	                        x + w / 2 - w / 20, y + h / 2 + h / 20,
	                        x + w / 8, y + h / 2 + h / 20,
	                        x + w / 2 - w / 20, y + h / 2 + h / 20,
	                        x + w / 2 - w / 8, y + h - h / 20,
	                        x + w / 2 - w / 20, y + h / 2 + h / 20,
	                        x, y + h,
	                        'Z'

	                    ];
	                },

	                'diamond': function(x, y, w, h) {
	                    return [
	                        'M', x + w / 2, y,
	                        'L', x + w, y + h / 2,
	                        x + w / 2, y + h,
	                        x, y + h / 2,
	                        'Z'
	                    ];
	                },
	                'arc': function(x, y, w, h, options) {
	                    var start = options.start,
	                        rx = options.r || w,
	                        ry = options.r || h || w,
	                        proximity = 0.001,
	                        fullCircle =
	                        Math.abs(options.end - options.start - 2 * Math.PI) <
	                        proximity,
	                        // Substract a small number to prevent cos and sin of start and
	                        // end from becoming equal on 360 arcs (related: #1561)
	                        end = options.end - proximity,
	                        innerRadius = options.innerR,
	                        open = pick(options.open, fullCircle),
	                        cosStart = Math.cos(start),
	                        sinStart = Math.sin(start),
	                        cosEnd = Math.cos(end),
	                        sinEnd = Math.sin(end),
	                        // Proximity takes care of rounding errors around PI (#6971)
	                        longArc = options.end - start - Math.PI < proximity ? 0 : 1,
	                        arc;

	                    arc = [
	                        'M',
	                        x + rx * cosStart,
	                        y + ry * sinStart,
	                        'A', // arcTo
	                        rx, // x radius
	                        ry, // y radius
	                        0, // slanting
	                        longArc, // long or short arc
	                        1, // clockwise
	                        x + rx * cosEnd,
	                        y + ry * sinEnd
	                    ];

	                    if (defined(innerRadius)) {
	                        arc.push(
	                            open ? 'M' : 'L',
	                            x + innerRadius * cosEnd,
	                            y + innerRadius * sinEnd,
	                            'A', // arcTo
	                            innerRadius, // x radius
	                            innerRadius, // y radius
	                            0, // slanting
	                            longArc, // long or short arc
	                            0, // clockwise
	                            x + innerRadius * cosStart,
	                            y + innerRadius * sinStart
	                        );
	                    }

	                    arc.push(open ? '' : 'Z'); // close
	                    return arc;
	                },

	                /**
	                 * Callout shape used for default tooltips, also used for rounded rectangles in VML
	                 */
	                callout: function(x, y, w, h, options) {
	                    var arrowLength = 6,
	                        halfDistance = 6,
	                        r = Math.min((options && options.r) || 0, w, h),
	                        safeDistance = r + halfDistance,
	                        anchorX = options && options.anchorX,
	                        anchorY = options && options.anchorY,
	                        path;

	                    path = [
	                        'M', x + r, y,
	                        'L', x + w - r, y, // top side
	                        'C', x + w, y, x + w, y, x + w, y + r, // top-right corner
	                        'L', x + w, y + h - r, // right side
	                        'C', x + w, y + h, x + w, y + h, x + w - r, y + h, // bottom-right corner
	                        'L', x + r, y + h, // bottom side
	                        'C', x, y + h, x, y + h, x, y + h - r, // bottom-left corner
	                        'L', x, y + r, // left side
	                        'C', x, y, x, y, x + r, y // top-left corner
	                    ];

	                    // Anchor on right side
	                    if (anchorX && anchorX > w) {

	                        // Chevron
	                        if (anchorY > y + safeDistance && anchorY < y + h - safeDistance) {
	                            path.splice(13, 3,
	                                'L', x + w, anchorY - halfDistance,
	                                x + w + arrowLength, anchorY,
	                                x + w, anchorY + halfDistance,
	                                x + w, y + h - r
	                            );

	                            // Simple connector
	                        } else {
	                            path.splice(13, 3,
	                                'L', x + w, h / 2,
	                                anchorX, anchorY,
	                                x + w, h / 2,
	                                x + w, y + h - r
	                            );
	                        }

	                        // Anchor on left side
	                    } else if (anchorX && anchorX < 0) {

	                        // Chevron
	                        if (anchorY > y + safeDistance && anchorY < y + h - safeDistance) {
	                            path.splice(33, 3,
	                                'L', x, anchorY + halfDistance,
	                                x - arrowLength, anchorY,
	                                x, anchorY - halfDistance,
	                                x, y + r
	                            );

	                            // Simple connector
	                        } else {
	                            path.splice(33, 3,
	                                'L', x, h / 2,
	                                anchorX, anchorY,
	                                x, h / 2,
	                                x, y + r
	                            );
	                        }

	                    } else if (anchorY && anchorY > h && anchorX > x + safeDistance && anchorX < x + w - safeDistance) { // replace bottom
	                        path.splice(23, 3,
	                            'L', anchorX + halfDistance, y + h,
	                            anchorX, y + h + arrowLength,
	                            anchorX - halfDistance, y + h,
	                            x + r, y + h
	                        );
	                    } else if (anchorY && anchorY < 0 && anchorX > x + safeDistance && anchorX < x + w - safeDistance) { // replace top
	                        path.splice(3, 3,
	                            'L', anchorX - halfDistance, y,
	                            anchorX, y - arrowLength,
	                            anchorX + halfDistance, y,
	                            w - r, y
	                        );
	                    }

	                    return path;
	                }
	            },

	            /**
	             * @typedef {SVGElement} ClipRect - A clipping rectangle that can be applied
	             * to one or more {@link SVGElement} instances. It is instanciated with the
	             * {@link SVGRenderer#clipRect} function and applied with the {@link 
	             * SVGElement#clip} function.
	             *
	             * @example
	             * var circle = renderer.circle(100, 100, 100)
	             *     .attr({ fill: 'red' })
	             *     .add();
	             * var clipRect = renderer.clipRect(100, 100, 100, 100);
	             *
	             * // Leave only the lower right quarter visible
	             * circle.clip(clipRect);
	             */
	            /**
	             * Define a clipping rectangle. The clipping rectangle is later applied
	             * to {@link SVGElement} objects through the {@link SVGElement#clip}
	             * function.
	             * 
	             * @param {String} id
	             * @param {number} x
	             * @param {number} y
	             * @param {number} width
	             * @param {number} height
	             * @returns {ClipRect} A clipping rectangle.
	             *
	             * @example
	             * var circle = renderer.circle(100, 100, 100)
	             *     .attr({ fill: 'red' })
	             *     .add();
	             * var clipRect = renderer.clipRect(100, 100, 100, 100);
	             *
	             * // Leave only the lower right quarter visible
	             * circle.clip(clipRect);
	             */
	            clipRect: function(x, y, width, height) {
	                var wrapper,
	                    id = H.uniqueKey(),

	                    clipPath = this.createElement('clipPath').attr({
	                        id: id
	                    }).add(this.defs);

	                wrapper = this.rect(x, y, width, height, 0).add(clipPath);
	                wrapper.id = id;
	                wrapper.clipPath = clipPath;
	                wrapper.count = 0;

	                return wrapper;
	            },





	            /**
	             * Draw text. The text can contain a subset of HTML, like spans and anchors
	             * and some basic text styling of these. For more advanced features like
	             * border and background, use {@link Highcharts.SVGRenderer#label} instead.
	             * To update the text after render, run `text.attr({ text: 'New text' })`.
	             * @param  {String} str
	             *         The text of (subset) HTML to draw.
	             * @param  {number} x
	             *         The x position of the text's lower left corner.
	             * @param  {number} y
	             *         The y position of the text's lower left corner.
	             * @param  {Boolean} [useHTML=false]
	             *         Use HTML to render the text.
	             *
	             * @return {SVGElement} The text object.
	             *
	             * @sample highcharts/members/renderer-text-on-chart/
	             *         Annotate the chart freely
	             * @sample highcharts/members/renderer-on-chart/
	             *         Annotate with a border and in response to the data
	             * @sample highcharts/members/renderer-text/
	             *         Formatted text
	             */
	            text: function(str, x, y, useHTML) {

	                // declare variables
	                var renderer = this,
	                    fakeSVG = !svg && renderer.forExport,
	                    wrapper,
	                    attribs = {};

	                if (useHTML && (renderer.allowHTML || !renderer.forExport)) {
	                    return renderer.html(str, x, y);
	                }

	                attribs.x = Math.round(x || 0); // X is always needed for line-wrap logic
	                if (y) {
	                    attribs.y = Math.round(y);
	                }
	                if (str || str === 0) {
	                    attribs.text = str;
	                }

	                wrapper = renderer.createElement('text')
	                    .attr(attribs);

	                // Prevent wrapping from creating false offsetWidths in export in legacy IE (#1079, #1063)
	                if (fakeSVG) {
	                    wrapper.css({
	                        position: 'absolute'
	                    });
	                }

	                if (!useHTML) {
	                    wrapper.xSetter = function(value, key, element) {
	                        var tspans = element.getElementsByTagName('tspan'),
	                            tspan,
	                            parentVal = element.getAttribute(key),
	                            i;
	                        for (i = 0; i < tspans.length; i++) {
	                            tspan = tspans[i];
	                            // If the x values are equal, the tspan represents a linebreak
	                            if (tspan.getAttribute(key) === parentVal) {
	                                tspan.setAttribute(key, value);
	                            }
	                        }
	                        element.setAttribute(key, value);
	                    };
	                }

	                return wrapper;
	            },

	            /**
	             * Utility to return the baseline offset and total line height from the font
	             * size.
	             *
	             * @param {?string} fontSize The current font size to inspect. If not given,
	             *   the font size will be found from the DOM element.
	             * @param {SVGElement|SVGDOMElement} [elem] The element to inspect for a
	             *   current font size.
	             * @returns {Object} An object containing `h`: the line height, `b`: the
	             * baseline relative to the top of the box, and `f`: the font size.
	             */
	            fontMetrics: function(fontSize, elem) {
	                var lineHeight,
	                    baseline;


	                fontSize = fontSize ||
	                    // When the elem is a DOM element (#5932)
	                    (elem && elem.style && elem.style.fontSize) ||
	                    // Fall back on the renderer style default
	                    (this.style && this.style.fontSize);



	                // Handle different units
	                if (/px/.test(fontSize)) {
	                    fontSize = pInt(fontSize);
	                } else if (/em/.test(fontSize)) {
	                    // The em unit depends on parent items
	                    fontSize = parseFloat(fontSize) *
	                        (elem ? this.fontMetrics(null, elem.parentNode).f : 16);
	                } else {
	                    fontSize = 12;
	                }

	                // Empirical values found by comparing font size and bounding box
	                // height. Applies to the default font family.
	                // http://jsfiddle.net/highcharts/7xvn7/
	                lineHeight = fontSize < 24 ? fontSize + 3 : Math.round(fontSize * 1.2);
	                baseline = Math.round(lineHeight * 0.8);

	                return {
	                    h: lineHeight,
	                    b: baseline,
	                    f: fontSize
	                };
	            },

	            /**
	             * Correct X and Y positioning of a label for rotation (#1764).
	             *
	             * @private
	             */
	            rotCorr: function(baseline, rotation, alterY) {
	                var y = baseline;
	                if (rotation && alterY) {
	                    y = Math.max(y * Math.cos(rotation * deg2rad), 4);
	                }
	                return {
	                    x: (-baseline / 3) * Math.sin(rotation * deg2rad),
	                    y: y
	                };
	            },

	            /**
	             * Draw a label, which is an extended text element with support for border
	             * and background. Highcharts creates a `g` element with a text and a `path`
	             * or `rect` inside, to make it behave somewhat like a HTML div. Border and
	             * background are set through `stroke`, `stroke-width` and `fill` attributes
	             * using the {@link Highcharts.SVGElement#attr|attr} method. To update the
	             * text after render, run `label.attr({ text: 'New text' })`.
	             * 
	             * @param  {string} str
	             *         The initial text string or (subset) HTML to render.
	             * @param  {number} x
	             *         The x position of the label's left side.
	             * @param  {number} y
	             *         The y position of the label's top side or baseline, depending on
	             *         the `baseline` parameter.
	             * @param  {String} shape
	             *         The shape of the label's border/background, if any. Defaults to
	             *         `rect`. Other possible values are `callout` or other shapes
	             *         defined in {@link Highcharts.SVGRenderer#symbols}.
	             * @param  {number} anchorX
	             *         In case the `shape` has a pointer, like a flag, this is the
	             *         coordinates it should be pinned to.
	             * @param  {number} anchorY
	             *         In case the `shape` has a pointer, like a flag, this is the
	             *         coordinates it should be pinned to.
	             * @param  {Boolean} baseline
	             *         Whether to position the label relative to the text baseline,
	             *         like {@link Highcharts.SVGRenderer#text|renderer.text}, or to the
	             *         upper border of the rectangle.
	             * @param  {String} className
	             *         Class name for the group.
	             *
	             * @return {SVGElement}
	             *         The generated label.
	             *
	             * @sample highcharts/members/renderer-label-on-chart/
	             *         A label on the chart
	             */
	            label: function(str, x, y, shape, anchorX, anchorY, useHTML, baseline, className) {

	                var renderer = this,
	                    wrapper = renderer.g(className !== 'button' && 'label'),
	                    text = wrapper.text = renderer.text('', 0, 0, useHTML)
	                    .attr({
	                        zIndex: 1
	                    }),
	                    box,
	                    bBox,
	                    alignFactor = 0,
	                    padding = 3,
	                    paddingLeft = 0,
	                    width,
	                    height,
	                    wrapperX,
	                    wrapperY,
	                    textAlign,
	                    deferredAttr = {},
	                    strokeWidth,
	                    baselineOffset,
	                    hasBGImage = /^url\((.*?)\)$/.test(shape),
	                    needsBox = hasBGImage,
	                    getCrispAdjust,
	                    updateBoxSize,
	                    updateTextPadding,
	                    boxAttr;

	                if (className) {
	                    wrapper.addClass('highcharts-' + className);
	                }


	                needsBox = hasBGImage;
	                getCrispAdjust = function() {
	                    return (strokeWidth || 0) % 2 / 2;
	                };



	                /**
	                 * This function runs after the label is added to the DOM (when the bounding box is
	                 * available), and after the text of the label is updated to detect the new bounding
	                 * box and reflect it in the border box.
	                 */
	                updateBoxSize = function() {
	                    var style = text.element.style,
	                        crispAdjust,
	                        attribs = {};

	                    bBox = (width === undefined || height === undefined || textAlign) && defined(text.textStr) &&
	                        text.getBBox(); //#3295 && 3514 box failure when string equals 0
	                    wrapper.width = (width || bBox.width || 0) + 2 * padding + paddingLeft;
	                    wrapper.height = (height || bBox.height || 0) + 2 * padding;

	                    // Update the label-scoped y offset
	                    baselineOffset = padding + renderer.fontMetrics(style && style.fontSize, text).b;


	                    if (needsBox) {

	                        // Create the border box if it is not already present
	                        if (!box) {
	                            wrapper.box = box = renderer.symbols[shape] || hasBGImage ? // Symbol definition exists (#5324)
	                                renderer.symbol(shape) :
	                                renderer.rect();

	                            box.addClass(
	                                (className === 'button' ? '' : 'highcharts-label-box') + // Don't use label className for buttons
	                                (className ? ' highcharts-' + className + '-box' : '')
	                            );

	                            box.add(wrapper);

	                            crispAdjust = getCrispAdjust();
	                            attribs.x = crispAdjust;
	                            attribs.y = (baseline ? -baselineOffset : 0) + crispAdjust;
	                        }

	                        // Apply the box attributes
	                        attribs.width = Math.round(wrapper.width);
	                        attribs.height = Math.round(wrapper.height);

	                        box.attr(extend(attribs, deferredAttr));
	                        deferredAttr = {};
	                    }
	                };

	                /**
	                 * This function runs after setting text or padding, but only if padding is changed
	                 */
	                updateTextPadding = function() {
	                    var textX = paddingLeft + padding,
	                        textY;

	                    // determin y based on the baseline
	                    textY = baseline ? 0 : baselineOffset;

	                    // compensate for alignment
	                    if (defined(width) && bBox && (textAlign === 'center' || textAlign === 'right')) {
	                        textX += {
	                            center: 0.5,
	                            right: 1
	                        }[textAlign] * (width - bBox.width);
	                    }

	                    // update if anything changed
	                    if (textX !== text.x || textY !== text.y) {
	                        text.attr('x', textX);
	                        if (textY !== undefined) {
	                            text.attr('y', textY);
	                        }
	                    }

	                    // record current values
	                    text.x = textX;
	                    text.y = textY;
	                };

	                /**
	                 * Set a box attribute, or defer it if the box is not yet created
	                 * @param {Object} key
	                 * @param {Object} value
	                 */
	                boxAttr = function(key, value) {
	                    if (box) {
	                        box.attr(key, value);
	                    } else {
	                        deferredAttr[key] = value;
	                    }
	                };

	                /**
	                 * After the text element is added, get the desired size of the border box
	                 * and add it before the text in the DOM.
	                 */
	                wrapper.onAdd = function() {
	                    text.add(wrapper);
	                    wrapper.attr({
	                        text: (str || str === 0) ? str : '', // alignment is available now // #3295: 0 not rendered if given as a value
	                        x: x,
	                        y: y
	                    });

	                    if (box && defined(anchorX)) {
	                        wrapper.attr({
	                            anchorX: anchorX,
	                            anchorY: anchorY
	                        });
	                    }
	                };

	                /*
	                 * Add specific attribute setters.
	                 */

	                // only change local variables
	                wrapper.widthSetter = function(value) {
	                    width = H.isNumber(value) ? value : null; // width:auto => null
	                };
	                wrapper.heightSetter = function(value) {
	                    height = value;
	                };
	                wrapper['text-alignSetter'] = function(value) {
	                    textAlign = value;
	                };
	                wrapper.paddingSetter = function(value) {
	                    if (defined(value) && value !== padding) {
	                        padding = wrapper.padding = value;
	                        updateTextPadding();
	                    }
	                };
	                wrapper.paddingLeftSetter = function(value) {
	                    if (defined(value) && value !== paddingLeft) {
	                        paddingLeft = value;
	                        updateTextPadding();
	                    }
	                };


	                // change local variable and prevent setting attribute on the group
	                wrapper.alignSetter = function(value) {
	                    value = {
	                        left: 0,
	                        center: 0.5,
	                        right: 1
	                    }[value];
	                    if (value !== alignFactor) {
	                        alignFactor = value;
	                        if (bBox) { // Bounding box exists, means we're dynamically changing
	                            wrapper.attr({
	                                x: wrapperX
	                            }); // #5134
	                        }
	                    }
	                };

	                // apply these to the box and the text alike
	                wrapper.textSetter = function(value) {
	                    if (value !== undefined) {
	                        text.textSetter(value);
	                    }
	                    updateBoxSize();
	                    updateTextPadding();
	                };

	                // apply these to the box but not to the text
	                wrapper['stroke-widthSetter'] = function(value, key) {
	                    if (value) {
	                        needsBox = true;
	                    }
	                    strokeWidth = this['stroke-width'] = value;
	                    boxAttr(key, value);
	                };

	                wrapper.strokeSetter = wrapper.fillSetter = wrapper.rSetter = function(value, key) {
	                    if (key !== 'r') {
	                        if (key === 'fill' && value) {
	                            needsBox = true;
	                        }
	                        // for animation getter (#6776)
	                        wrapper[key] = value;
	                    }
	                    boxAttr(key, value);
	                };

	                wrapper.anchorXSetter = function(value, key) {
	                    anchorX = wrapper.anchorX = value;
	                    boxAttr(key, Math.round(value) - getCrispAdjust() - wrapperX);
	                };
	                wrapper.anchorYSetter = function(value, key) {
	                    anchorY = wrapper.anchorY = value;
	                    boxAttr(key, value - wrapperY);
	                };

	                // rename attributes
	                wrapper.xSetter = function(value) {
	                    wrapper.x = value; // for animation getter
	                    if (alignFactor) {
	                        value -= alignFactor * ((width || bBox.width) + 2 * padding);
	                    }
	                    wrapperX = Math.round(value);
	                    wrapper.attr('translateX', wrapperX);
	                };
	                wrapper.ySetter = function(value) {
	                    wrapperY = wrapper.y = Math.round(value);
	                    wrapper.attr('translateY', wrapperY);
	                };

	                // Redirect certain methods to either the box or the text
	                var baseCss = wrapper.css;
	                return extend(wrapper, {
	                    /**
	                     * Pick up some properties and apply them to the text instead of the
	                     * wrapper.
	                     * @ignore
	                     */
	                    css: function(styles) {
	                        if (styles) {
	                            var textStyles = {};
	                            styles = merge(styles); // create a copy to avoid altering the original object (#537)
	                            each(wrapper.textProps, function(prop) {
	                                if (styles[prop] !== undefined) {
	                                    textStyles[prop] = styles[prop];
	                                    delete styles[prop];
	                                }
	                            });
	                            text.css(textStyles);
	                        }
	                        return baseCss.call(wrapper, styles);
	                    },
	                    /**
	                     * Return the bounding box of the box, not the group.
	                     * @ignore
	                     */
	                    getBBox: function() {
	                        return {
	                            width: bBox.width + 2 * padding,
	                            height: bBox.height + 2 * padding,
	                            x: bBox.x - padding,
	                            y: bBox.y - padding
	                        };
	                    },

	                    /**
	                     * Apply the shadow to the box.
	                     * @ignore
	                     */
	                    shadow: function(b) {
	                        if (b) {
	                            updateBoxSize();
	                            if (box) {
	                                box.shadow(b);
	                            }
	                        }
	                        return wrapper;
	                    },

	                    /**
	                     * Destroy and release memory.
	                     * @ignore
	                     */
	                    destroy: function() {

	                        // Added by button implementation
	                        removeEvent(wrapper.element, 'mouseenter');
	                        removeEvent(wrapper.element, 'mouseleave');

	                        if (text) {
	                            text = text.destroy();
	                        }
	                        if (box) {
	                            box = box.destroy();
	                        }
	                        // Call base implementation to destroy the rest
	                        SVGElement.prototype.destroy.call(wrapper);

	                        // Release local pointers (#1298)
	                        wrapper = renderer = updateBoxSize = updateTextPadding = boxAttr = null;
	                    }
	                });
	            }
	        }); // end SVGRenderer


	        // general renderer
	        H.Renderer = SVGRenderer;

	    }(Highcharts));
	    (function(H) {
	        /**
	         * (c) 2010-2017 Torstein Honsi
	         *
	         * License: www.highcharts.com/license
	         */
	        /* eslint max-len: ["warn", 80, 4] */
	        var attr = H.attr,
	            createElement = H.createElement,
	            css = H.css,
	            defined = H.defined,
	            each = H.each,
	            extend = H.extend,
	            isFirefox = H.isFirefox,
	            isMS = H.isMS,
	            isWebKit = H.isWebKit,
	            pInt = H.pInt,
	            SVGElement = H.SVGElement,
	            SVGRenderer = H.SVGRenderer,
	            win = H.win,
	            wrap = H.wrap;

	        // Extend SvgElement for useHTML option
	        extend(SVGElement.prototype, /** @lends SVGElement.prototype */ {
	            /**
	             * Apply CSS to HTML elements. This is used in text within SVG rendering and
	             * by the VML renderer
	             */
	            htmlCss: function(styles) {
	                var wrapper = this,
	                    element = wrapper.element,
	                    textWidth = styles && element.tagName === 'SPAN' && styles.width;

	                if (textWidth) {
	                    delete styles.width;
	                    wrapper.textWidth = textWidth;
	                    wrapper.updateTransform();
	                }
	                if (styles && styles.textOverflow === 'ellipsis') {
	                    styles.whiteSpace = 'nowrap';
	                    styles.overflow = 'hidden';
	                }
	                wrapper.styles = extend(wrapper.styles, styles);
	                css(wrapper.element, styles);

	                return wrapper;
	            },

	            /**
	             * VML and useHTML method for calculating the bounding box based on offsets
	             * @param {Boolean} refresh Whether to force a fresh value from the DOM or
	             * to use the cached value.
	             *
	             * @return {Object} A hash containing values for x, y, width and height
	             */

	            htmlGetBBox: function() {
	                var wrapper = this,
	                    element = wrapper.element;

	                // faking getBBox in exported SVG in legacy IE (is this a duplicate of
	                // the fix for #1079?)
	                if (element.nodeName === 'text') {
	                    element.style.position = 'absolute';
	                }

	                return {
	                    x: element.offsetLeft,
	                    y: element.offsetTop,
	                    width: element.offsetWidth,
	                    height: element.offsetHeight
	                };
	            },

	            /**
	             * VML override private method to update elements based on internal
	             * properties based on SVG transform
	             */
	            htmlUpdateTransform: function() {
	                // aligning non added elements is expensive
	                if (!this.added) {
	                    this.alignOnAdd = true;
	                    return;
	                }

	                var wrapper = this,
	                    renderer = wrapper.renderer,
	                    elem = wrapper.element,
	                    translateX = wrapper.translateX || 0,
	                    translateY = wrapper.translateY || 0,
	                    x = wrapper.x || 0,
	                    y = wrapper.y || 0,
	                    align = wrapper.textAlign || 'left',
	                    alignCorrection = {
	                        left: 0,
	                        center: 0.5,
	                        right: 1
	                    }[align],
	                    styles = wrapper.styles;

	                // apply translate
	                css(elem, {
	                    marginLeft: translateX,
	                    marginTop: translateY
	                });


	                if (wrapper.shadows) { // used in labels/tooltip
	                    each(wrapper.shadows, function(shadow) {
	                        css(shadow, {
	                            marginLeft: translateX + 1,
	                            marginTop: translateY + 1
	                        });
	                    });
	                }


	                // apply inversion
	                if (wrapper.inverted) { // wrapper is a group
	                    each(elem.childNodes, function(child) {
	                        renderer.invertChild(child, elem);
	                    });
	                }

	                if (elem.tagName === 'SPAN') {

	                    var rotation = wrapper.rotation,
	                        baseline,
	                        textWidth = pInt(wrapper.textWidth),
	                        whiteSpace = styles && styles.whiteSpace,
	                        currentTextTransform = [
	                            rotation,
	                            align,
	                            elem.innerHTML,
	                            wrapper.textWidth,
	                            wrapper.textAlign
	                        ].join(',');

	                    // Do the calculations and DOM access only if properties changed
	                    if (currentTextTransform !== wrapper.cTT) {


	                        baseline = renderer.fontMetrics(elem.style.fontSize).b;

	                        // Renderer specific handling of span rotation
	                        if (defined(rotation)) {
	                            wrapper.setSpanRotation(
	                                rotation,
	                                alignCorrection,
	                                baseline
	                            );
	                        }

	                        // Reset multiline/ellipsis in order to read width (#4928,
	                        // #5417)
	                        css(elem, {
	                            width: '',
	                            whiteSpace: whiteSpace || 'nowrap'
	                        });

	                        // Update textWidth
	                        if (
	                            elem.offsetWidth > textWidth &&
	                            /[ \-]/.test(elem.textContent || elem.innerText)
	                        ) { // #983, #1254
	                            css(elem, {
	                                width: textWidth + 'px',
	                                display: 'block',
	                                whiteSpace: whiteSpace || 'normal' // #3331
	                            });
	                        }


	                        wrapper.getSpanCorrection(
	                            elem.offsetWidth,
	                            baseline,
	                            alignCorrection,
	                            rotation,
	                            align
	                        );
	                    }

	                    // apply position with correction
	                    css(elem, {
	                        left: (x + (wrapper.xCorr || 0)) + 'px',
	                        top: (y + (wrapper.yCorr || 0)) + 'px'
	                    });

	                    // Force reflow in webkit to apply the left and top on useHTML
	                    // element (#1249)
	                    if (isWebKit) {
	                        // Assigned to baseline for lint purpose
	                        baseline = elem.offsetHeight;
	                    }

	                    // record current text transform
	                    wrapper.cTT = currentTextTransform;
	                }
	            },

	            /**
	             * Set the rotation of an individual HTML span
	             */
	            setSpanRotation: function(rotation, alignCorrection, baseline) {
	                var rotationStyle = {},
	                    cssTransformKey =
	                    isMS ?
	                    '-ms-transform' :
	                    isWebKit ?
	                    '-webkit-transform' :
	                    isFirefox ?
	                    'MozTransform' :
	                    win.opera ?
	                    '-o-transform' :
	                    '';

	                rotationStyle[cssTransformKey] = rotationStyle.transform =
	                    'rotate(' + rotation + 'deg)';
	                rotationStyle[cssTransformKey + (isFirefox ? 'Origin' : '-origin')] =
	                    rotationStyle.transformOrigin =
	                    (alignCorrection * 100) + '% ' + baseline + 'px';
	                css(this.element, rotationStyle);
	            },

	            /**
	             * Get the correction in X and Y positioning as the element is rotated.
	             */
	            getSpanCorrection: function(width, baseline, alignCorrection) {
	                this.xCorr = -width * alignCorrection;
	                this.yCorr = -baseline;
	            }
	        });

	        // Extend SvgRenderer for useHTML option.
	        extend(SVGRenderer.prototype, /** @lends SVGRenderer.prototype */ {
	            /**
	             * Create HTML text node. This is used by the VML renderer as well as the
	             * SVG renderer through the useHTML option.
	             *
	             * @param {String} str
	             * @param {Number} x
	             * @param {Number} y
	             */
	            html: function(str, x, y) {
	                var wrapper = this.createElement('span'),
	                    element = wrapper.element,
	                    renderer = wrapper.renderer,
	                    isSVG = renderer.isSVG,
	                    addSetters = function(element, style) {
	                        // These properties are set as attributes on the SVG group, and
	                        // as identical CSS properties on the div. (#3542)
	                        each(['opacity', 'visibility'], function(prop) {
	                            wrap(element, prop + 'Setter', function(
	                                proceed,
	                                value,
	                                key,
	                                elem
	                            ) {
	                                proceed.call(this, value, key, elem);
	                                style[key] = value;
	                            });
	                        });
	                    };

	                // Text setter
	                wrapper.textSetter = function(value) {
	                    if (value !== element.innerHTML) {
	                        delete this.bBox;
	                    }
	                    element.innerHTML = this.textStr = value;
	                    wrapper.htmlUpdateTransform();
	                };

	                // Add setters for the element itself (#4938)
	                if (isSVG) { // #4938, only for HTML within SVG
	                    addSetters(wrapper, wrapper.element.style);
	                }

	                // Various setters which rely on update transform
	                wrapper.xSetter =
	                    wrapper.ySetter =
	                    wrapper.alignSetter =
	                    wrapper.rotationSetter =
	                    function(value, key) {
	                        if (key === 'align') {
	                            // Do not overwrite the SVGElement.align method. Same as VML.
	                            key = 'textAlign';
	                        }
	                        wrapper[key] = value;
	                        wrapper.htmlUpdateTransform();
	                    };

	                // Set the default attributes
	                wrapper
	                    .attr({
	                        text: str,
	                        x: Math.round(x),
	                        y: Math.round(y)
	                    })
	                    .css({

	                        fontFamily: this.style.fontFamily,
	                        fontSize: this.style.fontSize,

	                        position: 'absolute'
	                    });

	                // Keep the whiteSpace style outside the wrapper.styles collection
	                element.style.whiteSpace = 'nowrap';

	                // Use the HTML specific .css method
	                wrapper.css = wrapper.htmlCss;

	                // This is specific for HTML within SVG
	                if (isSVG) {
	                    wrapper.add = function(svgGroupWrapper) {

	                        var htmlGroup,
	                            container = renderer.box.parentNode,
	                            parentGroup,
	                            parents = [];

	                        this.parentGroup = svgGroupWrapper;

	                        // Create a mock group to hold the HTML elements
	                        if (svgGroupWrapper) {
	                            htmlGroup = svgGroupWrapper.div;
	                            if (!htmlGroup) {

	                                // Read the parent chain into an array and read from top
	                                // down
	                                parentGroup = svgGroupWrapper;
	                                while (parentGroup) {

	                                    parents.push(parentGroup);

	                                    // Move up to the next parent group
	                                    parentGroup = parentGroup.parentGroup;
	                                }

	                                // Ensure dynamically updating position when any parent
	                                // is translated
	                                each(parents.reverse(), function(parentGroup) {
	                                    var htmlGroupStyle,
	                                        cls = attr(parentGroup.element, 'class');

	                                    if (cls) {
	                                        cls = {
	                                            className: cls
	                                        };
	                                    } // else null

	                                    // Create a HTML div and append it to the parent div
	                                    // to emulate the SVG group structure
	                                    htmlGroup =
	                                        parentGroup.div =
	                                        parentGroup.div || createElement('div', cls, {
	                                            position: 'absolute',
	                                            left: (parentGroup.translateX || 0) + 'px',
	                                            top: (parentGroup.translateY || 0) + 'px',
	                                            display: parentGroup.display,
	                                            opacity: parentGroup.opacity, // #5075
	                                            pointerEvents: (
	                                                parentGroup.styles &&
	                                                parentGroup.styles.pointerEvents
	                                            ) // #5595

	                                            // the top group is appended to container
	                                        }, htmlGroup || container);

	                                    // Shortcut
	                                    htmlGroupStyle = htmlGroup.style;

	                                    // Set listeners to update the HTML div's position
	                                    // whenever the SVG group position is changed.
	                                    extend(parentGroup, {
	                                        classSetter: function(value) {
	                                            this.element.setAttribute('class', value);
	                                            htmlGroup.className = value;
	                                        },
	                                        on: function() {
	                                            if (parents[0].div) { // #6418
	                                                wrapper.on.apply({
	                                                        element: parents[0].div
	                                                    },
	                                                    arguments
	                                                );
	                                            }
	                                            return parentGroup;
	                                        },
	                                        translateXSetter: function(value, key) {
	                                            htmlGroupStyle.left = value + 'px';
	                                            parentGroup[key] = value;
	                                            parentGroup.doTransform = true;
	                                        },
	                                        translateYSetter: function(value, key) {
	                                            htmlGroupStyle.top = value + 'px';
	                                            parentGroup[key] = value;
	                                            parentGroup.doTransform = true;
	                                        }
	                                    });
	                                    addSetters(parentGroup, htmlGroupStyle);
	                                });

	                            }
	                        } else {
	                            htmlGroup = container;
	                        }

	                        htmlGroup.appendChild(element);

	                        // Shared with VML:
	                        wrapper.added = true;
	                        if (wrapper.alignOnAdd) {
	                            wrapper.htmlUpdateTransform();
	                        }

	                        return wrapper;
	                    };
	                }
	                return wrapper;
	            }
	        });

	    }(Highcharts));
	    (function(H) {
	        /**
	         * (c) 2010-2017 Torstein Honsi
	         *
	         * License: www.highcharts.com/license
	         */

	        var VMLRenderer,
	            VMLRendererExtension,
	            VMLElement,

	            createElement = H.createElement,
	            css = H.css,
	            defined = H.defined,
	            deg2rad = H.deg2rad,
	            discardElement = H.discardElement,
	            doc = H.doc,
	            each = H.each,
	            erase = H.erase,
	            extend = H.extend,
	            extendClass = H.extendClass,
	            isArray = H.isArray,
	            isNumber = H.isNumber,
	            isObject = H.isObject,
	            merge = H.merge,
	            noop = H.noop,
	            pick = H.pick,
	            pInt = H.pInt,
	            svg = H.svg,
	            SVGElement = H.SVGElement,
	            SVGRenderer = H.SVGRenderer,
	            win = H.win;

	        /* ****************************************************************************
	         *                                                                            *
	         * START OF INTERNET EXPLORER <= 8 SPECIFIC CODE                              *
	         *                                                                            *
	         * For applications and websites that don't need IE support, like platform    *
	         * targeted mobile apps and web apps, this code can be removed.               *
	         *                                                                            *
	         *****************************************************************************/

	        /**
	         * @constructor
	         */
	        if (!svg) {

	            /**
	             * The VML element wrapper.
	             */
	            VMLElement = {

	                docMode8: doc && doc.documentMode === 8,

	                /**
	                 * Initialize a new VML element wrapper. It builds the markup as a string
	                 * to minimize DOM traffic.
	                 * @param {Object} renderer
	                 * @param {Object} nodeName
	                 */
	                init: function(renderer, nodeName) {
	                    var wrapper = this,
	                        markup = ['<', nodeName, ' filled="f" stroked="f"'],
	                        style = ['position: ', 'absolute', ';'],
	                        isDiv = nodeName === 'div';

	                    // divs and shapes need size
	                    if (nodeName === 'shape' || isDiv) {
	                        style.push('left:0;top:0;width:1px;height:1px;');
	                    }
	                    style.push('visibility: ', isDiv ? 'hidden' : 'visible');

	                    markup.push(' style="', style.join(''), '"/>');

	                    // create element with default attributes and style
	                    if (nodeName) {
	                        markup = isDiv || nodeName === 'span' || nodeName === 'img' ?
	                            markup.join('') :
	                            renderer.prepVML(markup);
	                        wrapper.element = createElement(markup);
	                    }

	                    wrapper.renderer = renderer;
	                },

	                /**
	                 * Add the node to the given parent
	                 * @param {Object} parent
	                 */
	                add: function(parent) {
	                    var wrapper = this,
	                        renderer = wrapper.renderer,
	                        element = wrapper.element,
	                        box = renderer.box,
	                        inverted = parent && parent.inverted,

	                        // get the parent node
	                        parentNode = parent ?
	                        parent.element || parent :
	                        box;

	                    if (parent) {
	                        this.parentGroup = parent;
	                    }

	                    // if the parent group is inverted, apply inversion on all children
	                    if (inverted) { // only on groups
	                        renderer.invertChild(element, parentNode);
	                    }

	                    // append it
	                    parentNode.appendChild(element);

	                    // align text after adding to be able to read offset
	                    wrapper.added = true;
	                    if (wrapper.alignOnAdd && !wrapper.deferUpdateTransform) {
	                        wrapper.updateTransform();
	                    }

	                    // fire an event for internal hooks
	                    if (wrapper.onAdd) {
	                        wrapper.onAdd();
	                    }

	                    // IE8 Standards can't set the class name before the element is appended
	                    if (this.className) {
	                        this.attr('class', this.className);
	                    }

	                    return wrapper;
	                },

	                /**
	                 * VML always uses htmlUpdateTransform
	                 */
	                updateTransform: SVGElement.prototype.htmlUpdateTransform,

	                /**
	                 * Set the rotation of a span with oldIE's filter
	                 */
	                setSpanRotation: function() {
	                    // Adjust for alignment and rotation. Rotation of useHTML content is not yet implemented
	                    // but it can probably be implemented for Firefox 3.5+ on user request. FF3.5+
	                    // has support for CSS3 transform. The getBBox method also needs to be updated
	                    // to compensate for the rotation, like it currently does for SVG.
	                    // Test case: http://jsfiddle.net/highcharts/Ybt44/

	                    var rotation = this.rotation,
	                        costheta = Math.cos(rotation * deg2rad),
	                        sintheta = Math.sin(rotation * deg2rad);

	                    css(this.element, {
	                        filter: rotation ? ['progid:DXImageTransform.Microsoft.Matrix(M11=', costheta,
	                            ', M12=', -sintheta, ', M21=', sintheta, ', M22=', costheta,
	                            ', sizingMethod=\'auto expand\')'
	                        ].join('') : 'none'
	                    });
	                },

	                /**
	                 * Get the positioning correction for the span after rotating.
	                 */
	                getSpanCorrection: function(width, baseline, alignCorrection, rotation, align) {

	                    var costheta = rotation ? Math.cos(rotation * deg2rad) : 1,
	                        sintheta = rotation ? Math.sin(rotation * deg2rad) : 0,
	                        height = pick(this.elemHeight, this.element.offsetHeight),
	                        quad,
	                        nonLeft = align && align !== 'left';

	                    // correct x and y
	                    this.xCorr = costheta < 0 && -width;
	                    this.yCorr = sintheta < 0 && -height;

	                    // correct for baseline and corners spilling out after rotation
	                    quad = costheta * sintheta < 0;
	                    this.xCorr += sintheta * baseline * (quad ? 1 - alignCorrection : alignCorrection);
	                    this.yCorr -= costheta * baseline * (rotation ? (quad ? alignCorrection : 1 - alignCorrection) : 1);
	                    // correct for the length/height of the text
	                    if (nonLeft) {
	                        this.xCorr -= width * alignCorrection * (costheta < 0 ? -1 : 1);
	                        if (rotation) {
	                            this.yCorr -= height * alignCorrection * (sintheta < 0 ? -1 : 1);
	                        }
	                        css(this.element, {
	                            textAlign: align
	                        });
	                    }
	                },

	                /**
	                 * Converts a subset of an SVG path definition to its VML counterpart. Takes an array
	                 * as the parameter and returns a string.
	                 */
	                pathToVML: function(value) {
	                    // convert paths
	                    var i = value.length,
	                        path = [];

	                    while (i--) {

	                        // Multiply by 10 to allow subpixel precision.
	                        // Substracting half a pixel seems to make the coordinates
	                        // align with SVG, but this hasn't been tested thoroughly
	                        if (isNumber(value[i])) {
	                            path[i] = Math.round(value[i] * 10) - 5;
	                        } else if (value[i] === 'Z') { // close the path
	                            path[i] = 'x';
	                        } else {
	                            path[i] = value[i];

	                            // When the start X and end X coordinates of an arc are too close,
	                            // they are rounded to the same value above. In this case, substract or
	                            // add 1 from the end X and Y positions. #186, #760, #1371, #1410.
	                            if (value.isArc && (value[i] === 'wa' || value[i] === 'at')) {
	                                // Start and end X
	                                if (path[i + 5] === path[i + 7]) {
	                                    path[i + 7] += value[i + 7] > value[i + 5] ? 1 : -1;
	                                }
	                                // Start and end Y
	                                if (path[i + 6] === path[i + 8]) {
	                                    path[i + 8] += value[i + 8] > value[i + 6] ? 1 : -1;
	                                }
	                            }
	                        }
	                    }


	                    // Loop up again to handle path shortcuts (#2132)
	                    /*while (i++ < path.length) {
	                        if (path[i] === 'H') { // horizontal line to
	                            path[i] = 'L';
	                            path.splice(i + 2, 0, path[i - 1]);
	                        } else if (path[i] === 'V') { // vertical line to
	                            path[i] = 'L';
	                            path.splice(i + 1, 0, path[i - 2]);
	                        }
	                    }*/
	                    return path.join(' ') || 'x';
	                },

	                /**
	                 * Set the element's clipping to a predefined rectangle
	                 *
	                 * @param {String} id The id of the clip rectangle
	                 */
	                clip: function(clipRect) {
	                    var wrapper = this,
	                        clipMembers,
	                        cssRet;

	                    if (clipRect) {
	                        clipMembers = clipRect.members;
	                        erase(clipMembers, wrapper); // Ensure unique list of elements (#1258)
	                        clipMembers.push(wrapper);
	                        wrapper.destroyClip = function() {
	                            erase(clipMembers, wrapper);
	                        };
	                        cssRet = clipRect.getCSS(wrapper);

	                    } else {
	                        if (wrapper.destroyClip) {
	                            wrapper.destroyClip();
	                        }
	                        cssRet = {
	                            clip: wrapper.docMode8 ? 'inherit' : 'rect(auto)'
	                        }; // #1214
	                    }

	                    return wrapper.css(cssRet);

	                },

	                /**
	                 * Set styles for the element
	                 * @param {Object} styles
	                 */
	                css: SVGElement.prototype.htmlCss,

	                /**
	                 * Removes a child either by removeChild or move to garbageBin.
	                 * Issue 490; in VML removeChild results in Orphaned nodes according to sIEve, discardElement does not.
	                 */
	                safeRemoveChild: function(element) {
	                    // discardElement will detach the node from its parent before attaching it
	                    // to the garbage bin. Therefore it is important that the node is attached and have parent.
	                    if (element.parentNode) {
	                        discardElement(element);
	                    }
	                },

	                /**
	                 * Extend element.destroy by removing it from the clip members array
	                 */
	                destroy: function() {
	                    if (this.destroyClip) {
	                        this.destroyClip();
	                    }

	                    return SVGElement.prototype.destroy.apply(this);
	                },

	                /**
	                 * Add an event listener. VML override for normalizing event parameters.
	                 * @param {String} eventType
	                 * @param {Function} handler
	                 */
	                on: function(eventType, handler) {
	                    // simplest possible event model for internal use
	                    this.element['on' + eventType] = function() {
	                        var evt = win.event;
	                        evt.target = evt.srcElement;
	                        handler(evt);
	                    };
	                    return this;
	                },

	                /**
	                 * In stacked columns, cut off the shadows so that they don't overlap
	                 */
	                cutOffPath: function(path, length) {

	                    var len;

	                    path = path.split(/[ ,]/); // The extra comma tricks the trailing comma remover in "gulp scripts" task
	                    len = path.length;

	                    if (len === 9 || len === 11) {
	                        path[len - 4] = path[len - 2] = pInt(path[len - 2]) - 10 * length;
	                    }
	                    return path.join(' ');
	                },

	                /**
	                 * Apply a drop shadow by copying elements and giving them different strokes
	                 * @param {Boolean|Object} shadowOptions
	                 */
	                shadow: function(shadowOptions, group, cutOff) {
	                    var shadows = [],
	                        i,
	                        element = this.element,
	                        renderer = this.renderer,
	                        shadow,
	                        elemStyle = element.style,
	                        markup,
	                        path = element.path,
	                        strokeWidth,
	                        modifiedPath,
	                        shadowWidth,
	                        shadowElementOpacity;

	                    // some times empty paths are not strings
	                    if (path && typeof path.value !== 'string') {
	                        path = 'x';
	                    }
	                    modifiedPath = path;

	                    if (shadowOptions) {
	                        shadowWidth = pick(shadowOptions.width, 3);
	                        shadowElementOpacity = (shadowOptions.opacity || 0.15) / shadowWidth;
	                        for (i = 1; i <= 3; i++) {

	                            strokeWidth = (shadowWidth * 2) + 1 - (2 * i);

	                            // Cut off shadows for stacked column items
	                            if (cutOff) {
	                                modifiedPath = this.cutOffPath(path.value, strokeWidth + 0.5);
	                            }

	                            markup = ['<shape isShadow="true" strokeweight="', strokeWidth,
	                                '" filled="false" path="', modifiedPath,
	                                '" coordsize="10 10" style="', element.style.cssText, '" />'
	                            ];

	                            shadow = createElement(renderer.prepVML(markup),
	                                null, {
	                                    left: pInt(elemStyle.left) + pick(shadowOptions.offsetX, 1),
	                                    top: pInt(elemStyle.top) + pick(shadowOptions.offsetY, 1)
	                                }
	                            );
	                            if (cutOff) {
	                                shadow.cutOff = strokeWidth + 1;
	                            }

	                            // apply the opacity
	                            markup = [
	                                '<stroke color="',
	                                shadowOptions.color || '#000000',
	                                '" opacity="', shadowElementOpacity * i, '"/>'
	                            ];
	                            createElement(renderer.prepVML(markup), null, null, shadow);


	                            // insert it
	                            if (group) {
	                                group.element.appendChild(shadow);
	                            } else {
	                                element.parentNode.insertBefore(shadow, element);
	                            }

	                            // record it
	                            shadows.push(shadow);

	                        }

	                        this.shadows = shadows;
	                    }
	                    return this;
	                },
	                updateShadows: noop, // Used in SVG only

	                setAttr: function(key, value) {
	                    if (this.docMode8) { // IE8 setAttribute bug
	                        this.element[key] = value;
	                    } else {
	                        this.element.setAttribute(key, value);
	                    }
	                },
	                classSetter: function(value) {
	                    // IE8 Standards mode has problems retrieving the className unless set like this.
	                    // IE8 Standards can't set the class name before the element is appended.
	                    (this.added ? this.element : this).className = value;
	                },
	                dashstyleSetter: function(value, key, element) {
	                    var strokeElem = element.getElementsByTagName('stroke')[0] ||
	                        createElement(this.renderer.prepVML(['<stroke/>']), null, null, element);
	                    strokeElem[key] = value || 'solid';
	                    this[key] = value;
	                    /* because changing stroke-width will change the dash length
	                and cause an epileptic effect */
	                },
	                dSetter: function(value, key, element) {
	                    var i,
	                        shadows = this.shadows;
	                    value = value || [];
	                    this.d = value.join && value.join(' '); // used in getter for animation

	                    element.path = value = this.pathToVML(value);

	                    // update shadows
	                    if (shadows) {
	                        i = shadows.length;
	                        while (i--) {
	                            shadows[i].path = shadows[i].cutOff ? this.cutOffPath(value, shadows[i].cutOff) : value;
	                        }
	                    }
	                    this.setAttr(key, value);
	                },
	                fillSetter: function(value, key, element) {
	                    var nodeName = element.nodeName;
	                    if (nodeName === 'SPAN') { // text color
	                        element.style.color = value;
	                    } else if (nodeName !== 'IMG') { // #1336
	                        element.filled = value !== 'none';
	                        this.setAttr('fillcolor', this.renderer.color(value, element, key, this));
	                    }
	                },
	                'fill-opacitySetter': function(value, key, element) {
	                    createElement(
	                        this.renderer.prepVML(['<', key.split('-')[0], ' opacity="', value, '"/>']),
	                        null,
	                        null,
	                        element
	                    );
	                },
	                opacitySetter: noop, // Don't bother - animation is too slow and filters introduce artifacts
	                rotationSetter: function(value, key, element) {
	                    var style = element.style;
	                    this[key] = style[key] = value; // style is for #1873

	                    // Correction for the 1x1 size of the shape container. Used in gauge needles.
	                    style.left = -Math.round(Math.sin(value * deg2rad) + 1) + 'px';
	                    style.top = Math.round(Math.cos(value * deg2rad)) + 'px';
	                },
	                strokeSetter: function(value, key, element) {
	                    this.setAttr('strokecolor', this.renderer.color(value, element, key, this));
	                },
	                'stroke-widthSetter': function(value, key, element) {
	                    element.stroked = !!value; // VML "stroked" attribute
	                    this[key] = value; // used in getter, issue #113
	                    if (isNumber(value)) {
	                        value += 'px';
	                    }
	                    this.setAttr('strokeweight', value);
	                },
	                titleSetter: function(value, key) {
	                    this.setAttr(key, value);
	                },
	                visibilitySetter: function(value, key, element) {

	                    // Handle inherited visibility
	                    if (value === 'inherit') {
	                        value = 'visible';
	                    }

	                    // Let the shadow follow the main element
	                    if (this.shadows) {
	                        each(this.shadows, function(shadow) {
	                            shadow.style[key] = value;
	                        });
	                    }

	                    // Instead of toggling the visibility CSS property, move the div out of the viewport.
	                    // This works around #61 and #586
	                    if (element.nodeName === 'DIV') {
	                        value = value === 'hidden' ? '-999em' : 0;

	                        // In order to redraw, IE7 needs the div to be visible when tucked away
	                        // outside the viewport. So the visibility is actually opposite of
	                        // the expected value. This applies to the tooltip only.
	                        if (!this.docMode8) {
	                            element.style[key] = value ? 'visible' : 'hidden';
	                        }
	                        key = 'top';
	                    }
	                    element.style[key] = value;
	                },
	                xSetter: function(value, key, element) {
	                    this[key] = value; // used in getter

	                    if (key === 'x') {
	                        key = 'left';
	                    } else if (key === 'y') {
	                        key = 'top';
	                    }
	                    /* else {
	                                    value = Math.max(0, value); // don't set width or height below zero (#311)
	                                }*/

	                    // clipping rectangle special
	                    if (this.updateClipping) {
	                        this[key] = value; // the key is now 'left' or 'top' for 'x' and 'y'
	                        this.updateClipping();
	                    } else {
	                        // normal
	                        element.style[key] = value;
	                    }
	                },
	                zIndexSetter: function(value, key, element) {
	                    element.style[key] = value;
	                }
	            };
	            VMLElement['stroke-opacitySetter'] = VMLElement['fill-opacitySetter'];
	            H.VMLElement = VMLElement = extendClass(SVGElement, VMLElement);

	            // Some shared setters
	            VMLElement.prototype.ySetter =
	                VMLElement.prototype.widthSetter =
	                VMLElement.prototype.heightSetter =
	                VMLElement.prototype.xSetter;


	            /**
	             * The VML renderer
	             */
	            VMLRendererExtension = { // inherit SVGRenderer

	                Element: VMLElement,
	                isIE8: win.navigator.userAgent.indexOf('MSIE 8.0') > -1,


	                /**
	                 * Initialize the VMLRenderer
	                 * @param {Object} container
	                 * @param {Number} width
	                 * @param {Number} height
	                 */
	                init: function(container, width, height) {
	                    var renderer = this,
	                        boxWrapper,
	                        box,
	                        css;

	                    renderer.alignedObjects = [];

	                    boxWrapper = renderer.createElement('div')
	                        .css({
	                            position: 'relative'
	                        });
	                    box = boxWrapper.element;
	                    container.appendChild(boxWrapper.element);


	                    // generate the containing box
	                    renderer.isVML = true;
	                    renderer.box = box;
	                    renderer.boxWrapper = boxWrapper;
	                    renderer.gradients = {};
	                    renderer.cache = {}; // Cache for numerical bounding boxes
	                    renderer.cacheKeys = [];
	                    renderer.imgCount = 0;


	                    renderer.setSize(width, height, false);

	                    // The only way to make IE6 and IE7 print is to use a global namespace. However,
	                    // with IE8 the only way to make the dynamic shapes visible in screen and print mode
	                    // seems to be to add the xmlns attribute and the behaviour style inline.
	                    if (!doc.namespaces.hcv) {

	                        doc.namespaces.add('hcv', 'urn:schemas-microsoft-com:vml');

	                        // Setup default CSS (#2153, #2368, #2384)
	                        css = 'hcv\\:fill, hcv\\:path, hcv\\:shape, hcv\\:stroke' +
	                            '{ behavior:url(#default#VML); display: inline-block; } ';
	                        try {
	                            doc.createStyleSheet().cssText = css;
	                        } catch (e) {
	                            doc.styleSheets[0].cssText += css;
	                        }

	                    }
	                },


	                /**
	                 * Detect whether the renderer is hidden. This happens when one of the parent elements
	                 * has display: none
	                 */
	                isHidden: function() {
	                    return !this.box.offsetWidth;
	                },

	                /**
	                 * Define a clipping rectangle. In VML it is accomplished by storing the values
	                 * for setting the CSS style to all associated members.
	                 *
	                 * @param {Number} x
	                 * @param {Number} y
	                 * @param {Number} width
	                 * @param {Number} height
	                 */
	                clipRect: function(x, y, width, height) {

	                    // create a dummy element
	                    var clipRect = this.createElement(),
	                        isObj = isObject(x);

	                    // mimic a rectangle with its style object for automatic updating in attr
	                    return extend(clipRect, {
	                        members: [],
	                        count: 0,
	                        left: (isObj ? x.x : x) + 1,
	                        top: (isObj ? x.y : y) + 1,
	                        width: (isObj ? x.width : width) - 1,
	                        height: (isObj ? x.height : height) - 1,
	                        getCSS: function(wrapper) {
	                            var element = wrapper.element,
	                                nodeName = element.nodeName,
	                                isShape = nodeName === 'shape',
	                                inverted = wrapper.inverted,
	                                rect = this,
	                                top = rect.top - (isShape ? element.offsetTop : 0),
	                                left = rect.left,
	                                right = left + rect.width,
	                                bottom = top + rect.height,
	                                ret = {
	                                    clip: 'rect(' +
	                                        Math.round(inverted ? left : top) + 'px,' +
	                                        Math.round(inverted ? bottom : right) + 'px,' +
	                                        Math.round(inverted ? right : bottom) + 'px,' +
	                                        Math.round(inverted ? top : left) + 'px)'
	                                };

	                            // issue 74 workaround
	                            if (!inverted && wrapper.docMode8 && nodeName === 'DIV') {
	                                extend(ret, {
	                                    width: right + 'px',
	                                    height: bottom + 'px'
	                                });
	                            }
	                            return ret;
	                        },

	                        // used in attr and animation to update the clipping of all members
	                        updateClipping: function() {
	                            each(clipRect.members, function(member) {
	                                // Member.element is falsy on deleted series, like in
	                                // stock/members/series-remove demo. Should be removed
	                                // from members, but this will do.
	                                if (member.element) {
	                                    member.css(clipRect.getCSS(member));
	                                }
	                            });
	                        }
	                    });

	                },


	                /**
	                 * Take a color and return it if it's a string, make it a gradient if it's a
	                 * gradient configuration object, and apply opacity.
	                 *
	                 * @param {Object} color The color or config object
	                 */
	                color: function(color, elem, prop, wrapper) {
	                    var renderer = this,
	                        colorObject,
	                        regexRgba = /^rgba/,
	                        markup,
	                        fillType,
	                        ret = 'none';

	                    // Check for linear or radial gradient
	                    if (color && color.linearGradient) {
	                        fillType = 'gradient';
	                    } else if (color && color.radialGradient) {
	                        fillType = 'pattern';
	                    }


	                    if (fillType) {

	                        var stopColor,
	                            stopOpacity,
	                            gradient = color.linearGradient || color.radialGradient,
	                            x1,
	                            y1,
	                            x2,
	                            y2,
	                            opacity1,
	                            opacity2,
	                            color1,
	                            color2,
	                            fillAttr = '',
	                            stops = color.stops,
	                            firstStop,
	                            lastStop,
	                            colors = [],
	                            addFillNode = function() {
	                                // Add the fill subnode. When colors attribute is used, the meanings of opacity and o:opacity2
	                                // are reversed.
	                                markup = ['<fill colors="' + colors.join(',') +
	                                    '" opacity="', opacity2, '" o:opacity2="',
	                                    opacity1, '" type="', fillType, '" ', fillAttr,
	                                    'focus="100%" method="any" />'
	                                ];
	                                createElement(renderer.prepVML(markup), null, null, elem);
	                            };

	                        // Extend from 0 to 1
	                        firstStop = stops[0];
	                        lastStop = stops[stops.length - 1];
	                        if (firstStop[0] > 0) {
	                            stops.unshift([
	                                0,
	                                firstStop[1]
	                            ]);
	                        }
	                        if (lastStop[0] < 1) {
	                            stops.push([
	                                1,
	                                lastStop[1]
	                            ]);
	                        }

	                        // Compute the stops
	                        each(stops, function(stop, i) {
	                            if (regexRgba.test(stop[1])) {
	                                colorObject = H.color(stop[1]);
	                                stopColor = colorObject.get('rgb');
	                                stopOpacity = colorObject.get('a');
	                            } else {
	                                stopColor = stop[1];
	                                stopOpacity = 1;
	                            }

	                            // Build the color attribute
	                            colors.push((stop[0] * 100) + '% ' + stopColor);

	                            // Only start and end opacities are allowed, so we use the first and the last
	                            if (!i) {
	                                opacity1 = stopOpacity;
	                                color2 = stopColor;
	                            } else {
	                                opacity2 = stopOpacity;
	                                color1 = stopColor;
	                            }
	                        });

	                        // Apply the gradient to fills only.
	                        if (prop === 'fill') {

	                            // Handle linear gradient angle
	                            if (fillType === 'gradient') {
	                                x1 = gradient.x1 || gradient[0] || 0;
	                                y1 = gradient.y1 || gradient[1] || 0;
	                                x2 = gradient.x2 || gradient[2] || 0;
	                                y2 = gradient.y2 || gradient[3] || 0;
	                                fillAttr = 'angle="' + (90 - Math.atan(
	                                    (y2 - y1) / // y vector
	                                    (x2 - x1) // x vector
	                                ) * 180 / Math.PI) + '"';

	                                addFillNode();

	                                // Radial (circular) gradient
	                            } else {

	                                var r = gradient.r,
	                                    sizex = r * 2,
	                                    sizey = r * 2,
	                                    cx = gradient.cx,
	                                    cy = gradient.cy,
	                                    radialReference = elem.radialReference,
	                                    bBox,
	                                    applyRadialGradient = function() {
	                                        if (radialReference) {
	                                            bBox = wrapper.getBBox();
	                                            cx += (radialReference[0] - bBox.x) / bBox.width - 0.5;
	                                            cy += (radialReference[1] - bBox.y) / bBox.height - 0.5;
	                                            sizex *= radialReference[2] / bBox.width;
	                                            sizey *= radialReference[2] / bBox.height;
	                                        }
	                                        fillAttr = 'src="' + H.getOptions().global.VMLRadialGradientURL + '" ' +
	                                            'size="' + sizex + ',' + sizey + '" ' +
	                                            'origin="0.5,0.5" ' +
	                                            'position="' + cx + ',' + cy + '" ' +
	                                            'color2="' + color2 + '" ';

	                                        addFillNode();
	                                    };

	                                // Apply radial gradient
	                                if (wrapper.added) {
	                                    applyRadialGradient();
	                                } else {
	                                    // We need to know the bounding box to get the size and position right
	                                    wrapper.onAdd = applyRadialGradient;
	                                }

	                                // The fill element's color attribute is broken in IE8 standards mode, so we
	                                // need to set the parent shape's fillcolor attribute instead.
	                                ret = color1;
	                            }

	                            // Gradients are not supported for VML stroke, return the first color. #722.
	                        } else {
	                            ret = stopColor;
	                        }

	                        // If the color is an rgba color, split it and add a fill node
	                        // to hold the opacity component
	                    } else if (regexRgba.test(color) && elem.tagName !== 'IMG') {

	                        colorObject = H.color(color);

	                        wrapper[prop + '-opacitySetter'](colorObject.get('a'), prop, elem);

	                        ret = colorObject.get('rgb');


	                    } else {
	                        var propNodes = elem.getElementsByTagName(prop); // 'stroke' or 'fill' node
	                        if (propNodes.length) {
	                            propNodes[0].opacity = 1;
	                            propNodes[0].type = 'solid';
	                        }
	                        ret = color;
	                    }

	                    return ret;
	                },

	                /**
	                 * Take a VML string and prepare it for either IE8 or IE6/IE7.
	                 * @param {Array} markup A string array of the VML markup to prepare
	                 */
	                prepVML: function(markup) {
	                    var vmlStyle = 'display:inline-block;behavior:url(#default#VML);',
	                        isIE8 = this.isIE8;

	                    markup = markup.join('');

	                    if (isIE8) { // add xmlns and style inline
	                        markup = markup.replace('/>', ' xmlns="urn:schemas-microsoft-com:vml" />');
	                        if (markup.indexOf('style="') === -1) {
	                            markup = markup.replace('/>', ' style="' + vmlStyle + '" />');
	                        } else {
	                            markup = markup.replace('style="', 'style="' + vmlStyle);
	                        }

	                    } else { // add namespace
	                        markup = markup.replace('<', '<hcv:');
	                    }

	                    return markup;
	                },

	                /**
	                 * Create rotated and aligned text
	                 * @param {String} str
	                 * @param {Number} x
	                 * @param {Number} y
	                 */
	                text: SVGRenderer.prototype.html,

	                /**
	                 * Create and return a path element
	                 * @param {Array} path
	                 */
	                path: function(path) {
	                    var attr = {
	                        // subpixel precision down to 0.1 (width and height = 1px)
	                        coordsize: '10 10'
	                    };
	                    if (isArray(path)) {
	                        attr.d = path;
	                    } else if (isObject(path)) { // attributes
	                        extend(attr, path);
	                    }
	                    // create the shape
	                    return this.createElement('shape').attr(attr);
	                },

	                /**
	                 * Create and return a circle element. In VML circles are implemented as
	                 * shapes, which is faster than v:oval
	                 * @param {Number} x
	                 * @param {Number} y
	                 * @param {Number} r
	                 */
	                circle: function(x, y, r) {
	                    var circle = this.symbol('circle');
	                    if (isObject(x)) {
	                        r = x.r;
	                        y = x.y;
	                        x = x.x;
	                    }
	                    circle.isCircle = true; // Causes x and y to mean center (#1682)
	                    circle.r = r;
	                    return circle.attr({
	                        x: x,
	                        y: y
	                    });
	                },

	                /**
	                 * Create a group using an outer div and an inner v:group to allow rotating
	                 * and flipping. A simple v:group would have problems with positioning
	                 * child HTML elements and CSS clip.
	                 *
	                 * @param {String} name The name of the group
	                 */
	                g: function(name) {
	                    var wrapper,
	                        attribs;

	                    // set the class name
	                    if (name) {
	                        attribs = {
	                            'className': 'highcharts-' + name,
	                            'class': 'highcharts-' + name
	                        };
	                    }

	                    // the div to hold HTML and clipping
	                    wrapper = this.createElement('div').attr(attribs);

	                    return wrapper;
	                },

	                /**
	                 * VML override to create a regular HTML image
	                 * @param {String} src
	                 * @param {Number} x
	                 * @param {Number} y
	                 * @param {Number} width
	                 * @param {Number} height
	                 */
	                image: function(src, x, y, width, height) {
	                    var obj = this.createElement('img')
	                        .attr({
	                            src: src
	                        });

	                    if (arguments.length > 1) {
	                        obj.attr({
	                            x: x,
	                            y: y,
	                            width: width,
	                            height: height
	                        });
	                    }
	                    return obj;
	                },

	                /**
	                 * For rectangles, VML uses a shape for rect to overcome bugs and rotation problems
	                 */
	                createElement: function(nodeName) {
	                    return nodeName === 'rect' ?
	                        this.symbol(nodeName) :
	                        SVGRenderer.prototype.createElement.call(this, nodeName);
	                },

	                /**
	                 * In the VML renderer, each child of an inverted div (group) is inverted
	                 * @param {Object} element
	                 * @param {Object} parentNode
	                 */
	                invertChild: function(element, parentNode) {
	                    var ren = this,
	                        parentStyle = parentNode.style,
	                        imgStyle = element.tagName === 'IMG' && element.style; // #1111

	                    css(element, {
	                        flip: 'x',
	                        left: pInt(parentStyle.width) - (imgStyle ? pInt(imgStyle.top) : 1),
	                        top: pInt(parentStyle.height) - (imgStyle ? pInt(imgStyle.left) : 1),
	                        rotation: -90
	                    });

	                    // Recursively invert child elements, needed for nested composite
	                    // shapes like box plots and error bars. #1680, #1806.
	                    each(element.childNodes, function(child) {
	                        ren.invertChild(child, element);
	                    });
	                },

	                /**
	                 * Symbol definitions that override the parent SVG renderer's symbols
	                 *
	                 */
	                symbols: {
	                    // VML specific arc function
	                    arc: function(x, y, w, h, options) {
	                        var start = options.start,
	                            end = options.end,
	                            radius = options.r || w || h,
	                            innerRadius = options.innerR,
	                            cosStart = Math.cos(start),
	                            sinStart = Math.sin(start),
	                            cosEnd = Math.cos(end),
	                            sinEnd = Math.sin(end),
	                            ret;

	                        if (end - start === 0) { // no angle, don't show it.
	                            return ['x'];
	                        }

	                        ret = [
	                            'wa', // clockwise arc to
	                            x - radius, // left
	                            y - radius, // top
	                            x + radius, // right
	                            y + radius, // bottom
	                            x + radius * cosStart, // start x
	                            y + radius * sinStart, // start y
	                            x + radius * cosEnd, // end x
	                            y + radius * sinEnd // end y
	                        ];

	                        if (options.open && !innerRadius) {
	                            ret.push(
	                                'e',
	                                'M',
	                                x, // - innerRadius,
	                                y // - innerRadius
	                            );
	                        }

	                        ret.push(
	                            'at', // anti clockwise arc to
	                            x - innerRadius, // left
	                            y - innerRadius, // top
	                            x + innerRadius, // right
	                            y + innerRadius, // bottom
	                            x + innerRadius * cosEnd, // start x
	                            y + innerRadius * sinEnd, // start y
	                            x + innerRadius * cosStart, // end x
	                            y + innerRadius * sinStart, // end y
	                            'x', // finish path
	                            'e' // close
	                        );

	                        ret.isArc = true;
	                        return ret;

	                    },
	                    // Add circle symbol path. This performs significantly faster than v:oval.
	                    circle: function(x, y, w, h, wrapper) {

	                        if (wrapper && defined(wrapper.r)) {
	                            w = h = 2 * wrapper.r;
	                        }

	                        // Center correction, #1682
	                        if (wrapper && wrapper.isCircle) {
	                            x -= w / 2;
	                            y -= h / 2;
	                        }

	                        // Return the path
	                        return [
	                            'wa', // clockwisearcto
	                            x, // left
	                            y, // top
	                            x + w, // right
	                            y + h, // bottom
	                            x + w, // start x
	                            y + h / 2, // start y
	                            x + w, // end x
	                            y + h / 2, // end y
	                            //'x', // finish path
	                            'e' // close
	                        ];
	                    },
	                    /**
	                     * Add rectangle symbol path which eases rotation and omits arcsize problems
	                     * compared to the built-in VML roundrect shape. When borders are not rounded,
	                     * use the simpler square path, else use the callout path without the arrow.
	                     */
	                    rect: function(x, y, w, h, options) {
	                        return SVGRenderer.prototype.symbols[!defined(options) || !options.r ? 'square' : 'callout'].call(0, x, y, w, h, options);
	                    }
	                }
	            };
	            H.VMLRenderer = VMLRenderer = function() {
	                this.init.apply(this, arguments);
	            };
	            VMLRenderer.prototype = merge(SVGRenderer.prototype, VMLRendererExtension);

	            // general renderer
	            H.Renderer = VMLRenderer;
	        }

	        // This method is used with exporting in old IE, when emulating SVG (see #2314)
	        SVGRenderer.prototype.measureSpanWidth = function(text, styles) {
	            var measuringSpan = doc.createElement('span'),
	                offsetWidth,
	                textNode = doc.createTextNode(text);

	            measuringSpan.appendChild(textNode);
	            css(measuringSpan, styles);
	            this.box.appendChild(measuringSpan);
	            offsetWidth = measuringSpan.offsetWidth;
	            discardElement(measuringSpan); // #2463
	            return offsetWidth;
	        };


	        /* ****************************************************************************
	         *                                                                            *
	         * END OF INTERNET EXPLORER <= 8 SPECIFIC CODE                                *
	         *                                                                            *
	         *****************************************************************************/


	    }(Highcharts));
	    (function(H) {
	        /**
	         * (c) 2010-2017 Torstein Honsi
	         *
	         * License: www.highcharts.com/license
	         */
	        var color = H.color,
	            each = H.each,
	            getTZOffset = H.getTZOffset,
	            isTouchDevice = H.isTouchDevice,
	            merge = H.merge,
	            pick = H.pick,
	            svg = H.svg,
	            win = H.win;

	        /* ****************************************************************************
	         * Handle the options                                                         *
	         *****************************************************************************/
	        /**      
	         * @optionparent
	         */
	        H.defaultOptions = {


	            /**
	             * An array containing the default colors for the chart's series. When
	             * all colors are used, new colors are pulled from the start again.
	             * 
	             * Default colors can also be set on a series or series.type basis,
	             * see [column.colors](#plotOptions.column.colors), [pie.colors](#plotOptions.
	             * pie.colors).
	             * 
	             * In [styled mode](http://www.highcharts.com/docs/chart-design-and-
	             * style/style-by-css), the colors option doesn't exist. Instead, colors
	             * are defined in CSS and applied either through series or point class
	             * names, or through the [chart.colorCount](#chart.colorCount) option.
	             * 
	             * 
	             * ### Legacy
	             * 
	             * In Highcharts 3.x, the default colors were:
	             * 
	             * <pre>colors: ['#2f7ed8', '#0d233a', '#8bbc21', '#910000', '#1aadce',
	             * 
	             * '#492970', '#f28f43', '#77a1e5', '#c42525', '#a6c96a']</pre>
	             * 
	             * In Highcharts 2.x, the default colors were:
	             * 
	             * <pre>colors: ['#4572A7', '#AA4643', '#89A54E', '#80699B', '#3D96AE',
	             * 
	             *    '#DB843D', '#92A8CD', '#A47D7C', '#B5CA92']</pre>
	             * 
	             * @type {Array<Color>}
	             * @sample {highcharts} highcharts/chart/colors/ Assign a global color theme
	             * @default [ "#7cb5ec" , "#434348" , "#90ed7d" , "#f7a35c" , "#8085e9" ,
	             *          "#f15c80" , "#e4d354" , "#2b908f" , "#f45b5b" , "#91e8e1"]
	             * @product highcharts highstock highmaps
	             */
	            colors: '#7cb5ec #434348 #90ed7d #f7a35c #8085e9 #f15c80 #e4d354 #2b908f #f45b5b #91e8e1'.split(' '),


	            /**
	             */
	            symbols: ['circle', 'diamond', 'square', 'triangle', 'triangle-down'],
	            lang: {

	                /**
	                 * The loading text that appears when the chart is set into the loading
	                 * state following a call to `chart.showLoading`.
	                 * 
	                 * @type {String}
	                 * @default Loading...
	                 * @product highcharts highstock highmaps
	                 */
	                loading: 'Loading...',

	                /**
	                 * An array containing the months names. Corresponds to the `%B` format
	                 * in `Highcharts.dateFormat()`.
	                 * 
	                 * @type {Array<String>}
	                 * @default [ "January" , "February" , "March" , "April" , "May" ,
	                 *          "June" , "July" , "August" , "September" , "October" ,
	                 *          "November" , "December"]
	                 * @product highcharts highstock highmaps
	                 */
	                months: [
	                    'January', 'February', 'March', 'April', 'May', 'June', 'July',
	                    'August', 'September', 'October', 'November', 'December'
	                ],

	                /**
	                 * An array containing the months names in abbreviated form. Corresponds
	                 * to the `%b` format in `Highcharts.dateFormat()`.
	                 * 
	                 * @type {Array<String>}
	                 * @default [ "Jan" , "Feb" , "Mar" , "Apr" , "May" , "Jun" ,
	                 *          "Jul" , "Aug" , "Sep" , "Oct" , "Nov" , "Dec"]
	                 */
	                shortMonths: [
	                    'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul',
	                    'Aug', 'Sep', 'Oct', 'Nov', 'Dec'
	                ],

	                /**
	                 * An array containing the weekday names.
	                 * 
	                 * @type {Array<String>}
	                 * @default ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday",
	                 *          "Friday", "Saturday"]
	                 * @product highcharts highstock highmaps
	                 */
	                weekdays: [
	                    'Sunday', 'Monday', 'Tuesday', 'Wednesday',
	                    'Thursday', 'Friday', 'Saturday'
	                ],
	                // invalidDate: '',

	                /**
	                 * The default decimal point used in the `Highcharts.numberFormat`
	                 * method unless otherwise specified in the function arguments.
	                 * 
	                 * @type {String}
	                 * @default .
	                 * @since 1.2.2
	                 * @product highcharts highstock highmaps
	                 */
	                decimalPoint: '.',

	                /**
	                 * [Metric prefixes](http://en.wikipedia.org/wiki/Metric_prefix) used
	                 * to shorten high numbers in axis labels. Replacing any of the positions
	                 * with `null` causes the full number to be written. Setting `numericSymbols`
	                 * to `null` disables shortening altogether.
	                 * 
	                 * @type {Array<String>}
	                 * @sample {highcharts} highcharts/lang/numericsymbols/ Replacing the symbols with text
	                 * @sample {highstock} highcharts/lang/numericsymbols/ Replacing the symbols with text
	                 * @default [ "k" , "M" , "G" , "T" , "P" , "E"]
	                 * @since 2.3.0
	                 * @product highcharts highstock highmaps
	                 */
	                numericSymbols: ['k', 'M', 'G', 'T', 'P', 'E'], // SI prefixes used in axis labels

	                /**
	                 * The text for the label appearing when a chart is zoomed.
	                 * 
	                 * @type {String}
	                 * @default Reset zoom
	                 * @since 1.2.4
	                 * @product highcharts highstock highmaps
	                 */
	                resetZoom: 'Reset zoom',

	                /**
	                 * The tooltip title for the label appearing when a chart is zoomed.
	                 * 
	                 * @type {String}
	                 * @default Reset zoom level 1:1
	                 * @since 1.2.4
	                 * @product highcharts highstock highmaps
	                 */
	                resetZoomTitle: 'Reset zoom level 1:1',

	                /**
	                 * The default thousands separator used in the `Highcharts.numberFormat`
	                 * method unless otherwise specified in the function arguments. Since
	                 * Highcharts 4.1 it defaults to a single space character, which is
	                 * compatible with ISO and works across Anglo-American and continental
	                 * European languages.
	                 * 
	                 * The default is a single space.
	                 * 
	                 * @type {String}
	                 * @default  
	                 * @since 1.2.2
	                 * @product highcharts highstock highmaps
	                 */
	                thousandsSep: ' '
	            },

	            /**
	             * Global options that don't apply to each chart. These options, like
	             * the `lang` options, must be set using the `Highcharts.setOptions`
	             * method.
	             * 
	             * <pre>Highcharts.setOptions({
	             * global: {
	             * useUTC: false
	             * }
	             * });</pre>
	             * 
	             * @product highcharts highstock highmaps
	             */
	            global: {

	                /**
	                 * Whether to use UTC time for axis scaling, tickmark placement and
	                 * time display in `Highcharts.dateFormat`. Advantages of using UTC
	                 * is that the time displays equally regardless of the user agent's
	                 * time zone settings. Local time can be used when the data is loaded
	                 * in real time or when correct Daylight Saving Time transitions are
	                 * required.
	                 * 
	                 * @type {Boolean}
	                 * @sample {highcharts} highcharts/global/useutc-true/ True by default
	                 * @sample {highcharts} highcharts/global/useutc-false/ False
	                 * @default true
	                 * @product highcharts highstock highmaps
	                 */
	                useUTC: true,
	                //timezoneOffset: 0,


	                /**
	                 * Path to the pattern image required by VML browsers in order to
	                 * draw radial gradients.
	                 * 
	                 * @type {String}
	                 * @default {highcharts} http://code.highcharts.com/{version}/gfx/vml-radial-gradient.png
	                 * @default {highstock} http://code.highcharts.com/highstock/{version}/gfx/vml-radial-gradient.png
	                 * @default {highmaps} http://code.highcharts.com/{version}/gfx/vml-radial-gradient.png
	                 * @since 2.3.0
	                 * @product highcharts highstock highmaps
	                 */
	                VMLRadialGradientURL: 'http://code.highcharts.com/5.0.14/gfx/vml-radial-gradient.png'

	            },
	            chart: {

	                /**
	                 * When using multiple axis, the ticks of two or more opposite axes
	                 * will automatically be aligned by adding ticks to the axis or axes
	                 * with the least ticks, as if `tickAmount` were specified.
	                 * 
	                 * This can be prevented by setting `alignTicks` to false. If the grid
	                 * lines look messy, it's a good idea to hide them for the secondary
	                 * axis by setting `gridLineWidth` to 0.
	                 * 
	                 * @type {Boolean}
	                 * @sample {highcharts} highcharts/chart/alignticks-true/ True by default
	                 * @sample {highcharts} highcharts/chart/alignticks-false/ False
	                 * @sample {highstock} stock/chart/alignticks-true/
	                 *         True by default
	                 * @sample {highstock} stock/chart/alignticks-false/
	                 *         False
	                 * @default true
	                 * @product highcharts highstock
	                 * @apioption chart.alignTicks
	                 */


	                /**
	                 * Set the overall animation for all chart updating. Animation can be
	                 * disabled throughout the chart by setting it to false here. It can
	                 * be overridden for each individual API method as a function parameter.
	                 * The only animation not affected by this option is the initial series
	                 * animation, see [plotOptions.series.animation](#plotOptions.series.
	                 * animation).
	                 * 
	                 * The animation can either be set as a boolean or a configuration
	                 * object. If `true`, it will use the 'swing' jQuery easing and a
	                 * duration of 500 ms. If used as a configuration object, the following
	                 * properties are supported:
	                 * 
	                 * <dl>
	                 * 
	                 * <dt>duration</dt>
	                 * 
	                 * <dd>The duration of the animation in milliseconds.</dd>
	                 * 
	                 * <dt>easing</dt>
	                 * 
	                 * <dd>A string reference to an easing function set on the `Math` object.
	                 * See [the easing demo](http://jsfiddle.net/gh/get/library/pure/
	                 * highcharts/highcharts/tree/master/samples/highcharts/plotoptions/
	                 * series-animation-easing/).</dd>
	                 * 
	                 * </dl>
	                 * 
	                 * @type {Boolean|Object}
	                 * @sample {highcharts} highcharts/chart/animation-none/
	                 *         Updating with no animation
	                 * @sample {highcharts} highcharts/chart/animation-duration/
	                 *         With a longer duration
	                 * @sample {highcharts} highcharts/chart/animation-easing/
	                 *         With a jQuery UI easing
	                 * @sample {highmaps} maps/chart/animation-none/
	                 *         Updating with no animation
	                 * @sample {highmaps} maps/chart/animation-duration/
	                 *         With a longer duration
	                 * @default true
	                 * @apioption chart.animation
	                 */

	                /**
	                 * A CSS class name to apply to the charts container `div`, allowing
	                 * unique CSS styling for each chart.
	                 * 
	                 * @type {String}
	                 * @apioption chart.className
	                 */

	                /**
	                 * Event listeners for the chart.
	                 * 
	                 * @apioption chart.events
	                 */

	                /**
	                 * Fires when a series is added to the chart after load time, using
	                 * the `addSeries` method. One parameter, `event`, is passed to the
	                 * function, containing common event information.
	                 * Through `event.options` you can access the series options that was
	                 * passed to the `addSeries` method. Returning false prevents the series
	                 * from being added.
	                 * 
	                 * @type {Function}
	                 * @context Chart
	                 * @sample {highcharts} highcharts/chart/events-addseries/ Alert on add series
	                 * @sample {highstock} stock/chart/events-addseries/ Alert on add series
	                 * @since 1.2.0
	                 * @apioption chart.events.addSeries
	                 */

	                /**
	                 * Fires when clicking on the plot background. One parameter, `event`,
	                 * is passed to the function, containing common event information.
	                 * 
	                 * Information on the clicked spot can be found through `event.xAxis`
	                 * and `event.yAxis`, which are arrays containing the axes of each dimension
	                 * and each axis' value at the clicked spot. The primary axes are `event.
	                 * xAxis[0]` and `event.yAxis[0]`. Remember the unit of a datetime axis
	                 * is milliseconds since 1970-01-01 00:00:00.
	                 * 
	                 * <pre>click: function(e) {
	                 * console.log(
	                 * Highcharts.dateFormat('%Y-%m-%d %H:%M:%S', e.xAxis[0].value),
	                 * e.yAxis[0].value
	                 * )
	                 * }</pre>
	                 * 
	                 * @type {Function}
	                 * @context Chart
	                 * @sample {highcharts} highcharts/chart/events-click/
	                 *         Alert coordinates on click
	                 * @sample {highcharts} highcharts/chart/events-container/
	                 *         Alternatively, attach event to container
	                 * @sample {highstock} stock/chart/events-click/
	                 *         Alert coordinates on click
	                 * @sample {highstock} highcharts/chart/events-container/
	                 *         Alternatively, attach event to container
	                 * @sample {highmaps} maps/chart/events-click/
	                 *         Record coordinates on click
	                 * @sample {highmaps} highcharts/chart/events-container/
	                 *         Alternatively, attach event to container
	                 * @since 1.2.0
	                 * @apioption chart.events.click
	                 */


	                /**
	                 * Fires when the chart is finished loading. Since v4.2.2, it also waits
	                 * for images to be loaded, for example from point markers. One parameter,
	                 * `event`, is passed to the function, containing common event information.
	                 * 
	                 * There is also a second parameter to the chart constructor where a
	                 * callback function can be passed to be executed on chart.load.
	                 * 
	                 * @type {Function}
	                 * @context Chart
	                 * @sample {highcharts} highcharts/chart/events-load/
	                 *         Alert on chart load
	                 * @sample {highstock} stock/chart/events-load/
	                 *         Alert on chart load
	                 * @sample {highmaps} maps/chart/events-load/
	                 *         Add series on chart load
	                 * @apioption chart.events.load
	                 */

	                /**
	                 * Fires when the chart is redrawn, either after a call to chart.redraw()
	                 * or after an axis, series or point is modified with the `redraw` option
	                 * set to true. One parameter, `event`, is passed to the function, containing common event information.
	                 * 
	                 * @type {Function}
	                 * @context Chart
	                 * @sample {highcharts} highcharts/chart/events-redraw/
	                 *         Alert on chart redraw
	                 * @sample {highstock} stock/chart/events-redraw/
	                 *         Alert on chart redraw when adding a series or moving the
	                 *         zoomed range
	                 * @sample {highmaps} maps/chart/events-redraw/
	                 *         Set subtitle on chart redraw
	                 * @since 1.2.0
	                 * @apioption chart.events.redraw
	                 */

	                /**
	                 * Fires after initial load of the chart (directly after the `load`
	                 * event), and after each redraw (directly after the `redraw` event).
	                 * 
	                 * @type {Function}
	                 * @context Chart
	                 * @since 5.0.7
	                 * @apioption chart.events.render
	                 */

	                /**
	                 * Fires when an area of the chart has been selected. Selection is enabled
	                 * by setting the chart's zoomType. One parameter, `event`, is passed
	                 * to the function, containing common event information. The default action for the selection event is to
	                 * zoom the chart to the selected area. It can be prevented by calling
	                 * `event.preventDefault()`.
	                 * 
	                 * Information on the selected area can be found through `event.xAxis`
	                 * and `event.yAxis`, which are arrays containing the axes of each dimension
	                 * and each axis' min and max values. The primary axes are `event.xAxis[0]`
	                 * and `event.yAxis[0]`. Remember the unit of a datetime axis is milliseconds
	                 * since 1970-01-01 00:00:00.
	                 * 
	                 * <pre>selection: function(event) {
	                 * // log the min and max of the primary, datetime x-axis
	                 * console.log(
	                 * Highcharts.dateFormat('%Y-%m-%d %H:%M:%S', event.xAxis[0].min),
	                 * 
	                 * Highcharts.dateFormat('%Y-%m-%d %H:%M:%S', event.xAxis[0].max)
	                 * );
	                 * // log the min and max of the y axis
	                 * console.log(event.yAxis[0].min, event.yAxis[0].max);
	                 * }</pre>
	                 * 
	                 * @type {Function}
	                 * @sample {highcharts} highcharts/chart/events-selection/
	                 *         Report on selection and reset
	                 * @sample {highcharts} highcharts/chart/events-selection-points/
	                 *         Select a range of points through a drag selection
	                 * @sample {highstock} stock/chart/events-selection/
	                 *         Report on selection and reset
	                 * @sample {highstock} highcharts/chart/events-selection-points/
	                 *         Select a range of points through a drag selection (Highcharts)
	                 * @apioption chart.events.selection
	                 */

	                /**
	                 * The margin between the outer edge of the chart and the plot area.
	                 * The numbers in the array designate top, right, bottom and left
	                 * respectively. Use the options `marginTop`, `marginRight`,
	                 * `marginBottom` and `marginLeft` for shorthand setting of one option.
	                 * 
	                 * By default there is no margin. The actual space is dynamically calculated
	                 * from the offset of axis labels, axis title, title, subtitle and legend
	                 * in addition to the `spacingTop`, `spacingRight`, `spacingBottom`
	                 * and `spacingLeft` options.
	                 * 
	                 * @type {Array}
	                 * @sample {highcharts} highcharts/chart/margins-zero/
	                 *         Zero margins
	                 * @sample {highstock} stock/chart/margin-zero/
	                 *         Zero margins
	                 *
	                 * @defaults {all} null
	                 * @apioption chart.margin
	                 */

	                /**
	                 * The margin between the bottom outer edge of the chart and the plot
	                 * area. Use this to set a fixed pixel value for the margin as opposed
	                 * to the default dynamic margin. See also `spacingBottom`.
	                 * 
	                 * @type {Number}
	                 * @sample {highcharts} highcharts/chart/marginbottom/
	                 *         100px bottom margin
	                 * @sample {highstock} stock/chart/marginbottom/
	                 *         100px bottom margin
	                 * @sample {highmaps} maps/chart/margin/
	                 *         100px margins
	                 * @since 2.0
	                 * @apioption chart.marginBottom
	                 */

	                /**
	                 * The margin between the left outer edge of the chart and the plot
	                 * area. Use this to set a fixed pixel value for the margin as opposed
	                 * to the default dynamic margin. See also `spacingLeft`.
	                 * 
	                 * @type {Number}
	                 * @sample {highcharts} highcharts/chart/marginleft/
	                 *         150px left margin
	                 * @sample {highstock} stock/chart/marginleft/
	                 *         150px left margin
	                 * @sample {highmaps} maps/chart/margin/
	                 *         100px margins
	                 * @default null
	                 * @since 2.0
	                 * @apioption chart.marginLeft
	                 */

	                /**
	                 * The margin between the right outer edge of the chart and the plot
	                 * area. Use this to set a fixed pixel value for the margin as opposed
	                 * to the default dynamic margin. See also `spacingRight`.
	                 * 
	                 * @type {Number}
	                 * @sample {highcharts} highcharts/chart/marginright/
	                 *         100px right margin
	                 * @sample {highstock} stock/chart/marginright/
	                 *         100px right margin
	                 * @sample {highmaps} maps/chart/margin/
	                 *         100px margins
	                 * @default null
	                 * @since 2.0
	                 * @apioption chart.marginRight
	                 */

	                /**
	                 * The margin between the top outer edge of the chart and the plot area.
	                 * Use this to set a fixed pixel value for the margin as opposed to
	                 * the default dynamic margin. See also `spacingTop`.
	                 * 
	                 * @type {Number}
	                 * @sample {highcharts} highcharts/chart/margintop/ 100px top margin
	                 * @sample {highstock} stock/chart/margintop/
	                 *         100px top margin
	                 * @sample {highmaps} maps/chart/margin/
	                 *         100px margins
	                 * @default null
	                 * @since 2.0
	                 * @apioption chart.marginTop
	                 */

	                /**
	                 * Allows setting a key to switch between zooming and panning. Can be
	                 * one of `alt`, `ctrl`, `meta` (the command key on Mac and Windows
	                 * key on Windows) or `shift`. The keys are mapped directly to the key
	                 * properties of the click event argument (`event.altKey`, `event.ctrlKey`,
	                 * `event.metaKey` and `event.shiftKey`).
	                 * 
	                 * @validvalue [null, "alt", "ctrl", "meta", "shift"]
	                 * @type {String}
	                 * @since 4.0.3
	                 * @product highcharts
	                 * @apioption chart.panKey
	                 */

	                /**
	                 * Allow panning in a chart. Best used with [panKey](#chart.panKey)
	                 * to combine zooming and panning.
	                 * 
	                 * On touch devices, when the [tooltip.followTouchMove](#tooltip.followTouchMove)
	                 * option is `true` (default), panning requires two fingers. To allow
	                 * panning with one finger, set `followTouchMove` to `false`.
	                 * 
	                 * @type {Boolean}
	                 * @sample {highcharts} highcharts/chart/pankey/ Zooming and panning
	                 * @default {highcharts} false
	                 * @default {highstock} true
	                 * @since 4.0.3
	                 * @product highcharts highstock
	                 * @apioption chart.panning
	                 */


	                /**
	                 * Equivalent to [zoomType](#chart.zoomType), but for multitouch gestures
	                 * only. By default, the `pinchType` is the same as the `zoomType` setting.
	                 * However, pinching can be enabled separately in some cases, for example
	                 * in stock charts where a mouse drag pans the chart, while pinching
	                 * is enabled. When [tooltip.followTouchMove](#tooltip.followTouchMove)
	                 * is true, pinchType only applies to two-finger touches.
	                 * 
	                 * @validvalue ["x", "y", "xy"]
	                 * @type {String}
	                 * @default {highcharts} null
	                 * @default {highstock} x
	                 * @since 3.0
	                 * @product highcharts highstock
	                 * @apioption chart.pinchType
	                 */

	                /**
	                 * The corner radius of the outer chart border.
	                 * 
	                 * @type {Number}
	                 * @sample {highcharts} highcharts/chart/borderradius/ 20px radius
	                 * @sample {highstock} stock/chart/border/ 10px radius
	                 * @sample {highmaps} maps/chart/border/ Border options
	                 * @default 0
	                 * @product highcharts highstock highmaps
	                 */
	                borderRadius: 0,


	                /**
	                 * Alias of `type`.
	                 * 
	                 * @validvalue ["line", "spline", "column", "area", "areaspline", "pie"]
	                 * @type {String}
	                 * @deprecated
	                 * @sample {highcharts} highcharts/chart/defaultseriestype/ Bar
	                 * @default line
	                 * @product highcharts
	                 */
	                defaultSeriesType: 'line',

	                /**
	                 * If true, the axes will scale to the remaining visible series once
	                 * one series is hidden. If false, hiding and showing a series will
	                 * not affect the axes or the other series. For stacks, once one series
	                 * within the stack is hidden, the rest of the stack will close in
	                 * around it even if the axis is not affected.
	                 * 
	                 * @type {Boolean}
	                 * @sample {highcharts} highcharts/chart/ignorehiddenseries-true/
	                 *         True by default
	                 * @sample {highcharts} highcharts/chart/ignorehiddenseries-false/
	                 *         False
	                 * @sample {highcharts} highcharts/chart/ignorehiddenseries-true-stacked/
	                 *         True with stack
	                 * @sample {highstock} stock/chart/ignorehiddenseries-true/
	                 *         True by default
	                 * @sample {highstock} stock/chart/ignorehiddenseries-false/
	                 *         False
	                 * @default true
	                 * @since 1.2.0
	                 * @product highcharts highstock
	                 */
	                ignoreHiddenSeries: true,


	                /**
	                 * Whether to invert the axes so that the x axis is vertical and y axis
	                 * is horizontal. When `true`, the x axis is [reversed](#xAxis.reversed)
	                 * by default.
	                 *
	                 * @productdesc {highcharts}
	                 * If a bar series is present in the chart, it will be inverted
	                 * automatically. Inverting the chart doesn't have an effect if there
	                 * are no cartesian series in the chart, or if the chart is
	                 * [polar](#chart.polar).
	                 * 
	                 * @type {Boolean}
	                 * @sample {highcharts} highcharts/chart/inverted/
	                 *         Inverted line
	                 * @sample {highstock} stock/navigator/inverted/
	                 *         Inverted stock chart
	                 * @default false
	                 * @product highcharts highstock
	                 * @apioption chart.inverted
	                 */

	                /**
	                 * The distance between the outer edge of the chart and the content,
	                 * like title or legend, or axis title and labels if present. The
	                 * numbers in the array designate top, right, bottom and left respectively.
	                 * Use the options spacingTop, spacingRight, spacingBottom and spacingLeft
	                 * options for shorthand setting of one option.
	                 * 
	                 * @type {Array<Number>}
	                 * @see [chart.margin](#chart.margin)
	                 * @default [10, 10, 15, 10]
	                 * @since 3.0.6
	                 * @product highcharts highstock highmaps
	                 */
	                spacing: [10, 10, 15, 10],

	                /**
	                 * The button that appears after a selection zoom, allowing the user
	                 * to reset zoom.
	                 * 
	                 * @product highcharts highstock highmaps
	                 */
	                resetZoomButton: {

	                    /**
	                     * A collection of attributes for the button. The object takes SVG
	                     * attributes like `fill`, `stroke`, `stroke-width` or `r`, the border
	                     * radius. The theme also supports `style`, a collection of CSS properties
	                     * for the text. Equivalent attributes for the hover state are given
	                     * in `theme.states.hover`.
	                     * 
	                     * @type {Object}
	                     * @sample {highcharts} highcharts/chart/resetzoombutton-theme/ Theming the button
	                     * @sample {highstock} highcharts/chart/resetzoombutton-theme/ Theming the button
	                     * @since 2.2
	                     * @product highcharts highstock highmaps
	                     */
	                    theme: {

	                        /**
	                         */
	                        zIndex: 20
	                    },

	                    /**
	                     * The position of the button.
	                     * 
	                     * @type {Object}
	                     * @sample {highcharts} highcharts/chart/resetzoombutton-position/
	                     *         Above the plot area
	                     * @sample {highstock} highcharts/chart/resetzoombutton-position/
	                     *         Above the plot area
	                     * @sample {highmaps} highcharts/chart/resetzoombutton-position/
	                     *         Above the plot area
	                     * @since 2.2
	                     * @product highcharts highstock highmaps
	                     */
	                    position: {

	                        /**
	                         * The horizontal alignment of the button.
	                         * 
	                         * @type {String}
	                         */
	                        align: 'right',

	                        /**
	                         * The horizontal offset of the button.
	                         * 
	                         * @type {Number}
	                         */
	                        x: -10,

	                        /**
	                         * The vertical alignment of the button.
	                         * 
	                         * @validvalue ["top", "middle", "bottom"]
	                         * @type {String}
	                         * @default top
	                         * @apioption chart.resetZoomButton.position.verticalAlign
	                         */

	                        /**
	                         * The vertical offset of the button.
	                         * 
	                         * @type {Number}
	                         */
	                        y: 10
	                    }

	                    /**
	                     * What frame the button should be placed related to. Can be either
	                     * `plot` or `chart`
	                     * 
	                     * @validvalue ["plot", "chart"]
	                     * @type {String}
	                     * @sample {highcharts} highcharts/chart/resetzoombutton-relativeto/
	                     *         Relative to the chart
	                     * @sample {highstock} highcharts/chart/resetzoombutton-relativeto/
	                     *         Relative to the chart
	                     * @default plot
	                     * @since 2.2
	                     * @apioption chart.resetZoomButton.relativeTo
	                     */
	                },

	                /**
	                 * An explicit width for the chart. By default (when `null`) the width
	                 * is calculated from the offset width of the containing element.
	                 * 
	                 * @type {Number}
	                 * @sample {highcharts} highcharts/chart/width/ 800px wide
	                 * @sample {highstock} stock/chart/width/ 800px wide
	                 * @sample {highmaps} maps/chart/size/ Chart with explicit size
	                 * @default null
	                 * @product highcharts highstock highmaps
	                 */
	                width: null,

	                /**
	                 * An explicit height for the chart. If a _number_, the height is
	                 * given in pixels. If given a _percentage string_ (for example `'56%'`),
	                 * the height is given as the percentage of the actual chart width.
	                 * This allows for preserving the aspect ratio across responsive
	                 * sizes.
	                 * 
	                 * By default (when `null`) the height is calculated from the offset
	                 * height of the containing element, or 400 pixels if the containing
	                 * element's height is 0.
	                 * 
	                 * @type {Number|String}
	                 * @sample {highcharts} highcharts/chart/height/
	                 *         500px height
	                 * @sample {highstock} stock/chart/height/
	                 *         300px height
	                 * @sample {highmaps} maps/chart/size/
	                 *         Chart with explicit size
	                 * @sample highcharts/chart/height-percent/
	                 *         Highcharts with percentage height
	                 * @default null
	                 * @product highcharts highstock highmaps
	                 */
	                height: null,



	                /**
	                 * The color of the outer chart border.
	                 * 
	                 * @type {Color}
	                 * @see In [styled mode](http://www.highcharts.com/docs/chart-design-and-
	                 * style/style-by-css), the stroke is set with the `.highcharts-background`
	                 * class.
	                 * @sample {highcharts} highcharts/chart/bordercolor/ Brown border
	                 * @sample {highstock} stock/chart/border/ Brown border
	                 * @sample {highmaps} maps/chart/border/ Border options
	                 * @default #335cad
	                 * @product highcharts highstock highmaps
	                 */
	                borderColor: '#335cad',

	                /**
	                 * The pixel width of the outer chart border.
	                 * 
	                 * @type {Number}
	                 * @see In [styled mode](http://www.highcharts.com/docs/chart-design-and-
	                 * style/style-by-css), the stroke is set with the `.highcharts-background`
	                 * class.
	                 * @sample {highcharts} highcharts/chart/borderwidth/ 5px border
	                 * @sample {highstock} stock/chart/border/
	                 *         2px border
	                 * @sample {highmaps} maps/chart/border/
	                 *         Border options
	                 * @default 0
	                 * @apioption chart.borderWidth
	                 */

	                //style: {
	                //  fontFamily: '"Lucida Grande", "Lucida Sans Unicode", Verdana, Arial, Helvetica, sans-serif', // default font
	                //  fontSize: '12px'
	                //},

	                /**
	                 * The background color or gradient for the outer chart area.
	                 * 
	                 * @type {Color}
	                 * @see In [styled mode](http://www.highcharts.com/docs/chart-design-and-
	                 * style/style-by-css), the background is set with the `.highcharts-
	                 * background` class.
	                 * @sample {highcharts} highcharts/chart/backgroundcolor-color/ Color
	                 * @sample {highcharts} highcharts/chart/backgroundcolor-gradient/ Gradient
	                 * @sample {highstock} stock/chart/backgroundcolor-color/
	                 *         Color
	                 * @sample {highstock} stock/chart/backgroundcolor-gradient/
	                 *         Gradient
	                 * @sample {highmaps} maps/chart/backgroundcolor-color/
	                 *         Color
	                 * @sample {highmaps} maps/chart/backgroundcolor-gradient/
	                 *         Gradient
	                 * @default #FFFFFF
	                 * @product highcharts highstock highmaps
	                 */
	                backgroundColor: '#ffffff',

	                /**
	                 * The background color or gradient for the plot area.
	                 * 
	                 * @type {Color}
	                 * @see In [styled mode](http://www.highcharts.com/docs/chart-design-and-
	                 * style/style-by-css), the plot background is set with the `.highcharts-
	                 * plot-background` class.
	                 * @sample {highcharts} highcharts/chart/plotbackgroundcolor-color/
	                 *         Color
	                 * @sample {highcharts} highcharts/chart/plotbackgroundcolor-gradient/
	                 *         Gradient
	                 * @sample {highstock} stock/chart/plotbackgroundcolor-color/
	                 *         Color
	                 * @sample {highstock} stock/chart/plotbackgroundcolor-gradient/
	                 *         Gradient
	                 * @sample {highmaps} maps/chart/plotbackgroundcolor-color/
	                 *         Color
	                 * @sample {highmaps} maps/chart/plotbackgroundcolor-gradient/
	                 *         Gradient
	                 * @default null
	                 * @apioption chart.plotBackgroundColor
	                 */


	                /**
	                 * The URL for an image to use as the plot background. To set an image
	                 * as the background for the entire chart, set a CSS background image
	                 * to the container element. Note that for the image to be applied to
	                 * exported charts, its URL needs to be accessible by the export server.
	                 * 
	                 * @type {String}
	                 * @see In [styled mode](http://www.highcharts.com/docs/chart-design-and-
	                 * style/style-by-css), a plot background image can be set with the
	                 * `.highcharts-plot-background` class and a [custom pattern](http://www.
	                 * highcharts.com/docs/chart-design-and-style/gradients-shadows-and-
	                 * patterns).
	                 * @sample {highcharts} highcharts/chart/plotbackgroundimage/ Skies
	                 * @sample {highstock} stock/chart/plotbackgroundimage/ Skies
	                 * @default null
	                 * @apioption chart.plotBackgroundImage
	                 */

	                /**
	                 * The color of the inner chart or plot area border.
	                 * 
	                 * @type {Color}
	                 * @see In [styled mode](http://www.highcharts.com/docs/chart-design-and-
	                 * style/style-by-css), a plot border stroke can be set with the `.
	                 * highcharts-plot-border` class.
	                 * @sample {highcharts} highcharts/chart/plotbordercolor/ Blue border
	                 * @sample {highstock} stock/chart/plotborder/ Blue border
	                 * @sample {highmaps} maps/chart/plotborder/ Plot border options
	                 * @default #cccccc
	                 * @product highcharts highstock highmaps
	                 */
	                plotBorderColor: '#cccccc'


	                /**
	                 * The pixel width of the plot area border.
	                 * 
	                 * @type {Number}
	                 * @sample {highcharts} highcharts/chart/plotborderwidth/ 1px border
	                 * @sample {highstock} stock/chart/plotborder/
	                 *         2px border
	                 * @sample {highmaps} maps/chart/plotborder/
	                 *         Plot border options
	                 * @default 0
	                 * @apioption chart.plotBorderWidth
	                 */

	                /**
	                 * Whether to apply a drop shadow to the plot area. Requires that
	                 * plotBackgroundColor be set. The shadow can be an object configuration
	                 * containing `color`, `offsetX`, `offsetY`, `opacity` and `width`.
	                 * 
	                 * @type {Boolean|Object}
	                 * @sample {highcharts} highcharts/chart/plotshadow/ Plot shadow
	                 * @sample {highstock} stock/chart/plotshadow/
	                 *         Plot shadow
	                 * @sample {highmaps} maps/chart/plotborder/
	                 *         Plot border options
	                 * @default false
	                 * @apioption chart.plotShadow
	                 */

	                /**
	                 * When true, cartesian charts like line, spline, area and column are
	                 * transformed into the polar coordinate system. Requires `highcharts-
	                 * more.js`.
	                 * 
	                 * @type {Boolean}
	                 * @default false
	                 * @since 2.3.0
	                 * @product highcharts
	                 * @apioption chart.polar
	                 */

	                /**
	                 * Whether to reflow the chart to fit the width of the container div
	                 * on resizing the window.
	                 * 
	                 * @type {Boolean}
	                 * @sample {highcharts} highcharts/chart/reflow-true/ True by default
	                 * @sample {highcharts} highcharts/chart/reflow-false/ False
	                 * @sample {highstock} stock/chart/reflow-true/
	                 *         True by default
	                 * @sample {highstock} stock/chart/reflow-false/
	                 *         False
	                 * @sample {highmaps} maps/chart/reflow-true/
	                 *         True by default
	                 * @sample {highmaps} maps/chart/reflow-false/
	                 *         False
	                 * @default true
	                 * @since 2.1
	                 * @apioption chart.reflow
	                 */




	                /**
	                 * The HTML element where the chart will be rendered. If it is a string,
	                 * the element by that id is used. The HTML element can also be passed
	                 * by direct reference, or as the first argument of the chart constructor,
	                 *  in which case the option is not needed.
	                 * 
	                 * @type {String|Object}
	                 * @sample {highcharts} highcharts/chart/reflow-true/
	                 *         String
	                 * @sample {highcharts} highcharts/chart/renderto-object/
	                 *         Object reference
	                 * @sample {highcharts} highcharts/chart/renderto-jquery/
	                 *         Object reference through jQuery
	                 * @sample {highstock} stock/chart/renderto-string/
	                 *         String
	                 * @sample {highstock} stock/chart/renderto-object/
	                 *         Object reference
	                 * @sample {highstock} stock/chart/renderto-jquery/
	                 *         Object reference through jQuery
	                 * @apioption chart.renderTo
	                 */

	                /**
	                 * The background color of the marker square when selecting (zooming
	                 * in on) an area of the chart.
	                 * 
	                 * @type {Color}
	                 * @see In [styled mode](http://www.highcharts.com/docs/chart-design-and-
	                 * style/style-by-css), the selection marker fill is set with the
	                 * `.highcharts-selection-marker` class.
	                 * @default rgba(51,92,173,0.25)
	                 * @since 2.1.7
	                 * @apioption chart.selectionMarkerFill
	                 */

	                /**
	                 * Whether to apply a drop shadow to the outer chart area. Requires
	                 * that backgroundColor be set. The shadow can be an object configuration
	                 * containing `color`, `offsetX`, `offsetY`, `opacity` and `width`.
	                 * 
	                 * @type {Boolean|Object}
	                 * @sample {highcharts} highcharts/chart/shadow/ Shadow
	                 * @sample {highstock} stock/chart/shadow/
	                 *         Shadow
	                 * @sample {highmaps} maps/chart/border/
	                 *         Chart border and shadow
	                 * @default false
	                 * @apioption chart.shadow
	                 */

	                /**
	                 * Whether to show the axes initially. This only applies to empty charts
	                 * where series are added dynamically, as axes are automatically added
	                 * to cartesian series.
	                 * 
	                 * @type {Boolean}
	                 * @sample {highcharts} highcharts/chart/showaxes-false/ False by default
	                 * @sample {highcharts} highcharts/chart/showaxes-true/ True
	                 * @since 1.2.5
	                 * @product highcharts
	                 * @apioption chart.showAxes
	                 */

	                /**
	                 * The space between the bottom edge of the chart and the content (plot
	                 * area, axis title and labels, title, subtitle or legend in top position).
	                 * 
	                 * @type {Number}
	                 * @sample {highcharts} highcharts/chart/spacingbottom/
	                 *         Spacing bottom set to 100
	                 * @sample {highstock} stock/chart/spacingbottom/
	                 *         Spacing bottom set to 100
	                 * @sample {highmaps} maps/chart/spacing/
	                 *         Spacing 100 all around
	                 * @default 15
	                 * @since 2.1
	                 * @apioption chart.spacingBottom
	                 */

	                /**
	                 * The space between the left edge of the chart and the content (plot
	                 * area, axis title and labels, title, subtitle or legend in top position).
	                 * 
	                 * @type {Number}
	                 * @sample {highcharts} highcharts/chart/spacingleft/
	                 *         Spacing left set to 100
	                 * @sample {highstock} stock/chart/spacingleft/
	                 *         Spacing left set to 100
	                 * @sample {highmaps} maps/chart/spacing/
	                 *         Spacing 100 all around
	                 * @default 10
	                 * @since 2.1
	                 * @apioption chart.spacingLeft
	                 */

	                /**
	                 * The space between the right edge of the chart and the content (plot
	                 * area, axis title and labels, title, subtitle or legend in top
	                 * position).
	                 * 
	                 * @type {Number}
	                 * @sample {highcharts} highcharts/chart/spacingright-100/
	                 *         Spacing set to 100
	                 * @sample {highcharts} highcharts/chart/spacingright-legend/
	                 *         Legend in right position with default spacing
	                 * @sample {highstock} stock/chart/spacingright/
	                 *         Spacing set to 100
	                 * @sample {highmaps} maps/chart/spacing/
	                 *         Spacing 100 all around
	                 * @default 10
	                 * @since 2.1
	                 * @apioption chart.spacingRight
	                 */

	                /**
	                 * The space between the top edge of the chart and the content (plot
	                 * area, axis title and labels, title, subtitle or legend in top
	                 * position).
	                 * 
	                 * @type {Number}
	                 * @sample {highcharts} highcharts/chart/spacingtop-100/
	                 * A top spacing of 100
	                 * @sample {highcharts} highcharts/chart/spacingtop-10/
	                 *         Floating chart title makes the plot area align to the default
	                 *         spacingTop of 10.
	                 * @sample {highstock} stock/chart/spacingtop/
	                 *         A top spacing of 100
	                 * @sample {highmaps} maps/chart/spacing/
	                 *         Spacing 100 all around
	                 * @default 10
	                 * @since 2.1
	                 * @apioption chart.spacingTop
	                 */

	                /**
	                 * Additional CSS styles to apply inline to the container `div`. Note
	                 * that since the default font styles are applied in the renderer, it
	                 * is ignorant of the individual chart options and must be set globally.
	                 * 
	                 * @type {CSSObject}
	                 * @see In [styled mode](http://www.highcharts.com/docs/chart-design-and-
	                 * style/style-by-css), general chart styles can be set with the `.highcharts-
	                 * root` class.
	                 * @sample {highcharts} highcharts/chart/style-serif-font/
	                 *         Using a serif type font
	                 * @sample {highcharts} highcharts/css/em/
	                 *         Styled mode with relative font sizes
	                 * @sample {highstock} stock/chart/style/
	                 *         Using a serif type font
	                 * @sample {highmaps} maps/chart/style-serif-font/
	                 *         Using a serif type font
	                 * @default {"fontFamily":"\"Lucida Grande\", \"Lucida Sans Unicode\", Verdana, Arial, Helvetica, sans-serif","fontSize":"12px"}
	                 * @apioption chart.style
	                 */

	                /**
	                 * The default series type for the chart. Can be any of the chart types
	                 * listed under [plotOptions](#plotOptions).
	                 * 
	                 * @validvalue ["line", "spline", "column", "bar", "area", "areaspline", "pie", "arearange", "areasplinerange", "boxplot", "bubble", "columnrange", "errorbar", "funnel", "gauge", "heatmap", "polygon", "pyramid", "scatter", "solidgauge", "treemap", "waterfall"]
	                 * @type {String}
	                 * @sample {highcharts} highcharts/chart/type-bar/ Bar
	                 * @sample {highstock} stock/chart/type/
	                 *         Areaspline
	                 * @sample {highmaps} maps/chart/type-mapline/
	                 *         Mapline
	                 * @default {highcharts} line
	                 * @default {highstock} line
	                 * @default {highmaps} map
	                 * @since 2.1.0
	                 * @apioption chart.type
	                 */

	                /**
	                 * Decides in what dimensions the user can zoom by dragging the mouse.
	                 * Can be one of `x`, `y` or `xy`.
	                 * 
	                 * @validvalue [null, "x", "y", "xy"]
	                 * @type {String}
	                 * @see [panKey](#chart.panKey)
	                 * @sample {highcharts} highcharts/chart/zoomtype-none/ None by default
	                 * @sample {highcharts} highcharts/chart/zoomtype-x/ X
	                 * @sample {highcharts} highcharts/chart/zoomtype-y/ Y
	                 * @sample {highcharts} highcharts/chart/zoomtype-xy/ Xy
	                 * @sample {highstock} stock/demo/basic-line/ None by default
	                 * @sample {highstock} stock/chart/zoomtype-x/ X
	                 * @sample {highstock} stock/chart/zoomtype-y/ Y
	                 * @sample {highstock} stock/chart/zoomtype-xy/ Xy
	                 * @product highcharts highstock
	                 * @apioption chart.zoomType
	                 */
	            },

	            /**
	             * The chart's main title.
	             * 
	             * @sample {highmaps} maps/title/title/ Title options demonstrated
	             * @product highcharts highstock highmaps
	             */
	            title: {

	                /**
	                 * The title of the chart. To disable the title, set the `text` to
	                 * `null`.
	                 * 
	                 * @type {String}
	                 * @sample {highcharts} highcharts/title/text/ Custom title
	                 * @sample {highstock} stock/chart/title-text/ Custom title
	                 * @default {highcharts} Chart title
	                 * @default {highstock} null
	                 * @default {highmaps} Chart title
	                 * @product highcharts highstock highmaps
	                 */
	                text: 'Chart title',

	                /**
	                 * The horizontal alignment of the title. Can be one of "left", "center"
	                 * and "right".
	                 * 
	                 * @validvalue ["left", "center", "right"]
	                 * @type {String}
	                 * @sample {highcharts} highcharts/title/align/ Aligned to the plot area (x = 70px     = margin left - spacing left)
	                 * @sample {highstock} stock/chart/title-align/ Aligned to the plot area (x = 50px     = margin left - spacing left)
	                 * @default center
	                 * @since 2.0
	                 * @product highcharts highstock highmaps
	                 */
	                align: 'center',
	                // floating: false,

	                /**
	                 * The margin between the title and the plot area, or if a subtitle
	                 * is present, the margin between the subtitle and the plot area.
	                 * 
	                 * @type {Number}
	                 * @sample {highcharts} highcharts/title/margin-50/ A chart title margin of 50
	                 * @sample {highcharts} highcharts/title/margin-subtitle/ The same margin applied with a subtitle
	                 * @sample {highstock} stock/chart/title-margin/ A chart title margin of 50
	                 * @default 15
	                 * @since 2.1
	                 * @product highcharts highstock highmaps
	                 */
	                margin: 15,
	                // x: 0,
	                // verticalAlign: 'top',
	                // y: null,
	                // style: {}, // defined inline

	                /**
	                 * Adjustment made to the title width, normally to reserve space for
	                 * the exporting burger menu.
	                 * 
	                 * @type {Number}
	                 * @sample {highcharts} highcharts/title/widthadjust/ Wider menu, greater padding
	                 * @sample {highstock} highcharts/title/widthadjust/ Wider menu, greater padding
	                 * @sample {highmaps} highcharts/title/widthadjust/ Wider menu, greater padding
	                 * @default -44
	                 * @since 4.2.5
	                 * @product highcharts highstock highmaps
	                 */
	                widthAdjust: -44

	            },

	            /**
	             * The chart's subtitle. This can be used both to display a subtitle below
	             * the main title, and to display random text anywhere in the chart. The
	             * subtitle can be updated after chart initialization through the 
	             * `Chart.setTitle` method.
	             * 
	             * @sample {highmaps} maps/title/subtitle/ Subtitle options demonstrated
	             * @product highcharts highstock highmaps
	             */
	            subtitle: {

	                /**
	                 * The subtitle of the chart.
	                 * 
	                 * @type {String}
	                 * @sample {highcharts} highcharts/subtitle/text/ Custom subtitle
	                 * @sample {highcharts} highcharts/subtitle/text-formatted/ Formatted and linked text.
	                 * @sample {highstock} stock/chart/subtitle-text Custom subtitle
	                 * @sample {highstock} stock/chart/subtitle-text-formatted Formatted and linked text.
	                 * @product highcharts highstock highmaps
	                 */
	                text: '',

	                /**
	                 * The horizontal alignment of the subtitle. Can be one of "left",
	                 *  "center" and "right".
	                 * 
	                 * @validvalue ["left", "center", "right"]
	                 * @type {String}
	                 * @sample {highcharts} highcharts/subtitle/align/ Footnote at right of plot area
	                 * @sample {highstock} stock/chart/subtitle-footnote Footnote at bottom right of plot area
	                 * @default center
	                 * @since 2.0
	                 * @product highcharts highstock highmaps
	                 */
	                align: 'center',
	                // floating: false
	                // x: 0,
	                // verticalAlign: 'top',
	                // y: null,
	                // style: {}, // defined inline

	                /**
	                 * Adjustment made to the subtitle width, normally to reserve space
	                 * for the exporting burger menu.
	                 * 
	                 * @type {Number}
	                 * @see [title.widthAdjust](#title.widthAdjust)
	                 * @sample {highcharts} highcharts/title/widthadjust/ Wider menu, greater padding
	                 * @sample {highstock} highcharts/title/widthadjust/ Wider menu, greater padding
	                 * @sample {highmaps} highcharts/title/widthadjust/ Wider menu, greater padding
	                 * @default -44
	                 * @since 4.2.5
	                 * @product highcharts highstock highmaps
	                 */
	                widthAdjust: -44
	            },

	            /**
	             * The plotOptions is a wrapper object for config objects for each series
	             * type. The config objects for each series can also be overridden for
	             * each series item as given in the series array.
	             * 
	             * Configuration options for the series are given in three levels. Options
	             * for all series in a chart are given in the [plotOptions.series](#plotOptions.
	             * series) object. Then options for all series of a specific type are
	             * given in the plotOptions of that type, for example plotOptions.line.
	             * Next, options for one single series are given in [the series array](#series).
	             * 
	             * @product highcharts highstock highmaps
	             */
	            plotOptions: {},

	            /**
	             * HTML labels that can be positioned anywhere in the chart area.
	             * 
	             * @product highcharts highstock highmaps
	             */
	            labels: {
	                //items: [],

	                /**
	                 * Shared CSS styles for all labels.
	                 * 
	                 * @type {CSSObject}
	                 * @default { "color": "#333333" }
	                 * @product highcharts highstock highmaps
	                 */
	                style: {
	                    //font: defaultFont,

	                    /**
	                     */
	                    position: 'absolute',

	                    /**
	                     */
	                    color: '#333333'
	                }
	            },

	            /**
	             * The legend is a box containing a symbol and name for each series
	             * item or point item in the chart. Each series (or points in case
	             * of pie charts) is represented by a symbol and its name in the legend.
	             *  
	             * It is possible to override the symbol creator function and
	             * create [custom legend symbols](http://jsfiddle.net/gh/get/library/pure/highcharts/highcharts/tree/master/samples/highcharts/studies/legend-
	             * custom-symbol/).
	             * 
	             * @productdesc {highmaps}
	             * A Highmaps legend by default contains one legend item per series, but if
	             * a `colorAxis` is defined, the axis will be displayed in the legend.
	             * Either as a gradient, or as multiple legend items for `dataClasses`.
	             */
	            legend: {

	                /**
	                 * Enable or disable the legend.
	                 * 
	                 * @type {Boolean}
	                 * @sample {highcharts} highcharts/legend/enabled-false/ Legend disabled
	                 * @sample {highstock} stock/legend/align/ Various legend options
	                 * @sample {highmaps} maps/legend/enabled-false/ Legend disabled
	                 * @default {highstock} false
	                 * @default {highmaps} true
	                 * @product highcharts highstock highmaps
	                 */
	                enabled: true,

	                /**
	                 * The horizontal alignment of the legend box within the chart area.
	                 * Valid values are `left`, `center` and `right`.
	                 * 
	                 * In the case that the legend is aligned in a corner position, the
	                 * `layout` option will determine whether to place it above/below
	                 * or on the side of the plot area.
	                 * 
	                 * @validvalue ["left", "center", "right"]
	                 * @type {String}
	                 * @sample {highcharts} highcharts/legend/align/ Legend at the right of the chart
	                 * @sample {highstock} stock/legend/align/ Various legend options
	                 * @sample {highmaps} maps/legend/alignment/ Legend alignment
	                 * @default center
	                 * @since 2.0
	                 * @product highcharts highstock highmaps
	                 */
	                align: 'center',
	                //floating: false,

	                /**
	                 * The layout of the legend items. Can be one of "horizontal" or "vertical".
	                 * 
	                 * @validvalue ["horizontal", "vertical"]
	                 * @type {String}
	                 * @sample {highcharts} highcharts/legend/layout-horizontal/ Horizontal by default
	                 * @sample {highcharts} highcharts/legend/layout-vertical/ Vertical
	                 * @sample {highstock} stock/legend/layout-horizontal/ Horizontal by default
	                 * @sample {highmaps} maps/legend/padding-itemmargin/ Vertical with data classes
	                 * @sample {highmaps} maps/legend/layout-vertical/ Vertical with color axis gradient
	                 * @default horizontal
	                 * @product highcharts highstock highmaps
	                 */
	                layout: 'horizontal',

	                /**
	                 * Callback function to format each of the series' labels. The `this`
	                 * keyword refers to the series object, or the point object in case
	                 * of pie charts. By default the series or point name is printed.
	                 *
	                 * @productdesc {highmaps}
	                 *              In Highmaps the context can also be a data class in case
	                 *              of a `colorAxis`.
	                 * 
	                 * @type {Function}
	                 * @sample {highcharts} highcharts/legend/labelformatter/ Add text
	                 * @sample {highmaps} maps/legend/labelformatter/ Data classes with label formatter
	                 * @context {Series|Point}
	                 */
	                labelFormatter: function() {
	                    return this.name;
	                },
	                //borderWidth: 0,

	                /**
	                 * The color of the drawn border around the legend.
	                 * 
	                 * @type {Color}
	                 * @see In [styled mode](http://www.highcharts.com/docs/chart-design-and-
	                 * style/style-by-css), the legend border stroke can be applied with
	                 * the `.highcharts-legend-box` class.
	                 * @sample {highcharts} highcharts/legend/bordercolor/ Brown border
	                 * @sample {highstock} stock/legend/align/ Various legend options
	                 * @sample {highmaps} maps/legend/border-background/ Border and background options
	                 * @default #999999
	                 * @product highcharts highstock highmaps
	                 */
	                borderColor: '#999999',

	                /**
	                 * The border corner radius of the legend.
	                 * 
	                 * @type {Number}
	                 * @sample {highcharts} highcharts/legend/borderradius-default/ Square by default
	                 * @sample {highcharts} highcharts/legend/borderradius-round/ 5px rounded
	                 * @sample {highmaps} maps/legend/border-background/ Border and background options
	                 * @default 0
	                 * @product highcharts highstock highmaps
	                 */
	                borderRadius: 0,

	                /**
	                 * Options for the paging or navigation appearing when the legend
	                 * is overflown. Navigation works well on screen, but not in static
	                 * exported images. One way of working around that is to [increase
	                 * the chart height in export](http://jsfiddle.net/gh/get/library/pure/highcharts/highcharts/tree/master/samples/highcharts/legend/navigation-
	                 * enabled-false/).
	                 * 
	                 * @product highcharts highstock highmaps
	                 */
	                navigation: {


	                    /**
	                     * The color for the active up or down arrow in the legend page navigation.
	                     * 
	                     * @type {Color}
	                     * @see In [styled mode](http://www.highcharts.com/docs/chart-design-and-
	                     * style/style-by-css), the active arrow be styled with the `.highcharts-
	                     * legend-nav-active` class.
	                     * @sample {highcharts} highcharts/legend/navigation/ Legend page navigation demonstrated
	                     * @sample {highstock} highcharts/legend/navigation/ Legend page navigation demonstrated
	                     * @default #003399
	                     * @since 2.2.4
	                     * @product highcharts highstock highmaps
	                     */
	                    activeColor: '#003399',

	                    /**
	                     * The color of the inactive up or down arrow in the legend page
	                     * navigation. .
	                     * 
	                     * @type {Color}
	                     * @see In [styled mode](http://www.highcharts.com/docs/chart-design-and-
	                     * style/style-by-css), the inactive arrow be styled with the `.highcharts-
	                     * legend-nav-inactive` class.
	                     * @sample {highcharts} highcharts/legend/navigation/ Legend page navigation demonstrated
	                     * @sample {highstock} highcharts/legend/navigation/ Legend page navigation demonstrated
	                     * @default {highcharts} #cccccc
	                     * @default {highstock} #cccccc
	                     * @default {highmaps} ##cccccc
	                     * @since 2.2.4
	                     * @product highcharts highstock highmaps
	                     */
	                    inactiveColor: '#cccccc'

	                    // animation: true,
	                    // arrowSize: 12
	                    // style: {} // text styles
	                },
	                // margin: 20,
	                // reversed: false,
	                // backgroundColor: null,
	                /*style: {
	                    padding: '5px'
	                },*/


	                /**
	                 * CSS styles for each legend item. Only a subset of CSS is supported,
	                 * notably those options related to text. The default `textOverflow`
	                 * property makes long texts truncate. Set it to `null` to wrap text
	                 * instead. A `width` property can be added to control the text width.
	                 * 
	                 * @type {CSSObject}
	                 * @see In [styled mode](http://www.highcharts.com/docs/chart-design-and-
	                 * style/style-by-css), the legend items can be styled with the `.
	                 * highcharts-legend-item` class.
	                 * @sample {highcharts} highcharts/legend/itemstyle/ Bold black text
	                 * @sample {highmaps} maps/legend/itemstyle/ Item text styles
	                 * @default { "color": "#333333", "cursor": "pointer", "fontSize": "12px", "fontWeight": "bold", "textOverflow": "ellipsis" }
	                 * @product highcharts highstock highmaps
	                 */
	                itemStyle: {

	                    /**
	                     */
	                    color: '#333333',

	                    /**
	                     */
	                    fontSize: '12px',

	                    /**
	                     */
	                    fontWeight: 'bold',

	                    /**
	                     */
	                    textOverflow: 'ellipsis'
	                },

	                /**
	                 * CSS styles for each legend item in hover mode. Only a subset of
	                 * CSS is supported, notably those options related to text. Properties
	                 * are inherited from `style` unless overridden here.
	                 * 
	                 * @type {CSSObject}
	                 * @see In [styled mode](http://www.highcharts.com/docs/chart-design-and-
	                 * style/style-by-css), the hovered legend items can be styled with
	                 * the `.highcharts-legend-item:hover` pesudo-class.
	                 * @sample {highcharts} highcharts/legend/itemhoverstyle/ Red on hover
	                 * @sample {highmaps} maps/legend/itemstyle/ Item text styles
	                 * @default { "color": "#000000" }
	                 * @product highcharts highstock highmaps
	                 */
	                itemHoverStyle: {
	                    //cursor: 'pointer', removed as of #601

	                    /**
	                     */
	                    color: '#000000'
	                },

	                /**
	                 * CSS styles for each legend item when the corresponding series or
	                 * point is hidden. Only a subset of CSS is supported, notably those
	                 * options related to text. Properties are inherited from `style`
	                 * unless overridden here.
	                 * 
	                 * @type {CSSObject}
	                 * @see In [styled mode](http://www.highcharts.com/docs/chart-design-and-
	                 * style/style-by-css), the hidden legend items can be styled with
	                 * the `.highcharts-legend-item-hidden` class.
	                 * @sample {highcharts} highcharts/legend/itemhiddenstyle/ Darker gray color
	                 * @default { "color": "#cccccc" }
	                 * @product highcharts highstock highmaps
	                 */
	                itemHiddenStyle: {

	                    /**
	                     */
	                    color: '#cccccc'
	                },

	                /**
	                 * Whether to apply a drop shadow to the legend. A `backgroundColor`
	                 * also needs to be applied for this to take effect. The shadow can be
	                 * an object configuration containing `color`, `offsetX`, `offsetY`,
	                 * `opacity` and `width`.
	                 * 
	                 * @type {Boolean|Object}
	                 * @sample {highcharts} highcharts/legend/shadow/
	                 *         White background and drop shadow
	                 * @sample {highstock} stock/legend/align/
	                 *         Various legend options
	                 * @sample {highmaps} maps/legend/border-background/
	                 *         Border and background options
	                 * @default false
	                 * @product highcharts highstock highmaps
	                 */
	                shadow: false,


	                /**
	                 */
	                itemCheckboxStyle: {

	                    /**
	                     */
	                    position: 'absolute',

	                    /**
	                     */
	                    width: '13px', // for IE precision

	                    /**
	                     */
	                    height: '13px'
	                },
	                // itemWidth: undefined,

	                /**
	                 * When this is true, the legend symbol width will be the same as
	                 * the symbol height, which in turn defaults to the font size of the
	                 * legend items.
	                 * 
	                 * @type {Boolean}
	                 * @default true
	                 * @since 5.0.0
	                 * @product highcharts highstock highmaps
	                 */
	                squareSymbol: true,

	                /**
	                 * The pixel height of the symbol for series types that use a rectangle
	                 * in the legend. Defaults to the font size of legend items.
	                 *
	                 * @productdesc {highmaps}
	                 * In Highmaps, when the symbol is the gradient of a vertical color
	                 * axis, the height defaults to 200.
	                 * 
	                 * @type {Number}
	                 * @sample {highmaps} maps/legend/layout-vertical-sized/
	                 *         Sized vertical gradient
	                 * @sample {highmaps} maps/legend/padding-itemmargin/
	                 *         No distance between data classes
	                 * @since 3.0.8
	                 * @apioption legend.symbolHeight
	                 */

	                /**
	                 * The border radius of the symbol for series types that use a rectangle
	                 * in the legend. Defaults to half the `symbolHeight`.
	                 * 
	                 * @type {Number}
	                 * @sample {highcharts} highcharts/legend/symbolradius/ Round symbols
	                 * @sample {highstock} highcharts/legend/symbolradius/ Round symbols
	                 * @sample {highmaps} highcharts/legend/symbolradius/ Round symbols
	                 * @since 3.0.8
	                 * @apioption legend.symbolRadius
	                 */

	                /**
	                 * The pixel width of the legend item symbol. When the `squareSymbol`
	                 * option is set, this defaults to the `symbolHeight`, otherwise 16.
	                 * 
	                 * @productdesc {highmaps}
	                 * In Highmaps, when the symbol is the gradient of a horizontal color
	                 * axis, the width defaults to 200.
	                 * 
	                 * @type {Number}
	                 * @sample {highcharts} highcharts/legend/symbolwidth/
	                 *         Greater symbol width and padding
	                 * @sample {highmaps} maps/legend/padding-itemmargin/
	                 *         Padding and item margins demonstrated
	                 * @sample {highmaps} maps/legend/layout-vertical-sized/
	                 *         Sized vertical gradient
	                 * @apioption legend.symbolWidth
	                 */

	                /**
	                 * Whether to [use HTML](http://www.highcharts.com/docs/chart-concepts/labels-
	                 * and-string-formatting#html) to render the legend item texts. Prior
	                 * to 4.1.7, when using HTML, [legend.navigation](#legend.navigation)
	                 * was disabled.
	                 * 
	                 * @type {Boolean}
	                 * @default false
	                 * @apioption legend.useHTML
	                 */

	                /**
	                 * The width of the legend box.
	                 * 
	                 * @type {Number}
	                 * @sample {highcharts} highcharts/legend/width/ Aligned to the plot area
	                 * @default null
	                 * @since 2.0
	                 * @apioption legend.width
	                 */

	                /**
	                 * The pixel padding between the legend item symbol and the legend
	                 * item text.
	                 * 
	                 * @type {Number}
	                 * @sample {highcharts} highcharts/legend/symbolpadding/ Greater symbol width and padding
	                 * @default 5
	                 * @product highcharts highstock highmaps
	                 */
	                symbolPadding: 5,

	                /**
	                 * The vertical alignment of the legend box. Can be one of `top`,
	                 * `middle` or `bottom`. Vertical position can be further determined
	                 * by the `y` option.
	                 * 
	                 * In the case that the legend is aligned in a corner position, the
	                 * `layout` option will determine whether to place it above/below
	                 * or on the side of the plot area.
	                 * 
	                 * @validvalue ["top", "middle", "bottom"]
	                 * @type {String}
	                 * @sample {highcharts} highcharts/legend/verticalalign/ Legend 100px from the top of the chart
	                 * @sample {highstock} stock/legend/align/ Various legend options
	                 * @sample {highmaps} maps/legend/alignment/ Legend alignment
	                 * @default bottom
	                 * @since 2.0
	                 * @product highcharts highstock highmaps
	                 */
	                verticalAlign: 'bottom',
	                // width: undefined,

	                /**
	                 * The x offset of the legend relative to its horizontal alignment
	                 * `align` within chart.spacingLeft and chart.spacingRight. Negative
	                 * x moves it to the left, positive x moves it to the right.
	                 * 
	                 * @type {Number}
	                 * @sample {highcharts} highcharts/legend/width/ Aligned to the plot area
	                 * @default 0
	                 * @since 2.0
	                 * @product highcharts highstock highmaps
	                 */
	                x: 0,

	                /**
	                 * The vertical offset of the legend relative to it's vertical alignment
	                 * `verticalAlign` within chart.spacingTop and chart.spacingBottom.
	                 *  Negative y moves it up, positive y moves it down.
	                 * 
	                 * @type {Number}
	                 * @sample {highcharts} highcharts/legend/verticalalign/ Legend 100px from the top of the chart
	                 * @sample {highstock} stock/legend/align/ Various legend options
	                 * @sample {highmaps} maps/legend/alignment/ Legend alignment
	                 * @default 0
	                 * @since 2.0
	                 * @product highcharts highstock highmaps
	                 */
	                y: 0,

	                /**
	                 * A title to be added on top of the legend.
	                 * 
	                 * @sample {highcharts} highcharts/legend/title/ Legend title
	                 * @sample {highmaps} maps/legend/alignment/ Legend with title
	                 * @since 3.0
	                 * @product highcharts highstock highmaps
	                 */
	                title: {
	                    //text: null,


	                    /**
	                     * Generic CSS styles for the legend title.
	                     * 
	                     * @type {CSSObject}
	                     * @see In [styled mode](http://www.highcharts.com/docs/chart-design-and-
	                     * style/style-by-css), the legend title is styled with the `.highcharts-
	                     * legend-title` class.
	                     * @default {"fontWeight":"bold"}
	                     * @since 3.0
	                     * @product highcharts highstock highmaps
	                     */
	                    style: {

	                        /**
	                         */
	                        fontWeight: 'bold'
	                    }

	                }
	            },


	            /**
	             * The loading options control the appearance of the loading screen
	             * that covers the plot area on chart operations. This screen only
	             * appears after an explicit call to `chart.showLoading()`. It is a
	             * utility for developers to communicate to the end user that something
	             * is going on, for example while retrieving new data via an XHR connection.
	             * The "Loading..." text itself is not part of this configuration
	             * object, but part of the `lang` object.
	             * 
	             * @product highcharts highstock highmaps
	             */
	            loading: {

	                /**
	                 * The duration in milliseconds of the fade out effect.
	                 * 
	                 * @type {Number}
	                 * @sample highcharts/loading/hideduration/ Fade in and out over a second
	                 * @default 100
	                 * @since 1.2.0
	                 * @apioption loading.hideDuration
	                 */

	                /**
	                 * The duration in milliseconds of the fade in effect.
	                 * 
	                 * @type {Number}
	                 * @sample highcharts/loading/hideduration/ Fade in and out over a second
	                 * @default 100
	                 * @since 1.2.0
	                 * @apioption loading.showDuration
	                 */


	                /**
	                 * CSS styles for the loading label `span`.
	                 * 
	                 * @type {CSSObject}
	                 * @see In [styled mode](http://www.highcharts.com/docs/chart-design-and-
	                 * style/style-by-css), the loading label is styled with the
	                 * `.highcharts-legend-loading-inner` class.
	                 * @sample {highcharts|highmaps} highcharts/loading/labelstyle/ Vertically centered
	                 * @sample {highstock} stock/loading/general/ Label styles
	                 * @default { "fontWeight": "bold", "position": "relative", "top": "45%" }
	                 * @since 1.2.0
	                 * @product highcharts highstock highmaps
	                 */
	                labelStyle: {
	                    fontWeight: 'bold',
	                    position: 'relative',
	                    top: '45%'
	                },

	                /**
	                 * CSS styles for the loading screen that covers the plot area.
	                 * 
	                 * @type {CSSObject}
	                 * @see In [styled mode](http://www.highcharts.com/docs/chart-design-and-
	                 * style/style-by-css), the loading label is styled with the `.highcharts-
	                 * legend-loading` class.
	                 * @sample {highcharts|highmaps} highcharts/loading/style/ Gray plot area, white text
	                 * @sample {highstock} stock/loading/general/ Gray plot area, white text
	                 * @default { "position": "absolute", "backgroundColor": "#ffffff", "opacity": 0.5, "textAlign": "center" }
	                 * @since 1.2.0
	                 */
	                style: {
	                    position: 'absolute',
	                    backgroundColor: '#ffffff',
	                    opacity: 0.5,
	                    textAlign: 'center'
	                }

	            },


	            /**
	             * Options for the tooltip that appears when the user hovers over a
	             * series or point.
	             * 
	             * @product highcharts highstock highmaps
	             */
	            tooltip: {

	                /**
	                 * Enable or disable the tooltip.
	                 * 
	                 * @type {Boolean}
	                 * @sample {highcharts} highcharts/tooltip/enabled/ Disabled
	                 * @sample {highcharts} highcharts/plotoptions/series-point-events-mouseover/ Disable tooltip and show values on chart instead
	                 * @default true
	                 * @product highcharts highstock highmaps
	                 */
	                enabled: true,

	                /**
	                 * Enable or disable animation of the tooltip. In slow legacy IE browsers
	                 * the animation is disabled by default.
	                 * 
	                 * @type {Boolean}
	                 * @default true
	                 * @since 2.3.0
	                 * @product highcharts highstock highmaps
	                 */
	                animation: svg,
	                //crosshairs: null,

	                /**
	                 * The radius of the rounded border corners.
	                 * 
	                 * @type {Number}
	                 * @sample {highcharts} highcharts/tooltip/bordercolor-default/ 5px by default
	                 * @sample {highcharts} highcharts/tooltip/borderradius-0/ Square borders
	                 * @sample {highmaps} maps/tooltip/background-border/ Background and border demo
	                 * @default 3
	                 * @product highcharts highstock highmaps
	                 */
	                borderRadius: 3,

	                /**
	                 * For series on a datetime axes, the date format in the tooltip's
	                 * header will by default be guessed based on the closest data points.
	                 * This member gives the default string representations used for
	                 * each unit. For an overview of the replacement codes, see [dateFormat](#Highcharts.
	                 * dateFormat).
	                 * 
	                 * Defaults to:
	                 * 
	                 * <pre>{
	                 * millisecond:"%A, %b %e, %H:%M:%S.%L",
	                 * second:"%A, %b %e, %H:%M:%S",
	                 * minute:"%A, %b %e, %H:%M",
	                 * hour:"%A, %b %e, %H:%M",
	                 * day:"%A, %b %e, %Y",
	                 * week:"Week from %A, %b %e, %Y",
	                 * month:"%B %Y",
	                 * year:"%Y"
	                 * }</pre>
	                 * 
	                 * @type {Object}
	                 * @see [xAxis.dateTimeLabelFormats](#xAxis.dateTimeLabelFormats)
	                 * @product highcharts highstock
	                 */
	                dateTimeLabelFormats: {

	                    /**
	                     */
	                    millisecond: '%A, %b %e, %H:%M:%S.%L',

	                    /**
	                     */
	                    second: '%A, %b %e, %H:%M:%S',

	                    /**
	                     */
	                    minute: '%A, %b %e, %H:%M',

	                    /**
	                     */
	                    hour: '%A, %b %e, %H:%M',

	                    /**
	                     */
	                    day: '%A, %b %e, %Y',

	                    /**
	                     */
	                    week: 'Week from %A, %b %e, %Y',

	                    /**
	                     */
	                    month: '%B %Y',

	                    /**
	                     */
	                    year: '%Y'
	                },

	                /**
	                 * A string to append to the tooltip format.
	                 * 
	                 * @type {String}
	                 * @sample {highcharts} highcharts/tooltip/footerformat/ A table for value alignment
	                 * @sample {highmaps} maps/tooltip/format/ Format demo
	                 * @default false
	                 * @since 2.2
	                 * @product highcharts highmaps
	                 */
	                footerFormat: '',
	                //formatter: defaultFormatter,
	                /* todo: em font-size when finished comparing against HC4
	                headerFormat: '<span style="font-size: 0.85em">{point.key}</span><br/>',
	                */

	                /**
	                 * Padding inside the tooltip, in pixels.
	                 * 
	                 * @type {Number}
	                 * @default 8
	                 * @since 5.0.0
	                 * @product highcharts highstock highmaps
	                 */
	                padding: 8,

	                //shape: 'callout',
	                //shared: false,

	                /**
	                 * Proximity snap for graphs or single points. It defaults to 10 for
	                 * mouse-powered devices and 25 for touch devices.
	                 * 
	                 * Note that in most cases the whole plot area captures the mouse
	                 * movement, and in these cases `tooltip.snap` doesn't make sense.
	                 * This applies when [stickyTracking](#plotOptions.series.stickyTracking)
	                 * is `true` (default) and when the tooltip is [shared](#tooltip.shared)
	                 * or [split](#tooltip.split).
	                 * 
	                 * @type {Number}
	                 * @sample {highcharts} highcharts/tooltip/bordercolor-default/ 10 px by default
	                 * @sample {highcharts} highcharts/tooltip/snap-50/ 50 px on graph
	                 * @default 10/25
	                 * @since 1.2.0
	                 * @product highcharts highstock
	                 */
	                snap: isTouchDevice ? 25 : 10,


	                /**
	                 * The background color or gradient for the tooltip.
	                 * 
	                 * In [styled mode](http://www.highcharts.com/docs/chart-design-and-
	                 * style/style-by-css), the stroke width is set in the `.highcharts-
	                 * tooltip-box` class.
	                 * 
	                 * @type {Color}
	                 * @sample {highcharts} highcharts/tooltip/backgroundcolor-solid/ Yellowish background
	                 * @sample {highcharts} highcharts/tooltip/backgroundcolor-gradient/ Gradient
	                 * @sample {highcharts} highcharts/css/tooltip-border-background/ Tooltip in styled mode
	                 * @sample {highstock} stock/tooltip/general/ Custom tooltip
	                 * @sample {highstock} highcharts/css/tooltip-border-background/ Tooltip in styled mode
	                 * @sample {highmaps} maps/tooltip/background-border/ Background and border demo
	                 * @sample {highmaps} highcharts/css/tooltip-border-background/ Tooltip in styled mode
	                 * @default rgba(247,247,247,0.85)
	                 * @product highcharts highstock highmaps
	                 */
	                backgroundColor: color('#f7f7f7').setOpacity(0.85).get(),

	                /**
	                 * The pixel width of the tooltip border.
	                 * 
	                 * In [styled mode](http://www.highcharts.com/docs/chart-design-and-
	                 * style/style-by-css), the stroke width is set in the `.highcharts-
	                 * tooltip-box` class.
	                 * 
	                 * @type {Number}
	                 * @sample {highcharts} highcharts/tooltip/bordercolor-default/ 2px by default
	                 * @sample {highcharts} highcharts/tooltip/borderwidth/ No border (shadow only)
	                 * @sample {highcharts} highcharts/css/tooltip-border-background/ Tooltip in styled mode
	                 * @sample {highstock} stock/tooltip/general/ Custom tooltip
	                 * @sample {highstock} highcharts/css/tooltip-border-background/ Tooltip in styled mode
	                 * @sample {highmaps} maps/tooltip/background-border/ Background and border demo
	                 * @sample {highmaps} highcharts/css/tooltip-border-background/ Tooltip in styled mode
	                 * @default 1
	                 * @product highcharts highstock highmaps
	                 */
	                borderWidth: 1,

	                /**
	                 * The HTML of the tooltip header line. Variables are enclosed by
	                 * curly brackets. Available variables are `point.key`, `series.name`,
	                 * `series.color` and other members from the `point` and `series`
	                 * objects. The `point.key` variable contains the category name, x
	                 * value or datetime string depending on the type of axis. For datetime
	                 * axes, the `point.key` date format can be set using tooltip.xDateFormat.
	                 * 
	                 * 
	                 * Defaults to `<span style="font-size: 10px">{point.key}</span><br/>`
	                 * 
	                 * @type {String}
	                 * @sample {highcharts} highcharts/tooltip/footerformat/ A HTML table in the tooltip
	                 * @sample {highstock} highcharts/tooltip/footerformat/ A HTML table in the tooltip
	                 * @sample {highmaps} maps/tooltip/format/ Format demo
	                 * @product highcharts highstock highmaps
	                 */
	                headerFormat: '<span style="font-size: 10px">{point.key}</span><br/>',

	                /**
	                 * The HTML of the point's line in the tooltip. Variables are enclosed
	                 * by curly brackets. Available variables are point.x, point.y, series.
	                 * name and series.color and other properties on the same form. Furthermore,
	                 * point.y can be extended by the `tooltip.valuePrefix` and `tooltip.
	                 * valueSuffix` variables. This can also be overridden for each series,
	                 * which makes it a good hook for displaying units.
	                 * 
	                 * In [styled mode](http://www.highcharts.com/docs/chart-design-and-
	                 * style/style-by-css), the dot is colored by a class name rather
	                 * than the point color.
	                 * 
	                 * @type {String}
	                 * @sample {highcharts} highcharts/tooltip/pointformat/ A different point format with value suffix
	                 * @sample {highmaps} maps/tooltip/format/ Format demo
	                 * @default <span style="color:{point.color}">\u25CF</span> {series.name}: <b>{point.y}</b><br/>
	                 * @since 2.2
	                 * @product highcharts highstock highmaps
	                 */
	                pointFormat: '<span style="color:{point.color}">\u25CF</span> {series.name}: <b>{point.y}</b><br/>',

	                /**
	                 * Whether to apply a drop shadow to the tooltip.
	                 * 
	                 * @type {Boolean}
	                 * @sample {highcharts} highcharts/tooltip/bordercolor-default/ True by default
	                 * @sample {highcharts} highcharts/tooltip/shadow/ False
	                 * @sample {highmaps} maps/tooltip/positioner/ Fixed tooltip position, border and shadow disabled
	                 * @default true
	                 * @product highcharts highstock highmaps
	                 */
	                shadow: true,

	                /**
	                 * CSS styles for the tooltip. The tooltip can also be styled through
	                 * the CSS class `.highcharts-tooltip`.
	                 * 
	                 * @type {CSSObject}
	                 * @sample {highcharts} highcharts/tooltip/style/ Greater padding, bold text
	                 * @default { "color": "#333333", "cursor": "default", "fontSize": "12px", "pointerEvents": "none", "whiteSpace": "nowrap" }
	                 * @product highcharts highstock highmaps
	                 */
	                style: {

	                    /**
	                     */
	                    color: '#333333',

	                    /**
	                     */
	                    cursor: 'default',

	                    /**
	                     */
	                    fontSize: '12px',

	                    /**
	                     */
	                    pointerEvents: 'none', // #1686 http://caniuse.com/#feat=pointer-events

	                    /**
	                     */
	                    whiteSpace: 'nowrap'
	                }

	                //xDateFormat: '%A, %b %e, %Y',
	                //valueDecimals: null,
	                //valuePrefix: '',
	                //valueSuffix: ''
	            },


	            /**
	             * Highchart by default puts a credits label in the lower right corner
	             * of the chart. This can be changed using these options.
	             * 
	             * @product highcharts highstock highmaps
	             */
	            credits: {

	                /**
	                 * Whether to show the credits text.
	                 * 
	                 * @type {Boolean}
	                 * @sample {highcharts} highcharts/credits/enabled-false/ Credits disabled
	                 * @sample {highstock} stock/credits/enabled/ Credits disabled
	                 * @sample {highmaps} maps/credits/enabled-false/ Credits disabled
	                 * @default true
	                 * @product highcharts highstock highmaps
	                 */
	                enabled: true,

	                /**
	                 * The URL for the credits label.
	                 * 
	                 * @type {String}
	                 * @sample {highcharts} highcharts/credits/href/ Custom URL and text
	                 * @sample {highmaps} maps/credits/customized/ Custom URL and text
	                 * @default {highcharts} http://www.highcharts.com
	                 * @default {highstock} "http://www.highcharts.com"
	                 * @default {highmaps} http://www.highcharts.com
	                 * @product highcharts highstock highmaps
	                 */
	                href: 'http://www.highcharts.com',

	                /**
	                 * Position configuration for the credits label.
	                 * 
	                 * @type {Object}
	                 * @sample {highcharts} highcharts/credits/position-left/ Left aligned
	                 * @sample {highcharts} highcharts/credits/position-left/ Left aligned
	                 * @sample {highmaps} maps/credits/customized/ Left aligned
	                 * @sample {highmaps} maps/credits/customized/ Left aligned
	                 * @since 2.1
	                 * @product highcharts highstock highmaps
	                 */
	                position: {

	                    /**
	                     * Horizontal alignment of the credits.
	                     * 
	                     * @validvalue ["left", "center", "right"]
	                     * @type {String}
	                     * @default right
	                     * @product highcharts highstock highmaps
	                     */
	                    align: 'right',

	                    /**
	                     * Horizontal pixel offset of the credits.
	                     * 
	                     * @type {Number}
	                     * @default -10
	                     * @product highcharts highstock highmaps
	                     */
	                    x: -10,

	                    /**
	                     * Vertical alignment of the credits.
	                     * 
	                     * @validvalue ["top", "middle", "bottom"]
	                     * @type {String}
	                     * @default bottom
	                     * @product highcharts highstock highmaps
	                     */
	                    verticalAlign: 'bottom',

	                    /**
	                     * Vertical pixel offset of the credits.
	                     * 
	                     * @type {Number}
	                     * @default -5
	                     * @product highcharts highstock highmaps
	                     */
	                    y: -5
	                },


	                /**
	                 * CSS styles for the credits label.
	                 * 
	                 * @type {CSSObject}
	                 * @see In [styled mode](http://www.highcharts.com/docs/chart-design-and-
	                 * style/style-by-css), credits styles can be set with the `.highcharts-
	                 * credits` class.
	                 * @default { "cursor": "pointer", "color": "#999999", "fontSize": "10px" }
	                 * @product highcharts highstock highmaps
	                 */
	                style: {

	                    /**
	                     */
	                    cursor: 'pointer',

	                    /**
	                     */
	                    color: '#999999',

	                    /**
	                     */
	                    fontSize: '9px'
	                },


	                /**
	                 * The text for the credits label.
	                 *
	                 * @productdesc {highmaps}
	                 * If a map is loaded as GeoJSON, the text defaults to `Highcharts @
	                 * {map-credits}`. Otherwise, it defaults to `Highcharts.com`.
	                 * 
	                 * @type {String}
	                 * @sample {highcharts} highcharts/credits/href/ Custom URL and text
	                 * @sample {highmaps} maps/credits/customized/ Custom URL and text
	                 * @default {highcharts|highstock} Highcharts.com
	                 */
	                text: 'Highcharts.com'
	            }
	        };



	        /**
	         * Sets the getTimezoneOffset function. If the timezone option is set, a default
	         * getTimezoneOffset function with that timezone is returned. If not, the
	         * specified getTimezoneOffset function is returned. If neither are specified,
	         * undefined is returned.
	         * @return {function} a getTimezoneOffset function or undefined
	         */
	        function getTimezoneOffsetOption() {
	            var globalOptions = H.defaultOptions.global,
	                moment = win.moment;

	            if (globalOptions.timezone) {
	                if (!moment) {
	                    // getTimezoneOffset-function stays undefined because it depends on
	                    // Moment.js
	                    H.error(25);

	                } else {
	                    return function(timestamp) {
	                        return -moment.tz(
	                            timestamp,
	                            globalOptions.timezone
	                        ).utcOffset();
	                    };
	                }
	            }

	            // If not timezone is set, look for the getTimezoneOffset callback
	            return globalOptions.useUTC && globalOptions.getTimezoneOffset;
	        }

	        /**
	         * Set the time methods globally based on the useUTC option. Time method can be
	         *   either local time or UTC (default). It is called internally on initiating
	         *   Highcharts and after running `Highcharts.setOptions`.
	         *
	         * @private
	         */
	        function setTimeMethods() {
	            var globalOptions = H.defaultOptions.global,
	                Date,
	                useUTC = globalOptions.useUTC,
	                GET = useUTC ? 'getUTC' : 'get',
	                SET = useUTC ? 'setUTC' : 'set';

	            H.Date = Date = globalOptions.Date || win.Date; // Allow using a different Date class
	            Date.hcTimezoneOffset = useUTC && globalOptions.timezoneOffset;
	            Date.hcGetTimezoneOffset = getTimezoneOffsetOption();
	            Date.hcMakeTime = function(year, month, date, hours, minutes, seconds) {
	                var d;
	                if (useUTC) {
	                    d = Date.UTC.apply(0, arguments);
	                    d += getTZOffset(d);
	                } else {
	                    d = new Date(
	                        year,
	                        month,
	                        pick(date, 1),
	                        pick(hours, 0),
	                        pick(minutes, 0),
	                        pick(seconds, 0)
	                    ).getTime();
	                }
	                return d;
	            };
	            each(['Minutes', 'Hours', 'Day', 'Date', 'Month', 'FullYear'], function(s) {
	                Date['hcGet' + s] = GET + s;
	            });
	            each(['Milliseconds', 'Seconds', 'Minutes', 'Hours', 'Date', 'Month', 'FullYear'], function(s) {
	                Date['hcSet' + s] = SET + s;
	            });
	        }

	        /**
	         * Merge the default options with custom options and return the new options
	         * structure. Commonly used for defining reusable templates.
	         *
	         * @function #setOptions
	         * @memberOf  Highcharts
	         * @sample highcharts/global/useutc-false Setting a global option
	         * @sample highcharts/members/setoptions Applying a global theme
	         * @param {Object} options The new custom chart options.
	         * @returns {Object} Updated options.
	         */
	        H.setOptions = function(options) {

	            // Copy in the default options
	            H.defaultOptions = merge(true, H.defaultOptions, options);

	            // Apply UTC
	            setTimeMethods();

	            return H.defaultOptions;
	        };

	        /**
	         * Get the updated default options. Until 3.0.7, merely exposing defaultOptions for outside modules
	         * wasn't enough because the setOptions method created a new object.
	         */
	        H.getOptions = function() {
	            return H.defaultOptions;
	        };


	        // Series defaults
	        H.defaultPlotOptions = H.defaultOptions.plotOptions;

	        // set the default time methods
	        setTimeMethods();

	    }(Highcharts));
	    (function(H) {
	        /**
	         * (c) 2010-2017 Torstein Honsi
	         *
	         * License: www.highcharts.com/license
	         */
	        var correctFloat = H.correctFloat,
	            defined = H.defined,
	            destroyObjectProperties = H.destroyObjectProperties,
	            isNumber = H.isNumber,
	            merge = H.merge,
	            pick = H.pick,
	            deg2rad = H.deg2rad;

	        /**
	         * The Tick class
	         */
	        H.Tick = function(axis, pos, type, noLabel) {
	            this.axis = axis;
	            this.pos = pos;
	            this.type = type || '';
	            this.isNew = true;
	            this.isNewLabel = true;

	            if (!type && !noLabel) {
	                this.addLabel();
	            }
	        };

	        H.Tick.prototype = {
	            /**
	             * Write the tick label
	             */
	            addLabel: function() {
	                var tick = this,
	                    axis = tick.axis,
	                    options = axis.options,
	                    chart = axis.chart,
	                    categories = axis.categories,
	                    names = axis.names,
	                    pos = tick.pos,
	                    labelOptions = options.labels,
	                    str,
	                    tickPositions = axis.tickPositions,
	                    isFirst = pos === tickPositions[0],
	                    isLast = pos === tickPositions[tickPositions.length - 1],
	                    value = categories ?
	                    pick(categories[pos], names[pos], pos) :
	                    pos,
	                    label = tick.label,
	                    tickPositionInfo = tickPositions.info,
	                    dateTimeLabelFormat;

	                // Set the datetime label format. If a higher rank is set for this position, use that. If not,
	                // use the general format.
	                if (axis.isDatetimeAxis && tickPositionInfo) {
	                    dateTimeLabelFormat =
	                        options.dateTimeLabelFormats[
	                            tickPositionInfo.higherRanks[pos] || tickPositionInfo.unitName
	                        ];
	                }
	                // set properties for access in render method
	                tick.isFirst = isFirst;
	                tick.isLast = isLast;

	                // get the string
	                str = axis.labelFormatter.call({
	                    axis: axis,
	                    chart: chart,
	                    isFirst: isFirst,
	                    isLast: isLast,
	                    dateTimeLabelFormat: dateTimeLabelFormat,
	                    value: axis.isLog ? correctFloat(axis.lin2log(value)) : value,
	                    pos: pos
	                });

	                // prepare CSS
	                //css = width && { width: Math.max(1, Math.round(width - 2 * (labelOptions.padding || 10))) + 'px' };

	                // first call
	                if (!defined(label)) {

	                    tick.label = label =
	                        defined(str) && labelOptions.enabled ?
	                        chart.renderer.text(
	                            str,
	                            0,
	                            0,
	                            labelOptions.useHTML
	                        )

	                        // without position absolute, IE export sometimes is wrong
	                        .css(merge(labelOptions.style))

	                        .add(axis.labelGroup) :
	                        null;
	                    tick.labelLength = label && label.getBBox().width; // Un-rotated length
	                    tick.rotation = 0; // Base value to detect change for new calls to getBBox

	                    // update
	                } else if (label) {
	                    label.attr({
	                        text: str
	                    });
	                }
	            },

	            /**
	             * Get the offset height or width of the label
	             */
	            getLabelSize: function() {
	                return this.label ?
	                    this.label.getBBox()[this.axis.horiz ? 'height' : 'width'] :
	                    0;
	            },

	            /**
	             * Handle the label overflow by adjusting the labels to the left and right edge, or
	             * hide them if they collide into the neighbour label.
	             */
	            handleOverflow: function(xy) {
	                var axis = this.axis,
	                    pxPos = xy.x,
	                    chartWidth = axis.chart.chartWidth,
	                    spacing = axis.chart.spacing,
	                    leftBound = pick(axis.labelLeft, Math.min(axis.pos, spacing[3])),
	                    rightBound = pick(axis.labelRight, Math.max(axis.pos + axis.len, chartWidth - spacing[1])),
	                    label = this.label,
	                    rotation = this.rotation,
	                    factor = {
	                        left: 0,
	                        center: 0.5,
	                        right: 1
	                    }[axis.labelAlign],
	                    labelWidth = label.getBBox().width,
	                    slotWidth = axis.getSlotWidth(),
	                    modifiedSlotWidth = slotWidth,
	                    xCorrection = factor,
	                    goRight = 1,
	                    leftPos,
	                    rightPos,
	                    textWidth,
	                    css = {};

	                // Check if the label overshoots the chart spacing box. If it does, move it.
	                // If it now overshoots the slotWidth, add ellipsis.
	                if (!rotation) {
	                    leftPos = pxPos - factor * labelWidth;
	                    rightPos = pxPos + (1 - factor) * labelWidth;

	                    if (leftPos < leftBound) {
	                        modifiedSlotWidth = xy.x + modifiedSlotWidth * (1 - factor) - leftBound;
	                    } else if (rightPos > rightBound) {
	                        modifiedSlotWidth = rightBound - xy.x + modifiedSlotWidth * factor;
	                        goRight = -1;
	                    }

	                    modifiedSlotWidth = Math.min(slotWidth, modifiedSlotWidth); // #4177
	                    if (modifiedSlotWidth < slotWidth && axis.labelAlign === 'center') {
	                        xy.x += goRight * (slotWidth - modifiedSlotWidth - xCorrection *
	                            (slotWidth - Math.min(labelWidth, modifiedSlotWidth)));
	                    }
	                    // If the label width exceeds the available space, set a text width to be
	                    // picked up below. Also, if a width has been set before, we need to set a new
	                    // one because the reported labelWidth will be limited by the box (#3938).
	                    if (labelWidth > modifiedSlotWidth || (axis.autoRotation && (label.styles || {}).width)) {
	                        textWidth = modifiedSlotWidth;
	                    }

	                    // Add ellipsis to prevent rotated labels to be clipped against the edge of the chart
	                } else if (rotation < 0 && pxPos - factor * labelWidth < leftBound) {
	                    textWidth = Math.round(pxPos / Math.cos(rotation * deg2rad) - leftBound);
	                } else if (rotation > 0 && pxPos + factor * labelWidth > rightBound) {
	                    textWidth = Math.round((chartWidth - pxPos) / Math.cos(rotation * deg2rad));
	                }

	                if (textWidth) {
	                    css.width = textWidth;
	                    if (!(axis.options.labels.style || {}).textOverflow) {
	                        css.textOverflow = 'ellipsis';
	                    }
	                    label.css(css);
	                }
	            },

	            /**
	             * Get the x and y position for ticks and labels
	             */
	            getPosition: function(horiz, pos, tickmarkOffset, old) {
	                var axis = this.axis,
	                    chart = axis.chart,
	                    cHeight = (old && chart.oldChartHeight) || chart.chartHeight;

	                return {
	                    x: horiz ?
	                        axis.translate(pos + tickmarkOffset, null, null, old) + axis.transB : axis.left + axis.offset +
	                        (axis.opposite ?
	                            ((old && chart.oldChartWidth) || chart.chartWidth) - axis.right - axis.left :
	                            0
	                        ),

	                    y: horiz ?
	                        cHeight - axis.bottom + axis.offset - (axis.opposite ? axis.height : 0) : cHeight - axis.translate(pos + tickmarkOffset, null, null, old) - axis.transB
	                };

	            },

	            /**
	             * Get the x, y position of the tick label
	             */
	            getLabelPosition: function(x, y, label, horiz, labelOptions, tickmarkOffset, index, step) {
	                var axis = this.axis,
	                    transA = axis.transA,
	                    reversed = axis.reversed,
	                    staggerLines = axis.staggerLines,
	                    rotCorr = axis.tickRotCorr || {
	                        x: 0,
	                        y: 0
	                    },
	                    yOffset = labelOptions.y,
	                    line;

	                if (!defined(yOffset)) {
	                    if (axis.side === 0) {
	                        yOffset = label.rotation ? -8 : -label.getBBox().height;
	                    } else if (axis.side === 2) {
	                        yOffset = rotCorr.y + 8;
	                    } else {
	                        // #3140, #3140
	                        yOffset = Math.cos(label.rotation * deg2rad) * (rotCorr.y - label.getBBox(false, 0).height / 2);
	                    }
	                }

	                x = x + labelOptions.x + rotCorr.x - (tickmarkOffset && horiz ?
	                    tickmarkOffset * transA * (reversed ? -1 : 1) : 0);
	                y = y + yOffset - (tickmarkOffset && !horiz ?
	                    tickmarkOffset * transA * (reversed ? 1 : -1) : 0);

	                // Correct for staggered labels
	                if (staggerLines) {
	                    line = (index / (step || 1) % staggerLines);
	                    if (axis.opposite) {
	                        line = staggerLines - line - 1;
	                    }
	                    y += line * (axis.labelOffset / staggerLines);
	                }

	                return {
	                    x: x,
	                    y: Math.round(y)
	                };
	            },

	            /**
	             * Extendible method to return the path of the marker
	             */
	            getMarkPath: function(x, y, tickLength, tickWidth, horiz, renderer) {
	                return renderer.crispLine([
	                    'M',
	                    x,
	                    y,
	                    'L',
	                    x + (horiz ? 0 : -tickLength),
	                    y + (horiz ? tickLength : 0)
	                ], tickWidth);
	            },

	            /**
	             * Renders the gridLine.
	             * @param  {Boolean} old         Whether or not the tick is old
	             * @param  {number} opacity      The opacity of the grid line
	             * @param  {number} reverseCrisp Modifier for avoiding overlapping 1 or -1
	             * @return {undefined}
	             */
	            renderGridLine: function(old, opacity, reverseCrisp) {
	                var tick = this,
	                    axis = tick.axis,
	                    options = axis.options,
	                    gridLine = tick.gridLine,
	                    gridLinePath,
	                    attribs = {},
	                    pos = tick.pos,
	                    type = tick.type,
	                    tickmarkOffset = axis.tickmarkOffset,
	                    renderer = axis.chart.renderer;


	                var gridPrefix = type ? type + 'Grid' : 'grid',
	                    gridLineWidth = options[gridPrefix + 'LineWidth'],
	                    gridLineColor = options[gridPrefix + 'LineColor'],
	                    dashStyle = options[gridPrefix + 'LineDashStyle'];


	                if (!gridLine) {

	                    attribs.stroke = gridLineColor;
	                    attribs['stroke-width'] = gridLineWidth;
	                    if (dashStyle) {
	                        attribs.dashstyle = dashStyle;
	                    }

	                    if (!type) {
	                        attribs.zIndex = 1;
	                    }
	                    if (old) {
	                        attribs.opacity = 0;
	                    }
	                    tick.gridLine = gridLine = renderer.path()
	                        .attr(attribs)
	                        .addClass(
	                            'highcharts-' + (type ? type + '-' : '') + 'grid-line'
	                        )
	                        .add(axis.gridGroup);
	                }

	                // If the parameter 'old' is set, the current call will be followed
	                // by another call, therefore do not do any animations this time
	                if (!old && gridLine) {
	                    gridLinePath = axis.getPlotLinePath(
	                        pos + tickmarkOffset,
	                        gridLine.strokeWidth() * reverseCrisp,
	                        old, true
	                    );
	                    if (gridLinePath) {
	                        gridLine[tick.isNew ? 'attr' : 'animate']({
	                            d: gridLinePath,
	                            opacity: opacity
	                        });
	                    }
	                }
	            },

	            /**
	             * Renders the tick mark.
	             * @param  {Object} xy           The position vector of the mark
	             * @param  {number} xy.x         The x position of the mark
	             * @param  {number} xy.y         The y position of the mark
	             * @param  {number} opacity      The opacity of the mark
	             * @param  {number} reverseCrisp Modifier for avoiding overlapping 1 or -1
	             * @return {undefined}
	             */
	            renderMark: function(xy, opacity, reverseCrisp) {
	                var tick = this,
	                    axis = tick.axis,
	                    options = axis.options,
	                    renderer = axis.chart.renderer,
	                    type = tick.type,
	                    tickPrefix = type ? type + 'Tick' : 'tick',
	                    tickSize = axis.tickSize(tickPrefix),
	                    mark = tick.mark,
	                    isNewMark = !mark,
	                    x = xy.x,
	                    y = xy.y;


	                var tickWidth = pick(
	                        options[tickPrefix + 'Width'], !type && axis.isXAxis ? 1 : 0
	                    ), // X axis defaults to 1
	                    tickColor = options[tickPrefix + 'Color'];


	                if (tickSize) {

	                    // negate the length
	                    if (axis.opposite) {
	                        tickSize[0] = -tickSize[0];
	                    }

	                    // First time, create it
	                    if (isNewMark) {
	                        tick.mark = mark = renderer.path()
	                            .addClass('highcharts-' + (type ? type + '-' : '') + 'tick')
	                            .add(axis.axisGroup);


	                        mark.attr({
	                            stroke: tickColor,
	                            'stroke-width': tickWidth
	                        });

	                    }
	                    mark[isNewMark ? 'attr' : 'animate']({
	                        d: tick.getMarkPath(
	                            x,
	                            y,
	                            tickSize[0],
	                            mark.strokeWidth() * reverseCrisp,
	                            axis.horiz,
	                            renderer),
	                        opacity: opacity
	                    });

	                }
	            },

	            /**
	             * Renders the tick label.
	             * Note: The label should already be created in init(), so it should only
	             * have to be moved into place.
	             * @param  {Object} xy      The position vector of the label
	             * @param  {number} xy.x    The x position of the label
	             * @param  {number} xy.y    The y position of the label
	             * @param  {Boolean} old    Whether or not the tick is old
	             * @param  {number} opacity The opacity of the label
	             * @param  {number} index   The index of the tick
	             * @return {undefined}
	             */
	            renderLabel: function(xy, old, opacity, index) {
	                var tick = this,
	                    axis = tick.axis,
	                    horiz = axis.horiz,
	                    options = axis.options,
	                    label = tick.label,
	                    labelOptions = options.labels,
	                    step = labelOptions.step,
	                    tickmarkOffset = axis.tickmarkOffset,
	                    show = true,
	                    x = xy.x,
	                    y = xy.y;
	                if (label && isNumber(x)) {
	                    label.xy = xy = tick.getLabelPosition(
	                        x,
	                        y,
	                        label,
	                        horiz,
	                        labelOptions,
	                        tickmarkOffset,
	                        index,
	                        step
	                    );

	                    // Apply show first and show last. If the tick is both first and
	                    // last, it is a single centered tick, in which case we show the
	                    // label anyway (#2100).
	                    if (
	                        (
	                            tick.isFirst &&
	                            !tick.isLast &&
	                            !pick(options.showFirstLabel, 1)
	                        ) ||
	                        (
	                            tick.isLast &&
	                            !tick.isFirst &&
	                            !pick(options.showLastLabel, 1)
	                        )
	                    ) {
	                        show = false;

	                        // Handle label overflow and show or hide accordingly
	                    } else if (horiz && !axis.isRadial && !labelOptions.step &&
	                        !labelOptions.rotation && !old && opacity !== 0) {
	                        tick.handleOverflow(xy);
	                    }

	                    // apply step
	                    if (step && index % step) {
	                        // show those indices dividable by step
	                        show = false;
	                    }

	                    // Set the new position, and show or hide
	                    if (show && isNumber(xy.y)) {
	                        xy.opacity = opacity;
	                        label[tick.isNewLabel ? 'attr' : 'animate'](xy);
	                        tick.isNewLabel = false;
	                    } else {
	                        label.attr('y', -9999); // #1338
	                        tick.isNewLabel = true;
	                    }
	                    tick.isNew = false;
	                }
	            },

	            /**
	             * Put everything in place
	             *
	             * @param index {Number}
	             * @param old {Boolean} Use old coordinates to prepare an animation into new
	             *                      position
	             */
	            render: function(index, old, opacity) {
	                var tick = this,
	                    axis = tick.axis,
	                    horiz = axis.horiz,
	                    pos = tick.pos,
	                    tickmarkOffset = axis.tickmarkOffset,
	                    xy = tick.getPosition(horiz, pos, tickmarkOffset, old),
	                    x = xy.x,
	                    y = xy.y,
	                    reverseCrisp = ((horiz && x === axis.pos + axis.len) ||
	                        (!horiz && y === axis.pos)) ? -1 : 1; // #1480, #1687

	                opacity = pick(opacity, 1);
	                this.isActive = true;

	                // Create the grid line
	                this.renderGridLine(old, opacity, reverseCrisp);

	                // create the tick mark
	                this.renderMark(xy, opacity, reverseCrisp);

	                // the label is created on init - now move it into place
	                this.renderLabel(xy, old, opacity, index);
	            },

	            /**
	             * Destructor for the tick prototype
	             */
	            destroy: function() {
	                destroyObjectProperties(this, this.axis);
	            }
	        };

	    }(Highcharts));
	    var Axis = (function(H) {
	        /**
	         * (c) 2010-2017 Torstein Honsi
	         *
	         * License: www.highcharts.com/license
	         */

	        var addEvent = H.addEvent,
	            animObject = H.animObject,
	            arrayMax = H.arrayMax,
	            arrayMin = H.arrayMin,
	            color = H.color,
	            correctFloat = H.correctFloat,
	            defaultOptions = H.defaultOptions,
	            defined = H.defined,
	            deg2rad = H.deg2rad,
	            destroyObjectProperties = H.destroyObjectProperties,
	            each = H.each,
	            extend = H.extend,
	            fireEvent = H.fireEvent,
	            format = H.format,
	            getMagnitude = H.getMagnitude,
	            grep = H.grep,
	            inArray = H.inArray,
	            isArray = H.isArray,
	            isNumber = H.isNumber,
	            isString = H.isString,
	            merge = H.merge,
	            normalizeTickInterval = H.normalizeTickInterval,
	            objectEach = H.objectEach,
	            pick = H.pick,
	            removeEvent = H.removeEvent,
	            splat = H.splat,
	            syncTimeout = H.syncTimeout,
	            Tick = H.Tick;

	        /**
	         * Create a new axis object. Called internally when instanciating a new chart or
	         * adding axes by {@link Highcharts.Chart#addAxis}.
	         *
	         * A chart can have from 0 axes (pie chart) to multiples. In a normal, single
	         * series cartesian chart, there is one X axis and one Y axis.
	         * 
	         * The X axis or axes are referenced by {@link Highcharts.Chart.xAxis}, which is
	         * an array of Axis objects. If there is only one axis, it can be referenced
	         * through `chart.xAxis[0]`, and multiple axes have increasing indices. The same
	         * pattern goes for Y axes.
	         * 
	         * If you need to get the axes from a series object, use the `series.xAxis` and
	         * `series.yAxis` properties. These are not arrays, as one series can only be
	         * associated to one X and one Y axis.
	         * 
	         * A third way to reference the axis programmatically is by `id`. Add an `id` in
	         * the axis configuration options, and get the axis by
	         * {@link Highcharts.Chart#get}.
	         * 
	         * Configuration options for the axes are given in options.xAxis and
	         * options.yAxis.
	         * 
	         * @class Highcharts.Axis
	         * @memberOf Highcharts
	         * @param {Highcharts.Chart} chart - The Chart instance to apply the axis on.
	         * @param {Object} options - Axis options
	         */
	        var Axis = function() {
	            this.init.apply(this, arguments);
	        };

	        H.extend(Axis.prototype, /** @lends Highcharts.Axis.prototype */ {

	            /**
	             * The X axis or category axis. Normally this is the horizontal axis,
	             * though if the chart is inverted this is the vertical axis. In case of
	             * multiple axes, the xAxis node is an array of configuration objects.
	             * 
	             * See [../class-reference/Highcharts.Axis](the Axis object) for
	             * programmatic access to the axis.
	             *
	             * @productdesc {highmaps}
	             * In Highmaps, the axis is hidden, but it is used behind the scenes to
	             * control features like zooming and panning. Zooming is in effect the same
	             * as setting the extremes of one of the exes.
	             * 
	             * @optionparent xAxis
	             */
	            defaultOptions: {
	                // allowDecimals: null,
	                // alternateGridColor: null,
	                // categories: [],

	                /**
	                 * For a datetime axis, the scale will automatically adjust to the
	                 * appropriate unit. This member gives the default string representations
	                 * used for each unit. For intermediate values, different units may
	                 * be used, for example the `day` unit can be used on midnight and
	                 * `hour` unit be used for intermediate values on the same axis. For
	                 * an overview of the replacement codes, see [dateFormat](#Highcharts.
	                 * dateFormat). Defaults to:
	                 * 
	                 * <pre>{
	                 * millisecond: '%H:%M:%S.%L',
	                 * second: '%H:%M:%S',
	                 * minute: '%H:%M',
	                 * hour: '%H:%M',
	                 * day: '%e. %b',
	                 * week: '%e. %b',
	                 * month: '%b \'%y',
	                 * year: '%Y'
	                 * }</pre>
	                 * 
	                 * @type {Object}
	                 * @sample {highcharts} highcharts/xaxis/datetimelabelformats/ Different day format on X axis
	                 * @sample {highstock} stock/xaxis/datetimelabelformats/ More information in x axis labels
	                 * @product highcharts highstock
	                 */
	                dateTimeLabelFormats: {

	                    /**
	                     */
	                    millisecond: '%H:%M:%S.%L',

	                    /**
	                     */
	                    second: '%H:%M:%S',

	                    /**
	                     */
	                    minute: '%H:%M',

	                    /**
	                     */
	                    hour: '%H:%M',

	                    /**
	                     */
	                    day: '%e. %b',

	                    /**
	                     */
	                    week: '%e. %b',

	                    /**
	                     */
	                    month: '%b \'%y',

	                    /**
	                     */
	                    year: '%Y'
	                },

	                /**
	                 * Whether to force the axis to end on a tick. Use this option with
	                 * the `maxPadding` option to control the axis end.
	                 * 
	                 * @type {Boolean}
	                 * @sample {highcharts} highcharts/chart/reflow-true/ True by default
	                 * @sample {highcharts} highcharts/yaxis/endontick/ False
	                 * @sample {highstock} stock/demo/basic-line/ True by default
	                 * @sample {highstock} stock/xaxis/endontick/ False
	                 * @default false
	                 * @since 1.2.0
	                 * @product highcharts highstock highmaps
	                 */
	                endOnTick: false,
	                // reversed: false,


	                /**
	                 * The axis labels show the number or category for each tick.
	                 *
	                 * @productdesc {highmaps}
	                 * X and Y axis labels are by default disabled in Highmaps, but the
	                 * functionality is inherited from Highcharts and used on `colorAxis`,
	                 * and can be enabled on X and Y axes too.
	                 */
	                labels: {

	                    /**
	                     * Enable or disable the axis labels.
	                     * 
	                     * @type {Boolean}
	                     * @sample {highcharts} highcharts/xaxis/labels-enabled/ X axis labels disabled
	                     * @sample {highstock} stock/xaxis/labels-enabled/ X axis labels disabled
	                     * @default {highstock} true
	                     * @default {highmaps} false
	                     * @product highcharts highstock highmaps
	                     */
	                    enabled: true,
	                    // rotation: 0,
	                    // align: 'center',
	                    // step: null,


	                    /**
	                     * CSS styles for the label. Use `whiteSpace: 'nowrap'` to prevent
	                     * wrapping of category labels. Use `textOverflow: 'none'` to prevent
	                     * ellipsis (dots).
	                     * 
	                     * In [styled mode](http://www.highcharts.com/docs/chart-design-and-
	                     * style/style-by-css), the labels are styled with the `.highcharts-
	                     * axis-labels` class.
	                     * 
	                     * @type {CSSObject}
	                     * @sample {highcharts} highcharts/xaxis/labels-style/ Red X axis labels
	                     * @default { "color": "#666666", "cursor": "default", "fontSize": "11px" }
	                     * @product highcharts highstock highmaps
	                     */
	                    style: {

	                        /**
	                         */
	                        color: '#666666',

	                        /**
	                         */
	                        cursor: 'default',

	                        /**
	                         */
	                        fontSize: '11px'
	                    },


	                    /**
	                     * The x position offset of the label relative to the tick position
	                     * on the axis.
	                     * 
	                     * @type {Number}
	                     * @sample {highcharts} highcharts/xaxis/labels-x/ Y axis labels placed on grid lines
	                     * @default 0
	                     * @product highcharts highstock highmaps
	                     */
	                    x: 0
	                    //y: undefined
	                    /*formatter: function () {
	                        return this.value;
	                    },*/
	                },
	                //linkedTo: null,
	                //max: undefined,
	                //min: undefined,

	                /**
	                 * Padding of the min value relative to the length of the axis. A
	                 * padding of 0.05 will make a 100px axis 5px longer. This is useful
	                 * when you don't want the lowest data value to appear on the edge
	                 * of the plot area. When the axis' `min` option is set or a min extreme
	                 * is set using `axis.setExtremes()`, the minPadding will be ignored.
	                 * 
	                 * @type {Number}
	                 * @sample {highcharts} highcharts/yaxis/minpadding/ Min padding of 0.2
	                 * @sample {highstock} stock/xaxis/minpadding-maxpadding/ Greater min- and maxPadding
	                 * @sample {highmaps} maps/chart/plotbackgroundcolor-gradient/ Add some padding
	                 * @default {highcharts} 0.01
	                 * @default {highstock} 0
	                 * @default {highmaps} 0
	                 * @since 1.2.0
	                 * @product highcharts highstock highmaps
	                 */
	                minPadding: 0.01,

	                /**
	                 * Padding of the max value relative to the length of the axis. A
	                 * padding of 0.05 will make a 100px axis 5px longer. This is useful
	                 * when you don't want the highest data value to appear on the edge
	                 * of the plot area. When the axis' `max` option is set or a max extreme
	                 * is set using `axis.setExtremes()`, the maxPadding will be ignored.
	                 * 
	                 * @type {Number}
	                 * @sample {highcharts} highcharts/yaxis/maxpadding/ Max padding of 0.25 on y axis
	                 * @sample {highstock} stock/xaxis/minpadding-maxpadding/ Greater min- and maxPadding
	                 * @sample {highmaps} maps/chart/plotbackgroundcolor-gradient/ Add some padding
	                 * @default {highcharts} 0.01
	                 * @default {highstock} 0
	                 * @default {highmaps} 0
	                 * @since 1.2.0
	                 * @product highcharts highstock highmaps
	                 */
	                maxPadding: 0.01,
	                //minRange: null,
	                //minorTickInterval: null,

	                /**
	                 * The pixel length of the minor tick marks.
	                 * 
	                 * @type {Number}
	                 * @sample {highcharts} highcharts/yaxis/minorticklength/ 10px on Y axis
	                 * @sample {highstock} stock/xaxis/minorticks/ 10px on Y axis
	                 * @default 2
	                 * @product highcharts highstock highmaps
	                 */
	                minorTickLength: 2,

	                /**
	                 * The position of the minor tick marks relative to the axis line.
	                 *  Can be one of `inside` and `outside`.
	                 * 
	                 * @validvalue ["inside", "outside"]
	                 * @type {String}
	                 * @sample {highcharts} highcharts/yaxis/minortickposition-outside/ Outside by default
	                 * @sample {highcharts} highcharts/yaxis/minortickposition-inside/ Inside
	                 * @sample {highstock} stock/xaxis/minorticks/ Inside
	                 * @default outside
	                 * @product highcharts highstock highmaps
	                 */
	                minorTickPosition: 'outside', // inside or outside
	                //opposite: false,
	                //offset: 0,
	                //plotBands: [{
	                //  events: {},
	                //  zIndex: 1,
	                //  labels: { align, x, verticalAlign, y, style, rotation, textAlign }
	                //}],
	                //plotLines: [{
	                //  events: {}
	                //  dashStyle: {}
	                //  zIndex:
	                //  labels: { align, x, verticalAlign, y, style, rotation, textAlign }
	                //}],
	                //reversed: false,
	                // showFirstLabel: true,
	                // showLastLabel: true,

	                /**
	                 * For datetime axes, this decides where to put the tick between weeks.
	                 *  0 = Sunday, 1 = Monday.
	                 * 
	                 * @type {Number}
	                 * @sample {highcharts} highcharts/xaxis/startofweek-monday/ Monday by default
	                 * @sample {highcharts} highcharts/xaxis/startofweek-sunday/ Sunday
	                 * @sample {highstock} stock/xaxis/startofweek-1 Monday by default
	                 * @sample {highstock} stock/xaxis/startofweek-0 Sunday
	                 * @default 1
	                 * @product highcharts highstock
	                 */
	                startOfWeek: 1,

	                /**
	                 * Whether to force the axis to start on a tick. Use this option with
	                 * the `minPadding` option to control the axis start.
	                 *
	                 * @productdesc {highstock}
	                 * In Highstock, `startOnTick` is always false when the navigator is
	                 * enabled, to prevent jumpy scrolling.
	                 * 
	                 * @type {Boolean}
	                 * @sample {highcharts} highcharts/xaxis/startontick-false/ False by default
	                 * @sample {highcharts} highcharts/xaxis/startontick-true/ True
	                 * @sample {highstock} stock/xaxis/endontick/ False for Y axis
	                 * @default false
	                 * @since 1.2.0
	                 */
	                startOnTick: false,
	                //tickInterval: null,

	                /**
	                 * The pixel length of the main tick marks.
	                 * 
	                 * @type {Number}
	                 * @sample {highcharts} highcharts/xaxis/ticklength/ 20 px tick length on the X axis
	                 * @sample {highstock} stock/xaxis/ticks/ Formatted ticks on X axis
	                 * @default 10
	                 * @product highcharts highstock highmaps
	                 */
	                tickLength: 10,

	                /**
	                 * For categorized axes only. If `on` the tick mark is placed in the
	                 * center of the category, if `between` the tick mark is placed between
	                 * categories. The default is `between` if the `tickInterval` is 1,
	                 *  else `on`.
	                 * 
	                 * @validvalue [null, "on", "between"]
	                 * @type {String}
	                 * @sample {highcharts} highcharts/xaxis/tickmarkplacement-between/ "between" by default
	                 * @sample {highcharts} highcharts/xaxis/tickmarkplacement-on/ "on"
	                 * @default null
	                 * @product highcharts
	                 */
	                tickmarkPlacement: 'between', // on or between

	                /**
	                 * If tickInterval is `null` this option sets the approximate pixel
	                 * interval of the tick marks. Not applicable to categorized axis.
	                 * 
	                 * 
	                 * The tick interval is also influenced by the [minTickInterval](#xAxis.
	                 * minTickInterval) option, that, by default prevents ticks from being
	                 * denser than the data points.
	                 * 
	                 * Defaults to `72` for the Y axis and `100` for the X axis.
	                 * 
	                 * @type {Number}
	                 * @see [tickInterval](#xAxis.tickInterval), [tickPositioner](#xAxis.tickPositioner),
	                 *  [tickPositions](#xAxis.tickPositions)-
	                 * @sample {highcharts} highcharts/xaxis/tickpixelinterval-50/ 50 px on X axis
	                 * @sample {highstock} stock/xaxis/tickpixelinterval/ 200 px on X axis
	                 * @product highcharts highstock highmaps
	                 */
	                tickPixelInterval: 100,

	                /**
	                 * The position of the major tick marks relative to the axis line.
	                 *  Can be one of `inside` and `outside`.
	                 * 
	                 * @validvalue ["inside", "outside"]
	                 * @type {String}
	                 * @sample {highcharts} highcharts/xaxis/tickposition-outside/ "outside" by default
	                 * @sample {highcharts} highcharts/xaxis/tickposition-inside/ "inside"
	                 * @sample {highstock} stock/xaxis/ticks/ Formatted ticks on X axis
	                 * @default {highcharts} outside
	                 * @default {highstock} "outside"
	                 * @default {highmaps} outside
	                 * @product highcharts highstock highmaps
	                 */
	                tickPosition: 'outside',

	                /**
	                 * The axis title, showing next to the axis line.
	                 *
	                 * @productdesc {highmaps}
	                 * In Highmaps, the axis is hidden by default, but adding an axis title
	                 * is still possible. X axis and Y axis titles will appear at the bottom
	                 * and left by default.
	                 */
	                title: {
	                    //text: null,

	                    /**
	                     * Alignment of the title relative to the axis values. Possible values
	                     * are "low", "middle" or "high".
	                     * 
	                     * @validvalue ["low", "middle", "high"]
	                     * @type {String}
	                     * @sample {highcharts} highcharts/xaxis/title-align-low/ "low"
	                     * @sample {highcharts} highcharts/xaxis/title-align-center/ "middle" by default
	                     * @sample {highcharts} highcharts/xaxis/title-align-high/ "high"
	                     * @sample {highcharts} highcharts/yaxis/title-offset/ Place the Y axis title on top of the axis
	                     * @sample {highstock} stock/xaxis/title-align/ Aligned to "high" value
	                     * @default {highcharts} middle
	                     * @default {highstock} "middle"
	                     * @default {highmaps} middle
	                     * @product highcharts highstock highmaps
	                     */
	                    align: 'middle', // low, middle or high
	                    //margin: 0 for horizontal, 10 for vertical axes,
	                    // reserveSpace: true,
	                    //rotation: 0,
	                    //side: 'outside',


	                    /**
	                     * CSS styles for the title. If the title text is longer than the
	                     * axis length, it will wrap to multiple lines by default. This can
	                     * be customized by setting `textOverflow: 'ellipsis'`, by 
	                     * setting a specific `width` or by setting `wordSpace: 'nowrap'`.
	                     * 
	                     * 
	                     * In [styled mode](http://www.highcharts.com/docs/chart-design-and-
	                     * style/style-by-css), the stroke width is given in the
	                     * `.highcharts-axis-title` class.
	                     * 
	                     * @type {CSSObject}
	                     * @sample {highcharts} highcharts/xaxis/title-style/ Red
	                     * @sample {highcharts} highcharts/css/axis/ Styled mode
	                     * @default { "color": "#666666" }
	                     * @product highcharts highstock highmaps
	                     */
	                    style: {

	                        /**
	                         */
	                        color: '#666666'
	                    }

	                    //x: 0,
	                    //y: 0
	                },

	                /**
	                 * The type of axis. Can be one of `linear`, `logarithmic`, `datetime`
	                 * or `category`. In a datetime axis, the numbers are given in milliseconds,
	                 * and tick marks are placed on appropriate values like full hours
	                 * or days. In a category axis, the [point names](#series<line>.data.
	                 * name) of the chart's series are used for categories, if not a [categories](#xAxis.
	                 * categories) array is defined.
	                 * 
	                 * @validvalue ["linear", "logarithmic", "datetime", "category"]
	                 * @type {String}
	                 * @sample {highcharts} highcharts/xaxis/type-linear/ Linear
	                 * @sample {highcharts} highcharts/yaxis/type-log/ Logarithmic
	                 * @sample {highcharts} highcharts/yaxis/type-log-minorgrid/ Logarithmic with minor grid lines
	                 * @sample {highcharts} highcharts/xaxis/type-log-both/ Logarithmic on two axes
	                 * @sample {highcharts} highcharts/yaxis/type-log-negative/ Logarithmic with extension to emulate negative values
	                 * @default linear
	                 * @product highcharts
	                 */
	                type: 'linear', // linear, logarithmic or datetime
	                //visible: true


	                /**
	                 * Color of the minor, secondary grid lines.
	                 * 
	                 * In [styled mode](http://www.highcharts.com/docs/chart-design-and-
	                 * style/style-by-css), the stroke width is given in the `.highcharts-
	                 * minor-grid-line` class.
	                 * 
	                 * @type {Color}
	                 * @sample {highcharts} highcharts/yaxis/minorgridlinecolor/ Bright grey lines from Y axis
	                 * @sample {highcharts} highcharts/css/axis-grid/ Styled mode
	                 * @sample {highstock} stock/xaxis/minorgridlinecolor/ Bright grey lines from Y axis
	                 * @sample {highstock} highcharts/css/axis-grid/ Styled mode
	                 * @default #f2f2f2
	                 * @product highcharts highstock highmaps
	                 */
	                minorGridLineColor: '#f2f2f2',
	                // minorGridLineDashStyle: null,

	                /**
	                 * Width of the minor, secondary grid lines.
	                 * 
	                 * In [styled mode](http://www.highcharts.com/docs/chart-design-and-
	                 * style/style-by-css), the stroke width is given in the `.highcharts-
	                 * grid-line` class.
	                 * 
	                 * @type {Number}
	                 * @sample {highcharts} highcharts/yaxis/minorgridlinewidth/ 2px lines from Y axis
	                 * @sample {highcharts} highcharts/css/axis-grid/ Styled mode
	                 * @sample {highstock} stock/xaxis/minorgridlinewidth/ 2px lines from Y axis
	                 * @sample {highstock} highcharts/css/axis-grid/ Styled mode
	                 * @default 1
	                 * @product highcharts highstock highmaps
	                 */
	                minorGridLineWidth: 1,

	                /**
	                 * Color for the minor tick marks.
	                 * 
	                 * @type {Color}
	                 * @sample {highcharts} highcharts/yaxis/minortickcolor/ Black tick marks on Y axis
	                 * @sample {highstock} stock/xaxis/minorticks/ Black tick marks on Y axis
	                 * @default #999999
	                 * @product highcharts highstock highmaps
	                 */
	                minorTickColor: '#999999',
	                //minorTickWidth: 0,

	                /**
	                 * The color of the line marking the axis itself.
	                 * 
	                 * In [styled mode](http://www.highcharts.com/docs/chart-design-and-
	                 * style/style-by-css), the line stroke is given in the `.highcharts-
	                 * axis-line` or `.highcharts-xaxis-line` class.
	                 * 
	                 * @productdesc {highmaps}
	                 * In Highmaps, the axis line is hidden by default.
	                 * 
	                 * @type {Color}
	                 * @sample {highcharts} highcharts/yaxis/linecolor/ A red line on Y axis
	                 * @sample {highcharts} highcharts/css/axis/ Axes in styled mode
	                 * @sample {highstock} stock/xaxis/linecolor/ A red line on X axis
	                 * @sample {highstock} highcharts/css/axis/ Axes in styled mode
	                 * @default #ccd6eb
	                 * @product highcharts highstock highmaps
	                 */
	                lineColor: '#ccd6eb',

	                /**
	                 * The width of the line marking the axis itself.
	                 * 
	                 * In [styled mode](http://www.highcharts.com/docs/chart-design-and-
	                 * style/style-by-css), the stroke width is given in the `.highcharts-
	                 * axis-line` or `.highcharts-xaxis-line` class.
	                 * 
	                 * @type {Number}
	                 * @sample {highcharts} highcharts/yaxis/linecolor/ A 1px line on Y axis
	                 * @sample {highcharts} highcharts/css/axis/ Axes in styled mode
	                 * @sample {highstock} stock/xaxis/linewidth/ A 2px line on X axis
	                 * @sample {highstock} highcharts/css/axis/ Axes in styled mode
	                 * @default {highcharts} 1
	                 * @default {highstock} 1
	                 * @default {highmaps} 0
	                 * @product highcharts highstock highmaps
	                 */
	                lineWidth: 1,

	                /**
	                 * Color of the grid lines extending the ticks across the plot area.
	                 * 
	                 * In [styled mode](http://www.highcharts.com/docs/chart-design-and-
	                 * style/style-by-css), the stroke is given in the `.highcharts-grid-
	                 * line` class.
	                 *
	                 * @productdesc {highmaps}
	                 * In Highmaps, the grid lines are hidden by default.
	                 * 
	                 * @type {Color}
	                 * @sample {highcharts} highcharts/yaxis/gridlinecolor/ Green lines
	                 * @sample {highcharts} highcharts/css/axis-grid/ Styled mode
	                 * @sample {highstock} stock/xaxis/gridlinecolor/ Green lines
	                 * @sample {highstock} highcharts/css/axis-grid/ Styled mode
	                 * @default #e6e6e6
	                 * @product highcharts highstock highmaps
	                 */
	                gridLineColor: '#e6e6e6',
	                // gridLineDashStyle: 'solid',
	                // gridLineWidth: 0,

	                /**
	                 * Color for the main tick marks.
	                 * 
	                 * In [styled mode](http://www.highcharts.com/docs/chart-design-and-
	                 * style/style-by-css), the stroke is given in the `.highcharts-tick`
	                 * class.
	                 * 
	                 * @type {Color}
	                 * @sample {highcharts} highcharts/xaxis/tickcolor/ Red ticks on X axis
	                 * @sample {highcharts} highcharts/css/axis-grid/ Styled mode
	                 * @sample {highstock} stock/xaxis/ticks/ Formatted ticks on X axis
	                 * @sample {highstock} highcharts/css/axis-grid/ Styled mode
	                 * @default #ccd6eb
	                 * @product highcharts highstock highmaps
	                 */
	                tickColor: '#ccd6eb'
	                // tickWidth: 1

	            },

	            /**
	             * This option set extends the defaultOptions for Y axes.
	             * @extends xAxis
	             * @optionparent yAxis
	             */
	            defaultYAxisOptions: {

	                /**
	                 * Whether to force the axis to end on a tick. Use this option with
	                 * the `maxPadding` option to control the axis end.
	                 *
	                 * @productdesc {highstock}
	                 * In Highstock, `endOnTick` is always false when the navigator is
	                 * enabled, to prevent jumpy scrolling.
	                 * 
	                 * @type {Boolean}
	                 * @sample {highcharts} highcharts/chart/reflow-true/ True by default
	                 * @sample {highcharts} highcharts/yaxis/endontick-false/ False
	                 * @sample {highcharts} highcharts/yaxis/endontick-log-false/ False
	                 * @sample {highstock} stock/demo/basic-line/ True by default
	                 * @sample {highstock} stock/xaxis/endontick/ False
	                 * @default true
	                 * @since 1.2.0
	                 * @product highcharts highstock
	                 */
	                endOnTick: true,

	                /**
	                 */
	                tickPixelInterval: 72,

	                /**
	                 * Whether to show the last tick label. Defaults to `true` on cartesian
	                 * charts, and `false` on polar charts.
	                 * 
	                 * @type {Boolean}
	                 * @sample {highcharts} highcharts/xaxis/showlastlabel-true/ Set to true on X axis
	                 * @sample {highstock} stock/xaxis/showfirstlabel/ Labels below plot lines on Y axis
	                 * @default false
	                 * @product highcharts highstock
	                 */
	                showLastLabel: true,

	                /**
	                 * @extends xAxis.labels
	                 * @product highcharts highstock highmaps
	                 */
	                labels: {

	                    /**
	                     * The x position offset of the label relative to the tick position
	                     * on the axis. Defaults to -15 for left axis, 15 for right axis.
	                     * 
	                     * @type {Number}
	                     * @sample {highcharts} highcharts/xaxis/labels-x/ Y axis labels placed on grid lines
	                     * @default 0
	                     * @product highcharts highstock highmaps
	                     */
	                    x: -8
	                },

	                /**
	                 * Padding of the max value relative to the length of the axis. A
	                 * padding of 0.05 will make a 100px axis 5px longer. This is useful
	                 * when you don't want the highest data value to appear on the edge
	                 * of the plot area. When the axis' `max` option is set or a max extreme
	                 * is set using `axis.setExtremes()`, the maxPadding will be ignored.
	                 * 
	                 * @type {Number}
	                 * @sample {highcharts} highcharts/yaxis/maxpadding-02/ Max padding of 0.2
	                 * @sample {highstock} stock/xaxis/minpadding-maxpadding/ Greater min- and maxPadding
	                 * @default 0.05
	                 * @since 1.2.0
	                 * @product highcharts highstock
	                 */
	                maxPadding: 0.05,

	                /**
	                 * Padding of the min value relative to the length of the axis. A
	                 * padding of 0.05 will make a 100px axis 5px longer. This is useful
	                 * when you don't want the lowest data value to appear on the edge
	                 * of the plot area. When the axis' `min` option is set or a max extreme
	                 * is set using `axis.setExtremes()`, the maxPadding will be ignored.
	                 * 
	                 * @type {Number}
	                 * @sample {highcharts} highcharts/yaxis/minpadding/ Min padding of 0.2
	                 * @sample {highstock} stock/xaxis/minpadding-maxpadding/ Greater min- and maxPadding
	                 * @default 0.05
	                 * @since 1.2.0
	                 * @product highcharts highstock
	                 */
	                minPadding: 0.05,

	                /**
	                 * Whether to force the axis to start on a tick. Use this option with
	                 * the `maxPadding` option to control the axis start.
	                 * 
	                 * @type {Boolean}
	                 * @sample {highcharts} highcharts/xaxis/startontick-false/ False by default
	                 * @sample {highcharts} highcharts/xaxis/startontick-true/ True
	                 * @sample {highstock} stock/xaxis/endontick/ False for Y axis
	                 * @default true
	                 * @since 1.2.0
	                 * @product highcharts highstock
	                 */
	                startOnTick: true,

	                /**
	                 * @extends xAxis.title
	                 * @product highcharts highstock highmaps
	                 */
	                title: {

	                    /**
	                     * The rotation of the text in degrees. 0 is horizontal, 270 is vertical
	                     * reading from bottom to top.
	                     * 
	                     * @type {Number}
	                     * @sample {highcharts} highcharts/yaxis/title-offset/ Horizontal
	                     * @default 270
	                     * @product highcharts highstock highmaps
	                     */
	                    rotation: 270,

	                    /**
	                     * The actual text of the axis title. Horizontal texts can contain
	                     * HTML, but rotated texts are painted using vector techniques and
	                     * must be clean text. The Y axis title is disabled by setting the
	                     * `text` option to `null`.
	                     * 
	                     * @type {String}
	                     * @sample {highcharts} highcharts/xaxis/title-text/ Custom HTML
	                     * @default Values
	                     * @product highcharts
	                     */
	                    text: 'Values'
	                },

	                /**
	                 * The stack labels show the total value for each bar in a stacked
	                 * column or bar chart. The label will be placed on top of positive
	                 * columns and below negative columns. In case of an inverted column
	                 * chart or a bar chart the label is placed to the right of positive
	                 * bars and to the left of negative bars.
	                 * 
	                 * @product highcharts
	                 */
	                stackLabels: {

	                    /**
	                     * Allow the stack labels to overlap.
	                     * 
	                     * @type {Boolean}
	                     * @sample {highcharts} highcharts/yaxis/stacklabels-allowoverlap-false/
	                     *         Default false
	                     * @since 5.0.13
	                     * @product highcharts
	                     */
	                    allowOverlap: false,

	                    /**
	                     * Enable or disable the stack total labels.
	                     * 
	                     * @type {Boolean}
	                     * @sample {highcharts} highcharts/yaxis/stacklabels-enabled/ Enabled stack total labels
	                     * @since 2.1.5
	                     * @product highcharts
	                     */
	                    enabled: false,
	                    //align: dynamic,
	                    //y: dynamic,
	                    //x: dynamic,
	                    //verticalAlign: dynamic,
	                    //textAlign: dynamic,
	                    //rotation: 0,

	                    /**
	                     * Callback JavaScript function to format the label. The value is
	                     * given by `this.total`. Defaults to:
	                     * 
	                     * <pre>function() {
	                     * return this.total;
	                     * }</pre>
	                     * 
	                     * @type {Function}
	                     * @sample {highcharts} highcharts/yaxis/stacklabels-formatter/ Added units to stack total value
	                     * @since 2.1.5
	                     * @product highcharts
	                     */
	                    formatter: function() {
	                        return H.numberFormat(this.total, -1);
	                    },


	                    /**
	                     * CSS styles for the label.
	                     * 
	                     * In [styled mode](http://www.highcharts.com/docs/chart-design-and-
	                     * style/style-by-css), the styles are set in the `.highcharts-stack-
	                     * label` class.
	                     * 
	                     * @type {CSSObject}
	                     * @sample {highcharts} highcharts/yaxis/stacklabels-style/ Red stack total labels
	                     * @default { "color": "#000000", "fontSize": "11px", "fontWeight": "bold", "textShadow": "1px 1px contrast, -1px -1px contrast, -1px 1px contrast, 1px -1px contrast" }
	                     * @since 2.1.5
	                     * @product highcharts
	                     */
	                    style: {

	                        /**
	                         */
	                        fontSize: '11px',

	                        /**
	                         */
	                        fontWeight: 'bold',

	                        /**
	                         */
	                        color: '#000000',

	                        /**
	                         */
	                        textOutline: '1px contrast'
	                    }

	                },


	                /**
	                 * The width of the grid lines extending the ticks across the plot
	                 * area.
	                 * 
	                 * @productdesc {highmaps}
	                 * In Highmaps, the grid lines are hidden by default.
	                 * 
	                 * @type {Number}
	                 * @sample {highcharts} highcharts/yaxis/gridlinewidth/ 2px lines
	                 * @sample {highstock} stock/xaxis/gridlinewidth/ 2px lines
	                 * @default 1
	                 * @product highcharts highstock
	                 */
	                gridLineWidth: 1,

	                /**
	                 * The width of the line marking the axis itself.
	                 * 
	                 * @type {Number}
	                 * @sample {highcharts} highcharts/yaxis/linecolor/ A 1px line on Y axis
	                 * @sample {highstock} stock/xaxis/linewidth/ A 2px line on X axis
	                 * @default 0
	                 * @product highcharts highstock
	                 */
	                lineWidth: 0
	                // tickWidth: 0

	            },

	            /**
	             * These options extend the defaultOptions for left axes.
	             * 
	             * @private
	             * @type {Object}
	             */
	            defaultLeftAxisOptions: {
	                labels: {
	                    x: -15
	                },
	                title: {
	                    rotation: 270
	                }
	            },

	            /**
	             * These options extend the defaultOptions for right axes.
	             *
	             * @private
	             * @type {Object}
	             */
	            defaultRightAxisOptions: {
	                labels: {
	                    x: 15
	                },
	                title: {
	                    rotation: 90
	                }
	            },

	            /**
	             * These options extend the defaultOptions for bottom axes.
	             *
	             * @private
	             * @type {Object}
	             */
	            defaultBottomAxisOptions: {
	                labels: {
	                    autoRotation: [-45],
	                    x: 0
	                    // overflow: undefined,
	                    // staggerLines: null
	                },
	                title: {
	                    rotation: 0
	                }
	            },
	            /**
	             * These options extend the defaultOptions for top axes.
	             *
	             * @private
	             * @type {Object}
	             */
	            defaultTopAxisOptions: {
	                labels: {
	                    autoRotation: [-45],
	                    x: 0
	                    // overflow: undefined
	                    // staggerLines: null
	                },
	                title: {
	                    rotation: 0
	                }
	            },

	            /**
	             * Overrideable function to initialize the axis. 
	             *
	             * @see {@link Axis}
	             */
	            init: function(chart, userOptions) {


	                var isXAxis = userOptions.isX,
	                    axis = this;


	                /**
	                 * The Chart that the axis belongs to.
	                 *
	                 * @name chart
	                 * @memberOf Axis
	                 * @type {Chart}
	                 */
	                axis.chart = chart;

	                /**
	                 * Whether the axis is horizontal.
	                 *
	                 * @name horiz
	                 * @memberOf Axis
	                 * @type {Boolean}
	                 */
	                axis.horiz = chart.inverted && !axis.isZAxis ? !isXAxis : isXAxis;

	                // Flag, isXAxis
	                axis.isXAxis = isXAxis;

	                /**
	                 * The collection where the axis belongs, for example `xAxis`, `yAxis`
	                 * or `colorAxis`. Corresponds to properties on Chart, for example
	                 * {@link Chart.xAxis}.
	                 *
	                 * @name coll
	                 * @memberOf Axis
	                 * @type {String}
	                 */
	                axis.coll = axis.coll || (isXAxis ? 'xAxis' : 'yAxis');


	                axis.opposite = userOptions.opposite; // needed in setOptions

	                /**
	                 * The side on which the axis is rendered. 0 is top, 1 is right, 2 is
	                 * bottom and 3 is left.
	                 *
	                 * @name side
	                 * @memberOf Axis
	                 * @type {Number}
	                 */
	                axis.side = userOptions.side || (axis.horiz ?
	                    (axis.opposite ? 0 : 2) : // top : bottom
	                    (axis.opposite ? 1 : 3)); // right : left

	                axis.setOptions(userOptions);


	                var options = this.options,
	                    type = options.type,
	                    isDatetimeAxis = type === 'datetime';

	                axis.labelFormatter = options.labels.formatter ||
	                    axis.defaultLabelFormatter; // can be overwritten by dynamic format


	                // Flag, stagger lines or not
	                axis.userOptions = userOptions;

	                //axis.axisTitleMargin = undefined,// = options.title.margin,
	                axis.minPixelPadding = 0;


	                /**
	                 * Whether the axis is reversed. Based on the `axis.reversed`,
	                 * option, but inverted charts have reversed xAxis by default.
	                 *
	                 * @name reversed
	                 * @memberOf Axis
	                 * @type {Boolean}
	                 */
	                axis.reversed = options.reversed;
	                axis.visible = options.visible !== false;
	                axis.zoomEnabled = options.zoomEnabled !== false;

	                // Initial categories
	                axis.hasNames = type === 'category' || options.categories === true;
	                axis.categories = options.categories || axis.hasNames;
	                axis.names = axis.names || []; // Preserve on update (#3830)

	                // Elements
	                //axis.axisGroup = undefined;
	                //axis.gridGroup = undefined;
	                //axis.axisTitle = undefined;
	                //axis.axisLine = undefined;

	                // Placeholder for plotlines and plotbands groups
	                axis.plotLinesAndBandsGroups = {};

	                // Shorthand types
	                axis.isLog = type === 'logarithmic';
	                axis.isDatetimeAxis = isDatetimeAxis;
	                axis.positiveValuesOnly = axis.isLog && !axis.allowNegativeLog;

	                // Flag, if axis is linked to another axis
	                axis.isLinked = defined(options.linkedTo);
	                // Linked axis.
	                //axis.linkedParent = undefined;

	                // Major ticks
	                axis.ticks = {};
	                axis.labelEdge = [];
	                // Minor ticks
	                axis.minorTicks = {};

	                // List of plotLines/Bands
	                axis.plotLinesAndBands = [];

	                // Alternate bands
	                axis.alternateBands = {};

	                // Axis metrics
	                //axis.left = undefined;
	                //axis.top = undefined;
	                //axis.width = undefined;
	                //axis.height = undefined;
	                //axis.bottom = undefined;
	                //axis.right = undefined;
	                //axis.transA = undefined;
	                //axis.transB = undefined;
	                //axis.oldTransA = undefined;
	                axis.len = 0;
	                //axis.oldMin = undefined;
	                //axis.oldMax = undefined;
	                //axis.oldUserMin = undefined;
	                //axis.oldUserMax = undefined;
	                //axis.oldAxisLength = undefined;
	                axis.minRange = axis.userMinRange = options.minRange || options.maxZoom;
	                axis.range = options.range;
	                axis.offset = options.offset || 0;


	                // Dictionary for stacks
	                axis.stacks = {};
	                axis.oldStacks = {};
	                axis.stacksTouched = 0;

	                // Min and max in the data
	                //axis.dataMin = undefined,
	                //axis.dataMax = undefined,

	                /**
	                 * The maximum value of the axis. In a logarithmic axis, this is the
	                 * logarithm of the real value, and the real value can be obtained from
	                 * {@link Axis#getExtremes}.
	                 *
	                 * @name max
	                 * @memberOf Axis
	                 * @type {Number}
	                 */
	                axis.max = null;
	                /**
	                 * The minimum value of the axis. In a logarithmic axis, this is the
	                 * logarithm of the real value, and the real value can be obtained from
	                 * {@link Axis#getExtremes}.
	                 *
	                 * @name min
	                 * @memberOf Axis
	                 * @type {Number}
	                 */
	                axis.min = null;

	                // User set min and max
	                //axis.userMin = undefined,
	                //axis.userMax = undefined,

	                /**
	                 * The processed crosshair options.
	                 *
	                 * @name crosshair
	                 * @memberOf Axis
	                 * @type {AxisCrosshairOptions}
	                 */
	                axis.crosshair = pick(
	                    options.crosshair,
	                    splat(chart.options.tooltip.crosshairs)[isXAxis ? 0 : 1],
	                    false
	                );

	                var events = axis.options.events;

	                // Register. Don't add it again on Axis.update().
	                if (inArray(axis, chart.axes) === -1) { // 
	                    if (isXAxis) { // #2713
	                        chart.axes.splice(chart.xAxis.length, 0, axis);
	                    } else {
	                        chart.axes.push(axis);
	                    }

	                    chart[axis.coll].push(axis);
	                }

	                /**
	                 * All series associated to the axis.
	                 *
	                 * @name series
	                 * @memberOf Axis
	                 * @type {Array.<Series>}
	                 */
	                axis.series = axis.series || []; // populated by Series

	                // Reversed axis
	                if (
	                    chart.inverted &&
	                    !axis.isZAxis &&
	                    isXAxis &&
	                    axis.reversed === undefined
	                ) {
	                    axis.reversed = true;
	                }

	                // register event listeners
	                objectEach(events, function(event, eventType) {
	                    addEvent(axis, eventType, event);
	                });

	                // extend logarithmic axis
	                axis.lin2log = options.linearToLogConverter || axis.lin2log;
	                if (axis.isLog) {
	                    axis.val2lin = axis.log2lin;
	                    axis.lin2val = axis.lin2log;
	                }
	            },

	            /**
	             * Merge and set options.
	             *
	             * @private
	             */
	            setOptions: function(userOptions) {
	                this.options = merge(
	                    this.defaultOptions,
	                    this.coll === 'yAxis' && this.defaultYAxisOptions, [
	                        this.defaultTopAxisOptions,
	                        this.defaultRightAxisOptions,
	                        this.defaultBottomAxisOptions,
	                        this.defaultLeftAxisOptions
	                    ][this.side],
	                    merge(
	                        defaultOptions[this.coll], // if set in setOptions (#1053)
	                        userOptions
	                    )
	                );
	            },

	            /**
	             * The default label formatter. The context is a special config object for
	             * the label. In apps, use the {@link
	             * https://api.highcharts.com/highcharts/xAxis.labels.formatter|
	             * labels.formatter} instead except when a modification is needed.
	             *
	             * @private
	             */
	            defaultLabelFormatter: function() {
	                var axis = this.axis,
	                    value = this.value,
	                    categories = axis.categories,
	                    dateTimeLabelFormat = this.dateTimeLabelFormat,
	                    lang = defaultOptions.lang,
	                    numericSymbols = lang.numericSymbols,
	                    numSymMagnitude = lang.numericSymbolMagnitude || 1000,
	                    i = numericSymbols && numericSymbols.length,
	                    multi,
	                    ret,
	                    formatOption = axis.options.labels.format,

	                    // make sure the same symbol is added for all labels on a linear
	                    // axis
	                    numericSymbolDetector = axis.isLog ?
	                    Math.abs(value) :
	                    axis.tickInterval;

	                if (formatOption) {
	                    ret = format(formatOption, this);

	                } else if (categories) {
	                    ret = value;

	                } else if (dateTimeLabelFormat) { // datetime axis
	                    ret = H.dateFormat(dateTimeLabelFormat, value);

	                } else if (i && numericSymbolDetector >= 1000) {
	                    // Decide whether we should add a numeric symbol like k (thousands)
	                    // or M (millions). If we are to enable this in tooltip or other
	                    // places as well, we can move this logic to the numberFormatter and
	                    // enable it by a parameter.
	                    while (i-- && ret === undefined) {
	                        multi = Math.pow(numSymMagnitude, i + 1);
	                        if (
	                            numericSymbolDetector >= multi &&
	                            (value * 10) % multi === 0 &&
	                            numericSymbols[i] !== null &&
	                            value !== 0
	                        ) { // #5480
	                            ret = H.numberFormat(value / multi, -1) + numericSymbols[i];
	                        }
	                    }
	                }

	                if (ret === undefined) {
	                    if (Math.abs(value) >= 10000) { // add thousands separators
	                        ret = H.numberFormat(value, -1);
	                    } else { // small numbers
	                        ret = H.numberFormat(value, -1, undefined, ''); // #2466
	                    }
	                }

	                return ret;
	            },

	            /**
	             * Get the minimum and maximum for the series of each axis. The function
	             * analyzes the axis series and updates `this.dataMin` and `this.dataMax`.
	             *
	             * @private
	             */
	            getSeriesExtremes: function() {
	                var axis = this,
	                    chart = axis.chart;
	                axis.hasVisibleSeries = false;

	                // Reset properties in case we're redrawing (#3353)
	                axis.dataMin = axis.dataMax = axis.threshold = null;
	                axis.softThreshold = !axis.isXAxis;

	                if (axis.buildStacks) {
	                    axis.buildStacks();
	                }

	                // loop through this axis' series
	                each(axis.series, function(series) {

	                    if (series.visible || !chart.options.chart.ignoreHiddenSeries) {

	                        var seriesOptions = series.options,
	                            xData,
	                            threshold = seriesOptions.threshold,
	                            seriesDataMin,
	                            seriesDataMax;

	                        axis.hasVisibleSeries = true;

	                        // Validate threshold in logarithmic axes
	                        if (axis.positiveValuesOnly && threshold <= 0) {
	                            threshold = null;
	                        }

	                        // Get dataMin and dataMax for X axes
	                        if (axis.isXAxis) {
	                            xData = series.xData;
	                            if (xData.length) {
	                                // If xData contains values which is not numbers, then
	                                // filter them out. To prevent performance hit, we only
	                                // do this after we have already found seriesDataMin
	                                // because in most cases all data is valid. #5234.
	                                seriesDataMin = arrayMin(xData);
	                                if (!isNumber(seriesDataMin) &&
	                                    !(seriesDataMin instanceof Date) // #5010
	                                ) {
	                                    xData = grep(xData, function(x) {
	                                        return isNumber(x);
	                                    });
	                                    seriesDataMin = arrayMin(xData); // Do it again with valid data
	                                }

	                                axis.dataMin = Math.min(
	                                    pick(axis.dataMin, xData[0]),
	                                    seriesDataMin
	                                );
	                                axis.dataMax = Math.max(
	                                    pick(axis.dataMax, xData[0]),
	                                    arrayMax(xData)
	                                );

	                            }

	                            // Get dataMin and dataMax for Y axes, as well as handle
	                            // stacking and processed data
	                        } else {

	                            // Get this particular series extremes
	                            series.getExtremes();
	                            seriesDataMax = series.dataMax;
	                            seriesDataMin = series.dataMin;

	                            // Get the dataMin and dataMax so far. If percentage is
	                            // used, the min and max are always 0 and 100. If
	                            // seriesDataMin and seriesDataMax is null, then series
	                            // doesn't have active y data, we continue with nulls
	                            if (defined(seriesDataMin) && defined(seriesDataMax)) {
	                                axis.dataMin = Math.min(
	                                    pick(axis.dataMin, seriesDataMin),
	                                    seriesDataMin
	                                );
	                                axis.dataMax = Math.max(
	                                    pick(axis.dataMax, seriesDataMax),
	                                    seriesDataMax
	                                );
	                            }

	                            // Adjust to threshold
	                            if (defined(threshold)) {
	                                axis.threshold = threshold;
	                            }
	                            // If any series has a hard threshold, it takes precedence
	                            if (!seriesOptions.softThreshold ||
	                                axis.positiveValuesOnly
	                            ) {
	                                axis.softThreshold = false;
	                            }
	                        }
	                    }
	                });
	            },

	            /**
	             * Translate from axis value to pixel position on the chart, or back. Use
	             * the `toPixels` and `toValue` functions in applications.
	             *
	             * @private
	             */
	            translate: function(val, backwards, cvsCoord, old, handleLog, pointPlacement) {
	                var axis = this.linkedParent || this, // #1417
	                    sign = 1,
	                    cvsOffset = 0,
	                    localA = old ? axis.oldTransA : axis.transA,
	                    localMin = old ? axis.oldMin : axis.min,
	                    returnValue,
	                    minPixelPadding = axis.minPixelPadding,
	                    doPostTranslate = (axis.isOrdinal || axis.isBroken || (axis.isLog && handleLog)) && axis.lin2val;

	                if (!localA) {
	                    localA = axis.transA;
	                }

	                // In vertical axes, the canvas coordinates start from 0 at the top like in
	                // SVG.
	                if (cvsCoord) {
	                    sign *= -1; // canvas coordinates inverts the value
	                    cvsOffset = axis.len;
	                }

	                // Handle reversed axis
	                if (axis.reversed) {
	                    sign *= -1;
	                    cvsOffset -= sign * (axis.sector || axis.len);
	                }

	                // From pixels to value
	                if (backwards) { // reverse translation

	                    val = val * sign + cvsOffset;
	                    val -= minPixelPadding;
	                    returnValue = val / localA + localMin; // from chart pixel to value
	                    if (doPostTranslate) { // log and ordinal axes
	                        returnValue = axis.lin2val(returnValue);
	                    }

	                    // From value to pixels
	                } else {
	                    if (doPostTranslate) { // log and ordinal axes
	                        val = axis.val2lin(val);
	                    }
	                    returnValue = sign * (val - localMin) * localA + cvsOffset +
	                        (sign * minPixelPadding) +
	                        (isNumber(pointPlacement) ? localA * pointPlacement : 0);
	                }

	                return returnValue;
	            },

	            /**
	             * Translate a value in terms of axis units into pixels within the chart.
	             * 
	             * @param  {Number} value
	             *         A value in terms of axis units.
	             * @param  {Boolean} paneCoordinates
	             *         Whether to return the pixel coordinate relative to the chart or
	             *         just the axis/pane itself.
	             * @return {Number} Pixel position of the value on the chart or axis.
	             */
	            toPixels: function(value, paneCoordinates) {
	                return this.translate(value, false, !this.horiz, null, true) +
	                    (paneCoordinates ? 0 : this.pos);
	            },

	            /**
	             * Translate a pixel position along the axis to a value in terms of axis
	             * units.
	             * @param  {Number} pixel
	             *         The pixel value coordinate.
	             * @param  {Boolean} paneCoordiantes
	             *         Whether the input pixel is relative to the chart or just the
	             *         axis/pane itself.
	             * @return {Number} The axis value.
	             */
	            toValue: function(pixel, paneCoordinates) {
	                return this.translate(
	                    pixel - (paneCoordinates ? 0 : this.pos),
	                    true, !this.horiz,
	                    null,
	                    true
	                );
	            },

	            /**
	             * Create the path for a plot line that goes from the given value on
	             * this axis, across the plot to the opposite side. Also used internally for
	             * grid lines and crosshairs.
	             * 
	             * @param  {Number} value
	             *         Axis value.
	             * @param  {Number} [lineWidth=1]
	             *         Used for calculation crisp line coordinates.
	             * @param  {Boolean} [old=false]
	             *         Use old coordinates (for resizing and rescaling).
	             * @param  {Boolean} [force=false]
	             *         If `false`, the function will return null when it falls outside
	             *         the axis bounds.
	             * @param  {Number} [translatedValue]
	             *         If given, return the plot line path of a pixel position on the
	             *         axis.
	             *
	             * @return {Array.<String|Number>}
	             *         The SVG path definition for the plot line.
	             */
	            getPlotLinePath: function(value, lineWidth, old, force, translatedValue) {
	                var axis = this,
	                    chart = axis.chart,
	                    axisLeft = axis.left,
	                    axisTop = axis.top,
	                    x1,
	                    y1,
	                    x2,
	                    y2,
	                    cHeight = (old && chart.oldChartHeight) || chart.chartHeight,
	                    cWidth = (old && chart.oldChartWidth) || chart.chartWidth,
	                    skip,
	                    transB = axis.transB,
	                    /**
	                     * Check if x is between a and b. If not, either move to a/b or skip,
	                     * depending on the force parameter.
	                     */
	                    between = function(x, a, b) {
	                        if (x < a || x > b) {
	                            if (force) {
	                                x = Math.min(Math.max(a, x), b);
	                            } else {
	                                skip = true;
	                            }
	                        }
	                        return x;
	                    };

	                translatedValue = pick(translatedValue, axis.translate(value, null, null, old));
	                x1 = x2 = Math.round(translatedValue + transB);
	                y1 = y2 = Math.round(cHeight - translatedValue - transB);
	                if (!isNumber(translatedValue)) { // no min or max
	                    skip = true;

	                } else if (axis.horiz) {
	                    y1 = axisTop;
	                    y2 = cHeight - axis.bottom;
	                    x1 = x2 = between(x1, axisLeft, axisLeft + axis.width);
	                } else {
	                    x1 = axisLeft;
	                    x2 = cWidth - axis.right;
	                    y1 = y2 = between(y1, axisTop, axisTop + axis.height);
	                }
	                return skip && !force ?
	                    null :
	                    chart.renderer.crispLine(['M', x1, y1, 'L', x2, y2], lineWidth || 1);
	            },

	            /**
	             * Internal function to et the tick positions of a linear axis to round
	             * values like whole tens or every five.
	             *
	             * @param  {Number} tickInterval
	             *         The normalized tick interval
	             * @param  {Number} min
	             *         Axis minimum.
	             * @param  {Number} max
	             *         Axis maximum.
	             *
	             * @return {Array.<Number>}
	             *         An array of axis values where ticks should be placed.
	             */
	            getLinearTickPositions: function(tickInterval, min, max) {
	                var pos,
	                    lastPos,
	                    roundedMin = correctFloat(Math.floor(min / tickInterval) * tickInterval),
	                    roundedMax = correctFloat(Math.ceil(max / tickInterval) * tickInterval),
	                    tickPositions = [];

	                // For single points, add a tick regardless of the relative position
	                // (#2662, #6274)
	                if (this.single) {
	                    return [min];
	                }

	                // Populate the intermediate values
	                pos = roundedMin;
	                while (pos <= roundedMax) {

	                    // Place the tick on the rounded value
	                    tickPositions.push(pos);

	                    // Always add the raw tickInterval, not the corrected one.
	                    pos = correctFloat(pos + tickInterval);

	                    // If the interval is not big enough in the current min - max range to actually increase
	                    // the loop variable, we need to break out to prevent endless loop. Issue #619
	                    if (pos === lastPos) {
	                        break;
	                    }

	                    // Record the last value
	                    lastPos = pos;
	                }
	                return tickPositions;
	            },

	            /**
	             * Internal function to return the minor tick positions. For logarithmic
	             * axes, the same logic as for major ticks is reused.
	             *
	             * @return {Array.<Number>}
	             *         An array of axis values where ticks should be placed.
	             */
	            getMinorTickPositions: function() {
	                var axis = this,
	                    options = axis.options,
	                    tickPositions = axis.tickPositions,
	                    minorTickInterval = axis.minorTickInterval,
	                    minorTickPositions = [],
	                    pos,
	                    pointRangePadding = axis.pointRangePadding || 0,
	                    min = axis.min - pointRangePadding, // #1498
	                    max = axis.max + pointRangePadding, // #1498
	                    range = max - min;

	                // If minor ticks get too dense, they are hard to read, and may cause long running script. So we don't draw them.
	                if (range && range / minorTickInterval < axis.len / 3) { // #3875

	                    if (axis.isLog) {
	                        // For each interval in the major ticks, compute the minor ticks
	                        // separately.
	                        each(this.paddedTicks, function(pos, i, paddedTicks) {
	                            if (i) {
	                                minorTickPositions.push.apply(
	                                    minorTickPositions,
	                                    axis.getLogTickPositions(
	                                        minorTickInterval,
	                                        paddedTicks[i - 1],
	                                        paddedTicks[i],
	                                        true
	                                    )
	                                );
	                            }
	                        });

	                    } else if (axis.isDatetimeAxis && options.minorTickInterval === 'auto') { // #1314
	                        minorTickPositions = minorTickPositions.concat(
	                            axis.getTimeTicks(
	                                axis.normalizeTimeTickInterval(minorTickInterval),
	                                min,
	                                max,
	                                options.startOfWeek
	                            )
	                        );
	                    } else {
	                        for (
	                            pos = min + (tickPositions[0] - min) % minorTickInterval; pos <= max; pos += minorTickInterval
	                        ) {
	                            // Very, very, tight grid lines (#5771)
	                            if (pos === minorTickPositions[0]) {
	                                break;
	                            }
	                            minorTickPositions.push(pos);
	                        }
	                    }
	                }

	                if (minorTickPositions.length !== 0) {
	                    axis.trimTicks(minorTickPositions); // #3652 #3743 #1498 #6330
	                }
	                return minorTickPositions;
	            },

	            /**
	             * Adjust the min and max for the minimum range. Keep in mind that the series data is
	             * not yet processed, so we don't have information on data cropping and grouping, or
	             * updated axis.pointRange or series.pointRange. The data can't be processed until
	             * we have finally established min and max.
	             *
	             * @private
	             */
	            adjustForMinRange: function() {
	                var axis = this,
	                    options = axis.options,
	                    min = axis.min,
	                    max = axis.max,
	                    zoomOffset,
	                    spaceAvailable,
	                    closestDataRange,
	                    i,
	                    distance,
	                    xData,
	                    loopLength,
	                    minArgs,
	                    maxArgs,
	                    minRange;

	                // Set the automatic minimum range based on the closest point distance
	                if (axis.isXAxis && axis.minRange === undefined && !axis.isLog) {

	                    if (defined(options.min) || defined(options.max)) {
	                        axis.minRange = null; // don't do this again

	                    } else {

	                        // Find the closest distance between raw data points, as opposed to
	                        // closestPointRange that applies to processed points (cropped and grouped)
	                        each(axis.series, function(series) {
	                            xData = series.xData;
	                            loopLength = series.xIncrement ? 1 : xData.length - 1;
	                            for (i = loopLength; i > 0; i--) {
	                                distance = xData[i] - xData[i - 1];
	                                if (closestDataRange === undefined || distance < closestDataRange) {
	                                    closestDataRange = distance;
	                                }
	                            }
	                        });
	                        axis.minRange = Math.min(closestDataRange * 5, axis.dataMax - axis.dataMin);
	                    }
	                }

	                // if minRange is exceeded, adjust
	                if (max - min < axis.minRange) {

	                    spaceAvailable = axis.dataMax - axis.dataMin >= axis.minRange;
	                    minRange = axis.minRange;
	                    zoomOffset = (minRange - max + min) / 2;

	                    // if min and max options have been set, don't go beyond it
	                    minArgs = [min - zoomOffset, pick(options.min, min - zoomOffset)];
	                    if (spaceAvailable) { // if space is available, stay within the data range
	                        minArgs[2] = axis.isLog ? axis.log2lin(axis.dataMin) : axis.dataMin;
	                    }
	                    min = arrayMax(minArgs);

	                    maxArgs = [min + minRange, pick(options.max, min + minRange)];
	                    if (spaceAvailable) { // if space is availabe, stay within the data range
	                        maxArgs[2] = axis.isLog ? axis.log2lin(axis.dataMax) : axis.dataMax;
	                    }

	                    max = arrayMin(maxArgs);

	                    // now if the max is adjusted, adjust the min back
	                    if (max - min < minRange) {
	                        minArgs[0] = max - minRange;
	                        minArgs[1] = pick(options.min, max - minRange);
	                        min = arrayMax(minArgs);
	                    }
	                }

	                // Record modified extremes
	                axis.min = min;
	                axis.max = max;
	            },

	            /**
	             * Find the closestPointRange across all series.
	             *
	             * @private
	             */
	            getClosest: function() {
	                var ret;

	                if (this.categories) {
	                    ret = 1;
	                } else {
	                    each(this.series, function(series) {
	                        var seriesClosest = series.closestPointRange,
	                            visible = series.visible ||
	                            !series.chart.options.chart.ignoreHiddenSeries;

	                        if (!series.noSharedTooltip &&
	                            defined(seriesClosest) &&
	                            visible
	                        ) {
	                            ret = defined(ret) ?
	                                Math.min(ret, seriesClosest) :
	                                seriesClosest;
	                        }
	                    });
	                }
	                return ret;
	            },

	            /**
	             * When a point name is given and no x, search for the name in the existing
	             * categories, or if categories aren't provided, search names or create a
	             * new category (#2522).
	             *
	             * @private
	             *
	             * @param  {Point}
	             *         The point to inspect.
	             *
	             * @return {Number}
	             *         The X value that the point is given.
	             */
	            nameToX: function(point) {
	                var explicitCategories = isArray(this.categories),
	                    names = explicitCategories ? this.categories : this.names,
	                    nameX = point.options.x,
	                    x;

	                point.series.requireSorting = false;

	                if (!defined(nameX)) {
	                    nameX = this.options.uniqueNames === false ?
	                        point.series.autoIncrement() :
	                        inArray(point.name, names);
	                }
	                if (nameX === -1) { // The name is not found in currenct categories
	                    if (!explicitCategories) {
	                        x = names.length;
	                    }
	                } else {
	                    x = nameX;
	                }

	                // Write the last point's name to the names array
	                if (x !== undefined) {
	                    this.names[x] = point.name;
	                }

	                return x;
	            },

	            /**
	             * When changes have been done to series data, update the axis.names.
	             *
	             * @private
	             */
	            updateNames: function() {
	                var axis = this;

	                if (this.names.length > 0) {
	                    this.names.length = 0;
	                    this.minRange = this.userMinRange; // Reset
	                    each(this.series || [], function(series) {

	                        // Reset incrementer (#5928)
	                        series.xIncrement = null;

	                        // When adding a series, points are not yet generated
	                        if (!series.points || series.isDirtyData) {
	                            series.processData();
	                            series.generatePoints();
	                        }

	                        each(series.points, function(point, i) {
	                            var x;
	                            if (point.options) {
	                                x = axis.nameToX(point);
	                                if (x !== undefined && x !== point.x) {
	                                    point.x = x;
	                                    series.xData[i] = x;
	                                }
	                            }
	                        });
	                    });
	                }
	            },

	            /**
	             * Update translation information.
	             *
	             * @private
	             */
	            setAxisTranslation: function(saveOld) {
	                var axis = this,
	                    range = axis.max - axis.min,
	                    pointRange = axis.axisPointRange || 0,
	                    closestPointRange,
	                    minPointOffset = 0,
	                    pointRangePadding = 0,
	                    linkedParent = axis.linkedParent,
	                    ordinalCorrection,
	                    hasCategories = !!axis.categories,
	                    transA = axis.transA,
	                    isXAxis = axis.isXAxis;

	                // Adjust translation for padding. Y axis with categories need to go through the same (#1784).
	                if (isXAxis || hasCategories || pointRange) {

	                    // Get the closest points
	                    closestPointRange = axis.getClosest();

	                    if (linkedParent) {
	                        minPointOffset = linkedParent.minPointOffset;
	                        pointRangePadding = linkedParent.pointRangePadding;
	                    } else {
	                        each(axis.series, function(series) {
	                            var seriesPointRange = hasCategories ?
	                                1 :
	                                (isXAxis ?
	                                    pick(series.options.pointRange, closestPointRange, 0) :
	                                    (axis.axisPointRange || 0)), // #2806
	                                pointPlacement = series.options.pointPlacement;

	                            pointRange = Math.max(pointRange, seriesPointRange);

	                            if (!axis.single) {
	                                // minPointOffset is the value padding to the left of the axis in order to make
	                                // room for points with a pointRange, typically columns. When the pointPlacement option
	                                // is 'between' or 'on', this padding does not apply.
	                                minPointOffset = Math.max(
	                                    minPointOffset,
	                                    isString(pointPlacement) ? 0 : seriesPointRange / 2
	                                );

	                                // Determine the total padding needed to the length of the axis to make room for the
	                                // pointRange. If the series' pointPlacement is 'on', no padding is added.
	                                pointRangePadding = Math.max(
	                                    pointRangePadding,
	                                    pointPlacement === 'on' ? 0 : seriesPointRange
	                                );
	                            }
	                        });
	                    }

	                    // Record minPointOffset and pointRangePadding
	                    ordinalCorrection = axis.ordinalSlope && closestPointRange ? axis.ordinalSlope / closestPointRange : 1; // #988, #1853
	                    axis.minPointOffset = minPointOffset = minPointOffset * ordinalCorrection;
	                    axis.pointRangePadding = pointRangePadding = pointRangePadding * ordinalCorrection;

	                    // pointRange means the width reserved for each point, like in a column chart
	                    axis.pointRange = Math.min(pointRange, range);

	                    // closestPointRange means the closest distance between points. In columns
	                    // it is mostly equal to pointRange, but in lines pointRange is 0 while closestPointRange
	                    // is some other value
	                    if (isXAxis) {
	                        axis.closestPointRange = closestPointRange;
	                    }
	                }

	                // Secondary values
	                if (saveOld) {
	                    axis.oldTransA = transA;
	                }
	                axis.translationSlope = axis.transA = transA =
	                    axis.options.staticScale ||
	                    axis.len / ((range + pointRangePadding) || 1);
	                axis.transB = axis.horiz ? axis.left : axis.bottom; // translation addend
	                axis.minPixelPadding = transA * minPointOffset;
	            },

	            minFromRange: function() {
	                return this.max - this.range;
	            },

	            /**
	             * Set the tick positions to round values and optionally extend the extremes
	             * to the nearest tick.
	             *
	             * @private
	             */
	            setTickInterval: function(secondPass) {
	                var axis = this,
	                    chart = axis.chart,
	                    options = axis.options,
	                    isLog = axis.isLog,
	                    log2lin = axis.log2lin,
	                    isDatetimeAxis = axis.isDatetimeAxis,
	                    isXAxis = axis.isXAxis,
	                    isLinked = axis.isLinked,
	                    maxPadding = options.maxPadding,
	                    minPadding = options.minPadding,
	                    length,
	                    linkedParentExtremes,
	                    tickIntervalOption = options.tickInterval,
	                    minTickInterval,
	                    tickPixelIntervalOption = options.tickPixelInterval,
	                    categories = axis.categories,
	                    threshold = axis.threshold,
	                    softThreshold = axis.softThreshold,
	                    thresholdMin,
	                    thresholdMax,
	                    hardMin,
	                    hardMax;

	                if (!isDatetimeAxis && !categories && !isLinked) {
	                    this.getTickAmount();
	                }

	                // Min or max set either by zooming/setExtremes or initial options
	                hardMin = pick(axis.userMin, options.min);
	                hardMax = pick(axis.userMax, options.max);

	                // Linked axis gets the extremes from the parent axis
	                if (isLinked) {
	                    axis.linkedParent = chart[axis.coll][options.linkedTo];
	                    linkedParentExtremes = axis.linkedParent.getExtremes();
	                    axis.min = pick(linkedParentExtremes.min, linkedParentExtremes.dataMin);
	                    axis.max = pick(linkedParentExtremes.max, linkedParentExtremes.dataMax);
	                    if (options.type !== axis.linkedParent.options.type) {
	                        H.error(11, 1); // Can't link axes of different type
	                    }

	                    // Initial min and max from the extreme data values
	                } else {

	                    // Adjust to hard threshold
	                    if (!softThreshold && defined(threshold)) {
	                        if (axis.dataMin >= threshold) {
	                            thresholdMin = threshold;
	                            minPadding = 0;
	                        } else if (axis.dataMax <= threshold) {
	                            thresholdMax = threshold;
	                            maxPadding = 0;
	                        }
	                    }

	                    axis.min = pick(hardMin, thresholdMin, axis.dataMin);
	                    axis.max = pick(hardMax, thresholdMax, axis.dataMax);

	                }

	                if (isLog) {
	                    if (
	                        axis.positiveValuesOnly &&
	                        !secondPass &&
	                        Math.min(axis.min, pick(axis.dataMin, axis.min)) <= 0
	                    ) { // #978
	                        H.error(10, 1); // Can't plot negative values on log axis
	                    }
	                    // The correctFloat cures #934, float errors on full tens. But it
	                    // was too aggressive for #4360 because of conversion back to lin,
	                    // therefore use precision 15.
	                    axis.min = correctFloat(log2lin(axis.min), 15);
	                    axis.max = correctFloat(log2lin(axis.max), 15);
	                }

	                // handle zoomed range
	                if (axis.range && defined(axis.max)) {
	                    axis.userMin = axis.min = hardMin = Math.max(axis.dataMin, axis.minFromRange()); // #618, #6773
	                    axis.userMax = hardMax = axis.max;

	                    axis.range = null; // don't use it when running setExtremes
	                }

	                // Hook for Highstock Scroller. Consider combining with beforePadding.
	                fireEvent(axis, 'foundExtremes');

	                // Hook for adjusting this.min and this.max. Used by bubble series.
	                if (axis.beforePadding) {
	                    axis.beforePadding();
	                }

	                // adjust min and max for the minimum range
	                axis.adjustForMinRange();

	                // Pad the values to get clear of the chart's edges. To avoid tickInterval taking the padding
	                // into account, we do this after computing tick interval (#1337).
	                if (!categories && !axis.axisPointRange && !axis.usePercentage && !isLinked && defined(axis.min) && defined(axis.max)) {
	                    length = axis.max - axis.min;
	                    if (length) {
	                        if (!defined(hardMin) && minPadding) {
	                            axis.min -= length * minPadding;
	                        }
	                        if (!defined(hardMax) && maxPadding) {
	                            axis.max += length * maxPadding;
	                        }
	                    }
	                }

	                // Handle options for floor, ceiling, softMin and softMax (#6359)
	                if (isNumber(options.softMin)) {
	                    axis.min = Math.min(axis.min, options.softMin);
	                }
	                if (isNumber(options.softMax)) {
	                    axis.max = Math.max(axis.max, options.softMax);
	                }
	                if (isNumber(options.floor)) {
	                    axis.min = Math.max(axis.min, options.floor);
	                }
	                if (isNumber(options.ceiling)) {
	                    axis.max = Math.min(axis.max, options.ceiling);
	                }


	                // When the threshold is soft, adjust the extreme value only if
	                // the data extreme and the padded extreme land on either side of the threshold. For example,
	                // a series of [0, 1, 2, 3] would make the yAxis add a tick for -1 because of the
	                // default minPadding and startOnTick options. This is prevented by the softThreshold
	                // option.
	                if (softThreshold && defined(axis.dataMin)) {
	                    threshold = threshold || 0;
	                    if (!defined(hardMin) && axis.min < threshold && axis.dataMin >= threshold) {
	                        axis.min = threshold;
	                    } else if (!defined(hardMax) && axis.max > threshold && axis.dataMax <= threshold) {
	                        axis.max = threshold;
	                    }
	                }


	                // get tickInterval
	                if (axis.min === axis.max || axis.min === undefined || axis.max === undefined) {
	                    axis.tickInterval = 1;
	                } else if (isLinked && !tickIntervalOption &&
	                    tickPixelIntervalOption === axis.linkedParent.options.tickPixelInterval) {
	                    axis.tickInterval = tickIntervalOption = axis.linkedParent.tickInterval;
	                } else {
	                    axis.tickInterval = pick(
	                        tickIntervalOption,
	                        this.tickAmount ? ((axis.max - axis.min) / Math.max(this.tickAmount - 1, 1)) : undefined,
	                        categories ? // for categoried axis, 1 is default, for linear axis use tickPix
	                        1 :
	                        // don't let it be more than the data range
	                        (axis.max - axis.min) * tickPixelIntervalOption / Math.max(axis.len, tickPixelIntervalOption)
	                    );
	                }

	                // Now we're finished detecting min and max, crop and group series data. This
	                // is in turn needed in order to find tick positions in ordinal axes.
	                if (isXAxis && !secondPass) {
	                    each(axis.series, function(series) {
	                        series.processData(axis.min !== axis.oldMin || axis.max !== axis.oldMax);
	                    });
	                }

	                // set the translation factor used in translate function
	                axis.setAxisTranslation(true);

	                // hook for ordinal axes and radial axes
	                if (axis.beforeSetTickPositions) {
	                    axis.beforeSetTickPositions();
	                }

	                // hook for extensions, used in Highstock ordinal axes
	                if (axis.postProcessTickInterval) {
	                    axis.tickInterval = axis.postProcessTickInterval(axis.tickInterval);
	                }

	                // In column-like charts, don't cramp in more ticks than there are points (#1943, #4184)
	                if (axis.pointRange && !tickIntervalOption) {
	                    axis.tickInterval = Math.max(axis.pointRange, axis.tickInterval);
	                }

	                // Before normalizing the tick interval, handle minimum tick interval. This applies only if tickInterval is not defined.
	                minTickInterval = pick(options.minTickInterval, axis.isDatetimeAxis && axis.closestPointRange);
	                if (!tickIntervalOption && axis.tickInterval < minTickInterval) {
	                    axis.tickInterval = minTickInterval;
	                }

	                // for linear axes, get magnitude and normalize the interval
	                if (!isDatetimeAxis && !isLog && !tickIntervalOption) {
	                    axis.tickInterval = normalizeTickInterval(
	                        axis.tickInterval,
	                        null,
	                        getMagnitude(axis.tickInterval),
	                        // If the tick interval is between 0.5 and 5 and the axis max is in the order of
	                        // thousands, chances are we are dealing with years. Don't allow decimals. #3363.
	                        pick(options.allowDecimals, !(axis.tickInterval > 0.5 && axis.tickInterval < 5 && axis.max > 1000 && axis.max < 9999)), !!this.tickAmount
	                    );
	                }

	                // Prevent ticks from getting so close that we can't draw the labels
	                if (!this.tickAmount) {
	                    axis.tickInterval = axis.unsquish();
	                }

	                this.setTickPositions();
	            },

	            /**
	             * Now we have computed the normalized tickInterval, get the tick positions
	             */
	            setTickPositions: function() {

	                var options = this.options,
	                    tickPositions,
	                    tickPositionsOption = options.tickPositions,
	                    tickPositioner = options.tickPositioner,
	                    startOnTick = options.startOnTick,
	                    endOnTick = options.endOnTick;

	                // Set the tickmarkOffset
	                this.tickmarkOffset = (this.categories && options.tickmarkPlacement === 'between' &&
	                    this.tickInterval === 1) ? 0.5 : 0; // #3202


	                // get minorTickInterval
	                this.minorTickInterval = options.minorTickInterval === 'auto' && this.tickInterval ?
	                    this.tickInterval / 5 : options.minorTickInterval;

	                // When there is only one point, or all points have the same value on
	                // this axis, then min and max are equal and tickPositions.length is 0
	                // or 1. In this case, add some padding in order to center the point,
	                // but leave it with one tick. #1337.
	                this.single =
	                    this.min === this.max &&
	                    defined(this.min) &&
	                    !this.tickAmount &&
	                    (
	                        // Data is on integer (#6563)
	                        parseInt(this.min, 10) === this.min ||

	                        // Between integers and decimals are not allowed (#6274)
	                        options.allowDecimals !== false
	                    );

	                // Find the tick positions
	                this.tickPositions = tickPositions = tickPositionsOption && tickPositionsOption.slice(); // Work on a copy (#1565)
	                if (!tickPositions) {

	                    if (this.isDatetimeAxis) {
	                        tickPositions = this.getTimeTicks(
	                            this.normalizeTimeTickInterval(
	                                this.tickInterval,
	                                options.units
	                            ),
	                            this.min,
	                            this.max,
	                            options.startOfWeek,
	                            this.ordinalPositions,
	                            this.closestPointRange,
	                            true
	                        );
	                    } else if (this.isLog) {
	                        tickPositions = this.getLogTickPositions(
	                            this.tickInterval,
	                            this.min,
	                            this.max
	                        );
	                    } else {
	                        tickPositions = this.getLinearTickPositions(
	                            this.tickInterval,
	                            this.min,
	                            this.max
	                        );
	                    }

	                    // Too dense ticks, keep only the first and last (#4477)
	                    if (tickPositions.length > this.len) {
	                        tickPositions = [tickPositions[0], tickPositions.pop()];
	                    }

	                    this.tickPositions = tickPositions;

	                    // Run the tick positioner callback, that allows modifying auto tick positions.
	                    if (tickPositioner) {
	                        tickPositioner = tickPositioner.apply(this, [this.min, this.max]);
	                        if (tickPositioner) {
	                            this.tickPositions = tickPositions = tickPositioner;
	                        }
	                    }

	                }

	                // Reset min/max or remove extremes based on start/end on tick
	                this.paddedTicks = tickPositions.slice(0); // Used for logarithmic minor
	                this.trimTicks(tickPositions, startOnTick, endOnTick);
	                if (!this.isLinked) {

	                    // Substract half a unit (#2619, #2846, #2515, #3390),
	                    // but not in case of multiple ticks (#6897)
	                    if (this.single && tickPositions.length < 2) {
	                        this.min -= 0.5;
	                        this.max += 0.5;
	                    }
	                    if (!tickPositionsOption && !tickPositioner) {
	                        this.adjustTickAmount();
	                    }
	                }
	            },

	            /**
	             * Handle startOnTick and endOnTick by either adapting to padding min/max or
	             * rounded min/max. Also handle single data points.
	             *
	             * @private
	             */
	            trimTicks: function(tickPositions, startOnTick, endOnTick) {
	                var roundedMin = tickPositions[0],
	                    roundedMax = tickPositions[tickPositions.length - 1],
	                    minPointOffset = this.minPointOffset || 0;

	                if (!this.isLinked) {
	                    if (startOnTick && roundedMin !== -Infinity) { // #6502
	                        this.min = roundedMin;
	                    } else {
	                        while (this.min - minPointOffset > tickPositions[0]) {
	                            tickPositions.shift();
	                        }
	                    }

	                    if (endOnTick) {
	                        this.max = roundedMax;
	                    } else {
	                        while (this.max + minPointOffset < tickPositions[tickPositions.length - 1]) {
	                            tickPositions.pop();
	                        }
	                    }

	                    // If no tick are left, set one tick in the middle (#3195)
	                    if (tickPositions.length === 0 && defined(roundedMin)) {
	                        tickPositions.push((roundedMax + roundedMin) / 2);
	                    }
	                }
	            },

	            /**
	             * Check if there are multiple axes in the same pane.
	             *
	             * @private
	             * @return {Boolean}
	             *         True if there are other axes.
	             */
	            alignToOthers: function() {
	                var others = {}, // Whether there is another axis to pair with this one
	                    hasOther,
	                    options = this.options;

	                if (
	                    // Only if alignTicks is true
	                    this.chart.options.chart.alignTicks !== false &&
	                    options.alignTicks !== false &&

	                    // Don't try to align ticks on a log axis, they are not evenly
	                    // spaced (#6021)
	                    !this.isLog
	                ) {
	                    each(this.chart[this.coll], function(axis) {
	                        var otherOptions = axis.options,
	                            horiz = axis.horiz,
	                            key = [
	                                horiz ? otherOptions.left : otherOptions.top,
	                                otherOptions.width,
	                                otherOptions.height,
	                                otherOptions.pane
	                            ].join(',');


	                        if (axis.series.length) { // #4442
	                            if (others[key]) {
	                                hasOther = true; // #4201
	                            } else {
	                                others[key] = 1;
	                            }
	                        }
	                    });
	                }
	                return hasOther;
	            },

	            /**
	             * Find the max ticks of either the x and y axis collection, and record it
	             * in `this.tickAmount`.
	             *
	             * @private
	             */
	            getTickAmount: function() {
	                var options = this.options,
	                    tickAmount = options.tickAmount,
	                    tickPixelInterval = options.tickPixelInterval;

	                if (!defined(options.tickInterval) && this.len < tickPixelInterval && !this.isRadial &&
	                    !this.isLog && options.startOnTick && options.endOnTick) {
	                    tickAmount = 2;
	                }

	                if (!tickAmount && this.alignToOthers()) {
	                    // Add 1 because 4 tick intervals require 5 ticks (including first and last)
	                    tickAmount = Math.ceil(this.len / tickPixelInterval) + 1;
	                }

	                // For tick amounts of 2 and 3, compute five ticks and remove the intermediate ones. This
	                // prevents the axis from adding ticks that are too far away from the data extremes.
	                if (tickAmount < 4) {
	                    this.finalTickAmt = tickAmount;
	                    tickAmount = 5;
	                }

	                this.tickAmount = tickAmount;
	            },

	            /**
	             * When using multiple axes, adjust the number of ticks to match the highest
	             * number of ticks in that group.
	             *
	             * @private
	             */
	            adjustTickAmount: function() {
	                var tickInterval = this.tickInterval,
	                    tickPositions = this.tickPositions,
	                    tickAmount = this.tickAmount,
	                    finalTickAmt = this.finalTickAmt,
	                    currentTickAmount = tickPositions && tickPositions.length,
	                    i,
	                    len;

	                if (currentTickAmount < tickAmount) {
	                    while (tickPositions.length < tickAmount) {
	                        tickPositions.push(correctFloat(
	                            tickPositions[tickPositions.length - 1] + tickInterval
	                        ));
	                    }
	                    this.transA *= (currentTickAmount - 1) / (tickAmount - 1);
	                    this.max = tickPositions[tickPositions.length - 1];

	                    // We have too many ticks, run second pass to try to reduce ticks
	                } else if (currentTickAmount > tickAmount) {
	                    this.tickInterval *= 2;
	                    this.setTickPositions();
	                }

	                // The finalTickAmt property is set in getTickAmount
	                if (defined(finalTickAmt)) {
	                    i = len = tickPositions.length;
	                    while (i--) {
	                        if (
	                            (finalTickAmt === 3 && i % 2 === 1) || // Remove every other tick
	                            (finalTickAmt <= 2 && i > 0 && i < len - 1) // Remove all but first and last
	                        ) {
	                            tickPositions.splice(i, 1);
	                        }
	                    }
	                    this.finalTickAmt = undefined;
	                }
	            },

	            /**
	             * Set the scale based on data min and max, user set min and max or options.
	             * 
	             * @private
	             */
	            setScale: function() {
	                var axis = this,
	                    isDirtyData,
	                    isDirtyAxisLength;

	                axis.oldMin = axis.min;
	                axis.oldMax = axis.max;
	                axis.oldAxisLength = axis.len;

	                // set the new axisLength
	                axis.setAxisSize();
	                //axisLength = horiz ? axisWidth : axisHeight;
	                isDirtyAxisLength = axis.len !== axis.oldAxisLength;

	                // is there new data?
	                each(axis.series, function(series) {
	                    if (series.isDirtyData || series.isDirty ||
	                        series.xAxis.isDirty) { // when x axis is dirty, we need new data extremes for y as well
	                        isDirtyData = true;
	                    }
	                });

	                // do we really need to go through all this?
	                if (isDirtyAxisLength || isDirtyData || axis.isLinked || axis.forceRedraw ||
	                    axis.userMin !== axis.oldUserMin || axis.userMax !== axis.oldUserMax || axis.alignToOthers()) {

	                    if (axis.resetStacks) {
	                        axis.resetStacks();
	                    }

	                    axis.forceRedraw = false;

	                    // get data extremes if needed
	                    axis.getSeriesExtremes();

	                    // get fixed positions based on tickInterval
	                    axis.setTickInterval();

	                    // record old values to decide whether a rescale is necessary later on (#540)
	                    axis.oldUserMin = axis.userMin;
	                    axis.oldUserMax = axis.userMax;

	                    // Mark as dirty if it is not already set to dirty and extremes have changed. #595.
	                    if (!axis.isDirty) {
	                        axis.isDirty = isDirtyAxisLength || axis.min !== axis.oldMin || axis.max !== axis.oldMax;
	                    }
	                } else if (axis.cleanStacks) {
	                    axis.cleanStacks();
	                }
	            },

	            /**
	             * Set the minimum and maximum of the axes after render time. If the
	             * `startOnTick` and `endOnTick` options are true, the minimum and maximum
	             * values are rounded off to the nearest tick. To prevent this, these
	             * options can be set to false before calling setExtremes. Also, setExtremes
	             * will not allow a range lower than the `minRange` option, which by default
	             * is the range of five points.
	             * 
	             * @param  {Number} [newMin]
	             *         The new minimum value.
	             * @param  {Number} [newMax]
	             *         The new maximum value.
	             * @param  {Boolean} [redraw=true]
	             *         Whether to redraw the chart or wait for an explicit call to 
	             *         {@link Highcharts.Chart#redraw}
	             * @param  {AnimationOptions} [animation=true]
	             *         Enable or modify animations.
	             * @param  {Object} [eventArguments]
	             *         Arguments to be accessed in event handler.
	             *
	             * @sample highcharts/members/axis-setextremes/
	             *         Set extremes from a button
	             * @sample highcharts/members/axis-setextremes-datetime/
	             *         Set extremes on a datetime axis
	             * @sample highcharts/members/axis-setextremes-off-ticks/
	             *         Set extremes off ticks
	             * @sample stock/members/axis-setextremes/
	             *         Set extremes in Highstock
	             * @sample maps/members/axis-setextremes/
	             *         Set extremes in Highmaps
	             */
	            setExtremes: function(newMin, newMax, redraw, animation, eventArguments) {
	                var axis = this,
	                    chart = axis.chart;

	                redraw = pick(redraw, true); // defaults to true

	                each(axis.series, function(serie) {
	                    delete serie.kdTree;
	                });

	                // Extend the arguments with min and max
	                eventArguments = extend(eventArguments, {
	                    min: newMin,
	                    max: newMax
	                });

	                // Fire the event
	                fireEvent(axis, 'setExtremes', eventArguments, function() { // the default event handler

	                    axis.userMin = newMin;
	                    axis.userMax = newMax;
	                    axis.eventArgs = eventArguments;

	                    if (redraw) {
	                        chart.redraw(animation);
	                    }
	                });
	            },

	            /**
	             * Overridable method for zooming chart. Pulled out in a separate method to
	             * allow overriding in stock charts.
	             *
	             * @private
	             */
	            zoom: function(newMin, newMax) {
	                var dataMin = this.dataMin,
	                    dataMax = this.dataMax,
	                    options = this.options,
	                    min = Math.min(dataMin, pick(options.min, dataMin)),
	                    max = Math.max(dataMax, pick(options.max, dataMax));

	                if (newMin !== this.min || newMax !== this.max) { // #5790

	                    // Prevent pinch zooming out of range. Check for defined is for #1946. #1734.
	                    if (!this.allowZoomOutside) {
	                        // #6014, sometimes newMax will be smaller than min (or newMin will be larger than max).
	                        if (defined(dataMin)) {
	                            if (newMin < min) {
	                                newMin = min;
	                            }
	                            if (newMin > max) {
	                                newMin = max;
	                            }
	                        }
	                        if (defined(dataMax)) {
	                            if (newMax < min) {
	                                newMax = min;
	                            }
	                            if (newMax > max) {
	                                newMax = max;
	                            }
	                        }
	                    }

	                    // In full view, displaying the reset zoom button is not required
	                    this.displayBtn = newMin !== undefined || newMax !== undefined;

	                    // Do it
	                    this.setExtremes(
	                        newMin,
	                        newMax,
	                        false,
	                        undefined, {
	                            trigger: 'zoom'
	                        }
	                    );
	                }

	                return true;
	            },

	            /**
	             * Update the axis metrics.
	             *
	             * @private
	             */
	            setAxisSize: function() {
	                var chart = this.chart,
	                    options = this.options,
	                    offsets = options.offsets || [0, 0, 0, 0], // top / right / bottom / left
	                    horiz = this.horiz,

	                    // Check for percentage based input values. Rounding fixes problems
	                    // with column overflow and plot line filtering (#4898, #4899)
	                    width = this.width = Math.round(H.relativeLength(
	                        pick(
	                            options.width,
	                            chart.plotWidth - offsets[3] + offsets[1]
	                        ),
	                        chart.plotWidth
	                    )),
	                    height = this.height = Math.round(H.relativeLength(
	                        pick(
	                            options.height,
	                            chart.plotHeight - offsets[0] + offsets[2]
	                        ),
	                        chart.plotHeight
	                    )),
	                    top = this.top = Math.round(H.relativeLength(
	                        pick(options.top, chart.plotTop + offsets[0]),
	                        chart.plotHeight,
	                        chart.plotTop
	                    )),
	                    left = this.left = Math.round(H.relativeLength(
	                        pick(options.left, chart.plotLeft + offsets[3]),
	                        chart.plotWidth,
	                        chart.plotLeft
	                    ));

	                // Expose basic values to use in Series object and navigator
	                this.bottom = chart.chartHeight - height - top;
	                this.right = chart.chartWidth - width - left;

	                // Direction agnostic properties
	                this.len = Math.max(horiz ? width : height, 0); // Math.max fixes #905
	                this.pos = horiz ? left : top; // distance from SVG origin
	            },

	            /**
	             * The returned object literal from the {@link Highcharts.Axis#getExtremes}
	             * function. 
	             * @typedef {Object} Extremes
	             * @property {Number} dataMax
	             *         The maximum value of the axis' associated series.
	             * @property {Number} dataMin
	             *         The minimum value of the axis' associated series.
	             * @property {Number} max
	             *         The maximum axis value, either automatic or set manually. If the
	             *         `max` option is not set, `maxPadding` is 0 and `endOnTick` is
	             *         false, this value will be the same as `dataMax`.
	             * @property {Number} min
	             *         The minimum axis value, either automatic or set manually. If the
	             *         `min` option is not set, `minPadding` is 0 and `startOnTick` is
	             *         false, this value will be the same as `dataMin`.
	             */
	            /**
	             * Get the current extremes for the axis.
	             *
	             * @returns {Extremes}
	             * An object containing extremes information.
	             * 
	             * @sample  members/axis-getextremes/
	             *          Report extremes by click on a button
	             * @sample  maps/members/axis-getextremes/
	             *          Get extremes in Highmaps
	             */
	            getExtremes: function() {
	                var axis = this,
	                    isLog = axis.isLog,
	                    lin2log = axis.lin2log;

	                return {
	                    min: isLog ? correctFloat(lin2log(axis.min)) : axis.min,
	                    max: isLog ? correctFloat(lin2log(axis.max)) : axis.max,
	                    dataMin: axis.dataMin,
	                    dataMax: axis.dataMax,
	                    userMin: axis.userMin,
	                    userMax: axis.userMax
	                };
	            },

	            /**
	             * Get the zero plane either based on zero or on the min or max value.
	             * Used in bar and area plots.
	             *
	             * @param  {Number} threshold
	             *         The threshold in axis values.
	             *
	             * @return {Number}
	             *         The translated threshold position in terms of pixels, and
	             *         corrected to stay within the axis bounds.
	             */
	            getThreshold: function(threshold) {
	                var axis = this,
	                    isLog = axis.isLog,
	                    lin2log = axis.lin2log,
	                    realMin = isLog ? lin2log(axis.min) : axis.min,
	                    realMax = isLog ? lin2log(axis.max) : axis.max;

	                if (threshold === null) {
	                    threshold = realMin;
	                } else if (realMin > threshold) {
	                    threshold = realMin;
	                } else if (realMax < threshold) {
	                    threshold = realMax;
	                }

	                return axis.translate(threshold, 0, 1, 0, 1);
	            },

	            /**
	             * Compute auto alignment for the axis label based on which side the axis is
	             * on and the given rotation for the label.
	             *
	             * @param  {Number} rotation
	             *         The rotation in degrees as set by either the `rotation` or 
	             *         `autoRotation` options.
	             * @private
	             */
	            autoLabelAlign: function(rotation) {
	                var ret,
	                    angle = (pick(rotation, 0) - (this.side * 90) + 720) % 360;

	                if (angle > 15 && angle < 165) {
	                    ret = 'right';
	                } else if (angle > 195 && angle < 345) {
	                    ret = 'left';
	                } else {
	                    ret = 'center';
	                }
	                return ret;
	            },

	            /**
	             * Get the tick length and width for the axis based on axis options.
	             *
	             * @private
	             * 
	             * @param  {String} prefix
	             *         'tick' or 'minorTick'
	             * @return {Array.<Number>}
	             *         An array of tickLength and tickWidth
	             */
	            tickSize: function(prefix) {
	                var options = this.options,
	                    tickLength = options[prefix + 'Length'],
	                    tickWidth = pick(options[prefix + 'Width'], prefix === 'tick' && this.isXAxis ? 1 : 0); // X axis defaults to 1

	                if (tickWidth && tickLength) {
	                    // Negate the length
	                    if (options[prefix + 'Position'] === 'inside') {
	                        tickLength = -tickLength;
	                    }
	                    return [tickLength, tickWidth];
	                }

	            },

	            /**
	             * Return the size of the labels.
	             *
	             * @private
	             */
	            labelMetrics: function() {
	                var index = this.tickPositions && this.tickPositions[0] || 0;
	                return this.chart.renderer.fontMetrics(
	                    this.options.labels.style && this.options.labels.style.fontSize,
	                    this.ticks[index] && this.ticks[index].label
	                );
	            },

	            /**
	             * Prevent the ticks from getting so close we can't draw the labels. On a
	             * horizontal axis, this is handled by rotating the labels, removing ticks
	             * and adding ellipsis. On a vertical axis remove ticks and add ellipsis.
	             *
	             * @private
	             */
	            unsquish: function() {
	                var labelOptions = this.options.labels,
	                    horiz = this.horiz,
	                    tickInterval = this.tickInterval,
	                    newTickInterval = tickInterval,
	                    slotSize = this.len / (((this.categories ? 1 : 0) + this.max - this.min) / tickInterval),
	                    rotation,
	                    rotationOption = labelOptions.rotation,
	                    labelMetrics = this.labelMetrics(),
	                    step,
	                    bestScore = Number.MAX_VALUE,
	                    autoRotation,
	                    // Return the multiple of tickInterval that is needed to avoid collision
	                    getStep = function(spaceNeeded) {
	                        var step = spaceNeeded / (slotSize || 1);
	                        step = step > 1 ? Math.ceil(step) : 1;
	                        return step * tickInterval;
	                    };

	                if (horiz) {
	                    autoRotation = !labelOptions.staggerLines && !labelOptions.step && ( // #3971
	                        defined(rotationOption) ? [rotationOption] :
	                        slotSize < pick(labelOptions.autoRotationLimit, 80) && labelOptions.autoRotation
	                    );

	                    if (autoRotation) {

	                        // Loop over the given autoRotation options, and determine which gives the best score. The
	                        // best score is that with the lowest number of steps and a rotation closest to horizontal.
	                        each(autoRotation, function(rot) {
	                            var score;

	                            if (rot === rotationOption || (rot && rot >= -90 && rot <= 90)) { // #3891

	                                step = getStep(Math.abs(labelMetrics.h / Math.sin(deg2rad * rot)));

	                                score = step + Math.abs(rot / 360);

	                                if (score < bestScore) {
	                                    bestScore = score;
	                                    rotation = rot;
	                                    newTickInterval = step;
	                                }
	                            }
	                        });
	                    }

	                } else if (!labelOptions.step) { // #4411
	                    newTickInterval = getStep(labelMetrics.h);
	                }

	                this.autoRotation = autoRotation;
	                this.labelRotation = pick(rotation, rotationOption);

	                return newTickInterval;
	            },

	            /**
	             * Get the general slot width for labels/categories on this axis. This may
	             * change between the pre-render (from Axis.getOffset) and the final tick
	             * rendering and placement.
	             *
	             * @private
	             * @return {Number}
	             *         The pixel width allocated to each axis label.
	             */
	            getSlotWidth: function() {
	                // #5086, #1580, #1931
	                var chart = this.chart,
	                    horiz = this.horiz,
	                    labelOptions = this.options.labels,
	                    slotCount = Math.max(this.tickPositions.length - (this.categories ? 0 : 1), 1),
	                    marginLeft = chart.margin[3];

	                return (
	                    horiz &&
	                    (labelOptions.step || 0) < 2 &&
	                    !labelOptions.rotation && // #4415
	                    ((this.staggerLines || 1) * this.len) / slotCount
	                ) || (!horiz && (
	                    (marginLeft && (marginLeft - chart.spacing[3])) ||
	                    chart.chartWidth * 0.33
	                ));

	            },

	            /**
	             * Render the axis labels and determine whether ellipsis or rotation need
	             * to be applied.
	             *
	             * @private
	             */
	            renderUnsquish: function() {
	                var chart = this.chart,
	                    renderer = chart.renderer,
	                    tickPositions = this.tickPositions,
	                    ticks = this.ticks,
	                    labelOptions = this.options.labels,
	                    horiz = this.horiz,
	                    slotWidth = this.getSlotWidth(),
	                    innerWidth = Math.max(1, Math.round(slotWidth - 2 * (labelOptions.padding || 5))),
	                    attr = {},
	                    labelMetrics = this.labelMetrics(),
	                    textOverflowOption = labelOptions.style && labelOptions.style.textOverflow,
	                    css,
	                    maxLabelLength = 0,
	                    label,
	                    i,
	                    pos;

	                // Set rotation option unless it is "auto", like in gauges
	                if (!isString(labelOptions.rotation)) {
	                    attr.rotation = labelOptions.rotation || 0; // #4443
	                }

	                // Get the longest label length
	                each(tickPositions, function(tick) {
	                    tick = ticks[tick];
	                    if (tick && tick.labelLength > maxLabelLength) {
	                        maxLabelLength = tick.labelLength;
	                    }
	                });
	                this.maxLabelLength = maxLabelLength;


	                // Handle auto rotation on horizontal axis
	                if (this.autoRotation) {

	                    // Apply rotation only if the label is too wide for the slot, and
	                    // the label is wider than its height.
	                    if (maxLabelLength > innerWidth && maxLabelLength > labelMetrics.h) {
	                        attr.rotation = this.labelRotation;
	                    } else {
	                        this.labelRotation = 0;
	                    }

	                    // Handle word-wrap or ellipsis on vertical axis
	                } else if (slotWidth) {
	                    // For word-wrap or ellipsis
	                    css = {
	                        width: innerWidth + 'px'
	                    };

	                    if (!textOverflowOption) {
	                        css.textOverflow = 'clip';

	                        // On vertical axis, only allow word wrap if there is room for more lines.
	                        i = tickPositions.length;
	                        while (!horiz && i--) {
	                            pos = tickPositions[i];
	                            label = ticks[pos].label;
	                            if (label) {
	                                // Reset ellipsis in order to get the correct bounding box (#4070)
	                                if (label.styles && label.styles.textOverflow === 'ellipsis') {
	                                    label.css({
	                                        textOverflow: 'clip'
	                                    });

	                                    // Set the correct width in order to read the bounding box height (#4678, #5034)
	                                } else if (ticks[pos].labelLength > slotWidth) {
	                                    label.css({
	                                        width: slotWidth + 'px'
	                                    });
	                                }

	                                if (label.getBBox().height > this.len / tickPositions.length - (labelMetrics.h - labelMetrics.f)) {
	                                    label.specCss = {
	                                        textOverflow: 'ellipsis'
	                                    };
	                                }
	                            }
	                        }
	                    }
	                }


	                // Add ellipsis if the label length is significantly longer than ideal
	                if (attr.rotation) {
	                    css = {
	                        width: (maxLabelLength > chart.chartHeight * 0.5 ? chart.chartHeight * 0.33 : chart.chartHeight) + 'px'
	                    };
	                    if (!textOverflowOption) {
	                        css.textOverflow = 'ellipsis';
	                    }
	                }

	                // Set the explicit or automatic label alignment
	                this.labelAlign = labelOptions.align || this.autoLabelAlign(this.labelRotation);
	                if (this.labelAlign) {
	                    attr.align = this.labelAlign;
	                }

	                // Apply general and specific CSS
	                each(tickPositions, function(pos) {
	                    var tick = ticks[pos],
	                        label = tick && tick.label;
	                    if (label) {
	                        label.attr(attr); // This needs to go before the CSS in old IE (#4502)
	                        if (css) {
	                            label.css(merge(css, label.specCss));
	                        }
	                        delete label.specCss;
	                        tick.rotation = attr.rotation;
	                    }
	                });

	                // Note: Why is this not part of getLabelPosition?
	                this.tickRotCorr = renderer.rotCorr(labelMetrics.b, this.labelRotation || 0, this.side !== 0);
	            },

	            /**
	             * Return true if the axis has associated data.
	             *
	             * @return {Boolean}
	             *         True if the axis has associated visible series and those series
	             *         have either valid data points or explicit `min` and `max`
	             *         settings.
	             */
	            hasData: function() {
	                return (
	                    this.hasVisibleSeries ||
	                    (defined(this.min) && defined(this.max) && !!this.tickPositions)
	                );
	            },

	            /**
	             * Adds the title defined in axis.options.title.
	             * @param {Boolean} display - whether or not to display the title
	             */
	            addTitle: function(display) {
	                var axis = this,
	                    renderer = axis.chart.renderer,
	                    horiz = axis.horiz,
	                    opposite = axis.opposite,
	                    options = axis.options,
	                    axisTitleOptions = options.title,
	                    textAlign;

	                if (!axis.axisTitle) {
	                    textAlign = axisTitleOptions.textAlign;
	                    if (!textAlign) {
	                        textAlign = (horiz ? {
	                            low: 'left',
	                            middle: 'center',
	                            high: 'right'
	                        } : {
	                            low: opposite ? 'right' : 'left',
	                            middle: 'center',
	                            high: opposite ? 'left' : 'right'
	                        })[axisTitleOptions.align];
	                    }
	                    axis.axisTitle = renderer.text(
	                            axisTitleOptions.text,
	                            0,
	                            0,
	                            axisTitleOptions.useHTML
	                        )
	                        .attr({
	                            zIndex: 7,
	                            rotation: axisTitleOptions.rotation || 0,
	                            align: textAlign
	                        })
	                        .addClass('highcharts-axis-title')

	                        .css(axisTitleOptions.style)

	                        .add(axis.axisGroup);
	                    axis.axisTitle.isNew = true;
	                }

	                // Max width defaults to the length of the axis

	                if (!axisTitleOptions.style.width && !axis.isRadial) {

	                    axis.axisTitle.css({
	                        width: axis.len
	                    });

	                }



	                // hide or show the title depending on whether showEmpty is set
	                axis.axisTitle[display ? 'show' : 'hide'](true);
	            },

	            /**
	             * Generates a tick for initial positioning.
	             *
	             * @private
	             * @param  {number} pos
	             *         The tick position in axis values.
	             * @param  {number} i
	             *         The index of the tick in {@link Axis.tickPositions}.
	             */
	            generateTick: function(pos) {
	                var ticks = this.ticks;

	                if (!ticks[pos]) {
	                    ticks[pos] = new Tick(this, pos);
	                } else {
	                    ticks[pos].addLabel(); // update labels depending on tick interval
	                }
	            },

	            /**
	             * Render the tick labels to a preliminary position to get their sizes.
	             *
	             * @private
	             */
	            getOffset: function() {
	                var axis = this,
	                    chart = axis.chart,
	                    renderer = chart.renderer,
	                    options = axis.options,
	                    tickPositions = axis.tickPositions,
	                    ticks = axis.ticks,
	                    horiz = axis.horiz,
	                    side = axis.side,
	                    invertedSide = chart.inverted && !axis.isZAxis ? [1, 0, 3, 2][side] : side,
	                    hasData,
	                    showAxis,
	                    titleOffset = 0,
	                    titleOffsetOption,
	                    titleMargin = 0,
	                    axisTitleOptions = options.title,
	                    labelOptions = options.labels,
	                    labelOffset = 0, // reset
	                    labelOffsetPadded,
	                    axisOffset = chart.axisOffset,
	                    clipOffset = chart.clipOffset,
	                    clip,
	                    directionFactor = [-1, 1, 1, -1][side],
	                    className = options.className,
	                    axisParent = axis.axisParent, // Used in color axis
	                    lineHeightCorrection,
	                    tickSize = this.tickSize('tick');

	                // For reuse in Axis.render
	                hasData = axis.hasData();
	                axis.showAxis = showAxis = hasData || pick(options.showEmpty, true);

	                // Set/reset staggerLines
	                axis.staggerLines = axis.horiz && labelOptions.staggerLines;

	                // Create the axisGroup and gridGroup elements on first iteration
	                if (!axis.axisGroup) {
	                    axis.gridGroup = renderer.g('grid')
	                        .attr({
	                            zIndex: options.gridZIndex || 1
	                        })
	                        .addClass('highcharts-' + this.coll.toLowerCase() + '-grid ' + (className || ''))
	                        .add(axisParent);
	                    axis.axisGroup = renderer.g('axis')
	                        .attr({
	                            zIndex: options.zIndex || 2
	                        })
	                        .addClass('highcharts-' + this.coll.toLowerCase() + ' ' + (className || ''))
	                        .add(axisParent);
	                    axis.labelGroup = renderer.g('axis-labels')
	                        .attr({
	                            zIndex: labelOptions.zIndex || 7
	                        })
	                        .addClass('highcharts-' + axis.coll.toLowerCase() + '-labels ' + (className || ''))
	                        .add(axisParent);
	                }

	                if (hasData || axis.isLinked) {

	                    // Generate ticks
	                    each(tickPositions, function(pos, i) {
	                        // i is not used here, but may be used in overrides
	                        axis.generateTick(pos, i);
	                    });

	                    axis.renderUnsquish();


	                    // Left side must be align: right and right side must have align: left for labels
	                    if (labelOptions.reserveSpace !== false && (side === 0 || side === 2 || {
	                            1: 'left',
	                            3: 'right'
	                        }[side] === axis.labelAlign || axis.labelAlign === 'center')) {
	                        each(tickPositions, function(pos) {

	                            // get the highest offset
	                            labelOffset = Math.max(
	                                ticks[pos].getLabelSize(),
	                                labelOffset
	                            );
	                        });
	                    }

	                    if (axis.staggerLines) {
	                        labelOffset *= axis.staggerLines;
	                        axis.labelOffset = labelOffset * (axis.opposite ? -1 : 1);
	                    }


	                } else { // doesn't have data
	                    objectEach(ticks, function(tick, n) {
	                        tick.destroy();
	                        delete ticks[n];
	                    });
	                }

	                if (axisTitleOptions && axisTitleOptions.text && axisTitleOptions.enabled !== false) {
	                    axis.addTitle(showAxis);

	                    if (showAxis && axisTitleOptions.reserveSpace !== false) {
	                        axis.titleOffset = titleOffset =
	                            axis.axisTitle.getBBox()[horiz ? 'height' : 'width'];
	                        titleOffsetOption = axisTitleOptions.offset;
	                        titleMargin = defined(titleOffsetOption) ? 0 : pick(axisTitleOptions.margin, horiz ? 5 : 10);
	                    }
	                }

	                // Render the axis line
	                axis.renderLine();

	                // handle automatic or user set offset
	                axis.offset = directionFactor * pick(options.offset, axisOffset[side]);

	                axis.tickRotCorr = axis.tickRotCorr || {
	                    x: 0,
	                    y: 0
	                }; // polar
	                if (side === 0) {
	                    lineHeightCorrection = -axis.labelMetrics().h;
	                } else if (side === 2) {
	                    lineHeightCorrection = axis.tickRotCorr.y;
	                } else {
	                    lineHeightCorrection = 0;
	                }

	                // Find the padded label offset
	                labelOffsetPadded = Math.abs(labelOffset) + titleMargin;
	                if (labelOffset) {
	                    labelOffsetPadded -= lineHeightCorrection;
	                    labelOffsetPadded += directionFactor * (horiz ? pick(labelOptions.y, axis.tickRotCorr.y + directionFactor * 8) : labelOptions.x);
	                }
	                axis.axisTitleMargin = pick(titleOffsetOption, labelOffsetPadded);

	                axisOffset[side] = Math.max(
	                    axisOffset[side],
	                    axis.axisTitleMargin + titleOffset + directionFactor * axis.offset,
	                    labelOffsetPadded, // #3027
	                    hasData && tickPositions.length && tickSize ?
	                    tickSize[0] + directionFactor * axis.offset :
	                    0 // #4866
	                );

	                // Decide the clipping needed to keep the graph inside the plot area and
	                // axis lines
	                clip = Math.floor(axis.axisLine.strokeWidth() / 2) * 2; // #4308, #4371
	                if (options.offset > 0) {
	                    clip -= options.offset * 2;
	                }
	                clipOffset[invertedSide] = Math.max(
	                    clipOffset[invertedSide] || clip,
	                    clip
	                );
	            },

	            /**
	             * Internal function to get the path for the axis line. Extended for polar
	             * charts.
	             *
	             * @param  {Number} lineWidth
	             *         The line width in pixels.
	             * @return {Array}
	             *         The SVG path definition in array form.
	             */
	            getLinePath: function(lineWidth) {
	                var chart = this.chart,
	                    opposite = this.opposite,
	                    offset = this.offset,
	                    horiz = this.horiz,
	                    lineLeft = this.left + (opposite ? this.width : 0) + offset,
	                    lineTop = chart.chartHeight - this.bottom -
	                    (opposite ? this.height : 0) + offset;

	                if (opposite) {
	                    lineWidth *= -1; // crispify the other way - #1480, #1687
	                }

	                return chart.renderer
	                    .crispLine([
	                        'M',
	                        horiz ?
	                        this.left :
	                        lineLeft,
	                        horiz ?
	                        lineTop :
	                        this.top,
	                        'L',
	                        horiz ?
	                        chart.chartWidth - this.right :
	                        lineLeft,
	                        horiz ?
	                        lineTop :
	                        chart.chartHeight - this.bottom
	                    ], lineWidth);
	            },

	            /**
	             * Render the axis line. Called internally when rendering and redrawing the
	             * axis.
	             */
	            renderLine: function() {
	                if (!this.axisLine) {
	                    this.axisLine = this.chart.renderer.path()
	                        .addClass('highcharts-axis-line')
	                        .add(this.axisGroup);


	                    this.axisLine.attr({
	                        stroke: this.options.lineColor,
	                        'stroke-width': this.options.lineWidth,
	                        zIndex: 7
	                    });

	                }
	            },

	            /**
	             * Position the axis title.
	             *
	             * @private
	             *
	             * @return {Object}
	             *         X and Y positions for the title.
	             */
	            getTitlePosition: function() {
	                // compute anchor points for each of the title align options
	                var horiz = this.horiz,
	                    axisLeft = this.left,
	                    axisTop = this.top,
	                    axisLength = this.len,
	                    axisTitleOptions = this.options.title,
	                    margin = horiz ? axisLeft : axisTop,
	                    opposite = this.opposite,
	                    offset = this.offset,
	                    xOption = axisTitleOptions.x || 0,
	                    yOption = axisTitleOptions.y || 0,
	                    axisTitle = this.axisTitle,
	                    fontMetrics = this.chart.renderer.fontMetrics(
	                        axisTitleOptions.style && axisTitleOptions.style.fontSize,
	                        axisTitle
	                    ),
	                    // The part of a multiline text that is below the baseline of the
	                    // first line. Subtract 1 to preserve pixel-perfectness from the 
	                    // old behaviour (v5.0.12), where only one line was allowed.
	                    textHeightOvershoot = Math.max(
	                        axisTitle.getBBox(null, 0).height - fontMetrics.h - 1,
	                        0
	                    ),

	                    // the position in the length direction of the axis
	                    alongAxis = {
	                        low: margin + (horiz ? 0 : axisLength),
	                        middle: margin + axisLength / 2,
	                        high: margin + (horiz ? axisLength : 0)
	                    }[axisTitleOptions.align],

	                    // the position in the perpendicular direction of the axis
	                    offAxis = (horiz ? axisTop + this.height : axisLeft) +
	                    (horiz ? 1 : -1) * // horizontal axis reverses the margin
	                    (opposite ? -1 : 1) * // so does opposite axes
	                    this.axisTitleMargin + [-textHeightOvershoot, // top
	                        textHeightOvershoot, // right
	                        fontMetrics.f, // bottom
	                        -textHeightOvershoot // left
	                    ][this.side];


	                return {
	                    x: horiz ?
	                        alongAxis + xOption : offAxis + (opposite ? this.width : 0) + offset + xOption,
	                    y: horiz ?
	                        offAxis + yOption - (opposite ? this.height : 0) + offset : alongAxis + yOption
	                };
	            },

	            /**
	             * Render a minor tick into the given position. If a minor tick already 
	             * exists in this position, move it.
	             * 
	             * @param  {number} pos
	             *         The position in axis values.
	             */
	            renderMinorTick: function(pos) {
	                var slideInTicks = this.chart.hasRendered && isNumber(this.oldMin),
	                    minorTicks = this.minorTicks;

	                if (!minorTicks[pos]) {
	                    minorTicks[pos] = new Tick(this, pos, 'minor');
	                }

	                // Render new ticks in old position
	                if (slideInTicks && minorTicks[pos].isNew) {
	                    minorTicks[pos].render(null, true);
	                }

	                minorTicks[pos].render(null, false, 1);
	            },

	            /**
	             * Render a major tick into the given position. If a tick already exists
	             * in this position, move it.
	             * 
	             * @param  {number} pos
	             *         The position in axis values.
	             * @param  {number} i
	             *         The tick index.
	             */
	            renderTick: function(pos, i) {
	                var isLinked = this.isLinked,
	                    ticks = this.ticks,
	                    slideInTicks = this.chart.hasRendered && isNumber(this.oldMin);

	                // Linked axes need an extra check to find out if
	                if (!isLinked || (pos >= this.min && pos <= this.max)) {

	                    if (!ticks[pos]) {
	                        ticks[pos] = new Tick(this, pos);
	                    }

	                    // render new ticks in old position
	                    if (slideInTicks && ticks[pos].isNew) {
	                        ticks[pos].render(i, true, 0.1);
	                    }

	                    ticks[pos].render(i);
	                }
	            },

	            /**
	             * Render the axis.
	             *
	             * @private
	             */
	            render: function() {
	                var axis = this,
	                    chart = axis.chart,
	                    renderer = chart.renderer,
	                    options = axis.options,
	                    isLog = axis.isLog,
	                    lin2log = axis.lin2log,
	                    isLinked = axis.isLinked,
	                    tickPositions = axis.tickPositions,
	                    axisTitle = axis.axisTitle,
	                    ticks = axis.ticks,
	                    minorTicks = axis.minorTicks,
	                    alternateBands = axis.alternateBands,
	                    stackLabelOptions = options.stackLabels,
	                    alternateGridColor = options.alternateGridColor,
	                    tickmarkOffset = axis.tickmarkOffset,
	                    axisLine = axis.axisLine,
	                    showAxis = axis.showAxis,
	                    animation = animObject(renderer.globalAnimation),
	                    from,
	                    to;

	                // Reset
	                axis.labelEdge.length = 0;
	                //axis.justifyToPlot = overflow === 'justify';
	                axis.overlap = false;

	                // Mark all elements inActive before we go over and mark the active ones
	                each([ticks, minorTicks, alternateBands], function(coll) {
	                    objectEach(coll, function(tick) {
	                        tick.isActive = false;
	                    });
	                });

	                // If the series has data draw the ticks. Else only the line and title
	                if (axis.hasData() || isLinked) {

	                    // minor ticks
	                    if (axis.minorTickInterval && !axis.categories) {
	                        each(axis.getMinorTickPositions(), function(pos) {
	                            axis.renderMinorTick(pos);
	                        });
	                    }

	                    // Major ticks. Pull out the first item and render it last so that
	                    // we can get the position of the neighbour label. #808.
	                    if (tickPositions.length) { // #1300
	                        each(tickPositions, function(pos, i) {
	                            axis.renderTick(pos, i);
	                        });
	                        // In a categorized axis, the tick marks are displayed between labels. So
	                        // we need to add a tick mark and grid line at the left edge of the X axis.
	                        if (tickmarkOffset && (axis.min === 0 || axis.single)) {
	                            if (!ticks[-1]) {
	                                ticks[-1] = new Tick(axis, -1, null, true);
	                            }
	                            ticks[-1].render(-1);
	                        }

	                    }

	                    // alternate grid color
	                    if (alternateGridColor) {
	                        each(tickPositions, function(pos, i) {
	                            to = tickPositions[i + 1] !== undefined ? tickPositions[i + 1] + tickmarkOffset : axis.max - tickmarkOffset;
	                            if (i % 2 === 0 && pos < axis.max && to <= axis.max + (chart.polar ? -tickmarkOffset : tickmarkOffset)) { // #2248, #4660
	                                if (!alternateBands[pos]) {
	                                    alternateBands[pos] = new H.PlotLineOrBand(axis);
	                                }
	                                from = pos + tickmarkOffset; // #949
	                                alternateBands[pos].options = {
	                                    from: isLog ? lin2log(from) : from,
	                                    to: isLog ? lin2log(to) : to,
	                                    color: alternateGridColor
	                                };
	                                alternateBands[pos].render();
	                                alternateBands[pos].isActive = true;
	                            }
	                        });
	                    }

	                    // custom plot lines and bands
	                    if (!axis._addedPlotLB) { // only first time
	                        each((options.plotLines || []).concat(options.plotBands || []), function(plotLineOptions) {
	                            axis.addPlotBandOrLine(plotLineOptions);
	                        });
	                        axis._addedPlotLB = true;
	                    }

	                } // end if hasData

	                // Remove inactive ticks
	                each([ticks, minorTicks, alternateBands], function(coll) {
	                    var i,
	                        forDestruction = [],
	                        delay = animation.duration,
	                        destroyInactiveItems = function() {
	                            i = forDestruction.length;
	                            while (i--) {
	                                // When resizing rapidly, the same items may be destroyed in different timeouts,
	                                // or the may be reactivated
	                                if (coll[forDestruction[i]] && !coll[forDestruction[i]].isActive) {
	                                    coll[forDestruction[i]].destroy();
	                                    delete coll[forDestruction[i]];
	                                }
	                            }

	                        };

	                    objectEach(coll, function(tick, pos) {
	                        if (!tick.isActive) {
	                            // Render to zero opacity
	                            tick.render(pos, false, 0);
	                            tick.isActive = false;
	                            forDestruction.push(pos);
	                        }
	                    });

	                    // When the objects are finished fading out, destroy them
	                    syncTimeout(
	                        destroyInactiveItems,
	                        coll === alternateBands || !chart.hasRendered || !delay ? 0 : delay
	                    );
	                });

	                // Set the axis line path
	                if (axisLine) {
	                    axisLine[axisLine.isPlaced ? 'animate' : 'attr']({
	                        d: this.getLinePath(axisLine.strokeWidth())
	                    });
	                    axisLine.isPlaced = true;

	                    // Show or hide the line depending on options.showEmpty
	                    axisLine[showAxis ? 'show' : 'hide'](true);
	                }

	                if (axisTitle && showAxis) {
	                    var titleXy = axis.getTitlePosition();
	                    if (isNumber(titleXy.y)) {
	                        axisTitle[axisTitle.isNew ? 'attr' : 'animate'](titleXy);
	                        axisTitle.isNew = false;
	                    } else {
	                        axisTitle.attr('y', -9999);
	                        axisTitle.isNew = true;
	                    }
	                }

	                // Stacked totals:
	                if (stackLabelOptions && stackLabelOptions.enabled) {
	                    axis.renderStackTotals();
	                }
	                // End stacked totals

	                axis.isDirty = false;
	            },

	            /**
	             * Redraw the axis to reflect changes in the data or axis extremes. Called
	             * internally from {@link Chart#redraw}.
	             *
	             * @private
	             */
	            redraw: function() {

	                if (this.visible) {
	                    // render the axis
	                    this.render();

	                    // move plot lines and bands
	                    each(this.plotLinesAndBands, function(plotLine) {
	                        plotLine.render();
	                    });
	                }

	                // mark associated series as dirty and ready for redraw
	                each(this.series, function(series) {
	                    series.isDirty = true;
	                });

	            },

	            // Properties to survive after destroy, needed for Axis.update (#4317,
	            // #5773, #5881).
	            keepProps: ['extKey', 'hcEvents', 'names', 'series', 'userMax', 'userMin'],

	            /**
	             * Destroys an Axis instance. See {@link Axis#remove} for the API endpoint
	             * to fully remove the axis.
	             *
	             * @private
	             * @param  {Boolean} keepEvents
	             *         Whether to preserve events, used internally in Axis.update.
	             */
	            destroy: function(keepEvents) {
	                var axis = this,
	                    stacks = axis.stacks,
	                    plotLinesAndBands = axis.plotLinesAndBands,
	                    plotGroup,
	                    i;

	                // Remove the events
	                if (!keepEvents) {
	                    removeEvent(axis);
	                }

	                // Destroy each stack total
	                objectEach(stacks, function(stack, stackKey) {
	                    destroyObjectProperties(stack);

	                    stacks[stackKey] = null;
	                });

	                // Destroy collections
	                each([axis.ticks, axis.minorTicks, axis.alternateBands], function(coll) {
	                    destroyObjectProperties(coll);
	                });
	                if (plotLinesAndBands) {
	                    i = plotLinesAndBands.length;
	                    while (i--) { // #1975
	                        plotLinesAndBands[i].destroy();
	                    }
	                }

	                // Destroy local variables
	                each(['stackTotalGroup', 'axisLine', 'axisTitle', 'axisGroup', 'gridGroup', 'labelGroup', 'cross'], function(prop) {
	                    if (axis[prop]) {
	                        axis[prop] = axis[prop].destroy();
	                    }
	                });

	                // Destroy each generated group for plotlines and plotbands
	                for (plotGroup in axis.plotLinesAndBandsGroups) {
	                    axis.plotLinesAndBandsGroups[plotGroup] = axis.plotLinesAndBandsGroups[plotGroup].destroy();
	                }

	                // Delete all properties and fall back to the prototype.
	                objectEach(axis, function(val, key) {
	                    if (inArray(key, axis.keepProps) === -1) {
	                        delete axis[key];
	                    }
	                });
	            },

	            /**
	             * Internal function to draw a crosshair.
	             *
	             * @param  {PointerEvent} [e]
	             *         The event arguments from the modified pointer event, extended 
	             *         with `chartX` and `chartY`
	             * @param  {Point} [point]
	             *         The Point object if the crosshair snaps to points.
	             */
	            drawCrosshair: function(e, point) {

	                var path,
	                    options = this.crosshair,
	                    snap = pick(options.snap, true),
	                    pos,
	                    categorized,
	                    graphic = this.cross;

	                // Use last available event when updating non-snapped crosshairs without
	                // mouse interaction (#5287)
	                if (!e) {
	                    e = this.cross && this.cross.e;
	                }

	                if (
	                    // Disabled in options
	                    !this.crosshair ||
	                    // Snap
	                    ((defined(point) || !snap) === false)
	                ) {
	                    this.hideCrosshair();
	                } else {

	                    // Get the path
	                    if (!snap) {
	                        pos = e && (this.horiz ? e.chartX - this.pos : this.len - e.chartY + this.pos);
	                    } else if (defined(point)) {
	                        pos = this.isXAxis ? point.plotX : this.len - point.plotY; // #3834
	                    }

	                    if (defined(pos)) {
	                        path = this.getPlotLinePath(
	                            // First argument, value, only used on radial
	                            point && (this.isXAxis ? point.x : pick(point.stackY, point.y)),
	                            null,
	                            null,
	                            null,
	                            pos // Translated position
	                        ) || null; // #3189
	                    }

	                    if (!defined(path)) {
	                        this.hideCrosshair();
	                        return;
	                    }

	                    categorized = this.categories && !this.isRadial;

	                    // Draw the cross
	                    if (!graphic) {
	                        this.cross = graphic = this.chart.renderer
	                            .path()
	                            .addClass('highcharts-crosshair highcharts-crosshair-' +
	                                (categorized ? 'category ' : 'thin ') + options.className)
	                            .attr({
	                                zIndex: pick(options.zIndex, 2)
	                            })
	                            .add();


	                        // Presentational attributes
	                        graphic.attr({
	                            'stroke': options.color || (categorized ? color('#ccd6eb').setOpacity(0.25).get() : '#cccccc'),
	                            'stroke-width': pick(options.width, 1)
	                        });
	                        if (options.dashStyle) {
	                            graphic.attr({
	                                dashstyle: options.dashStyle
	                            });
	                        }


	                    }

	                    graphic.show().attr({
	                        d: path
	                    });

	                    if (categorized && !options.width) {
	                        graphic.attr({
	                            'stroke-width': this.transA
	                        });
	                    }
	                    this.cross.e = e;
	                }
	            },

	            /**
	             *  Hide the crosshair if visible.
	             */
	            hideCrosshair: function() {
	                if (this.cross) {
	                    this.cross.hide();
	                }
	            }
	        }); // end Axis

	        H.Axis = Axis;
	        return Axis;
	    }(Highcharts));
	    (function(H) {
	        /**
	         * (c) 2010-2017 Torstein Honsi
	         *
	         * License: www.highcharts.com/license
	         */
	        var Axis = H.Axis,
	            Date = H.Date,
	            dateFormat = H.dateFormat,
	            defaultOptions = H.defaultOptions,
	            defined = H.defined,
	            each = H.each,
	            extend = H.extend,
	            getMagnitude = H.getMagnitude,
	            getTZOffset = H.getTZOffset,
	            normalizeTickInterval = H.normalizeTickInterval,
	            pick = H.pick,
	            timeUnits = H.timeUnits;
	        /**
	         * Set the tick positions to a time unit that makes sense, for example
	         * on the first of each month or on every Monday. Return an array
	         * with the time positions. Used in datetime axes as well as for grouping
	         * data on a datetime axis.
	         *
	         * @param {Object} normalizedInterval The interval in axis values (ms) and the count
	         * @param {Number} min The minimum in axis values
	         * @param {Number} max The maximum in axis values
	         * @param {Number} startOfWeek
	         */
	        Axis.prototype.getTimeTicks = function(normalizedInterval, min, max, startOfWeek) {
	            var tickPositions = [],
	                i,
	                higherRanks = {},
	                useUTC = defaultOptions.global.useUTC,
	                minYear, // used in months and years as a basis for Date.UTC()
	                // When crossing DST, use the max. Resolves #6278.
	                minDate = new Date(min - Math.max(getTZOffset(min), getTZOffset(max))),
	                makeTime = Date.hcMakeTime,
	                interval = normalizedInterval.unitRange,
	                count = normalizedInterval.count,
	                baseOffset, // #6797
	                variableDayLength;

	            if (defined(min)) { // #1300
	                minDate[Date.hcSetMilliseconds](interval >= timeUnits.second ? 0 : // #3935
	                    count * Math.floor(minDate.getMilliseconds() / count)); // #3652, #3654

	                if (interval >= timeUnits.second) { // second
	                    minDate[Date.hcSetSeconds](interval >= timeUnits.minute ? 0 : // #3935
	                        count * Math.floor(minDate.getSeconds() / count));
	                }

	                if (interval >= timeUnits.minute) { // minute
	                    minDate[Date.hcSetMinutes](interval >= timeUnits.hour ? 0 :
	                        count * Math.floor(minDate[Date.hcGetMinutes]() / count));
	                }

	                if (interval >= timeUnits.hour) { // hour
	                    minDate[Date.hcSetHours](interval >= timeUnits.day ? 0 :
	                        count * Math.floor(minDate[Date.hcGetHours]() / count));
	                }

	                if (interval >= timeUnits.day) { // day
	                    minDate[Date.hcSetDate](interval >= timeUnits.month ? 1 :
	                        count * Math.floor(minDate[Date.hcGetDate]() / count));
	                }

	                if (interval >= timeUnits.month) { // month
	                    minDate[Date.hcSetMonth](interval >= timeUnits.year ? 0 :
	                        count * Math.floor(minDate[Date.hcGetMonth]() / count));
	                    minYear = minDate[Date.hcGetFullYear]();
	                }

	                if (interval >= timeUnits.year) { // year
	                    minYear -= minYear % count;
	                    minDate[Date.hcSetFullYear](minYear);
	                }

	                // week is a special case that runs outside the hierarchy
	                if (interval === timeUnits.week) {
	                    // get start of current week, independent of count
	                    minDate[Date.hcSetDate](minDate[Date.hcGetDate]() - minDate[Date.hcGetDay]() +
	                        pick(startOfWeek, 1));
	                }


	                // Get basics for variable time spans
	                minYear = minDate[Date.hcGetFullYear]();
	                var minMonth = minDate[Date.hcGetMonth](),
	                    minDateDate = minDate[Date.hcGetDate](),
	                    minHours = minDate[Date.hcGetHours]();


	                // Handle local timezone offset
	                if (Date.hcTimezoneOffset || Date.hcGetTimezoneOffset) {

	                    // Detect whether we need to take the DST crossover into
	                    // consideration. If we're crossing over DST, the day length may be
	                    // 23h or 25h and we need to compute the exact clock time for each
	                    // tick instead of just adding hours. This comes at a cost, so first
	                    // we found out if it is needed. #4951.
	                    variableDayLength =
	                        (!useUTC || !!Date.hcGetTimezoneOffset) &&
	                        (
	                            // Long range, assume we're crossing over.
	                            max - min > 4 * timeUnits.month ||
	                            // Short range, check if min and max are in different time 
	                            // zones.
	                            getTZOffset(min) !== getTZOffset(max)
	                        );

	                    // Adjust minDate to the offset date
	                    minDate = minDate.getTime();
	                    baseOffset = getTZOffset(minDate);
	                    minDate = new Date(minDate + baseOffset);
	                }


	                // Iterate and add tick positions at appropriate values
	                var time = minDate.getTime();
	                i = 1;
	                while (time < max) {
	                    tickPositions.push(time);

	                    // if the interval is years, use Date.UTC to increase years
	                    if (interval === timeUnits.year) {
	                        time = makeTime(minYear + i * count, 0);

	                        // if the interval is months, use Date.UTC to increase months
	                    } else if (interval === timeUnits.month) {
	                        time = makeTime(minYear, minMonth + i * count);

	                        // if we're using global time, the interval is not fixed as it jumps
	                        // one hour at the DST crossover
	                    } else if (
	                        variableDayLength &&
	                        (interval === timeUnits.day || interval === timeUnits.week)
	                    ) {
	                        time = makeTime(minYear, minMonth, minDateDate +
	                            i * count * (interval === timeUnits.day ? 1 : 7));

	                    } else if (variableDayLength && interval === timeUnits.hour) {
	                        // corrected by the start date time zone offset (baseOffset)
	                        // to hide duplicated label (#6797)
	                        time = makeTime(minYear, minMonth, minDateDate, minHours +
	                            i * count, 0, 0, baseOffset) - baseOffset;

	                        // else, the interval is fixed and we use simple addition
	                    } else {
	                        time += interval * count;
	                    }

	                    i++;
	                }

	                // push the last time
	                tickPositions.push(time);


	                // Handle higher ranks. Mark new days if the time is on midnight
	                // (#950, #1649, #1760, #3349). Use a reasonable dropout threshold to 
	                // prevent looping over dense data grouping (#6156).
	                if (interval <= timeUnits.hour && tickPositions.length < 10000) {
	                    each(tickPositions, function(time) {
	                        if (
	                            // Speed optimization, no need to run dateFormat unless
	                            // we're on a full or half hour
	                            time % 1800000 === 0 &&
	                            // Check for local or global midnight
	                            dateFormat('%H%M%S%L', time) === '000000000'
	                        ) {
	                            higherRanks[time] = 'day';
	                        }
	                    });
	                }
	            }


	            // record information on the chosen unit - for dynamic label formatter
	            tickPositions.info = extend(normalizedInterval, {
	                higherRanks: higherRanks,
	                totalRange: interval * count
	            });

	            return tickPositions;
	        };

	        /**
	         * Get a normalized tick interval for dates. Returns a configuration object with
	         * unit range (interval), count and name. Used to prepare data for getTimeTicks.
	         * Previously this logic was part of getTimeTicks, but as getTimeTicks now runs
	         * of segments in stock charts, the normalizing logic was extracted in order to
	         * prevent it for running over again for each segment having the same interval.
	         * #662, #697.
	         */
	        Axis.prototype.normalizeTimeTickInterval = function(tickInterval, unitsOption) {
	            var units = unitsOption || [
	                    [
	                        'millisecond', // unit name
	                        [1, 2, 5, 10, 20, 25, 50, 100, 200, 500] // allowed multiples
	                    ],
	                    [
	                        'second', [1, 2, 5, 10, 15, 30]
	                    ],
	                    [
	                        'minute', [1, 2, 5, 10, 15, 30]
	                    ],
	                    [
	                        'hour', [1, 2, 3, 4, 6, 8, 12]
	                    ],
	                    [
	                        'day', [1, 2]
	                    ],
	                    [
	                        'week', [1, 2]
	                    ],
	                    [
	                        'month', [1, 2, 3, 4, 6]
	                    ],
	                    [
	                        'year',
	                        null
	                    ]
	                ],
	                unit = units[units.length - 1], // default unit is years
	                interval = timeUnits[unit[0]],
	                multiples = unit[1],
	                count,
	                i;

	            // loop through the units to find the one that best fits the tickInterval
	            for (i = 0; i < units.length; i++) {
	                unit = units[i];
	                interval = timeUnits[unit[0]];
	                multiples = unit[1];


	                if (units[i + 1]) {
	                    // lessThan is in the middle between the highest multiple and the next unit.
	                    var lessThan = (interval * multiples[multiples.length - 1] +
	                        timeUnits[units[i + 1][0]]) / 2;

	                    // break and keep the current unit
	                    if (tickInterval <= lessThan) {
	                        break;
	                    }
	                }
	            }

	            // prevent 2.5 years intervals, though 25, 250 etc. are allowed
	            if (interval === timeUnits.year && tickInterval < 5 * interval) {
	                multiples = [1, 2, 5];
	            }

	            // get the count
	            count = normalizeTickInterval(
	                tickInterval / interval,
	                multiples,
	                unit[0] === 'year' ? Math.max(getMagnitude(tickInterval / interval), 1) : 1 // #1913, #2360
	            );

	            return {
	                unitRange: interval,
	                count: count,
	                unitName: unit[0]
	            };
	        };

	    }(Highcharts));
	    (function(H) {
	        /**
	         * (c) 2010-2017 Torstein Honsi
	         *
	         * License: www.highcharts.com/license
	         */
	        var Axis = H.Axis,
	            getMagnitude = H.getMagnitude,
	            map = H.map,
	            normalizeTickInterval = H.normalizeTickInterval,
	            pick = H.pick;
	        /**
	         * Methods defined on the Axis prototype
	         */

	        /**
	         * Set the tick positions of a logarithmic axis
	         */
	        Axis.prototype.getLogTickPositions = function(interval, min, max, minor) {
	            var axis = this,
	                options = axis.options,
	                axisLength = axis.len,
	                lin2log = axis.lin2log,
	                log2lin = axis.log2lin,
	                // Since we use this method for both major and minor ticks,
	                // use a local variable and return the result
	                positions = [];

	            // Reset
	            if (!minor) {
	                axis._minorAutoInterval = null;
	            }

	            // First case: All ticks fall on whole logarithms: 1, 10, 100 etc.
	            if (interval >= 0.5) {
	                interval = Math.round(interval);
	                positions = axis.getLinearTickPositions(interval, min, max);

	                // Second case: We need intermediary ticks. For example
	                // 1, 2, 4, 6, 8, 10, 20, 40 etc.
	            } else if (interval >= 0.08) {
	                var roundedMin = Math.floor(min),
	                    intermediate,
	                    i,
	                    j,
	                    len,
	                    pos,
	                    lastPos,
	                    break2;

	                if (interval > 0.3) {
	                    intermediate = [1, 2, 4];
	                } else if (interval > 0.15) { // 0.2 equals five minor ticks per 1, 10, 100 etc
	                    intermediate = [1, 2, 4, 6, 8];
	                } else { // 0.1 equals ten minor ticks per 1, 10, 100 etc
	                    intermediate = [1, 2, 3, 4, 5, 6, 7, 8, 9];
	                }

	                for (i = roundedMin; i < max + 1 && !break2; i++) {
	                    len = intermediate.length;
	                    for (j = 0; j < len && !break2; j++) {
	                        pos = log2lin(lin2log(i) * intermediate[j]);
	                        if (pos > min && (!minor || lastPos <= max) && lastPos !== undefined) { // #1670, lastPos is #3113
	                            positions.push(lastPos);
	                        }

	                        if (lastPos > max) {
	                            break2 = true;
	                        }
	                        lastPos = pos;
	                    }
	                }

	                // Third case: We are so deep in between whole logarithmic values that
	                // we might as well handle the tick positions like a linear axis. For
	                // example 1.01, 1.02, 1.03, 1.04.
	            } else {
	                var realMin = lin2log(min),
	                    realMax = lin2log(max),
	                    tickIntervalOption = options[minor ? 'minorTickInterval' : 'tickInterval'],
	                    filteredTickIntervalOption = tickIntervalOption === 'auto' ? null : tickIntervalOption,
	                    tickPixelIntervalOption = options.tickPixelInterval / (minor ? 5 : 1),
	                    totalPixelLength = minor ? axisLength / axis.tickPositions.length : axisLength;

	                interval = pick(
	                    filteredTickIntervalOption,
	                    axis._minorAutoInterval,
	                    (realMax - realMin) * tickPixelIntervalOption / (totalPixelLength || 1)
	                );

	                interval = normalizeTickInterval(
	                    interval,
	                    null,
	                    getMagnitude(interval)
	                );

	                positions = map(axis.getLinearTickPositions(
	                    interval,
	                    realMin,
	                    realMax
	                ), log2lin);

	                if (!minor) {
	                    axis._minorAutoInterval = interval / 5;
	                }
	            }

	            // Set the axis-level tickInterval variable
	            if (!minor) {
	                axis.tickInterval = interval;
	            }
	            return positions;
	        };

	        Axis.prototype.log2lin = function(num) {
	            return Math.log(num) / Math.LN10;
	        };

	        Axis.prototype.lin2log = function(num) {
	            return Math.pow(10, num);
	        };

	    }(Highcharts));
	    (function(H, Axis) {
	        /**
	         * (c) 2010-2017 Torstein Honsi
	         *
	         * License: www.highcharts.com/license
	         */
	        var arrayMax = H.arrayMax,
	            arrayMin = H.arrayMin,
	            defined = H.defined,
	            destroyObjectProperties = H.destroyObjectProperties,
	            each = H.each,
	            erase = H.erase,
	            merge = H.merge,
	            pick = H.pick;
	        /*
	         * The object wrapper for plot lines and plot bands
	         * @param {Object} options
	         */
	        H.PlotLineOrBand = function(axis, options) {
	            this.axis = axis;

	            if (options) {
	                this.options = options;
	                this.id = options.id;
	            }
	        };

	        H.PlotLineOrBand.prototype = {

	            /**
	             * Render the plot line or plot band. If it is already existing,
	             * move it.
	             */
	            render: function() {
	                var plotLine = this,
	                    axis = plotLine.axis,
	                    horiz = axis.horiz,
	                    options = plotLine.options,
	                    optionsLabel = options.label,
	                    label = plotLine.label,
	                    to = options.to,
	                    from = options.from,
	                    value = options.value,
	                    isBand = defined(from) && defined(to),
	                    isLine = defined(value),
	                    svgElem = plotLine.svgElem,
	                    isNew = !svgElem,
	                    path = [],
	                    color = options.color,
	                    zIndex = pick(options.zIndex, 0),
	                    events = options.events,
	                    attribs = {
	                        'class': 'highcharts-plot-' + (isBand ? 'band ' : 'line ') + (options.className || '')
	                    },
	                    groupAttribs = {},
	                    renderer = axis.chart.renderer,
	                    groupName = isBand ? 'bands' : 'lines',
	                    group,
	                    log2lin = axis.log2lin;

	                // logarithmic conversion
	                if (axis.isLog) {
	                    from = log2lin(from);
	                    to = log2lin(to);
	                    value = log2lin(value);
	                }


	                // Set the presentational attributes
	                if (isLine) {
	                    attribs = {
	                        stroke: color,
	                        'stroke-width': options.width
	                    };
	                    if (options.dashStyle) {
	                        attribs.dashstyle = options.dashStyle;
	                    }

	                } else if (isBand) { // plot band
	                    if (color) {
	                        attribs.fill = color;
	                    }
	                    if (options.borderWidth) {
	                        attribs.stroke = options.borderColor;
	                        attribs['stroke-width'] = options.borderWidth;
	                    }
	                }


	                // Grouping and zIndex
	                groupAttribs.zIndex = zIndex;
	                groupName += '-' + zIndex;

	                group = axis.plotLinesAndBandsGroups[groupName];
	                if (!group) {
	                    axis.plotLinesAndBandsGroups[groupName] = group = renderer.g('plot-' + groupName)
	                        .attr(groupAttribs).add();
	                }

	                // Create the path
	                if (isNew) {
	                    plotLine.svgElem = svgElem =
	                        renderer
	                        .path()
	                        .attr(attribs).add(group);
	                }


	                // Set the path or return
	                if (isLine) {
	                    path = axis.getPlotLinePath(value, svgElem.strokeWidth());
	                } else if (isBand) { // plot band
	                    path = axis.getPlotBandPath(from, to, options);
	                } else {
	                    return;
	                }


	                // common for lines and bands
	                if (isNew && path && path.length) {
	                    svgElem.attr({
	                        d: path
	                    });

	                    // events
	                    if (events) {
	                        H.objectEach(events, function(event, eventType) {
	                            svgElem.on(eventType, function(e) {
	                                events[eventType].apply(plotLine, [e]);
	                            });
	                        });
	                    }
	                } else if (svgElem) {
	                    if (path) {
	                        svgElem.show();
	                        svgElem.animate({
	                            d: path
	                        });
	                    } else {
	                        svgElem.hide();
	                        if (label) {
	                            plotLine.label = label = label.destroy();
	                        }
	                    }
	                }

	                // the plot band/line label
	                if (optionsLabel && defined(optionsLabel.text) && path && path.length &&
	                    axis.width > 0 && axis.height > 0 && !path.flat) {
	                    // apply defaults
	                    optionsLabel = merge({
	                        align: horiz && isBand && 'center',
	                        x: horiz ? !isBand && 4 : 10,
	                        verticalAlign: !horiz && isBand && 'middle',
	                        y: horiz ? isBand ? 16 : 10 : isBand ? 6 : -4,
	                        rotation: horiz && !isBand && 90
	                    }, optionsLabel);

	                    this.renderLabel(optionsLabel, path, isBand, zIndex);

	                } else if (label) { // move out of sight
	                    label.hide();
	                }

	                // chainable
	                return plotLine;
	            },

	            /**
	             * Render and align label for plot line or band.
	             */
	            renderLabel: function(optionsLabel, path, isBand, zIndex) {
	                var plotLine = this,
	                    label = plotLine.label,
	                    renderer = plotLine.axis.chart.renderer,
	                    attribs,
	                    xs,
	                    ys,
	                    x,
	                    y;

	                // add the SVG element
	                if (!label) {
	                    attribs = {
	                        align: optionsLabel.textAlign || optionsLabel.align,
	                        rotation: optionsLabel.rotation,
	                        'class': 'highcharts-plot-' + (isBand ? 'band' : 'line') + '-label ' + (optionsLabel.className || '')
	                    };

	                    attribs.zIndex = zIndex;

	                    plotLine.label = label = renderer.text(
	                            optionsLabel.text,
	                            0,
	                            0,
	                            optionsLabel.useHTML
	                        )
	                        .attr(attribs)
	                        .add();


	                    label.css(optionsLabel.style);

	                }

	                // get the bounding box and align the label
	                // #3000 changed to better handle choice between plotband or plotline
	                xs = [path[1], path[4], (isBand ? path[6] : path[1])];
	                ys = [path[2], path[5], (isBand ? path[7] : path[2])];
	                x = arrayMin(xs);
	                y = arrayMin(ys);

	                label.align(optionsLabel, false, {
	                    x: x,
	                    y: y,
	                    width: arrayMax(xs) - x,
	                    height: arrayMax(ys) - y
	                });
	                label.show();
	            },

	            /**
	             * Remove the plot line or band
	             */
	            destroy: function() {
	                // remove it from the lookup
	                erase(this.axis.plotLinesAndBands, this);

	                delete this.axis;
	                destroyObjectProperties(this);
	            }
	        };

	        /**
	         * Object with members for extending the Axis prototype
	         * @todo Extend directly instead of adding object to Highcharts first
	         */

	        H.extend(Axis.prototype, /** @lends Highcharts.Axis.prototype */ {

	            /**
	             * Internal function to create the SVG path definition for a plot band.
	             *
	             * @param  {Number} from
	             *         The axis value to start from.
	             * @param  {Number} to
	             *         The axis value to end on.
	             *
	             * @return {Array.<String|Number>}
	             *         The SVG path definition in array form.
	             */
	            getPlotBandPath: function(from, to) {
	                var toPath = this.getPlotLinePath(to, null, null, true),
	                    path = this.getPlotLinePath(from, null, null, true),
	                    // #4964 check if chart is inverted or plotband is on yAxis 
	                    horiz = this.horiz,
	                    plus = 1,
	                    outside =
	                    (from < this.min && to < this.min) ||
	                    (from > this.max && to > this.max);

	                if (path && toPath) {

	                    // Flat paths don't need labels (#3836)
	                    if (outside) {
	                        path.flat = path.toString() === toPath.toString();
	                        plus = 0;
	                    }

	                    // Add 1 pixel, when coordinates are the same
	                    path.push(
	                        horiz && toPath[4] === path[4] ? toPath[4] + plus : toPath[4], !horiz && toPath[5] === path[5] ? toPath[5] + plus : toPath[5],
	                        horiz && toPath[1] === path[1] ? toPath[1] + plus : toPath[1], !horiz && toPath[2] === path[2] ? toPath[2] + plus : toPath[2]
	                    );
	                } else { // outside the axis area
	                    path = null;
	                }

	                return path;
	            },

	            /**
	             * Add a plot band after render time.
	             *
	             * @param  {AxisPlotBandsOptions} options
	             *         A configuration object for the plot band, as defined in {@link
	             *         https://api.highcharts.com/highcharts/xAxis.plotBands|
	             *         xAxis.plotBands}.
	             * @return {Object}
	             *         The added plot band.
	             * @sample highcharts/members/axis-addplotband/
	             *         Toggle the plot band from a button
	             */
	            addPlotBand: function(options) {
	                return this.addPlotBandOrLine(options, 'plotBands');
	            },

	            /**
	             * Add a plot line after render time.
	             * 
	             * @param  {AxisPlotLinesOptions} options
	             *         A configuration object for the plot line, as defined in {@link
	             *         https://api.highcharts.com/highcharts/xAxis.plotLines|
	             *         xAxis.plotLines}.
	             * @return {Object}
	             *         The added plot line.
	             * @sample highcharts/members/axis-addplotline/
	             *         Toggle the plot line from a button
	             */
	            addPlotLine: function(options) {
	                return this.addPlotBandOrLine(options, 'plotLines');
	            },

	            /**
	             * Add a plot band or plot line after render time. Called from addPlotBand
	             * and addPlotLine internally.
	             *
	             * @private
	             * @param  options {AxisPlotLinesOptions|AxisPlotBandsOptions}
	             *         The plotBand or plotLine configuration object.
	             */
	            addPlotBandOrLine: function(options, coll) {
	                var obj = new H.PlotLineOrBand(this, options).render(),
	                    userOptions = this.userOptions;

	                if (obj) { // #2189
	                    // Add it to the user options for exporting and Axis.update
	                    if (coll) {
	                        userOptions[coll] = userOptions[coll] || [];
	                        userOptions[coll].push(options);
	                    }
	                    this.plotLinesAndBands.push(obj);
	                }

	                return obj;
	            },

	            /**
	             * Remove a plot band or plot line from the chart by id. Called internally
	             * from `removePlotBand` and `removePlotLine`.
	             *
	             * @private
	             * @param {String} id
	             */
	            removePlotBandOrLine: function(id) {
	                var plotLinesAndBands = this.plotLinesAndBands,
	                    options = this.options,
	                    userOptions = this.userOptions,
	                    i = plotLinesAndBands.length;
	                while (i--) {
	                    if (plotLinesAndBands[i].id === id) {
	                        plotLinesAndBands[i].destroy();
	                    }
	                }
	                each([
	                    options.plotLines || [],
	                    userOptions.plotLines || [],
	                    options.plotBands || [],
	                    userOptions.plotBands || []
	                ], function(arr) {
	                    i = arr.length;
	                    while (i--) {
	                        if (arr[i].id === id) {
	                            erase(arr, arr[i]);
	                        }
	                    }
	                });
	            },

	            /**
	             * Remove a plot band by its id.
	             * 
	             * @param  {String} id
	             *         The plot band's `id` as given in the original configuration
	             *         object or in the `addPlotBand` option.
	             * @sample highcharts/members/axis-removeplotband/
	             *         Remove plot band by id
	             * @sample highcharts/members/axis-addplotband/
	             *         Toggle the plot band from a button
	             */
	            removePlotBand: function(id) {
	                this.removePlotBandOrLine(id);
	            },

	            /**
	             * Remove a plot line by its id.
	             * @param  {String} id
	             *         The plot line's `id` as given in the original configuration
	             *         object or in the `addPlotLine` option.
	             * @sample highcharts/xaxis/plotlines-id/
	             *         Remove plot line by id
	             * @sample highcharts/members/axis-addplotline/
	             *         Toggle the plot line from a button
	             */
	            removePlotLine: function(id) {
	                this.removePlotBandOrLine(id);
	            }
	        });

	    }(Highcharts, Axis));
	    (function(H) {
	        /**
	         * (c) 2010-2017 Torstein Honsi
	         *
	         * License: www.highcharts.com/license
	         */
	        var dateFormat = H.dateFormat,
	            each = H.each,
	            extend = H.extend,
	            format = H.format,
	            isNumber = H.isNumber,
	            map = H.map,
	            merge = H.merge,
	            pick = H.pick,
	            splat = H.splat,
	            syncTimeout = H.syncTimeout,
	            timeUnits = H.timeUnits;
	        /**
	         * The tooltip object
	         * @param {Object} chart The chart instance
	         * @param {Object} options Tooltip options
	         */
	        H.Tooltip = function() {
	            this.init.apply(this, arguments);
	        };

	        H.Tooltip.prototype = {

	            init: function(chart, options) {

	                // Save the chart and options
	                this.chart = chart;
	                this.options = options;

	                // Keep track of the current series
	                //this.currentSeries = undefined;

	                // List of crosshairs
	                this.crosshairs = [];

	                // Current values of x and y when animating
	                this.now = {
	                    x: 0,
	                    y: 0
	                };

	                // The tooltip is initially hidden
	                this.isHidden = true;



	                // Public property for getting the shared state.
	                this.split = options.split && !chart.inverted;
	                this.shared = options.shared || this.split;

	            },

	            /**
	             * Destroy the single tooltips in a split tooltip.
	             * If the tooltip is active then it is not destroyed, unless forced to.
	             * @param  {boolean} force Force destroy all tooltips.
	             * @return {undefined}
	             */
	            cleanSplit: function(force) {
	                each(this.chart.series, function(series) {
	                    var tt = series && series.tt;
	                    if (tt) {
	                        if (!tt.isActive || force) {
	                            series.tt = tt.destroy();
	                        } else {
	                            tt.isActive = false;
	                        }
	                    }
	                });
	            },




	            /**
	             * Create the Tooltip label element if it doesn't exist, then return the
	             * label.
	             */
	            getLabel: function() {

	                var renderer = this.chart.renderer,
	                    options = this.options;

	                if (!this.label) {
	                    // Create the label
	                    if (this.split) {
	                        this.label = renderer.g('tooltip');
	                    } else {
	                        this.label = renderer.label(
	                                '',
	                                0,
	                                0,
	                                options.shape || 'callout',
	                                null,
	                                null,
	                                options.useHTML,
	                                null,
	                                'tooltip'
	                            )
	                            .attr({
	                                padding: options.padding,
	                                r: options.borderRadius
	                            });


	                        this.label
	                            .attr({
	                                'fill': options.backgroundColor,
	                                'stroke-width': options.borderWidth
	                            })
	                            // #2301, #2657
	                            .css(options.style)
	                            .shadow(options.shadow);

	                    }



	                    this.label
	                        .attr({
	                            zIndex: 8
	                        })
	                        .add();
	                }
	                return this.label;
	            },

	            update: function(options) {
	                this.destroy();
	                // Update user options (#6218)
	                merge(true, this.chart.options.tooltip.userOptions, options);
	                this.init(this.chart, merge(true, this.options, options));
	            },

	            /**
	             * Destroy the tooltip and its elements.
	             */
	            destroy: function() {
	                // Destroy and clear local variables
	                if (this.label) {
	                    this.label = this.label.destroy();
	                }
	                if (this.split && this.tt) {
	                    this.cleanSplit(this.chart, true);
	                    this.tt = this.tt.destroy();
	                }
	                clearTimeout(this.hideTimer);
	                clearTimeout(this.tooltipTimeout);
	            },

	            /**
	             * Provide a soft movement for the tooltip
	             *
	             * @param {Number} x
	             * @param {Number} y
	             * @private
	             */
	            move: function(x, y, anchorX, anchorY) {
	                var tooltip = this,
	                    now = tooltip.now,
	                    animate = tooltip.options.animation !== false && !tooltip.isHidden &&
	                    // When we get close to the target position, abort animation and land on the right place (#3056)
	                    (Math.abs(x - now.x) > 1 || Math.abs(y - now.y) > 1),
	                    skipAnchor = tooltip.followPointer || tooltip.len > 1;

	                // Get intermediate values for animation
	                extend(now, {
	                    x: animate ? (2 * now.x + x) / 3 : x,
	                    y: animate ? (now.y + y) / 2 : y,
	                    anchorX: skipAnchor ? undefined : animate ? (2 * now.anchorX + anchorX) / 3 : anchorX,
	                    anchorY: skipAnchor ? undefined : animate ? (now.anchorY + anchorY) / 2 : anchorY
	                });

	                // Move to the intermediate value
	                tooltip.getLabel().attr(now);


	                // Run on next tick of the mouse tracker
	                if (animate) {

	                    // Never allow two timeouts
	                    clearTimeout(this.tooltipTimeout);

	                    // Set the fixed interval ticking for the smooth tooltip
	                    this.tooltipTimeout = setTimeout(function() {
	                        // The interval function may still be running during destroy,
	                        // so check that the chart is really there before calling.
	                        if (tooltip) {
	                            tooltip.move(x, y, anchorX, anchorY);
	                        }
	                    }, 32);

	                }
	            },

	            /**
	             * Hide the tooltip
	             */
	            hide: function(delay) {
	                var tooltip = this;
	                clearTimeout(this.hideTimer); // disallow duplicate timers (#1728, #1766)
	                delay = pick(delay, this.options.hideDelay, 500);
	                if (!this.isHidden) {
	                    this.hideTimer = syncTimeout(function() {
	                        tooltip.getLabel()[delay ? 'fadeOut' : 'hide']();
	                        tooltip.isHidden = true;
	                    }, delay);
	                }
	            },

	            /**
	             * Extendable method to get the anchor position of the tooltip
	             * from a point or set of points
	             */
	            getAnchor: function(points, mouseEvent) {
	                var ret,
	                    chart = this.chart,
	                    inverted = chart.inverted,
	                    plotTop = chart.plotTop,
	                    plotLeft = chart.plotLeft,
	                    plotX = 0,
	                    plotY = 0,
	                    yAxis,
	                    xAxis;

	                points = splat(points);

	                // Pie uses a special tooltipPos
	                ret = points[0].tooltipPos;

	                // When tooltip follows mouse, relate the position to the mouse
	                if (this.followPointer && mouseEvent) {
	                    if (mouseEvent.chartX === undefined) {
	                        mouseEvent = chart.pointer.normalize(mouseEvent);
	                    }
	                    ret = [
	                        mouseEvent.chartX - chart.plotLeft,
	                        mouseEvent.chartY - plotTop
	                    ];
	                }
	                // When shared, use the average position
	                if (!ret) {
	                    each(points, function(point) {
	                        yAxis = point.series.yAxis;
	                        xAxis = point.series.xAxis;
	                        plotX += point.plotX + (!inverted && xAxis ? xAxis.left - plotLeft : 0);
	                        plotY += (point.plotLow ? (point.plotLow + point.plotHigh) / 2 : point.plotY) +
	                            (!inverted && yAxis ? yAxis.top - plotTop : 0); // #1151
	                    });

	                    plotX /= points.length;
	                    plotY /= points.length;

	                    ret = [
	                        inverted ? chart.plotWidth - plotY : plotX,
	                        this.shared && !inverted && points.length > 1 && mouseEvent ?
	                        mouseEvent.chartY - plotTop : // place shared tooltip next to the mouse (#424)
	                        inverted ? chart.plotHeight - plotX : plotY
	                    ];
	                }

	                return map(ret, Math.round);
	            },

	            /**
	             * Place the tooltip in a chart without spilling over
	             * and not covering the point it self.
	             */
	            getPosition: function(boxWidth, boxHeight, point) {

	                var chart = this.chart,
	                    distance = this.distance,
	                    ret = {},
	                    h = point.h || 0, // #4117
	                    swapped,
	                    first = ['y', chart.chartHeight, boxHeight,
	                        point.plotY + chart.plotTop, chart.plotTop,
	                        chart.plotTop + chart.plotHeight
	                    ],
	                    second = ['x', chart.chartWidth, boxWidth,
	                        point.plotX + chart.plotLeft, chart.plotLeft,
	                        chart.plotLeft + chart.plotWidth
	                    ],
	                    // The far side is right or bottom
	                    preferFarSide = !this.followPointer && pick(point.ttBelow, !chart.inverted === !!point.negative), // #4984
	                    /**
	                     * Handle the preferred dimension. When the preferred dimension is tooltip
	                     * on top or bottom of the point, it will look for space there.
	                     */
	                    firstDimension = function(dim, outerSize, innerSize, point, min, max) {
	                        var roomLeft = innerSize < point - distance,
	                            roomRight = point + distance + innerSize < outerSize,
	                            alignedLeft = point - distance - innerSize,
	                            alignedRight = point + distance;

	                        if (preferFarSide && roomRight) {
	                            ret[dim] = alignedRight;
	                        } else if (!preferFarSide && roomLeft) {
	                            ret[dim] = alignedLeft;
	                        } else if (roomLeft) {
	                            ret[dim] = Math.min(max - innerSize, alignedLeft - h < 0 ? alignedLeft : alignedLeft - h);
	                        } else if (roomRight) {
	                            ret[dim] = Math.max(
	                                min,
	                                alignedRight + h + innerSize > outerSize ?
	                                alignedRight :
	                                alignedRight + h
	                            );
	                        } else {
	                            return false;
	                        }
	                    },
	                    /**
	                     * Handle the secondary dimension. If the preferred dimension is tooltip
	                     * on top or bottom of the point, the second dimension is to align the tooltip
	                     * above the point, trying to align center but allowing left or right
	                     * align within the chart box.
	                     */
	                    secondDimension = function(dim, outerSize, innerSize, point) {
	                        var retVal;

	                        // Too close to the edge, return false and swap dimensions
	                        if (point < distance || point > outerSize - distance) {
	                            retVal = false;
	                            // Align left/top
	                        } else if (point < innerSize / 2) {
	                            ret[dim] = 1;
	                            // Align right/bottom
	                        } else if (point > outerSize - innerSize / 2) {
	                            ret[dim] = outerSize - innerSize - 2;
	                            // Align center
	                        } else {
	                            ret[dim] = point - innerSize / 2;
	                        }
	                        return retVal;
	                    },
	                    /**
	                     * Swap the dimensions
	                     */
	                    swap = function(count) {
	                        var temp = first;
	                        first = second;
	                        second = temp;
	                        swapped = count;
	                    },
	                    run = function() {
	                        if (firstDimension.apply(0, first) !== false) {
	                            if (secondDimension.apply(0, second) === false && !swapped) {
	                                swap(true);
	                                run();
	                            }
	                        } else if (!swapped) {
	                            swap(true);
	                            run();
	                        } else {
	                            ret.x = ret.y = 0;
	                        }
	                    };

	                // Under these conditions, prefer the tooltip on the side of the point
	                if (chart.inverted || this.len > 1) {
	                    swap();
	                }
	                run();

	                return ret;

	            },

	            /**
	             * In case no user defined formatter is given, this will be used. Note that the context
	             * here is an object holding point, series, x, y etc.
	             *
	             * @returns {String|Array<String>}
	             */
	            defaultFormatter: function(tooltip) {
	                var items = this.points || splat(this),
	                    s;

	                // Build the header
	                s = [tooltip.tooltipFooterHeaderFormatter(items[0])];

	                // build the values
	                s = s.concat(tooltip.bodyFormatter(items));

	                // footer
	                s.push(tooltip.tooltipFooterHeaderFormatter(items[0], true));

	                return s;
	            },

	            /**
	             * Refresh the tooltip's text and position.
	             * @param {Object|Array} pointOrPoints Rither a point or an array of points
	             */
	            refresh: function(pointOrPoints, mouseEvent) {
	                var tooltip = this,
	                    label,
	                    options = tooltip.options,
	                    x,
	                    y,
	                    point = pointOrPoints,
	                    anchor,
	                    textConfig = {},
	                    text,
	                    pointConfig = [],
	                    formatter = options.formatter || tooltip.defaultFormatter,
	                    shared = tooltip.shared,
	                    currentSeries;

	                if (!options.enabled) {
	                    return;
	                }

	                clearTimeout(this.hideTimer);

	                // get the reference point coordinates (pie charts use tooltipPos)
	                tooltip.followPointer = splat(point)[0].series.tooltipOptions.followPointer;
	                anchor = tooltip.getAnchor(point, mouseEvent);
	                x = anchor[0];
	                y = anchor[1];

	                // shared tooltip, array is sent over
	                if (shared && !(point.series && point.series.noSharedTooltip)) {
	                    each(point, function(item) {
	                        item.setState('hover');

	                        pointConfig.push(item.getLabelConfig());
	                    });

	                    textConfig = {
	                        x: point[0].category,
	                        y: point[0].y
	                    };
	                    textConfig.points = pointConfig;
	                    point = point[0];

	                    // single point tooltip
	                } else {
	                    textConfig = point.getLabelConfig();
	                }
	                this.len = pointConfig.length; // #6128
	                text = formatter.call(textConfig, tooltip);

	                // register the current series
	                currentSeries = point.series;
	                this.distance = pick(currentSeries.tooltipOptions.distance, 16);

	                // update the inner HTML
	                if (text === false) {
	                    this.hide();
	                } else {

	                    label = tooltip.getLabel();

	                    // show it
	                    if (tooltip.isHidden) {
	                        label.attr({
	                            opacity: 1
	                        }).show();
	                    }

	                    // update text
	                    if (tooltip.split) {
	                        this.renderSplit(text, pointOrPoints);
	                    } else {

	                        // Prevent the tooltip from flowing over the chart box (#6659)

	                        if (!options.style.width) {

	                            label.css({
	                                width: this.chart.spacingBox.width
	                            });

	                        }


	                        label.attr({
	                            text: text && text.join ? text.join('') : text
	                        });

	                        // Set the stroke color of the box to reflect the point
	                        label.removeClass(/highcharts-color-[\d]+/g)
	                            .addClass('highcharts-color-' + pick(point.colorIndex, currentSeries.colorIndex));


	                        label.attr({
	                            stroke: options.borderColor || point.color || currentSeries.color || '#666666'
	                        });


	                        tooltip.updatePosition({
	                            plotX: x,
	                            plotY: y,
	                            negative: point.negative,
	                            ttBelow: point.ttBelow,
	                            h: anchor[2] || 0
	                        });
	                    }

	                    this.isHidden = false;
	                }
	            },

	            /**
	             * Render the split tooltip. Loops over each point's text and adds
	             * a label next to the point, then uses the distribute function to 
	             * find best non-overlapping positions.
	             */
	            renderSplit: function(labels, points) {
	                var tooltip = this,
	                    boxes = [],
	                    chart = this.chart,
	                    ren = chart.renderer,
	                    rightAligned = true,
	                    options = this.options,
	                    headerHeight = 0,
	                    tooltipLabel = this.getLabel();

	                // Create the individual labels for header and points, ignore footer
	                each(labels.slice(0, points.length + 1), function(str, i) {
	                    if (str !== false) {
	                        var point = points[i - 1] ||
	                            // Item 0 is the header. Instead of this, we could also
	                            // use the crosshair label
	                            {
	                                isHeader: true,
	                                plotX: points[0].plotX
	                            },
	                            owner = point.series || tooltip,
	                            tt = owner.tt,
	                            series = point.series || {},
	                            colorClass = 'highcharts-color-' + pick(
	                                point.colorIndex,
	                                series.colorIndex,
	                                'none'
	                            ),
	                            target,
	                            x,
	                            bBox,
	                            boxWidth;

	                        // Store the tooltip referance on the series
	                        if (!tt) {
	                            owner.tt = tt = ren.label(null, null, null, 'callout')
	                                .addClass('highcharts-tooltip-box ' + colorClass)
	                                .attr({
	                                    'padding': options.padding,
	                                    'r': options.borderRadius,

	                                    'fill': options.backgroundColor,
	                                    'stroke': (
	                                        options.borderColor ||
	                                        point.color ||
	                                        series.color ||
	                                        '#333333'
	                                    ),
	                                    'stroke-width': options.borderWidth

	                                })
	                                .add(tooltipLabel);
	                        }

	                        tt.isActive = true;
	                        tt.attr({
	                            text: str
	                        });

	                        tt.css(options.style)
	                            .shadow(options.shadow);


	                        // Get X position now, so we can move all to the other side in
	                        // case of overflow
	                        bBox = tt.getBBox();
	                        boxWidth = bBox.width + tt.strokeWidth();
	                        if (point.isHeader) {
	                            headerHeight = bBox.height;
	                            x = Math.max(
	                                0, // No left overflow
	                                Math.min(
	                                    point.plotX + chart.plotLeft - boxWidth / 2,
	                                    // No right overflow (#5794)
	                                    chart.chartWidth - boxWidth
	                                )
	                            );
	                        } else {
	                            x = point.plotX + chart.plotLeft -
	                                pick(options.distance, 16) - boxWidth;
	                        }


	                        // If overflow left, we don't use this x in the next loop
	                        if (x < 0) {
	                            rightAligned = false;
	                        }

	                        // Prepare for distribution
	                        target = (point.series && point.series.yAxis &&
	                            point.series.yAxis.pos) + (point.plotY || 0);
	                        target -= chart.plotTop;
	                        boxes.push({
	                            target: point.isHeader ?
	                                chart.plotHeight + headerHeight : target,
	                            rank: point.isHeader ? 1 : 0,
	                            size: owner.tt.getBBox().height + 1,
	                            point: point,
	                            x: x,
	                            tt: tt
	                        });
	                    }
	                });

	                // Clean previous run (for missing points)
	                this.cleanSplit();

	                // Distribute and put in place
	                H.distribute(boxes, chart.plotHeight + headerHeight);
	                each(boxes, function(box) {
	                    var point = box.point,
	                        series = point.series;

	                    // Put the label in place
	                    box.tt.attr({
	                        visibility: box.pos === undefined ? 'hidden' : 'inherit',
	                        x: (rightAligned || point.isHeader ?
	                            box.x :
	                            point.plotX + chart.plotLeft + pick(options.distance, 16)),
	                        y: box.pos + chart.plotTop,
	                        anchorX: point.isHeader ?
	                            point.plotX + chart.plotLeft : point.plotX + series.xAxis.pos,
	                        anchorY: point.isHeader ?
	                            box.pos + chart.plotTop - 15 : point.plotY + series.yAxis.pos
	                    });
	                });
	            },

	            /**
	             * Find the new position and perform the move
	             */
	            updatePosition: function(point) {
	                var chart = this.chart,
	                    label = this.getLabel(),
	                    pos = (this.options.positioner || this.getPosition).call(
	                        this,
	                        label.width,
	                        label.height,
	                        point
	                    );

	                // do the move
	                this.move(
	                    Math.round(pos.x),
	                    Math.round(pos.y || 0), // can be undefined (#3977) 
	                    point.plotX + chart.plotLeft,
	                    point.plotY + chart.plotTop
	                );
	            },

	            /**
	             * Get the optimal date format for a point, based on a range.
	             * @param  {number} range - The time range
	             * @param  {number|Date} date - The date of the point in question
	             * @param  {number} startOfWeek - An integer representing the first day of
	             * the week, where 0 is Sunday
	             * @param  {Object} dateTimeLabelFormats - A map of time units to formats
	             * @return {string} - the optimal date format for a point
	             */
	            getDateFormat: function(range, date, startOfWeek, dateTimeLabelFormats) {
	                var dateStr = dateFormat('%m-%d %H:%M:%S.%L', date),
	                    format,
	                    n,
	                    blank = '01-01 00:00:00.000',
	                    strpos = {
	                        millisecond: 15,
	                        second: 12,
	                        minute: 9,
	                        hour: 6,
	                        day: 3
	                    },
	                    lastN = 'millisecond'; // for sub-millisecond data, #4223
	                for (n in timeUnits) {

	                    // If the range is exactly one week and we're looking at a Sunday/Monday, go for the week format
	                    if (range === timeUnits.week && +dateFormat('%w', date) === startOfWeek &&
	                        dateStr.substr(6) === blank.substr(6)) {
	                        n = 'week';
	                        break;
	                    }

	                    // The first format that is too great for the range
	                    if (timeUnits[n] > range) {
	                        n = lastN;
	                        break;
	                    }

	                    // If the point is placed every day at 23:59, we need to show
	                    // the minutes as well. #2637.
	                    if (strpos[n] && dateStr.substr(strpos[n]) !== blank.substr(strpos[n])) {
	                        break;
	                    }

	                    // Weeks are outside the hierarchy, only apply them on Mondays/Sundays like in the first condition
	                    if (n !== 'week') {
	                        lastN = n;
	                    }
	                }

	                if (n) {
	                    format = dateTimeLabelFormats[n];
	                }

	                return format;
	            },

	            /**
	             * Get the best X date format based on the closest point range on the axis.
	             */
	            getXDateFormat: function(point, options, xAxis) {
	                var xDateFormat,
	                    dateTimeLabelFormats = options.dateTimeLabelFormats,
	                    closestPointRange = xAxis && xAxis.closestPointRange;

	                if (closestPointRange) {
	                    xDateFormat = this.getDateFormat(
	                        closestPointRange,
	                        point.x,
	                        xAxis.options.startOfWeek,
	                        dateTimeLabelFormats
	                    );
	                } else {
	                    xDateFormat = dateTimeLabelFormats.day;
	                }

	                return xDateFormat || dateTimeLabelFormats.year; // #2546, 2581
	            },

	            /**
	             * Format the footer/header of the tooltip
	             * #3397: abstraction to enable formatting of footer and header
	             */
	            tooltipFooterHeaderFormatter: function(labelConfig, isFooter) {
	                var footOrHead = isFooter ? 'footer' : 'header',
	                    series = labelConfig.series,
	                    tooltipOptions = series.tooltipOptions,
	                    xDateFormat = tooltipOptions.xDateFormat,
	                    xAxis = series.xAxis,
	                    isDateTime = xAxis && xAxis.options.type === 'datetime' && isNumber(labelConfig.key),
	                    formatString = tooltipOptions[footOrHead + 'Format'];

	                // Guess the best date format based on the closest point distance (#568, #3418)
	                if (isDateTime && !xDateFormat) {
	                    xDateFormat = this.getXDateFormat(labelConfig, tooltipOptions, xAxis);
	                }

	                // Insert the footer date format if any
	                if (isDateTime && xDateFormat) {
	                    formatString = formatString.replace('{point.key}', '{point.key:' + xDateFormat + '}');
	                }

	                return format(formatString, {
	                    point: labelConfig,
	                    series: series
	                });
	            },

	            /**
	             * Build the body (lines) of the tooltip by iterating over the items and returning one entry for each item,
	             * abstracting this functionality allows to easily overwrite and extend it.
	             */
	            bodyFormatter: function(items) {
	                return map(items, function(item) {
	                    var tooltipOptions = item.series.tooltipOptions;
	                    return (tooltipOptions.pointFormatter || item.point.tooltipFormatter)
	                        .call(item.point, tooltipOptions.pointFormat);
	                });
	            }

	        };

	    }(Highcharts));
	    (function(Highcharts) {
	        /**
	         * (c) 2010-2017 Torstein Honsi
	         *
	         * License: www.highcharts.com/license
	         */
	        var H = Highcharts,
	            addEvent = H.addEvent,
	            attr = H.attr,
	            charts = H.charts,
	            color = H.color,
	            css = H.css,
	            defined = H.defined,
	            each = H.each,
	            extend = H.extend,
	            find = H.find,
	            fireEvent = H.fireEvent,
	            isObject = H.isObject,
	            offset = H.offset,
	            pick = H.pick,
	            removeEvent = H.removeEvent,
	            splat = H.splat,
	            Tooltip = H.Tooltip,
	            win = H.win;

	        /**
	         * The mouse and touch tracker object. Each {@link Chart} item has one
	         * assosiated Pointer item that can be accessed from the  {@link Chart.pointer}
	         * property.
	         *
	         * @class
	         * @param  {Chart} chart
	         *         The Chart instance.
	         * @param  {Options} options
	         *         The root options object. The pointer uses options from the chart and
	         *         tooltip structures.
	         */
	        Highcharts.Pointer = function(chart, options) {
	            this.init(chart, options);
	        };

	        Highcharts.Pointer.prototype = {
	            /**
	             * Initialize the Pointer.
	             *
	             * @private
	             */
	            init: function(chart, options) {

	                // Store references
	                this.options = options;
	                this.chart = chart;

	                // Do we need to handle click on a touch device?
	                this.runChartClick = options.chart.events && !!options.chart.events.click;

	                this.pinchDown = [];
	                this.lastValidTouch = {};

	                if (Tooltip) {
	                    chart.tooltip = new Tooltip(chart, options.tooltip);
	                    this.followTouchMove = pick(options.tooltip.followTouchMove, true);
	                }

	                this.setDOMEvents();
	            },

	            /**
	             * Resolve the zoomType option, this is reset on all touch start and mouse
	             * down events.
	             *
	             * @private
	             */
	            zoomOption: function(e) {
	                var chart = this.chart,
	                    options = chart.options.chart,
	                    zoomType = options.zoomType || '',
	                    inverted = chart.inverted,
	                    zoomX,
	                    zoomY;

	                // Look for the pinchType option
	                if (/touch/.test(e.type)) {
	                    zoomType = pick(options.pinchType, zoomType);
	                }

	                this.zoomX = zoomX = /x/.test(zoomType);
	                this.zoomY = zoomY = /y/.test(zoomType);
	                this.zoomHor = (zoomX && !inverted) || (zoomY && inverted);
	                this.zoomVert = (zoomY && !inverted) || (zoomX && inverted);
	                this.hasZoom = zoomX || zoomY;
	            },

	            /**
	             * @typedef  {Object} PointerEvent
	             *           A native browser mouse or touch event, extended with position
	             *           information relative to the {@link Chart.container}.
	             * @property {Number} chartX
	             *           The X coordinate of the pointer interaction relative to the
	             *           chart.
	             * @property {Number} chartY
	             *           The Y coordinate of the pointer interaction relative to the 
	             *           chart.
	             * 
	             */
	            /**
	             * Takes a browser event object and extends it with custom Highcharts
	             * properties `chartX` and `chartY` in order to work on the internal 
	             * coordinate system.
	             * 
	             * @param  {Object} e
	             *         The event object in standard browsers.
	             *
	             * @return {PointerEvent}
	             *         A browser event with extended properties `chartX` and `chartY`.
	             */
	            normalize: function(e, chartPosition) {
	                var chartX,
	                    chartY,
	                    ePos;

	                // IE normalizing
	                e = e || win.event;
	                if (!e.target) {
	                    e.target = e.srcElement;
	                }

	                // iOS (#2757)
	                ePos = e.touches ? (e.touches.length ? e.touches.item(0) : e.changedTouches[0]) : e;

	                // Get mouse position
	                if (!chartPosition) {
	                    this.chartPosition = chartPosition = offset(this.chart.container);
	                }

	                // chartX and chartY
	                if (ePos.pageX === undefined) { // IE < 9. #886.
	                    chartX = Math.max(e.x, e.clientX - chartPosition.left); // #2005, #2129: the second case is 
	                    // for IE10 quirks mode within framesets
	                    chartY = e.y;
	                } else {
	                    chartX = ePos.pageX - chartPosition.left;
	                    chartY = ePos.pageY - chartPosition.top;
	                }

	                return extend(e, {
	                    chartX: Math.round(chartX),
	                    chartY: Math.round(chartY)
	                });
	            },

	            /**
	             * Get the click position in terms of axis values.
	             *
	             * @param  {PointerEvent} e
	             *         A pointer event, extended with `chartX` and `chartY`
	             *         properties.
	             */
	            getCoordinates: function(e) {
	                var coordinates = {
	                    xAxis: [],
	                    yAxis: []
	                };

	                each(this.chart.axes, function(axis) {
	                    coordinates[axis.isXAxis ? 'xAxis' : 'yAxis'].push({
	                        axis: axis,
	                        value: axis.toValue(e[axis.horiz ? 'chartX' : 'chartY'])
	                    });
	                });
	                return coordinates;
	            },
	            /**
	             * Finds the closest point to a set of coordinates, using the k-d-tree
	             * algorithm.
	             *
	             * @param  {Array.<Series>} series
	             *         All the series to search in.
	             * @param  {boolean} shared
	             *         Whether it is a shared tooltip or not.
	             * @param  {object} coordinates
	             *         Chart coordinates of the pointer.
	             * @param  {number} coordinates.chartX
	             * @param  {number} coordinates.chartY
	             *
	             * @return {Point|undefined} The point closest to given coordinates.
	             */
	            findNearestKDPoint: function(series, shared, coordinates) {
	                var closest,
	                    sort = function(p1, p2) {
	                        var isCloserX = p1.distX - p2.distX,
	                            isCloser = p1.dist - p2.dist,
	                            isAbove =
	                            (p2.series.group && p2.series.group.zIndex) -
	                            (p1.series.group && p1.series.group.zIndex),
	                            result;

	                        // We have two points which are not in the same place on xAxis
	                        // and shared tooltip:
	                        if (isCloserX !== 0 && shared) { // #5721
	                            result = isCloserX;
	                            // Points are not exactly in the same place on x/yAxis:
	                        } else if (isCloser !== 0) {
	                            result = isCloser;
	                            // The same xAxis and yAxis position, sort by z-index:
	                        } else if (isAbove !== 0) {
	                            result = isAbove;
	                            // The same zIndex, sort by array index:
	                        } else {
	                            result = p1.series.index > p2.series.index ? -1 : 1;
	                        }
	                        return result;
	                    };
	                each(series, function(s) {
	                    var noSharedTooltip = s.noSharedTooltip && shared,
	                        compareX = (!noSharedTooltip &&
	                            s.options.findNearestPointBy.indexOf('y') < 0
	                        ),
	                        point = s.searchPoint(
	                            coordinates,
	                            compareX
	                        );
	                    if (
	                        // Check that we actually found a point on the series.
	                        isObject(point, true) &&
	                        // Use the new point if it is closer.
	                        (!isObject(closest, true) || (sort(closest, point) > 0))
	                    ) {
	                        closest = point;
	                    }
	                });
	                return closest;
	            },
	            getPointFromEvent: function(e) {
	                var target = e.target,
	                    point;

	                while (target && !point) {
	                    point = target.point;
	                    target = target.parentNode;
	                }
	                return point;
	            },

	            getChartCoordinatesFromPoint: function(point, inverted) {
	                var series = point.series,
	                    xAxis = series.xAxis,
	                    yAxis = series.yAxis;

	                if (xAxis && yAxis) {
	                    return inverted ? {
	                        chartX: xAxis.len + xAxis.pos - point.clientX,
	                        chartY: yAxis.len + yAxis.pos - point.plotY
	                    } : {
	                        chartX: point.clientX + xAxis.pos,
	                        chartY: point.plotY + yAxis.pos
	                    };
	                }
	            },

	            /**
	             * Calculates what is the current hovered point/points and series.
	             *
	             * @private
	             *
	             * @param  {undefined|Point} existingHoverPoint
	             *         The point currrently beeing hovered.
	             * @param  {undefined|Series} existingHoverSeries
	             *         The series currently beeing hovered.
	             * @param  {Array.<Series>} series
	             *         All the series in the chart.
	             * @param  {boolean} isDirectTouch
	             *         Is the pointer directly hovering the point.
	             * @param  {boolean} shared
	             *         Whether it is a shared tooltip or not.
	             * @param  {object} coordinates
	             *         Chart coordinates of the pointer.
	             * @param  {number} coordinates.chartX
	             * @param  {number} coordinates.chartY
	             * 
	             * @return {object}
	             *         Object containing resulting hover data.
	             */
	            getHoverData: function(
	                existingHoverPoint,
	                existingHoverSeries,
	                series,
	                isDirectTouch,
	                shared,
	                coordinates
	            ) {
	                var hoverPoint,
	                    hoverPoints = [],
	                    hoverSeries = existingHoverSeries,
	                    useExisting = !!(isDirectTouch && existingHoverPoint),
	                    notSticky = hoverSeries && !hoverSeries.stickyTracking,
	                    filter = function(s) {
	                        return (
	                            s.visible &&
	                            !(!shared && s.directTouch) && // #3821
	                            pick(s.options.enableMouseTracking, true)
	                        );
	                    },
	                    // Which series to look in for the hover point
	                    searchSeries = notSticky ?
	                    // Only search on hovered series if it has stickyTracking false
	                    [hoverSeries] :
	                    // Filter what series to look in.
	                    H.grep(series, function(s) {
	                        return filter(s) && s.stickyTracking;
	                    });

	                // Use existing hovered point or find the one closest to coordinates.
	                hoverPoint = useExisting ?
	                    existingHoverPoint :
	                    this.findNearestKDPoint(searchSeries, shared, coordinates);

	                // Assign hover series
	                hoverSeries = hoverPoint && hoverPoint.series;

	                // If we have a hoverPoint, assign hoverPoints.
	                if (hoverPoint) {
	                    // When tooltip is shared, it displays more than one point
	                    if (shared && !hoverSeries.noSharedTooltip) {
	                        searchSeries = H.grep(series, function(s) {
	                            return filter(s) && !s.noSharedTooltip;
	                        });

	                        // Get all points with the same x value as the hoverPoint
	                        each(searchSeries, function(s) {
	                            var point = find(s.points, function(p) {
	                                return p.x === hoverPoint.x;
	                            });
	                            if (isObject(point) && !point.isNull) {
	                                hoverPoints.push(point);
	                            }
	                        });
	                    } else {
	                        hoverPoints.push(hoverPoint);
	                    }
	                }

	                return {
	                    hoverPoint: hoverPoint,
	                    hoverSeries: hoverSeries,
	                    hoverPoints: hoverPoints
	                };
	            },
	            /**
	             * With line type charts with a single tracker, get the point closest to the
	             * mouse. Run Point.onMouseOver and display tooltip for the point or points.
	             *
	             * @private
	             */
	            addCommas: function(nStr)
	            {
	                nStr += '';
	                var x = nStr.split('.');
	                var x1 = x[0];
	                var x2 = x.length > 1 ? '.' + x[1] : '';
	                var rgx = /(\d+)(\d{3})/;
	                while (rgx.test(x1)) {
	                    x1 = x1.replace(rgx, '$1' + ',' + '$2');
	                }
	                return x1 + x2;
	            },
	            runPointActions: function(e, p) {
	                var pointer = this,
	                    chart = pointer.chart,
	                    series = chart.series,
	                    tooltip = chart.tooltip,
	                    shared = tooltip ? tooltip.shared : false,
	                    hoverPoint = p || chart.hoverPoint,
	                    hoverSeries = hoverPoint && hoverPoint.series || chart.hoverSeries,
	                    // onMouseOver or already hovering a series with directTouch
	                    isDirectTouch = !!p || (
	                        (hoverSeries && hoverSeries.directTouch) &&
	                        pointer.isDirectTouch
	                    ),
	                    hoverData = this.getHoverData(
	                        hoverPoint,
	                        hoverSeries,
	                        series,
	                        isDirectTouch,
	                        shared,
	                        e
	                    ),
	                    useSharedTooltip,
	                    followPointer,
	                    anchor,
	                    points;

	                //-----------------------------self mod
	                if(chart.userOptions.custom_highchart != undefined && typeof hoverData.hoverPoint != 'undefined')
	                {
	                    // console.log(chart.userOptions.custom_highchart.chartType, hoverData.hoverPoint, series);
	                    if (chart.userOptions.custom_highchart.chartType == 3){
	                        if(series[2].points.indexOf(hoverData.hoverPoint) < 0)
	                            return false;
	                        else
	                            var tradeTimes = chart.userOptions.custom_highchart.tradeTimes[hoverData.hoverPoint.index][1]
	                    }
	                    
	                    var customSettings = chart.userOptions.custom_highchart;

	                    if (customSettings.clickCallback)
	                    {
	                        customSettings.clickCallback(hoverData.hoverPoints);
	                    }

	                    var current_date = new Date(hoverData.hoverPoint.x);
	                    var current_year = current_date.getFullYear();
	                    var current_month = current_date.getMonth() + 1;
	                    var current_day = current_date.getDate();
	                    var current_hour = current_date.getHours();
	                    var current_minute = current_date.getMinutes();

	                    
	                    if (customSettings.date_format != undefined)
	                    {                        
	                        $(customSettings.date_target).text(H.dateFormat(customSettings.date_format, current_date));
	                    }
	                    else
	                    {
	                        $(customSettings.date_target).text(H.dateFormat('%Y/%m/%d', current_date));
	                    } 
	                    
	                    if (chart.userOptions.custom_highchart.chartType == 3)
	                    {
	                        
	                        $(customSettings.date_target).hide();
	                        $(chart.userOptions.custom_highchart.label1_target).html('<i class="fa fa-minus dot color1"></i>' + chart.userOptions.custom_highchart.label1_name);
	                        $(chart.userOptions.custom_highchart.label2_target).html('<i class="fa fa-circle-o dot color2"></i>' + chart.userOptions.custom_highchart.label2_name +
	                                                                                 '<br>您於 ' + H.dateFormat('%Y/%m/%d', current_date) +
	                                                                                 ' 有 ' + tradeTimes + ' 筆換匯紀錄');
	                    }
	                    else if (chart.userOptions.custom_highchart.chartType == 4){
	                        var dataName  = [ chart.userOptions.custom_highchart.rawData[0]['name'],
	                                          chart.userOptions.custom_highchart.rawData[1]['name'] ];
	                        var rawDataValue = [chart.userOptions.custom_highchart.rawData[0]['data'][hoverData.hoverPoint.index][1],
	                                            chart.userOptions.custom_highchart.rawData[1]['data'][hoverData.hoverPoint.index][1]]
	                        var dataValue = [ this.addCommas(rawDataValue[0]),
	                                          this.addCommas(rawDataValue[1]) ];
	                        var dataMonth = hoverData.hoverPoint.x;
	                        if (dataMonth.toString().length == 1){
	                            dataMonth = '0' + dataMonth;
	                        }
	                        var lastDateOfMonth = new Date(chart.userOptions.custom_highchart.rawData[0]['year'], hoverData.hoverPoint.x, 0);
	                        $(chart.userOptions.custom_highchart.label1_target).html('<i class="fa fa-minus dot color1"></i>' + dataName[0] + ' - ' + dataName[1]);
	                        $(chart.userOptions.custom_highchart.label2_target).html('<i class="fa fa-circle dot color1"></i>' + dataMonth + '/01~' + dataMonth + '/' + lastDateOfMonth.getDate() +
	                                                                                 '<br> ' + dataName[0] + ' ' + dataValue[0] +
	                                                                                 ' ' + dataName[1] + ' ' + dataValue[1] +
	                                                                                 '<br> ' + dataName[0] + '-' + dataName[1] + ' ' + this.addCommas(rawDataValue[0] - rawDataValue[1]) ); 
	                    }
	                    else
	                    {
	                        if(hoverData.hoverPoints.length > 1)
	                        {                        
	                            var label1_value = Number(hoverData.hoverPoints[0].y).toFixed(chart.userOptions.custom_highchart.fixed_places);
	                            var label2_value = Number(hoverData.hoverPoints[1].y).toFixed(chart.userOptions.custom_highchart.fixed_places);
	                            //20171120 add thousands seperator
	                            if (chart.userOptions.custom_highchart.thousands_seperator != undefined && chart.userOptions.custom_highchart.thousands_seperator == true)
	                            {
	                                label1_value = this.addCommas(label1_value);
	                                label2_value = this.addCommas(label2_value);
	                            }
	                            $(chart.userOptions.custom_highchart.label1_target).html('<i class="fa fa-circle dot color1"></i>' + chart.userOptions.custom_highchart.label1_name + " " + label1_value + chart.userOptions.custom_highchart.axisy_unit);
	                            $(chart.userOptions.custom_highchart.label2_target).html('<i class="fa fa-circle dot color2"></i>' + chart.userOptions.custom_highchart.label2_name + " " + label2_value + chart.userOptions.custom_highchart.axisy_unit);
	                        }   
	                        else
	                        {
	                            var label1_value = Number(hoverData.hoverPoints[0].y).toFixed(chart.userOptions.custom_highchart.fixed_places);
	                            //20171120 add thousands seperator
	                            if (chart.userOptions.custom_highchart.thousands_seperator != undefined && chart.userOptions.custom_highchart.thousands_seperator == true)
	                            {
	                                label1_value = this.addCommas(label1_value);
	                            }
	                            $(chart.userOptions.custom_highchart.label1_target).html('<i class="fa fa-circle dot color1"></i>' + chart.userOptions.custom_highchart.label1_name + " " + label1_value + chart.userOptions.custom_highchart.axisy_unit);
	                            
	                        }
	                    }

	                }


	                
	                
	                //-----------------------------selfmod

	                // Update variables from hoverData.
	                hoverPoint = hoverData.hoverPoint;
	                points = hoverData.hoverPoints;
	                hoverSeries = hoverData.hoverSeries;
	                followPointer = hoverSeries && hoverSeries.tooltipOptions.followPointer;
	                useSharedTooltip = shared && hoverSeries && !hoverSeries.noSharedTooltip;

	                // Refresh tooltip for kdpoint if new hover point or tooltip was hidden
	                // #3926, #4200
	                if (hoverPoint) {
	                    this.reset(false, 0);
	                    each(chart.hoverPoints || [], function(p) {
	                        if (H.inArray(p, points) === -1) {
	                            p.setState();
	                        }
	                    });
	                    // Do mouseover on all points (#3919, #3985, #4410, #5622)
	                    each(points || [], function(p) {
	                        p.setState('hover');
	                    });
	                    // set normal state to previous series
	                    if (chart.hoverSeries !== hoverSeries) {
	                        hoverSeries.onMouseOver();
	                    }

	                    // If tracking is on series in stead of on each point, 
	                    // fire mouseOver on hover point. // #4448
	                    if (chart.hoverPoint) {
	                        chart.hoverPoint.firePointEvent('mouseOut');
	                    }
	                    hoverPoint.firePointEvent('mouseOver');
	                    chart.hoverPoints = points;
	                    chart.hoverPoint = hoverPoint;
	                    // Draw tooltip if necessary
	                    if (tooltip) {
	                        tooltip.refresh(useSharedTooltip ? points : hoverPoint, e);
	                    }
	                    // Update positions (regardless of kdpoint or hoverPoint)
	                } 
	                // else if (followPointer && tooltip && !tooltip.isHidden) {
	                //     anchor = tooltip.getAnchor([{}], e);
	                //     tooltip.updatePosition({
	                //         plotX: anchor[0],
	                //         plotY: anchor[1]
	                //     });
	                // }





	                // Start the event listener to pick up the tooltip and crosshairs
	                // if (!pointer.unDocMouseMove) {
	                //     pointer.unDocMouseMove = addEvent(
	                //         chart.container.ownerDocument,
	                //         'mousemove',
	                //         function(e) {
	                //             var chart = charts[H.hoverChartIndex];
	                //             if (chart) {
	                //                 chart.pointer.onDocumentMouseMove(e);
	                //             }
	                //         }
	                //     );
	                // }

	                // Issues related to crosshair #4927, #5269 #5066, #5658
	                each(chart.axes, function drawAxisCrosshair(axis) {
	                    var snap = pick(axis.crosshair.snap, true),
	                        point = !snap ?
	                        undefined :
	                        H.find(points, function(p) {
	                            return p.series[axis.coll] === axis;
	                        });

	                    // Axis has snapping crosshairs, and one of the hover points belongs
	                    // to axis. Always call drawCrosshair when it is not snap.
	                    if (point || !snap) {
	                        axis.drawCrosshair(e, point);
	                        // Axis has snapping crosshairs, but no hover point belongs to axis
	                    } else {
	                        axis.hideCrosshair();
	                    }
	                });
	            },

	            /**
	             * Reset the tracking by hiding the tooltip, the hover series state and the
	             * hover point
	             *
	             * @param allowMove {Boolean}
	             *        Instead of destroying the tooltip altogether, allow moving it if
	             *        possible.
	             */
	            reset: function(allowMove, delay) {
	                var pointer = this,
	                    chart = pointer.chart,
	                    hoverSeries = chart.hoverSeries,
	                    hoverPoint = chart.hoverPoint,
	                    hoverPoints = chart.hoverPoints,
	                    tooltip = chart.tooltip,
	                    tooltipPoints = tooltip && tooltip.shared ? hoverPoints : hoverPoint;

	                // Check if the points have moved outside the plot area (#1003, #4736, #5101)
	                if (allowMove && tooltipPoints) {
	                    each(splat(tooltipPoints), function(point) {
	                        if (point.series.isCartesian && point.plotX === undefined) {
	                            allowMove = false;
	                        }
	                    });
	                }

	                // Just move the tooltip, #349
	                if (allowMove) {
	                    if (tooltip && tooltipPoints) {
	                        tooltip.refresh(tooltipPoints);
	                        if (hoverPoint) { // #2500
	                            hoverPoint.setState(hoverPoint.state, true);
	                            each(chart.axes, function(axis) {
	                                if (axis.crosshair) {
	                                    axis.drawCrosshair(null, hoverPoint);
	                                }
	                            });
	                        }
	                    }

	                    // Full reset
	                } else {

	                    if (hoverPoint) {
	                        hoverPoint.onMouseOut();
	                    }

	                    if (hoverPoints) {
	                        each(hoverPoints, function(point) {
	                            point.setState();
	                        });
	                    }

	                    if (hoverSeries) {
	                        hoverSeries.onMouseOut();
	                    }

	                    if (tooltip) {
	                        tooltip.hide(delay);
	                    }

	                    if (pointer.unDocMouseMove) {
	                        pointer.unDocMouseMove = pointer.unDocMouseMove();
	                    }

	                    // Remove crosshairs
	                    each(chart.axes, function(axis) {
	                        axis.hideCrosshair();
	                    });

	                    pointer.hoverX = chart.hoverPoints = chart.hoverPoint = null;
	                }
	            },

	            /**
	             * Scale series groups to a certain scale and translation.
	             *
	             * @private
	             */
	            scaleGroups: function(attribs, clip) {

	                var chart = this.chart,
	                    seriesAttribs;

	                // Scale each series
	                each(chart.series, function(series) {
	                    seriesAttribs = attribs || series.getPlotBox(); // #1701
	                    if (series.xAxis && series.xAxis.zoomEnabled && series.group) {
	                        series.group.attr(seriesAttribs);
	                        if (series.markerGroup) {
	                            series.markerGroup.attr(seriesAttribs);
	                            series.markerGroup.clip(clip ? chart.clipRect : null);
	                        }
	                        if (series.dataLabelsGroup) {
	                            series.dataLabelsGroup.attr(seriesAttribs);
	                        }
	                    }
	                });

	                // Clip
	                chart.clipRect.attr(clip || chart.clipBox);
	            },

	            /**
	             * Start a drag operation.
	             *
	             * @private
	             */
	            dragStart: function(e) {
	                var chart = this.chart;

	                // Record the start position
	                chart.mouseIsDown = e.type;
	                chart.cancelClick = false;
	                chart.mouseDownX = this.mouseDownX = e.chartX;
	                chart.mouseDownY = this.mouseDownY = e.chartY;
	            },

	            /**
	             * Perform a drag operation in response to a mousemove event while the mouse
	             * is down.
	             *
	             * @private
	             */
	            drag: function(e) {

	                var chart = this.chart,
	                    chartOptions = chart.options.chart,
	                    chartX = e.chartX,
	                    chartY = e.chartY,
	                    zoomHor = this.zoomHor,
	                    zoomVert = this.zoomVert,
	                    plotLeft = chart.plotLeft,
	                    plotTop = chart.plotTop,
	                    plotWidth = chart.plotWidth,
	                    plotHeight = chart.plotHeight,
	                    clickedInside,
	                    size,
	                    selectionMarker = this.selectionMarker,
	                    mouseDownX = this.mouseDownX,
	                    mouseDownY = this.mouseDownY,
	                    panKey = chartOptions.panKey && e[chartOptions.panKey + 'Key'];

	                // If the device supports both touch and mouse (like IE11), and we are touch-dragging
	                // inside the plot area, don't handle the mouse event. #4339.
	                if (selectionMarker && selectionMarker.touch) {
	                    return;
	                }

	                // If the mouse is outside the plot area, adjust to cooordinates
	                // inside to prevent the selection marker from going outside
	                if (chartX < plotLeft) {
	                    chartX = plotLeft;
	                } else if (chartX > plotLeft + plotWidth) {
	                    chartX = plotLeft + plotWidth;
	                }

	                if (chartY < plotTop) {
	                    chartY = plotTop;
	                } else if (chartY > plotTop + plotHeight) {
	                    chartY = plotTop + plotHeight;
	                }

	                // determine if the mouse has moved more than 10px
	                this.hasDragged = Math.sqrt(
	                    Math.pow(mouseDownX - chartX, 2) +
	                    Math.pow(mouseDownY - chartY, 2)
	                );

	                if (this.hasDragged > 10) {
	                    clickedInside = chart.isInsidePlot(mouseDownX - plotLeft, mouseDownY - plotTop);

	                    // make a selection
	                    if (chart.hasCartesianSeries && (this.zoomX || this.zoomY) && clickedInside && !panKey) {
	                        if (!selectionMarker) {
	                            this.selectionMarker = selectionMarker = chart.renderer.rect(
	                                    plotLeft,
	                                    plotTop,
	                                    zoomHor ? 1 : plotWidth,
	                                    zoomVert ? 1 : plotHeight,
	                                    0
	                                )
	                                .attr({

	                                    fill: chartOptions.selectionMarkerFill || color('#335cad').setOpacity(0.25).get(),

	                                    'class': 'highcharts-selection-marker',
	                                    'zIndex': 7
	                                })
	                                .add();
	                        }
	                    }

	                    // adjust the width of the selection marker
	                    if (selectionMarker && zoomHor) {
	                        size = chartX - mouseDownX;
	                        selectionMarker.attr({
	                            width: Math.abs(size),
	                            x: (size > 0 ? 0 : size) + mouseDownX
	                        });
	                    }
	                    // adjust the height of the selection marker
	                    if (selectionMarker && zoomVert) {
	                        size = chartY - mouseDownY;
	                        selectionMarker.attr({
	                            height: Math.abs(size),
	                            y: (size > 0 ? 0 : size) + mouseDownY
	                        });
	                    }

	                    // panning
	                    if (clickedInside && !selectionMarker && chartOptions.panning) {
	                        chart.pan(e, chartOptions.panning);
	                    }
	                }
	            },

	            /**
	             * On mouse up or touch end across the entire document, drop the selection.
	             *
	             * @private
	             */
	            drop: function(e) {
	                var pointer = this,
	                    chart = this.chart,
	                    hasPinched = this.hasPinched;

	                if (this.selectionMarker) {
	                    var selectionData = {
	                            originalEvent: e, // #4890
	                            xAxis: [],
	                            yAxis: []
	                        },
	                        selectionBox = this.selectionMarker,
	                        selectionLeft = selectionBox.attr ? selectionBox.attr('x') : selectionBox.x,
	                        selectionTop = selectionBox.attr ? selectionBox.attr('y') : selectionBox.y,
	                        selectionWidth = selectionBox.attr ? selectionBox.attr('width') : selectionBox.width,
	                        selectionHeight = selectionBox.attr ? selectionBox.attr('height') : selectionBox.height,
	                        runZoom;

	                    // a selection has been made
	                    if (this.hasDragged || hasPinched) {

	                        // record each axis' min and max
	                        each(chart.axes, function(axis) {
	                            if (axis.zoomEnabled && defined(axis.min) && (hasPinched || pointer[{
	                                    xAxis: 'zoomX',
	                                    yAxis: 'zoomY'
	                                }[axis.coll]])) { // #859, #3569
	                                var horiz = axis.horiz,
	                                    minPixelPadding = e.type === 'touchend' ? axis.minPixelPadding : 0, // #1207, #3075
	                                    selectionMin = axis.toValue((horiz ? selectionLeft : selectionTop) + minPixelPadding),
	                                    selectionMax = axis.toValue((horiz ? selectionLeft + selectionWidth : selectionTop + selectionHeight) - minPixelPadding);

	                                selectionData[axis.coll].push({
	                                    axis: axis,
	                                    min: Math.min(selectionMin, selectionMax), // for reversed axes
	                                    max: Math.max(selectionMin, selectionMax)
	                                });
	                                runZoom = true;
	                            }
	                        });
	                        if (runZoom) {
	                            fireEvent(chart, 'selection', selectionData, function(args) {
	                                chart.zoom(extend(args, hasPinched ? {
	                                    animation: false
	                                } : null));
	                            });
	                        }

	                    }
	                    this.selectionMarker = this.selectionMarker.destroy();

	                    // Reset scaling preview
	                    if (hasPinched) {
	                        this.scaleGroups();
	                    }
	                }

	                // Reset all
	                if (chart) { // it may be destroyed on mouse up - #877
	                    css(chart.container, {
	                        cursor: chart._cursor
	                    });
	                    chart.cancelClick = this.hasDragged > 10; // #370
	                    chart.mouseIsDown = this.hasDragged = this.hasPinched = false;
	                    this.pinchDown = [];
	                }
	            },

	            onContainerMouseDown: function(e) {

	                e = this.normalize(e);

	                this.zoomOption(e);

	                // issue #295, dragging not always working in Firefox
	                if (e.preventDefault) {
	                    e.preventDefault();
	                }

	                this.dragStart(e);
	            },



	            onDocumentMouseUp: function(e) {
	                // 0313 diable document clicked related functions
	                // if (charts[H.hoverChartIndex]) {
	                //     charts[H.hoverChartIndex].pointer.drop(e);
	                // }
	            },

	            /**
	             * Special handler for mouse move that will hide the tooltip when the mouse
	             * leaves the plotarea. Issue #149 workaround. The mouseleave event does not
	             * always fire.
	             *
	             * @private
	             */
	            onDocumentMouseMove: function(e) {
	                // 0313 diable document clicked related functions
	                // var chart = this.chart,
	                //     chartPosition = this.chartPosition;

	                // e = this.normalize(e, chartPosition);

	                // // If we're outside, hide the tooltip
	                // if (chartPosition && !this.inClass(e.target, 'highcharts-tracker') &&
	                //     !chart.isInsidePlot(e.chartX - chart.plotLeft, e.chartY - chart.plotTop)) {
	                //     this.reset();
	                // }
	            },

	            /**
	             * When mouse leaves the container, hide the tooltip.
	             *
	             * @private
	             */
	            onContainerMouseLeave: function(e) {
	                // 0313 diable document clicked related functions
	                // var chart = charts[H.hoverChartIndex];
	                // if (chart && (e.relatedTarget || e.toElement)) { // #4886, MS Touch end fires mouseleave but with no related target
	                //     chart.pointer.reset();
	                //     chart.pointer.chartPosition = null; // also reset the chart position, used in #149 fix
	                // }
	            },

	            // The mousemove, touchmove and touchstart event handler
	            onContainerMouseMove: function(e) {

	                var chart = this.chart;

	                if(chart.userOptions.custom_highchart != undefined && chart.userOptions.custom_highchart.ismobile)
	                {
	                    return false;
	                }


	                if (!defined(H.hoverChartIndex) || !charts[H.hoverChartIndex] || !charts[H.hoverChartIndex].mouseIsDown) {
	                    H.hoverChartIndex = chart.index;
	                }

	                e = this.normalize(e);
	                e.returnValue = false; // #2251, #3224

	                if (chart.mouseIsDown === 'mousedown') {
	                    this.drag(e);
	                }

	                
	                if(chart.userOptions.custom_highchart != undefined && chart.userOptions.custom_highchart.fullchart)
	                {
	                    chart.getChartSize();
	                    var chartHeight = chart.chartHeight;
	                    var tempx = e.chartX;
	                    var tempx = e.chartX;
	                    e.chartX = e.chartY;
	                    e.chartY = chartHeight - tempx;
	                    
	                    // if ((this.inClass(e.target, 'highcharts-tracker') ||
	                    //     chart.isInsidePlot(e.chartX - chart.plotLeft, e.chartY - chart.plotTop)) && !chart.openMenu) {                    
	                    this.runPointActions(e);
	                    // }
	                }
	                else
	                {
	                    // Show the tooltip and run mouse over events (#977)
	                    if ((this.inClass(e.target, 'highcharts-tracker') ||
	                            chart.isInsidePlot(e.chartX - chart.plotLeft, e.chartY - chart.plotTop)) && !chart.openMenu) {
	                        this.runPointActions(e);
	                    }
	                }
	            },

	            /**
	             * Utility to detect whether an element has, or has a parent with, a specific
	             * class name. Used on detection of tracker objects and on deciding whether
	             * hovering the tooltip should cause the active series to mouse out.
	             *
	             * @param  {SVGDOMElement|HTMLDOMElement} element
	             *         The element to investigate.
	             * @param  {String} className
	             *         The class name to look for.
	             *
	             * @return {Boolean}
	             *         True if either the element or one of its parents has the given
	             *         class name.
	             */
	            inClass: function(element, className) {
	                var elemClassName;
	                while (element) {
	                    elemClassName = attr(element, 'class');
	                    if (elemClassName) {
	                        if (elemClassName.indexOf(className) !== -1) {
	                            return true;
	                        }
	                        if (elemClassName.indexOf('highcharts-container') !== -1) {
	                            return false;
	                        }
	                    }
	                    element = element.parentNode;
	                }
	            },

	            onTrackerMouseOut: function(e) {
	                var series = this.chart.hoverSeries,
	                    relatedTarget = e.relatedTarget || e.toElement;
	                this.isDirectTouch = false;
	                if (series && relatedTarget && !series.stickyTracking &&
	                    !this.inClass(relatedTarget, 'highcharts-tooltip') &&
	                    (!this.inClass(relatedTarget, 'highcharts-series-' + series.index) || // #2499, #4465
	                        !this.inClass(relatedTarget, 'highcharts-tracker') // #5553
	                    )
	                ) {
	                    series.onMouseOut();
	                }
	            },

	            onContainerClick: function(e) {
	                var chart = this.chart,
	                    hoverPoint = chart.hoverPoint,
	                    plotLeft = chart.plotLeft,
	                    plotTop = chart.plotTop;
	                if(chart.userOptions.custom_highchart != undefined && chart.userOptions.custom_highchart.ismobile)
	                {
	                    return false;
	                }


	                e = this.normalize(e);
	                if(chart.userOptions.custom_highchart != undefined && chart.userOptions.custom_highchart.fullchart)
	                {
	                    chart.getChartSize();
	                    var chartHeight = chart.chartHeight;
	                    var tempx = e.chartX;
	                    var tempx = e.chartX;
	                    e.chartX = e.chartY;
	                    e.chartY = chartHeight - tempx;
	                }

	                if (!chart.cancelClick) {

	                    // On tracker click, fire the series and point events. #783, #1583
	                    if (hoverPoint && this.inClass(e.target, 'highcharts-tracker')) {

	                        // the series click event
	                        fireEvent(hoverPoint.series, 'click', extend(e, {
	                            point: hoverPoint
	                        }));

	                        // the point click event
	                        if (chart.hoverPoint) { // it may be destroyed (#1844)
	                            hoverPoint.firePointEvent('click', e);
	                        }

	                        // When clicking outside a tracker, fire a chart event
	                    } else {
	                        extend(e, this.getCoordinates(e));

	                        // fire a click event in the chart
	                        if (chart.isInsidePlot(e.chartX - plotLeft, e.chartY - plotTop)) {
	                            fireEvent(chart, 'click', e);
	                            this.runPointActions(e)
	                        }
	                    }


	                }
	            },

	            /**
	             * Set the JS DOM events on the container and document. This method should contain
	             * a one-to-one assignment between methods and their handlers. Any advanced logic should
	             * be moved to the handler reflecting the event's name.
	             *
	             * @private
	             */
	            setDOMEvents: function() {

	                var pointer = this,
	                    container = pointer.chart.container,
	                    ownerDoc = container.ownerDocument;

	                container.onmousedown = function(e) {
	                    pointer.onContainerMouseDown(e);
	                };
	                container.onmousemove = function(e) {
	                    pointer.onContainerMouseMove(e);
	                };
	                container.onclick = function(e) {
	                    pointer.onContainerClick(e);
	                };
	                addEvent(container, 'mouseleave', pointer.onContainerMouseLeave);
	                if (H.chartCount === 1) {
	                    addEvent(
	                        ownerDoc,
	                        'mouseup',
	                        pointer.onDocumentMouseUp
	                    );
	                }
	                if (H.hasTouch) {

	                    container.ontouchstart = function(e) {
	                        pointer.onContainerTouchStart(e);
	                    };
	                    container.ontouchmove = function(e) {
	                        pointer.onContainerTouchMove(e);
	                    };
	                    if (H.chartCount === 1) {
	                        addEvent(
	                            ownerDoc,
	                            'touchend',
	                            pointer.onDocumentTouchEnd
	                        );
	                    }
	                }

	            },

	            /**
	             * Destroys the Pointer object and disconnects DOM events.
	             */
	            destroy: function() {
	                var pointer = this,
	                    ownerDoc = this.chart.container.ownerDocument;

	                if (pointer.unDocMouseMove) {
	                    pointer.unDocMouseMove();
	                }

	                removeEvent(
	                    pointer.chart.container,
	                    'mouseleave',
	                    pointer.onContainerMouseLeave
	                );
	                if (!H.chartCount) {
	                    removeEvent(ownerDoc, 'mouseup', pointer.onDocumentMouseUp);
	                    if (H.hasTouch) {
	                        removeEvent(ownerDoc, 'touchend', pointer.onDocumentTouchEnd);
	                    }
	                }

	                // memory and CPU leak
	                clearInterval(pointer.tooltipTimeout);

	                H.objectEach(pointer, function(val, prop) {
	                    pointer[prop] = null;
	                });
	            }
	        };

	    }(Highcharts));
	    (function(H) {
	        /**
	         * (c) 2010-2017 Torstein Honsi
	         *
	         * License: www.highcharts.com/license
	         */
	        var charts = H.charts,
	            each = H.each,
	            extend = H.extend,
	            map = H.map,
	            noop = H.noop,
	            pick = H.pick,
	            Pointer = H.Pointer;

	        /* Support for touch devices */
	        extend(Pointer.prototype, /** @lends Pointer.prototype */ {

	            /**
	             * Run translation operations
	             */
	            pinchTranslate: function(pinchDown, touches, transform, selectionMarker, clip, lastValidTouch) {
	                if (this.zoomHor) {
	                    this.pinchTranslateDirection(true, pinchDown, touches, transform, selectionMarker, clip, lastValidTouch);
	                }
	                if (this.zoomVert) {
	                    this.pinchTranslateDirection(false, pinchDown, touches, transform, selectionMarker, clip, lastValidTouch);
	                }
	            },

	            /**
	             * Run translation operations for each direction (horizontal and vertical) independently
	             */
	            pinchTranslateDirection: function(horiz, pinchDown, touches, transform,
	                selectionMarker, clip, lastValidTouch, forcedScale) {
	                var chart = this.chart,
	                    xy = horiz ? 'x' : 'y',
	                    XY = horiz ? 'X' : 'Y',
	                    sChartXY = 'chart' + XY,
	                    wh = horiz ? 'width' : 'height',
	                    plotLeftTop = chart['plot' + (horiz ? 'Left' : 'Top')],
	                    selectionWH,
	                    selectionXY,
	                    clipXY,
	                    scale = forcedScale || 1,
	                    inverted = chart.inverted,
	                    bounds = chart.bounds[horiz ? 'h' : 'v'],
	                    singleTouch = pinchDown.length === 1,
	                    touch0Start = pinchDown[0][sChartXY],
	                    touch0Now = touches[0][sChartXY],
	                    touch1Start = !singleTouch && pinchDown[1][sChartXY],
	                    touch1Now = !singleTouch && touches[1][sChartXY],
	                    outOfBounds,
	                    transformScale,
	                    scaleKey,
	                    setScale = function() {
	                        // Don't zoom if fingers are too close on this axis
	                        if (!singleTouch && Math.abs(touch0Start - touch1Start) > 20) {
	                            scale = forcedScale || Math.abs(touch0Now - touch1Now) / Math.abs(touch0Start - touch1Start);
	                        }

	                        clipXY = ((plotLeftTop - touch0Now) / scale) + touch0Start;
	                        selectionWH = chart['plot' + (horiz ? 'Width' : 'Height')] / scale;
	                    };

	                // Set the scale, first pass
	                setScale();

	                selectionXY = clipXY; // the clip position (x or y) is altered if out of bounds, the selection position is not

	                // Out of bounds
	                if (selectionXY < bounds.min) {
	                    selectionXY = bounds.min;
	                    outOfBounds = true;
	                } else if (selectionXY + selectionWH > bounds.max) {
	                    selectionXY = bounds.max - selectionWH;
	                    outOfBounds = true;
	                }

	                // Is the chart dragged off its bounds, determined by dataMin and dataMax?
	                if (outOfBounds) {

	                    // Modify the touchNow position in order to create an elastic drag movement. This indicates
	                    // to the user that the chart is responsive but can't be dragged further.
	                    touch0Now -= 0.8 * (touch0Now - lastValidTouch[xy][0]);
	                    if (!singleTouch) {
	                        touch1Now -= 0.8 * (touch1Now - lastValidTouch[xy][1]);
	                    }

	                    // Set the scale, second pass to adapt to the modified touchNow positions
	                    setScale();

	                } else {
	                    lastValidTouch[xy] = [touch0Now, touch1Now];
	                }

	                // Set geometry for clipping, selection and transformation
	                if (!inverted) {
	                    clip[xy] = clipXY - plotLeftTop;
	                    clip[wh] = selectionWH;
	                }
	                scaleKey = inverted ? (horiz ? 'scaleY' : 'scaleX') : 'scale' + XY;
	                transformScale = inverted ? 1 / scale : scale;

	                selectionMarker[wh] = selectionWH;
	                selectionMarker[xy] = selectionXY;
	                transform[scaleKey] = scale;
	                transform['translate' + XY] = (transformScale * plotLeftTop) + (touch0Now - (transformScale * touch0Start));
	            },

	            /**
	             * Handle touch events with two touches
	             */
	            pinch: function(e) {
	                
	                var self = this,
	                    chart = self.chart,
	                    pinchDown = self.pinchDown,
	                    touches = e.touches,
	                    touchesLength = touches.length,
	                    lastValidTouch = self.lastValidTouch,
	                    hasZoom = self.hasZoom,
	                    selectionMarker = self.selectionMarker,
	                    transform = {},
	                    fireClickEvent = touchesLength === 1 && ((self.inClass(e.target, 'highcharts-tracker') &&
	                        chart.runTrackerClick) || self.runChartClick),
	                    clip = {};

	                // Don't initiate panning until the user has pinched. This prevents us from
	                // blocking page scrolling as users scroll down a long page (#4210).
	                if (touchesLength > 1) {
	                    self.initiated = true;
	                }

	                // On touch devices, only proceed to trigger click if a handler is defined
	                if (hasZoom && self.initiated && !fireClickEvent) {
	                    e.preventDefault();
	                }

	                // Normalize each touch
	                map(touches, function(e) {
	                    return self.normalize(e);
	                });

	                // Register the touch start position
	                if (e.type === 'touchstart') {
	                    each(touches, function(e, i) {
	                        pinchDown[i] = {
	                            chartX: e.chartX,
	                            chartY: e.chartY
	                        };
	                    });
	                    lastValidTouch.x = [pinchDown[0].chartX, pinchDown[1] && pinchDown[1].chartX];
	                    lastValidTouch.y = [pinchDown[0].chartY, pinchDown[1] && pinchDown[1].chartY];

	                    // Identify the data bounds in pixels
	                    each(chart.axes, function(axis) {
	                        if (axis.zoomEnabled) {
	                            var bounds = chart.bounds[axis.horiz ? 'h' : 'v'],
	                                minPixelPadding = axis.minPixelPadding,
	                                min = axis.toPixels(pick(axis.options.min, axis.dataMin)),
	                                max = axis.toPixels(pick(axis.options.max, axis.dataMax)),
	                                absMin = Math.min(min, max),
	                                absMax = Math.max(min, max);

	                            // Store the bounds for use in the touchmove handler
	                            bounds.min = Math.min(axis.pos, absMin - minPixelPadding);
	                            bounds.max = Math.max(axis.pos + axis.len, absMax + minPixelPadding);
	                        }
	                    });
	                    self.res = true; // reset on next move

	                    // Optionally move the tooltip on touchmove
	                } else if (self.followTouchMove && touchesLength === 1) {
	                    self.normalize(e);
	                    if(chart.userOptions.custom_highchart != undefined && chart.userOptions.custom_highchart.fullchart)
	                    {
	                        chart.getChartSize();
	                        var chartHeight = chart.chartHeight;
	                        var tempx = e.chartX;
	                        var tempx = e.chartX;
	                        e.chartX = e.chartY;
	                        e.chartY = chartHeight - tempx;
	                    }
	                    this.runPointActions(e);

	                    // Event type is touchmove, handle panning and pinching
	                } else if (pinchDown.length) { // can be 0 when releasing, if touchend fires first


	                    // Set the marker
	                    if (!selectionMarker) {
	                        self.selectionMarker = selectionMarker = extend({
	                            destroy: noop,
	                            touch: true
	                        }, chart.plotBox);
	                    }

	                    self.pinchTranslate(pinchDown, touches, transform, selectionMarker, clip, lastValidTouch);

	                    self.hasPinched = hasZoom;

	                    // Scale and translate the groups to provide visual feedback during pinching
	                    self.scaleGroups(transform, clip);

	                    if (self.res) {
	                        self.res = false;
	                        this.reset(false, 0);
	                    }
	                }
	            },

	            /**
	             * General touch handler shared by touchstart and touchmove.
	             */
	            touch: function(e, start) {




	                var chart = this.chart,
	                    hasMoved,
	                    pinchDown,
	                    isInside;
	                // 0313 diable document clicked related functions
	                // if (chart.index !== H.hoverChartIndex) {
	                //     this.onContainerMouseLeave({
	                //         relatedTarget: true
	                //     });
	                // }

	                H.hoverChartIndex = chart.index;

	                if (e.touches.length === 1) {

	                    e = this.normalize(e);

	                    if(chart.userOptions.custom_highchart != undefined && this.chart.userOptions.custom_highchart.fullchart)
	                    {
	                        chart.getChartSize();
	                        var chartHeight = chart.chartHeight;
	                        var tempx = e.chartX;
	                        var tempx = e.chartX;
	                        e.chartX = e.chartY;
	                        e.chartY = chartHeight - tempx;
	                    }
	                    

	                    isInside = chart.isInsidePlot(
	                        e.chartX - chart.plotLeft,
	                        e.chartY - chart.plotTop
	                    );
	                    if (isInside && !chart.openMenu) {

	                        // Run mouse events and display tooltip etc
	                        if (start) {
	                            this.runPointActions(e);
	                        }

	                        // Android fires touchmove events after the touchstart even if the
	                        // finger hasn't moved, or moved only a pixel or two. In iOS however,
	                        // the touchmove doesn't fire unless the finger moves more than ~4px.
	                        // So we emulate this behaviour in Android by checking how much it
	                        // moved, and cancelling on small distances. #3450.
	                        if (e.type === 'touchmove') {
	                            pinchDown = this.pinchDown;
	                            
	                            hasMoved = pinchDown[0] ? Math.sqrt( // #5266
	                                Math.pow(pinchDown[0].chartX - e.chartX, 2) +
	                                Math.pow(pinchDown[0].chartY - e.chartY, 2)
	                            ) >= 4 : false;
	                            
	                        }

	                        if (pick(hasMoved, true)) {
	                            this.pinch(e);
	                        }
	                    // 0313 diable document clicked related functions
	                    // } else if (start) {
	                    //     // Hide the tooltip on touching outside the plot area (#1203)
	                    //     this.reset();
	                    }

	                } else if (e.touches.length === 2) {
	                    this.pinch(e);
	                }
	            },

	            onContainerTouchStart: function(e) {
	                this.zoomOption(e);
	                this.touch(e, true);
	            },

	            onContainerTouchMove: function(e) {

	                this.touch(e);
	            },

	            onDocumentTouchEnd: function(e) {
	                // 0313 diable document clicked related functions
	                // if (charts[H.hoverChartIndex]) {
	                //     charts[H.hoverChartIndex].pointer.drop(e);
	                // }
	            }

	        });

	    }(Highcharts));
	    (function(H) {
	        /**
	         * (c) 2010-2017 Torstein Honsi
	         *
	         * License: www.highcharts.com/license
	         */
	        var addEvent = H.addEvent,
	            charts = H.charts,
	            css = H.css,
	            doc = H.doc,
	            extend = H.extend,
	            hasTouch = H.hasTouch,
	            noop = H.noop,
	            Pointer = H.Pointer,
	            removeEvent = H.removeEvent,
	            win = H.win,
	            wrap = H.wrap;

	        if (!hasTouch && (win.PointerEvent || win.MSPointerEvent)) {

	            // The touches object keeps track of the points being touched at all times
	            var touches = {},
	                hasPointerEvent = !!win.PointerEvent,
	                getWebkitTouches = function() {
	                    var fake = [];
	                    fake.item = function(i) {
	                        return this[i];
	                    };
	                    H.objectEach(touches, function(touch) {
	                        fake.push({
	                            pageX: touch.pageX,
	                            pageY: touch.pageY,
	                            target: touch.target
	                        });
	                    });
	                    return fake;
	                },
	                translateMSPointer = function(e, method, wktype, func) {
	                    var p;
	                    if ((e.pointerType === 'touch' || e.pointerType === e.MSPOINTER_TYPE_TOUCH) && charts[H.hoverChartIndex]) {
	                        func(e);
	                        p = charts[H.hoverChartIndex].pointer;
	                        p[method]({
	                            type: wktype,
	                            target: e.currentTarget,
	                            preventDefault: noop,
	                            touches: getWebkitTouches()
	                        });
	                    }
	                };

	            /**
	             * Extend the Pointer prototype with methods for each event handler and more
	             */
	            extend(Pointer.prototype, /** @lends Pointer.prototype */ {
	                onContainerPointerDown: function(e) {
	                    translateMSPointer(e, 'onContainerTouchStart', 'touchstart', function(e) {
	                        touches[e.pointerId] = {
	                            pageX: e.pageX,
	                            pageY: e.pageY,
	                            target: e.currentTarget
	                        };
	                    });
	                },
	                onContainerPointerMove: function(e) {
	                    translateMSPointer(e, 'onContainerTouchMove', 'touchmove', function(e) {
	                        touches[e.pointerId] = {
	                            pageX: e.pageX,
	                            pageY: e.pageY
	                        };
	                        if (!touches[e.pointerId].target) {
	                            touches[e.pointerId].target = e.currentTarget;
	                        }
	                    });
	                },
	                onDocumentPointerUp: function(e) {
	                    // 0313 diable document clicked related functions
	                    // translateMSPointer(e, 'onDocumentTouchEnd', 'touchend', function(e) {
	                    //     delete touches[e.pointerId];
	                    // });
	                },

	                /**
	                 * Add or remove the MS Pointer specific events
	                 */
	                batchMSEvents: function(fn) {
	                    fn(this.chart.container, hasPointerEvent ? 'pointerdown' : 'MSPointerDown', this.onContainerPointerDown);
	                    fn(this.chart.container, hasPointerEvent ? 'pointermove' : 'MSPointerMove', this.onContainerPointerMove);
	                    fn(doc, hasPointerEvent ? 'pointerup' : 'MSPointerUp', this.onDocumentPointerUp);
	                }
	            });

	            // Disable default IE actions for pinch and such on chart element
	            wrap(Pointer.prototype, 'init', function(proceed, chart, options) {
	                proceed.call(this, chart, options);
	                if (this.hasZoom) { // #4014
	                    css(chart.container, {
	                        '-ms-touch-action': 'none',
	                        'touch-action': 'none'
	                    });
	                }
	            });

	            // Add IE specific touch events to chart
	            wrap(Pointer.prototype, 'setDOMEvents', function(proceed) {
	                proceed.apply(this);
	                if (this.hasZoom || this.followTouchMove) {
	                    this.batchMSEvents(addEvent);
	                }
	            });
	            // Destroy MS events also
	            wrap(Pointer.prototype, 'destroy', function(proceed) {
	                this.batchMSEvents(removeEvent);
	                proceed.call(this);
	            });
	        }

	    }(Highcharts));
	    (function(Highcharts) {
	        /**
	         * (c) 2010-2017 Torstein Honsi
	         *
	         * License: www.highcharts.com/license
	         */
	        var H = Highcharts,

	            addEvent = H.addEvent,
	            css = H.css,
	            discardElement = H.discardElement,
	            defined = H.defined,
	            each = H.each,
	            isFirefox = H.isFirefox,
	            marginNames = H.marginNames,
	            merge = H.merge,
	            pick = H.pick,
	            setAnimation = H.setAnimation,
	            stableSort = H.stableSort,
	            win = H.win,
	            wrap = H.wrap;

	        /**
	         * The overview of the chart's series. The legend object is instanciated
	         * internally in the chart constructor, and available from `chart.legend`. Each
	         * chart has only one legend.
	         * 
	         * @class
	         */
	        Highcharts.Legend = function(chart, options) {
	            this.init(chart, options);
	        };

	        Highcharts.Legend.prototype = {

	            /**
	             * Initialize the legend.
	             *
	             * @private
	             */
	            init: function(chart, options) {

	                this.chart = chart;

	                this.setOptions(options);

	                if (options.enabled) {

	                    // Render it
	                    this.render();

	                    // move checkboxes
	                    addEvent(this.chart, 'endResize', function() {
	                        this.legend.positionCheckboxes();
	                    });
	                }
	            },

	            setOptions: function(options) {

	                var padding = pick(options.padding, 8);

	                this.options = options;


	                this.itemStyle = options.itemStyle;
	                this.itemHiddenStyle = merge(this.itemStyle, options.itemHiddenStyle);

	                this.itemMarginTop = options.itemMarginTop || 0;
	                this.padding = padding;
	                this.initialItemY = padding - 5; // 5 is pixels above the text
	                this.maxItemWidth = 0;
	                this.itemHeight = 0;
	                this.symbolWidth = pick(options.symbolWidth, 16);
	                this.pages = [];

	            },

	            /**
	             * Update the legend with new options. Equivalent to running `chart.update`
	             * with a legend configuration option.
	             * @param  {LegendOptions} options
	             *         Legend options.
	             * @param  {Boolean} [redraw=true]
	             *         Whether to redraw the chart.
	             *
	             * @sample highcharts/legend/legend-update/
	             *         Legend update
	             */
	            update: function(options, redraw) {
	                var chart = this.chart;

	                this.setOptions(merge(true, this.options, options));
	                this.destroy();
	                chart.isDirtyLegend = chart.isDirtyBox = true;
	                if (pick(redraw, true)) {
	                    chart.redraw();
	                }
	            },

	            /**
	             * Set the colors for the legend item.
	             *
	             * @private
	             * @param  {Series|Point} item
	             *         A Series or Point instance
	             * @param  {Boolean} visible
	             *         Dimmed or colored
	             */
	            colorizeItem: function(item, visible) {
	                item.legendGroup[visible ? 'removeClass' : 'addClass'](
	                    'highcharts-legend-item-hidden'
	                );


	                var legend = this,
	                    options = legend.options,
	                    legendItem = item.legendItem,
	                    legendLine = item.legendLine,
	                    legendSymbol = item.legendSymbol,
	                    hiddenColor = legend.itemHiddenStyle.color,
	                    textColor = visible ? options.itemStyle.color : hiddenColor,
	                    symbolColor = visible ? (item.color || hiddenColor) : hiddenColor,
	                    markerOptions = item.options && item.options.marker,
	                    symbolAttr = {
	                        fill: symbolColor
	                    };

	                if (legendItem) {
	                    legendItem.css({
	                        fill: textColor,
	                        color: textColor // #1553, oldIE
	                    });
	                }
	                if (legendLine) {
	                    legendLine.attr({
	                        stroke: symbolColor
	                    });
	                }

	                if (legendSymbol) {

	                    // Apply marker options
	                    if (markerOptions && legendSymbol.isMarker) { // #585
	                        symbolAttr = item.pointAttribs();
	                        if (!visible) {
	                            symbolAttr.stroke = symbolAttr.fill = hiddenColor; // #6769
	                        }
	                    }

	                    legendSymbol.attr(symbolAttr);
	                }

	            },

	            /**
	             * Position the legend item.
	             *
	             * @private
	             * @param {Series|Point} item
	             *        The item to position
	             */
	            positionItem: function(item) {
	                var legend = this,
	                    options = legend.options,
	                    symbolPadding = options.symbolPadding,
	                    ltr = !options.rtl,
	                    legendItemPos = item._legendItemPos,
	                    itemX = legendItemPos[0],
	                    itemY = legendItemPos[1],
	                    checkbox = item.checkbox,
	                    legendGroup = item.legendGroup;

	                if (legendGroup && legendGroup.element) {
	                    legendGroup.translate(
	                        ltr ?
	                        itemX :
	                        legend.legendWidth - itemX - 2 * symbolPadding - 4,
	                        itemY
	                    );
	                }

	                if (checkbox) {
	                    checkbox.x = itemX;
	                    checkbox.y = itemY;
	                }
	            },

	            /**
	             * Destroy a single legend item, used internally on removing series items.
	             * 
	             * @param {Series|Point} item
	             *        The item to remove
	             */
	            destroyItem: function(item) {
	                var checkbox = item.checkbox;

	                // destroy SVG elements
	                each(
	                    ['legendItem', 'legendLine', 'legendSymbol', 'legendGroup'],
	                    function(key) {
	                        if (item[key]) {
	                            item[key] = item[key].destroy();
	                        }
	                    }
	                );

	                if (checkbox) {
	                    discardElement(item.checkbox);
	                }
	            },

	            /**
	             * Destroy the legend. Used internally. To reflow objects, `chart.redraw`
	             * must be called after destruction.
	             */
	            destroy: function() {
	                function destroyItems(key) {
	                    if (this[key]) {
	                        this[key] = this[key].destroy();
	                    }
	                }

	                // Destroy items
	                each(this.getAllItems(), function(item) {
	                    each(['legendItem', 'legendGroup'], destroyItems, item);
	                });

	                // Destroy legend elements
	                each([
	                    'clipRect',
	                    'up',
	                    'down',
	                    'pager',
	                    'nav',
	                    'box',
	                    'title',
	                    'group'
	                ], destroyItems, this);
	                this.display = null; // Reset in .render on update.
	            },

	            /**
	             * Position the checkboxes after the width is determined.
	             *
	             * @private
	             */
	            positionCheckboxes: function(scrollOffset) {
	                var alignAttr = this.group && this.group.alignAttr,
	                    translateY,
	                    clipHeight = this.clipHeight || this.legendHeight,
	                    titleHeight = this.titleHeight;

	                if (alignAttr) {
	                    translateY = alignAttr.translateY;
	                    each(this.allItems, function(item) {
	                        var checkbox = item.checkbox,
	                            top;

	                        if (checkbox) {
	                            top = translateY + titleHeight + checkbox.y +
	                                (scrollOffset || 0) + 3;
	                            css(checkbox, {
	                                left: (alignAttr.translateX + item.checkboxOffset +
	                                    checkbox.x - 20) + 'px',
	                                top: top + 'px',
	                                display: top > translateY - 6 && top < translateY +
	                                    clipHeight - 6 ? '' : 'none'
	                            });
	                        }
	                    });
	                }
	            },

	            /**
	             * Render the legend title on top of the legend.
	             *
	             * @private
	             */
	            renderTitle: function() {
	                var options = this.options,
	                    padding = this.padding,
	                    titleOptions = options.title,
	                    titleHeight = 0,
	                    bBox;

	                if (titleOptions.text) {
	                    if (!this.title) {
	                        this.title = this.chart.renderer.label(
	                                titleOptions.text,
	                                padding - 3,
	                                padding - 4,
	                                null,
	                                null,
	                                null,
	                                options.useHTML,
	                                null,
	                                'legend-title'
	                            )
	                            .attr({
	                                zIndex: 1
	                            })

	                            .css(titleOptions.style)

	                            .add(this.group);
	                    }
	                    bBox = this.title.getBBox();
	                    titleHeight = bBox.height;
	                    this.offsetWidth = bBox.width; // #1717
	                    this.contentGroup.attr({
	                        translateY: titleHeight
	                    });
	                }
	                this.titleHeight = titleHeight;
	            },

	            /**
	             * Set the legend item text.
	             *
	             * @param  {Series|Point} item
	             *         The item for which to update the text in the legend.
	             */
	            setText: function(item) {
	                var options = this.options;
	                item.legendItem.attr({
	                    text: options.labelFormat ?
	                        H.format(options.labelFormat, item) : options.labelFormatter.call(item)
	                });
	            },

	            /**
	             * Render a single specific legend item. Called internally from the `render`
	             * function.
	             *
	             * @private
	             * @param {Series|Point} item
	             *        The item to render.
	             */
	            renderItem: function(item) {
	                var legend = this,
	                    chart = legend.chart,
	                    renderer = chart.renderer,
	                    options = legend.options,
	                    horizontal = options.layout === 'horizontal',
	                    symbolWidth = legend.symbolWidth,
	                    symbolPadding = options.symbolPadding,

	                    itemStyle = legend.itemStyle,
	                    itemHiddenStyle = legend.itemHiddenStyle,

	                    padding = legend.padding,
	                    itemDistance = horizontal ? pick(options.itemDistance, 20) : 0,
	                    ltr = !options.rtl,
	                    itemHeight,
	                    widthOption = options.width,
	                    itemMarginBottom = options.itemMarginBottom || 0,
	                    itemMarginTop = legend.itemMarginTop,
	                    bBox,
	                    itemWidth,
	                    li = item.legendItem,
	                    isSeries = !item.series,
	                    series = !isSeries && item.series.drawLegendSymbol ?
	                    item.series :
	                    item,
	                    seriesOptions = series.options,
	                    showCheckbox = legend.createCheckboxForItem &&
	                    seriesOptions &&
	                    seriesOptions.showCheckbox,
	                    // full width minus text width
	                    itemExtraWidth = symbolWidth + symbolPadding + itemDistance +
	                    (showCheckbox ? 20 : 0),
	                    useHTML = options.useHTML,
	                    fontSize = 12,
	                    itemClassName = item.options.className;

	                if (!li) { // generate it once, later move it

	                    // Generate the group box, a group to hold the symbol and text. Text
	                    // is to be appended in Legend class.
	                    item.legendGroup = renderer.g('legend-item')
	                        .addClass(
	                            'highcharts-' + series.type + '-series ' +
	                            'highcharts-color-' + item.colorIndex +
	                            (itemClassName ? ' ' + itemClassName : '') +
	                            (isSeries ? ' highcharts-series-' + item.index : '')
	                        )
	                        .attr({
	                            zIndex: 1
	                        })
	                        .add(legend.scrollGroup);

	                    // Generate the list item text and add it to the group
	                    item.legendItem = li = renderer.text(
	                            '',
	                            ltr ? symbolWidth + symbolPadding : -symbolPadding,
	                            legend.baseline || 0,
	                            useHTML
	                        )

	                        // merge to prevent modifying original (#1021)
	                        .css(merge(item.visible ? itemStyle : itemHiddenStyle))

	                        .attr({
	                            align: ltr ? 'left' : 'right',
	                            zIndex: 2
	                        })
	                        .add(item.legendGroup);

	                    // Get the baseline for the first item - the font size is equal for
	                    // all
	                    if (!legend.baseline) {

	                        fontSize = itemStyle.fontSize;

	                        legend.fontMetrics = renderer.fontMetrics(
	                            fontSize,
	                            li
	                        );
	                        legend.baseline = legend.fontMetrics.f + 3 + itemMarginTop;
	                        li.attr('y', legend.baseline);
	                    }

	                    // Draw the legend symbol inside the group box
	                    legend.symbolHeight = options.symbolHeight || legend.fontMetrics.f;
	                    series.drawLegendSymbol(legend, item);

	                    if (legend.setItemEvents) {
	                        legend.setItemEvents(item, li, useHTML);
	                    }

	                    // add the HTML checkbox on top
	                    if (showCheckbox) {
	                        legend.createCheckboxForItem(item);
	                    }
	                }

	                // Colorize the items
	                legend.colorizeItem(item, item.visible);

	                // Take care of max width and text overflow (#6659)

	                if (!itemStyle.width) {

	                    li.css({
	                        width: (
	                            options.itemWidth ||
	                            options.width ||
	                            chart.spacingBox.width
	                        ) - itemExtraWidth
	                    });

	                }


	                // Always update the text
	                legend.setText(item);

	                // calculate the positions for the next line
	                bBox = li.getBBox();

	                itemWidth = item.checkboxOffset =
	                    options.itemWidth ||
	                    item.legendItemWidth ||
	                    bBox.width + itemExtraWidth;
	                legend.itemHeight = itemHeight = Math.round(
	                    item.legendItemHeight || bBox.height || legend.symbolHeight
	                );

	                // If the item exceeds the width, start a new line
	                if (
	                    horizontal &&
	                    legend.itemX - padding + itemWidth > (
	                        widthOption || (
	                            chart.spacingBox.width - 2 * padding - options.x
	                        )
	                    )
	                ) {
	                    legend.itemX = padding;
	                    legend.itemY += itemMarginTop + legend.lastLineHeight +
	                        itemMarginBottom;
	                    legend.lastLineHeight = 0; // reset for next line (#915, #3976)
	                }

	                // If the item exceeds the height, start a new column
	                /*if (!horizontal && legend.itemY + options.y +
	                        itemHeight > chart.chartHeight - spacingTop - spacingBottom) {
	                    legend.itemY = legend.initialItemY;
	                    legend.itemX += legend.maxItemWidth;
	                    legend.maxItemWidth = 0;
	                }*/

	                // Set the edge positions
	                legend.maxItemWidth = Math.max(legend.maxItemWidth, itemWidth);
	                legend.lastItemY = itemMarginTop + legend.itemY + itemMarginBottom;
	                legend.lastLineHeight = Math.max( // #915
	                    itemHeight,
	                    legend.lastLineHeight
	                );

	                // cache the position of the newly generated or reordered items
	                item._legendItemPos = [legend.itemX, legend.itemY];

	                // advance
	                if (horizontal) {
	                    legend.itemX += itemWidth;

	                } else {
	                    legend.itemY += itemMarginTop + itemHeight + itemMarginBottom;
	                    legend.lastLineHeight = itemHeight;
	                }

	                // the width of the widest item
	                legend.offsetWidth = widthOption || Math.max(
	                    (
	                        horizontal ? legend.itemX - padding - (item.checkbox ?
	                            // decrease by itemDistance only when no checkbox #4853
	                            0 :
	                            itemDistance
	                        ) : itemWidth
	                    ) + padding,
	                    legend.offsetWidth
	                );
	            },

	            /**
	             * Get all items, which is one item per series for most series and one
	             * item per point for pie series and its derivatives.
	             *
	             * @return {Array.<Series|Point>}
	             *         The current items in the legend.
	             */
	            getAllItems: function() {
	                var allItems = [];
	                each(this.chart.series, function(series) {
	                    var seriesOptions = series && series.options;

	                    // Handle showInLegend. If the series is linked to another series,
	                    // defaults to false.
	                    if (series && pick(
	                            seriesOptions.showInLegend, !defined(seriesOptions.linkedTo) ? undefined : false, true
	                        )) {

	                        // Use points or series for the legend item depending on
	                        // legendType
	                        allItems = allItems.concat(
	                            series.legendItems ||
	                            (
	                                seriesOptions.legendType === 'point' ?
	                                series.data :
	                                series
	                            )
	                        );
	                    }
	                });
	                return allItems;
	            },

	            /**
	             * Adjust the chart margins by reserving space for the legend on only one
	             * side of the chart. If the position is set to a corner, top or bottom is
	             * reserved for horizontal legends and left or right for vertical ones.
	             *
	             * @private
	             */
	            adjustMargins: function(margin, spacing) {
	                var chart = this.chart,
	                    options = this.options,
	                    // Use the first letter of each alignment option in order to detect
	                    // the side. (#4189 - use charAt(x) notation instead of [x] for IE7)
	                    alignment = options.align.charAt(0) +
	                    options.verticalAlign.charAt(0) +
	                    options.layout.charAt(0);

	                if (!options.floating) {

	                    each([
	                        /(lth|ct|rth)/,
	                        /(rtv|rm|rbv)/,
	                        /(rbh|cb|lbh)/,
	                        /(lbv|lm|ltv)/
	                    ], function(alignments, side) {
	                        if (alignments.test(alignment) && !defined(margin[side])) {
	                            // Now we have detected on which side of the chart we should
	                            // reserve space for the legend
	                            chart[marginNames[side]] = Math.max(
	                                chart[marginNames[side]],
	                                (
	                                    chart.legend[
	                                        (side + 1) % 2 ? 'legendHeight' : 'legendWidth'
	                                    ] + [1, -1, -1, 1][side] * options[
	                                        (side % 2) ? 'x' : 'y'
	                                    ] +
	                                    pick(options.margin, 12) +
	                                    spacing[side]
	                                )
	                            );
	                        }
	                    });
	                }
	            },

	            /**
	             * Render the legend. This method can be called both before and after
	             * `chart.render`. If called after, it will only rearrange items instead
	             * of creating new ones. Called internally on initial render and after
	             * redraws.
	             */
	            render: function() {
	                var legend = this,
	                    chart = legend.chart,
	                    renderer = chart.renderer,
	                    legendGroup = legend.group,
	                    allItems,
	                    display,
	                    legendWidth,
	                    legendHeight,
	                    box = legend.box,
	                    options = legend.options,
	                    padding = legend.padding;

	                legend.itemX = padding;
	                legend.itemY = legend.initialItemY;
	                legend.offsetWidth = 0;
	                legend.lastItemY = 0;

	                if (!legendGroup) {
	                    legend.group = legendGroup = renderer.g('legend')
	                        .attr({
	                            zIndex: 7
	                        })
	                        .add();
	                    legend.contentGroup = renderer.g()
	                        .attr({
	                            zIndex: 1
	                        }) // above background
	                        .add(legendGroup);
	                    legend.scrollGroup = renderer.g()
	                        .add(legend.contentGroup);
	                }

	                legend.renderTitle();

	                // add each series or point
	                allItems = legend.getAllItems();

	                // sort by legendIndex
	                stableSort(allItems, function(a, b) {
	                    return ((a.options && a.options.legendIndex) || 0) -
	                        ((b.options && b.options.legendIndex) || 0);
	                });

	                // reversed legend
	                if (options.reversed) {
	                    allItems.reverse();
	                }

	                legend.allItems = allItems;
	                legend.display = display = !!allItems.length;

	                // render the items
	                legend.lastLineHeight = 0;
	                each(allItems, function(item) {
	                    legend.renderItem(item);
	                });

	                // Get the box
	                legendWidth = (options.width || legend.offsetWidth) + padding;
	                legendHeight = legend.lastItemY + legend.lastLineHeight +
	                    legend.titleHeight;
	                legendHeight = legend.handleOverflow(legendHeight);
	                legendHeight += padding;

	                // Draw the border and/or background
	                if (!box) {
	                    legend.box = box = renderer.rect()
	                        .addClass('highcharts-legend-box')
	                        .attr({
	                            r: options.borderRadius
	                        })
	                        .add(legendGroup);
	                    box.isNew = true;
	                }


	                // Presentational
	                box
	                    .attr({
	                        stroke: options.borderColor,
	                        'stroke-width': options.borderWidth || 0,
	                        fill: options.backgroundColor || 'none'
	                    })
	                    .shadow(options.shadow);


	                if (legendWidth > 0 && legendHeight > 0) {
	                    box[box.isNew ? 'attr' : 'animate'](
	                        box.crisp({
	                            x: 0,
	                            y: 0,
	                            width: legendWidth,
	                            height: legendHeight
	                        }, box.strokeWidth())
	                    );
	                    box.isNew = false;
	                }

	                // hide the border if no items
	                box[display ? 'show' : 'hide']();



	                legend.legendWidth = legendWidth;
	                legend.legendHeight = legendHeight;

	                // Now that the legend width and height are established, put the items
	                // in the final position
	                each(allItems, function(item) {
	                    legend.positionItem(item);
	                });

	                // 1.x compatibility: positioning based on style
	                /*var props = ['left', 'right', 'top', 'bottom'],
	                    prop,
	                    i = 4;
	                while (i--) {
	                    prop = props[i];
	                    if (options.style[prop] && options.style[prop] !== 'auto') {
	                        options[i < 2 ? 'align' : 'verticalAlign'] = prop;
	                        options[i < 2 ? 'x' : 'y'] = 
	                            pInt(options.style[prop]) * (i % 2 ? -1 : 1);
	                    }
	                }*/

	                if (display) {
	                    legendGroup.align(merge(options, {
	                        width: legendWidth,
	                        height: legendHeight
	                    }), true, 'spacingBox');
	                }

	                if (!chart.isResizing) {
	                    this.positionCheckboxes();
	                }
	            },

	            /**
	             * Set up the overflow handling by adding navigation with up and down arrows
	             * below the legend.
	             *
	             * @private
	             */
	            handleOverflow: function(legendHeight) {
	                var legend = this,
	                    chart = this.chart,
	                    renderer = chart.renderer,
	                    options = this.options,
	                    optionsY = options.y,
	                    alignTop = options.verticalAlign === 'top',
	                    padding = this.padding,
	                    spaceHeight = chart.spacingBox.height +
	                    (alignTop ? -optionsY : optionsY) - padding,
	                    maxHeight = options.maxHeight,
	                    clipHeight,
	                    clipRect = this.clipRect,
	                    navOptions = options.navigation,
	                    animation = pick(navOptions.animation, true),
	                    arrowSize = navOptions.arrowSize || 12,
	                    nav = this.nav,
	                    pages = this.pages,
	                    lastY,
	                    allItems = this.allItems,
	                    clipToHeight = function(height) {
	                        if (typeof height === 'number') {
	                            clipRect.attr({
	                                height: height
	                            });
	                        } else if (clipRect) { // Reset (#5912)
	                            legend.clipRect = clipRect.destroy();
	                            legend.contentGroup.clip();
	                        }

	                        // useHTML
	                        if (legend.contentGroup.div) {
	                            legend.contentGroup.div.style.clip = height ?
	                                'rect(' + padding + 'px,9999px,' +
	                                (padding + height) + 'px,0)' :
	                                'auto';
	                        }
	                    };


	                // Adjust the height
	                if (
	                    options.layout === 'horizontal' &&
	                    options.verticalAlign !== 'middle' &&
	                    !options.floating
	                ) {
	                    spaceHeight /= 2;
	                }
	                if (maxHeight) {
	                    spaceHeight = Math.min(spaceHeight, maxHeight);
	                }

	                // Reset the legend height and adjust the clipping rectangle
	                pages.length = 0;
	                if (legendHeight > spaceHeight && navOptions.enabled !== false) {

	                    this.clipHeight = clipHeight =
	                        Math.max(spaceHeight - 20 - this.titleHeight - padding, 0);
	                    this.currentPage = pick(this.currentPage, 1);
	                    this.fullHeight = legendHeight;

	                    // Fill pages with Y positions so that the top of each a legend item
	                    // defines the scroll top for each page (#2098)
	                    each(allItems, function(item, i) {
	                        var y = item._legendItemPos[1],
	                            h = Math.round(item.legendItem.getBBox().height),
	                            len = pages.length;

	                        if (!len || (y - pages[len - 1] > clipHeight &&
	                                (lastY || y) !== pages[len - 1])) {
	                            pages.push(lastY || y);
	                            len++;
	                        }

	                        if (i === allItems.length - 1 &&
	                            y + h - pages[len - 1] > clipHeight) {
	                            pages.push(y);
	                        }
	                        if (y !== lastY) {
	                            lastY = y;
	                        }
	                    });

	                    // Only apply clipping if needed. Clipping causes blurred legend in
	                    // PDF export (#1787)
	                    if (!clipRect) {
	                        clipRect = legend.clipRect =
	                            renderer.clipRect(0, padding, 9999, 0);
	                        legend.contentGroup.clip(clipRect);
	                    }

	                    clipToHeight(clipHeight);

	                    // Add navigation elements
	                    if (!nav) {
	                        this.nav = nav = renderer.g()
	                            .attr({
	                                zIndex: 1
	                            })
	                            .add(this.group);

	                        this.up = renderer
	                            .symbol(
	                                'triangle',
	                                0,
	                                0,
	                                arrowSize,
	                                arrowSize
	                            )
	                            .on('click', function() {
	                                legend.scroll(-1, animation);
	                            })
	                            .add(nav);

	                        this.pager = renderer.text('', 15, 10)
	                            .addClass('highcharts-legend-navigation')

	                            .css(navOptions.style)

	                            .add(nav);

	                        this.down = renderer
	                            .symbol(
	                                'triangle-down',
	                                0,
	                                0,
	                                arrowSize,
	                                arrowSize
	                            )
	                            .on('click', function() {
	                                legend.scroll(1, animation);
	                            })
	                            .add(nav);
	                    }

	                    // Set initial position
	                    legend.scroll(0);

	                    legendHeight = spaceHeight;

	                    // Reset
	                } else if (nav) {
	                    clipToHeight();
	                    this.nav = nav.destroy(); // #6322
	                    this.scrollGroup.attr({
	                        translateY: 1
	                    });
	                    this.clipHeight = 0; // #1379
	                }

	                return legendHeight;
	            },

	            /**
	             * Scroll the legend by a number of pages.
	             * @param  {Number} scrollBy
	             *         The number of pages to scroll.
	             * @param  {AnimationOptions} animation
	             *         Whether and how to apply animation.
	             */
	            scroll: function(scrollBy, animation) {
	                var pages = this.pages,
	                    pageCount = pages.length,
	                    currentPage = this.currentPage + scrollBy,
	                    clipHeight = this.clipHeight,
	                    navOptions = this.options.navigation,
	                    pager = this.pager,
	                    padding = this.padding,
	                    scrollOffset;

	                // When resizing while looking at the last page
	                if (currentPage > pageCount) {
	                    currentPage = pageCount;
	                }

	                if (currentPage > 0) {

	                    if (animation !== undefined) {
	                        setAnimation(animation, this.chart);
	                    }

	                    this.nav.attr({
	                        translateX: padding,
	                        translateY: clipHeight + this.padding + 7 + this.titleHeight,
	                        visibility: 'visible'
	                    });
	                    this.up.attr({
	                        'class': currentPage === 1 ?
	                            'highcharts-legend-nav-inactive' : 'highcharts-legend-nav-active'
	                    });
	                    pager.attr({
	                        text: currentPage + '/' + pageCount
	                    });
	                    this.down.attr({
	                        'x': 18 + this.pager.getBBox().width, // adjust to text width
	                        'class': currentPage === pageCount ?
	                            'highcharts-legend-nav-inactive' : 'highcharts-legend-nav-active'
	                    });


	                    this.up
	                        .attr({
	                            fill: currentPage === 1 ?
	                                navOptions.inactiveColor : navOptions.activeColor
	                        })
	                        .css({
	                            cursor: currentPage === 1 ? 'default' : 'pointer'
	                        });
	                    this.down
	                        .attr({
	                            fill: currentPage === pageCount ?
	                                navOptions.inactiveColor : navOptions.activeColor
	                        })
	                        .css({
	                            cursor: currentPage === pageCount ? 'default' : 'pointer'
	                        });


	                    scrollOffset = -pages[currentPage - 1] + this.initialItemY;

	                    this.scrollGroup.animate({
	                        translateY: scrollOffset
	                    });

	                    this.currentPage = currentPage;
	                    this.positionCheckboxes(scrollOffset);
	                }

	            }

	        };

	        /*
	         * LegendSymbolMixin
	         */

	        H.LegendSymbolMixin = {

	            /**
	             * Get the series' symbol in the legend
	             *
	             * @param {Object} legend The legend object
	             * @param {Object} item The series (this) or point
	             */
	            drawRectangle: function(legend, item) {
	                var options = legend.options,
	                    symbolHeight = legend.symbolHeight,
	                    square = options.squareSymbol,
	                    symbolWidth = square ? symbolHeight : legend.symbolWidth;

	                item.legendSymbol = this.chart.renderer.rect(
	                        square ? (legend.symbolWidth - symbolHeight) / 2 : 0,
	                        legend.baseline - symbolHeight + 1, // #3988
	                        symbolWidth,
	                        symbolHeight,
	                        pick(legend.options.symbolRadius, symbolHeight / 2)
	                    )
	                    .addClass('highcharts-point')
	                    .attr({
	                        zIndex: 3
	                    }).add(item.legendGroup);

	            },

	            /**
	             * Get the series' symbol in the legend. This method should be overridable
	             * to create custom symbols through
	             * Highcharts.seriesTypes[type].prototype.drawLegendSymbols.
	             *
	             * @param {Object} legend The legend object
	             */
	            drawLineMarker: function(legend) {

	                var options = this.options,
	                    markerOptions = options.marker,
	                    radius,
	                    legendSymbol,
	                    symbolWidth = legend.symbolWidth,
	                    symbolHeight = legend.symbolHeight,
	                    generalRadius = symbolHeight / 2,
	                    renderer = this.chart.renderer,
	                    legendItemGroup = this.legendGroup,
	                    verticalCenter = legend.baseline -
	                    Math.round(legend.fontMetrics.b * 0.3),
	                    attr = {};

	                // Draw the line

	                attr = {
	                    'stroke-width': options.lineWidth || 0
	                };
	                if (options.dashStyle) {
	                    attr.dashstyle = options.dashStyle;
	                }


	                this.legendLine = renderer.path([
	                        'M',
	                        0,
	                        verticalCenter,
	                        'L',
	                        symbolWidth,
	                        verticalCenter
	                    ])
	                    .addClass('highcharts-graph')
	                    .attr(attr)
	                    .add(legendItemGroup);

	                // Draw the marker
	                if (markerOptions && markerOptions.enabled !== false) {

	                    // Do not allow the marker to be larger than the symbolHeight
	                    radius = Math.min(
	                        pick(markerOptions.radius, generalRadius),
	                        generalRadius
	                    );

	                    // Restrict symbol markers size
	                    if (this.symbol.indexOf('url') === 0) {
	                        markerOptions = merge(markerOptions, {
	                            width: symbolHeight,
	                            height: symbolHeight
	                        });
	                        radius = 0;
	                    }

	                    this.legendSymbol = legendSymbol = renderer.symbol(
	                            this.symbol,
	                            (symbolWidth / 2) - radius,
	                            verticalCenter - radius,
	                            2 * radius,
	                            2 * radius,
	                            markerOptions
	                        )
	                        .addClass('highcharts-point')
	                        .add(legendItemGroup);
	                    legendSymbol.isMarker = true;
	                }
	            }
	        };

	        // Workaround for #2030, horizontal legend items not displaying in IE11 Preview,
	        // and for #2580, a similar drawing flaw in Firefox 26.
	        // Explore if there's a general cause for this. The problem may be related
	        // to nested group elements, as the legend item texts are within 4 group
	        // elements.
	        if (/Trident\/7\.0/.test(win.navigator.userAgent) || isFirefox) {
	            wrap(Highcharts.Legend.prototype, 'positionItem', function(proceed, item) {
	                var legend = this,
	                    // If chart destroyed in sync, this is undefined (#2030)
	                    runPositionItem = function() {
	                        if (item._legendItemPos) {
	                            proceed.call(legend, item);
	                        }
	                    };

	                // Do it now, for export and to get checkbox placement
	                runPositionItem();

	                // Do it after to work around the core issue
	                setTimeout(runPositionItem);
	            });
	        }

	    }(Highcharts));
	    (function(H) {
	        /**
	         * (c) 2010-2017 Torstein Honsi
	         *
	         * License: www.highcharts.com/license
	         */
	        var addEvent = H.addEvent,
	            animate = H.animate,
	            animObject = H.animObject,
	            attr = H.attr,
	            doc = H.doc,
	            Axis = H.Axis, // @todo add as requirement
	            createElement = H.createElement,
	            defaultOptions = H.defaultOptions,
	            discardElement = H.discardElement,
	            charts = H.charts,
	            css = H.css,
	            defined = H.defined,
	            each = H.each,
	            extend = H.extend,
	            find = H.find,
	            fireEvent = H.fireEvent,
	            getStyle = H.getStyle,
	            grep = H.grep,
	            isNumber = H.isNumber,
	            isObject = H.isObject,
	            isString = H.isString,
	            Legend = H.Legend, // @todo add as requirement
	            marginNames = H.marginNames,
	            merge = H.merge,
	            objectEach = H.objectEach,
	            Pointer = H.Pointer, // @todo add as requirement
	            pick = H.pick,
	            pInt = H.pInt,
	            removeEvent = H.removeEvent,
	            seriesTypes = H.seriesTypes,
	            splat = H.splat,
	            svg = H.svg,
	            syncTimeout = H.syncTimeout,
	            win = H.win,
	            Renderer = H.Renderer;
	        /**
	         * The Chart class. The recommended constructor is {@link Highcharts#chart}.
	         * @class Highcharts.Chart
	         * @param  {String|HTMLDOMElement} renderTo
	         *         The DOM element to render to, or its id.
	         * @param  {Options} options
	         *         The chart options structure.
	         * @param  {Function} [callback]
	         *         Function to run when the chart has loaded and and all external images
	         *         are loaded. Defining a {@link
	         *         https://api.highcharts.com/highcharts/chart.events.load|chart.event.load}
	         *         handler is equivalent.
	         *
	         * @example
	         * var chart = Highcharts.chart('container', {
	         *     title: {
	         *         text: 'My chart'
	         *     },
	         *     series: [{
	         *         data: [1, 3, 2, 4]
	         *     }]
	         * })
	         */
	        var Chart = H.Chart = function() {
	            this.getArgs.apply(this, arguments);
	        };

	        /**
	         * Factory function for basic charts. 
	         *
	         * @function #chart
	         * @memberOf Highcharts
	         * @param  {String|HTMLDOMElement} renderTo - The DOM element to render to, or
	         * its id.
	         * @param  {Options} options - The chart options structure.
	         * @param  {Function} [callback] - Function to run when the chart has loaded and
	         * and all external images are loaded. Defining a {@link
	         * https://api.highcharts.com/highcharts/chart.events.load|chart.event.load}
	         * handler is equivalent.
	         * @return {Highcharts.Chart} - Returns the Chart object.
	         *
	         * @example
	         * // Render a chart in to div#container
	         * var chart = Highcharts.chart('container', {
	         *     title: {
	         *         text: 'My chart'
	         *     },
	         *     series: [{
	         *         data: [1, 3, 2, 4]
	         *     }]
	         * });
	         */
	        H.chart = function(a, b, c) {
	            return new Chart(a, b, c);
	        };

	        extend(Chart.prototype, /** @lends Highcharts.Chart.prototype */ {

	            // Hook for adding callbacks in modules
	            callbacks: [],

	            /**
	             * Handle the arguments passed to the constructor.
	             *
	             * @private
	             * @returns {Array} Arguments without renderTo
	             */
	            getArgs: function() {
	                var args = [].slice.call(arguments);

	                // Remove the optional first argument, renderTo, and
	                // set it on this.
	                if (isString(args[0]) || args[0].nodeName) {
	                    this.renderTo = args.shift();
	                }
	                this.init(args[0], args[1]);
	            },

	            /**
	             * Overridable function that initializes the chart. The constructor's
	             * arguments are passed on directly.
	             */
	            init: function(userOptions, callback) {

	                // Handle regular options
	                var options,
	                    type,
	                    seriesOptions = userOptions.series, // skip merging data points to increase performance
	                    userPlotOptions = userOptions.plotOptions || {};

	                userOptions.series = null;
	                options = merge(defaultOptions, userOptions); // do the merge

	                // Override (by copy of user options) or clear tooltip options
	                // in chart.options.plotOptions (#6218)
	                for (type in options.plotOptions) {
	                    options.plotOptions[type].tooltip = (
	                        userPlotOptions[type] &&
	                        merge(userPlotOptions[type].tooltip) // override by copy
	                    ) || undefined; // or clear
	                }
	                // User options have higher priority than default options (#6218).
	                // In case of exporting: path is changed
	                options.tooltip.userOptions = (userOptions.chart &&
	                        userOptions.chart.forExport && userOptions.tooltip.userOptions) ||
	                    userOptions.tooltip;

	                options.series = userOptions.series = seriesOptions; // set back the series data
	                this.userOptions = userOptions;

	                var optionsChart = options.chart;

	                var chartEvents = optionsChart.events;

	                this.margin = [];
	                this.spacing = [];

	                //this.runChartClick = chartEvents && !!chartEvents.click;
	                this.bounds = {
	                    h: {},
	                    v: {}
	                }; // Pixel data bounds for touch zoom

	                this.callback = callback;
	                this.isResizing = 0;

	                /**
	                 * The options structure for the chart. It contains members for the sub
	                 * elements like series, legend, tooltip etc.
	                 *
	                 * @memberof Highcharts.Chart
	                 * @name options
	                 * @type {Options}
	                 */
	                this.options = options;
	                /**
	                 * All the axes in the chart.
	                 *
	                 * @memberof Highcharts.Chart
	                 * @name axes
	                 * @see  Highcharts.Chart.xAxis
	                 * @see  Highcharts.Chart.yAxis
	                 * @type {Array.<Highcharts.Axis>}
	                 */
	                this.axes = [];

	                /**
	                 * All the current series in the chart.
	                 *
	                 * @memberof Highcharts.Chart
	                 * @name series
	                 * @type {Array.<Highcharts.Series>}
	                 */
	                this.series = [];

	                /**
	                 * The chart title. The title has an `update` method that allows
	                 * modifying the options directly or indirectly via `chart.update`.
	                 *
	                 * @memberof Highcharts.Chart
	                 * @name title
	                 * @type Object
	                 *
	                 * @sample highcharts/members/title-update/
	                 *         Updating titles
	                 */

	                /**
	                 * The chart subtitle. The subtitle has an `update` method that allows
	                 * modifying the options directly or indirectly via `chart.update`.
	                 *
	                 * @memberof Highcharts.Chart
	                 * @name subtitle
	                 * @type Object
	                 */



	                this.hasCartesianSeries = optionsChart.showAxes;
	                //this.axisOffset = undefined;
	                //this.inverted = undefined;
	                //this.loadingShown = undefined;
	                //this.container = undefined;
	                //this.chartWidth = undefined;
	                //this.chartHeight = undefined;
	                //this.marginRight = undefined;
	                //this.marginBottom = undefined;
	                //this.containerWidth = undefined;
	                //this.containerHeight = undefined;
	                //this.oldChartWidth = undefined;
	                //this.oldChartHeight = undefined;

	                //this.renderTo = undefined;

	                //this.spacingBox = undefined

	                //this.legend = undefined;

	                // Elements
	                //this.chartBackground = undefined;
	                //this.plotBackground = undefined;
	                //this.plotBGImage = undefined;
	                //this.plotBorder = undefined;
	                //this.loadingDiv = undefined;
	                //this.loadingSpan = undefined;

	                var chart = this;

	                // Add the chart to the global lookup
	                chart.index = charts.length;

	                charts.push(chart);
	                H.chartCount++;

	                // Chart event handlers
	                if (chartEvents) {
	                    objectEach(chartEvents, function(event, eventType) {
	                        addEvent(chart, eventType, event);
	                    });
	                }

	                /**
	                 * A collection of the X axes in the chart.
	                 * @type {Array.<Highcharts.Axis>}
	                 * @name xAxis
	                 * @memberOf Highcharts.Chart
	                 */
	                chart.xAxis = [];
	                /**
	                 * A collection of the Y axes in the chart.
	                 * @type {Array.<Highcharts.Axis>}
	                 * @name yAxis
	                 * @memberOf Highcharts.Chart
	                 */
	                chart.yAxis = [];

	                chart.pointCount = chart.colorCounter = chart.symbolCounter = 0;

	                chart.firstRender();
	            },

	            /**
	             * Internal function to unitialize an individual series.
	             *
	             * @private
	             */
	            initSeries: function(options) {
	                var chart = this,
	                    optionsChart = chart.options.chart,
	                    type = options.type || optionsChart.type || optionsChart.defaultSeriesType,
	                    series,
	                    Constr = seriesTypes[type];

	                // No such series type
	                if (!Constr) {
	                    H.error(17, true);
	                }

	                series = new Constr();
	                series.init(this, options);
	                return series;
	            },

	            /**
	             * Order all series above a given index. When series are added and ordered
	             * by configuration, only the last series is handled (#248, #1123, #2456,
	             * #6112). This function is called on series initialization and destroy.
	             *
	             * @private
	             *
	             * @param  {number} fromIndex
	             *         If this is given, only the series above this index are handled.
	             */
	            orderSeries: function(fromIndex) {
	                var series = this.series,
	                    i = fromIndex || 0;
	                for (; i < series.length; i++) {
	                    if (series[i]) {
	                        series[i].index = i;
	                        series[i].name = series[i].name ||
	                            'Series ' + (series[i].index + 1);
	                    }
	                }
	            },

	            /**
	             * Check whether a given point is within the plot area.
	             *
	             * @param  {Number} plotX
	             *         Pixel x relative to the plot area.
	             * @param  {Number} plotY
	             *         Pixel y relative to the plot area.
	             * @param  {Boolean} inverted
	             *         Whether the chart is inverted.
	             *
	             * @return {Boolean}
	             *         Returns true if the given point is inside the plot area.
	             */
	            isInsidePlot: function(plotX, plotY, inverted) {
	                var x = inverted ? plotY : plotX,
	                    y = inverted ? plotX : plotY;

	                return x >= 0 &&
	                    x <= this.plotWidth &&
	                    y >= 0 &&
	                    y <= this.plotHeight;
	            },

	            /**
	             * Redraw the chart after changes have been done to the data, axis extremes
	             * chart size or chart elements. All methods for updating axes, series or
	             * points have a parameter for redrawing the chart. This is `true` by
	             * default. But in many cases you want to do more than one operation on the
	             * chart before redrawing, for example add a number of points. In those
	             * cases it is a waste of resources to redraw the chart for each new point
	             * added. So you add the points and call `chart.redraw()` after.
	             *
	             * @param  {AnimationOptions} animation
	             *         If or how to apply animation to the redraw.
	             */
	            redraw: function(animation) {
	                var chart = this,
	                    axes = chart.axes,
	                    series = chart.series,
	                    pointer = chart.pointer,
	                    legend = chart.legend,
	                    redrawLegend = chart.isDirtyLegend,
	                    hasStackedSeries,
	                    hasDirtyStacks,
	                    hasCartesianSeries = chart.hasCartesianSeries,
	                    isDirtyBox = chart.isDirtyBox,
	                    i,
	                    serie,
	                    renderer = chart.renderer,
	                    isHiddenChart = renderer.isHidden(),
	                    afterRedraw = [];

	                // Handle responsive rules, not only on resize (#6130)
	                if (chart.setResponsive) {
	                    chart.setResponsive(false);
	                }

	                H.setAnimation(animation, chart);

	                if (isHiddenChart) {
	                    chart.temporaryDisplay();
	                }

	                // Adjust title layout (reflow multiline text)
	                chart.layOutTitles();

	                // link stacked series
	                i = series.length;
	                while (i--) {
	                    serie = series[i];

	                    if (serie.options.stacking) {
	                        hasStackedSeries = true;

	                        if (serie.isDirty) {
	                            hasDirtyStacks = true;
	                            break;
	                        }
	                    }
	                }
	                if (hasDirtyStacks) { // mark others as dirty
	                    i = series.length;
	                    while (i--) {
	                        serie = series[i];
	                        if (serie.options.stacking) {
	                            serie.isDirty = true;
	                        }
	                    }
	                }

	                // Handle updated data in the series
	                each(series, function(serie) {
	                    if (serie.isDirty) {
	                        if (serie.options.legendType === 'point') {
	                            if (serie.updateTotals) {
	                                serie.updateTotals();
	                            }
	                            redrawLegend = true;
	                        }
	                    }
	                    if (serie.isDirtyData) {
	                        fireEvent(serie, 'updatedData');
	                    }
	                });

	                // handle added or removed series
	                if (redrawLegend && legend.options.enabled) { // series or pie points are added or removed
	                    // draw legend graphics
	                    legend.render();

	                    chart.isDirtyLegend = false;
	                }

	                // reset stacks
	                if (hasStackedSeries) {
	                    chart.getStacks();
	                }


	                if (hasCartesianSeries) {
	                    // set axes scales
	                    each(axes, function(axis) {
	                        axis.updateNames();
	                        axis.setScale();
	                    });
	                }

	                chart.getMargins(); // #3098

	                if (hasCartesianSeries) {
	                    // If one axis is dirty, all axes must be redrawn (#792, #2169)
	                    each(axes, function(axis) {
	                        if (axis.isDirty) {
	                            isDirtyBox = true;
	                        }
	                    });

	                    // redraw axes
	                    each(axes, function(axis) {

	                        // Fire 'afterSetExtremes' only if extremes are set
	                        var key = axis.min + ',' + axis.max;
	                        if (axis.extKey !== key) { // #821, #4452
	                            axis.extKey = key;
	                            afterRedraw.push(function() { // prevent a recursive call to chart.redraw() (#1119)
	                                fireEvent(axis, 'afterSetExtremes', extend(axis.eventArgs, axis.getExtremes())); // #747, #751
	                                delete axis.eventArgs;
	                            });
	                        }
	                        if (isDirtyBox || hasStackedSeries) {
	                            axis.redraw();
	                        }
	                    });
	                }

	                // the plot areas size has changed
	                if (isDirtyBox) {
	                    chart.drawChartBox();
	                }

	                // Fire an event before redrawing series, used by the boost module to
	                // clear previous series renderings.
	                fireEvent(chart, 'predraw');

	                // redraw affected series
	                each(series, function(serie) {
	                    if ((isDirtyBox || serie.isDirty) && serie.visible) {
	                        serie.redraw();
	                    }
	                    // Set it here, otherwise we will have unlimited 'updatedData' calls
	                    // for a hidden series after setData(). Fixes #6012
	                    serie.isDirtyData = false;
	                });

	                // move tooltip or reset
	                if (pointer) {
	                    pointer.reset(true);
	                }

	                // redraw if canvas
	                renderer.draw();

	                // Fire the events
	                fireEvent(chart, 'redraw');
	                fireEvent(chart, 'render');

	                if (isHiddenChart) {
	                    chart.temporaryDisplay(true);
	                }

	                // Fire callbacks that are put on hold until after the redraw
	                each(afterRedraw, function(callback) {
	                    callback.call();
	                });
	            },

	            /**
	             * Get an axis, series or point object by `id` as given in the configuration
	             * options. Returns `undefined` if no item is found.
	             * @param id {String} The id as given in the configuration options.
	             * @return {Highcharts.Axis|Highcharts.Series|Highcharts.Point|undefined}
	             *         The retrieved item.
	             * @sample highcharts/plotoptions/series-id/
	             *         Get series by id
	             */
	            get: function(id) {

	                var ret,
	                    series = this.series,
	                    i;

	                function itemById(item) {
	                    return item.id === id || (item.options && item.options.id === id);
	                }

	                ret =
	                    // Search axes
	                    find(this.axes, itemById) ||

	                    // Search series
	                    find(this.series, itemById);

	                // Search points
	                for (i = 0; !ret && i < series.length; i++) {
	                    ret = find(series[i].points || [], itemById);
	                }

	                return ret;
	            },

	            /**
	             * Create the Axis instances based on the config options.
	             *
	             * @private
	             */
	            getAxes: function() {
	                var chart = this,
	                    options = this.options,
	                    xAxisOptions = options.xAxis = splat(options.xAxis || {}),
	                    yAxisOptions = options.yAxis = splat(options.yAxis || {}),
	                    optionsArray;

	                // make sure the options are arrays and add some members
	                each(xAxisOptions, function(axis, i) {
	                    axis.index = i;
	                    axis.isX = true;
	                });

	                each(yAxisOptions, function(axis, i) {
	                    axis.index = i;
	                });

	                // concatenate all axis options into one array
	                optionsArray = xAxisOptions.concat(yAxisOptions);

	                each(optionsArray, function(axisOptions) {
	                    new Axis(chart, axisOptions); // eslint-disable-line no-new
	                });
	            },


	            /**
	             * Returns an array of all currently selected points in the chart. Points
	             * can be selected by clicking or programmatically by the {@link
	             * Highcharts.Point#select} function.
	             *
	             * @return {Array.<Highcharts.Point>}
	             *         The currently selected points.
	             *
	             * @sample highcharts/plotoptions/series-allowpointselect-line/
	             *         Get selected points
	             */
	            getSelectedPoints: function() {
	                var points = [];
	                each(this.series, function(serie) {
	                    // series.data - for points outside of viewed range (#6445)
	                    points = points.concat(grep(serie.data || [], function(point) {
	                        return point.selected;
	                    }));
	                });
	                return points;
	            },

	            /**
	             * Returns an array of all currently selected series in the chart. Series
	             * can be selected either programmatically by the {@link
	             * Highcharts.Series#select} function or by checking the checkbox next to
	             * the legend item if {@link
	             * https://api.highcharts.com/highcharts/plotOptions.series.showCheckbox|
	             * series.showCheckBox} is true.
	             * 
	             * @return {Array.<Highcharts.Series>}
	             *         The currently selected series.
	             *
	             * @sample highcharts/members/chart-getselectedseries/
	             *         Get selected series
	             */
	            getSelectedSeries: function() {
	                return grep(this.series, function(serie) {
	                    return serie.selected;
	                });
	            },

	            /**
	             * Set a new title or subtitle for the chart.
	             *
	             * @param  titleOptions {TitleOptions}
	             *         New title options. The title text itself is set by the
	             *         `titleOptions.text` property.
	             * @param  subtitleOptions {SubtitleOptions}
	             *         New subtitle options. The subtitle text itself is set by the
	             *         `subtitleOptions.text` property.
	             * @param  redraw {Boolean}
	             *         Whether to redraw the chart or wait for a later call to 
	             *         `chart.redraw()`.
	             *
	             * @sample highcharts/members/chart-settitle/ Set title text and styles
	             *
	             */
	            setTitle: function(titleOptions, subtitleOptions, redraw) {
	                var chart = this,
	                    options = chart.options,
	                    chartTitleOptions,
	                    chartSubtitleOptions;

	                chartTitleOptions = options.title = merge(

	                    // Default styles
	                    {
	                        style: {
	                            color: '#333333',
	                            fontSize: options.isStock ? '16px' : '18px' // #2944
	                        }
	                    },

	                    options.title,
	                    titleOptions
	                );
	                chartSubtitleOptions = options.subtitle = merge(

	                    // Default styles
	                    {
	                        style: {
	                            color: '#666666'
	                        }
	                    },

	                    options.subtitle,
	                    subtitleOptions
	                );

	                // add title and subtitle
	                each([
	                    ['title', titleOptions, chartTitleOptions],
	                    ['subtitle', subtitleOptions, chartSubtitleOptions]
	                ], function(arr, i) {
	                    var name = arr[0],
	                        title = chart[name],
	                        titleOptions = arr[1],
	                        chartTitleOptions = arr[2];

	                    if (title && titleOptions) {
	                        chart[name] = title = title.destroy(); // remove old
	                    }

	                    if (chartTitleOptions && chartTitleOptions.text && !title) {
	                        chart[name] = chart.renderer.text(
	                                chartTitleOptions.text,
	                                0,
	                                0,
	                                chartTitleOptions.useHTML
	                            )
	                            .attr({
	                                align: chartTitleOptions.align,
	                                'class': 'highcharts-' + name,
	                                zIndex: chartTitleOptions.zIndex || 4
	                            })
	                            .add();

	                        // Update methods, shortcut to Chart.setTitle
	                        chart[name].update = function(o) {
	                            chart.setTitle(!i && o, i && o);
	                        };


	                        // Presentational
	                        chart[name].css(chartTitleOptions.style);


	                    }
	                });
	                chart.layOutTitles(redraw);
	            },

	            /**
	             * Internal function to lay out the chart titles and cache the full offset
	             * height for use in `getMargins`. The result is stored in 
	             * `this.titleOffset`.
	             *
	             * @private
	             */
	            layOutTitles: function(redraw) {
	                var titleOffset = 0,
	                    requiresDirtyBox,
	                    renderer = this.renderer,
	                    spacingBox = this.spacingBox;

	                // Lay out the title and the subtitle respectively
	                each(['title', 'subtitle'], function(key) {
	                    var title = this[key],
	                        titleOptions = this.options[key],
	                        offset = key === 'title' ? -3 :
	                        // Floating subtitle (#6574)
	                        titleOptions.verticalAlign ? 0 : titleOffset + 2,
	                        titleSize;

	                    if (title) {

	                        titleSize = titleOptions.style.fontSize;

	                        titleSize = renderer.fontMetrics(titleSize, title).b;

	                        title
	                            .css({
	                                width: (titleOptions.width ||
	                                    spacingBox.width + titleOptions.widthAdjust) + 'px'
	                            })
	                            .align(extend({
	                                y: offset + titleSize
	                            }, titleOptions), false, 'spacingBox');

	                        if (!titleOptions.floating && !titleOptions.verticalAlign) {
	                            titleOffset = Math.ceil(
	                                titleOffset +
	                                // Skip the cache for HTML (#3481)
	                                title.getBBox(titleOptions.useHTML).height
	                            );
	                        }
	                    }
	                }, this);

	                requiresDirtyBox = this.titleOffset !== titleOffset;
	                this.titleOffset = titleOffset; // used in getMargins

	                if (!this.isDirtyBox && requiresDirtyBox) {
	                    this.isDirtyBox = requiresDirtyBox;
	                    // Redraw if necessary (#2719, #2744)
	                    if (this.hasRendered && pick(redraw, true) && this.isDirtyBox) {
	                        this.redraw();
	                    }
	                }
	            },

	            /**
	             * Internal function to get the chart width and height according to options
	             * and container size. Sets {@link Chart.chartWidth} and {@link
	             * Chart.chartHeight}.
	             */
	            getChartSize: function() {
	                var chart = this,
	                    optionsChart = chart.options.chart,
	                    widthOption = optionsChart.width,
	                    heightOption = optionsChart.height,
	                    renderTo = chart.renderTo;

	                // Get inner width and height
	                if (!defined(widthOption)) {
	                    chart.containerWidth = getStyle(renderTo, 'width');
	                }
	                if (!defined(heightOption)) {
	                    chart.containerHeight = getStyle(renderTo, 'height');
	                }

	                /**
	                 * The current pixel width of the chart.
	                 *
	                 * @name chartWidth
	                 * @memberOf Chart
	                 * @type {Number}
	                 */
	                chart.chartWidth = Math.max( // #1393
	                    0,
	                    widthOption || chart.containerWidth || 600 // #1460
	                );
	                /**
	                 * The current pixel height of the chart.
	                 *
	                 * @name chartHeight
	                 * @memberOf Chart
	                 * @type {Number}
	                 */
	                chart.chartHeight = Math.max(
	                    0,
	                    H.relativeLength(
	                        heightOption,
	                        chart.chartWidth
	                    ) || chart.containerHeight || 400
	                );
	            },

	            /**
	             * If the renderTo element has no offsetWidth, most likely one or more of
	             * its parents are hidden. Loop up the DOM tree to temporarily display the
	             * parents, then save the original display properties, and when the true
	             * size is retrieved, reset them. Used on first render and on redraws.
	             *
	             * @private
	             * 
	             * @param  {Boolean} revert
	             *         Revert to the saved original styles.
	             */
	            temporaryDisplay: function(revert) {
	                var node = this.renderTo,
	                    tempStyle;
	                if (!revert) {
	                    while (node && node.style) {

	                        // When rendering to a detached node, it needs to be temporarily
	                        // attached in order to read styling and bounding boxes (#5783).
	                        if (!doc.body.contains(node)) {
	                            node.hcOrigDetached = true;
	                            doc.body.appendChild(node);
	                        }
	                        if (
	                            getStyle(node, 'display', false) === 'none' ||
	                            node.hcOricDetached
	                        ) {
	                            node.hcOrigStyle = {
	                                display: node.style.display,
	                                height: node.style.height,
	                                overflow: node.style.overflow
	                            };
	                            tempStyle = {
	                                display: 'block',
	                                overflow: 'hidden'
	                            };
	                            if (node !== this.renderTo) {
	                                tempStyle.height = 0;
	                            }

	                            H.css(node, tempStyle);

	                            // If it still doesn't have an offset width after setting
	                            // display to block, it probably has an !important priority
	                            // #2631, 6803
	                            if (!node.offsetWidth) {
	                                node.style.setProperty('display', 'block', 'important');
	                            }
	                        }
	                        node = node.parentNode;

	                        if (node === doc.body) {
	                            break;
	                        }
	                    }
	                } else {
	                    while (node && node.style) {
	                        if (node.hcOrigStyle) {
	                            H.css(node, node.hcOrigStyle);
	                            delete node.hcOrigStyle;
	                        }
	                        if (node.hcOrigDetached) {
	                            doc.body.removeChild(node);
	                            node.hcOrigDetached = false;
	                        }
	                        node = node.parentNode;
	                    }
	                }
	            },

	            /**
	             * Set the {@link Chart.container|chart container's} class name, in
	             * addition to `highcharts-container`. 
	             */
	            setClassName: function(className) {
	                this.container.className = 'highcharts-container ' + (className || '');
	            },

	            /**
	             * Get the containing element, determine the size and create the inner
	             * container div to hold the chart.
	             *
	             * @private
	             */
	            getContainer: function() {
	                var chart = this,
	                    container,
	                    options = chart.options,
	                    optionsChart = options.chart,
	                    chartWidth,
	                    chartHeight,
	                    renderTo = chart.renderTo,
	                    indexAttrName = 'data-highcharts-chart',
	                    oldChartIndex,
	                    Ren,
	                    containerId = H.uniqueKey(),
	                    containerStyle,
	                    key;

	                if (!renderTo) {
	                    chart.renderTo = renderTo = optionsChart.renderTo;
	                }

	                if (isString(renderTo)) {
	                    chart.renderTo = renderTo = doc.getElementById(renderTo);
	                }

	                // Display an error if the renderTo is wrong
	                if (!renderTo) {
	                    H.error(13, true);
	                }

	                // If the container already holds a chart, destroy it. The check for
	                // hasRendered is there because web pages that are saved to disk from
	                // the browser, will preserve the data-highcharts-chart attribute and
	                // the SVG contents, but not an interactive chart. So in this case,
	                // charts[oldChartIndex] will point to the wrong chart if any (#2609).
	                oldChartIndex = pInt(attr(renderTo, indexAttrName));
	                if (
	                    isNumber(oldChartIndex) &&
	                    charts[oldChartIndex] &&
	                    charts[oldChartIndex].hasRendered
	                ) {
	                    charts[oldChartIndex].destroy();
	                }

	                // Make a reference to the chart from the div
	                attr(renderTo, indexAttrName, chart.index);

	                // remove previous chart
	                renderTo.innerHTML = '';

	                // If the container doesn't have an offsetWidth, it has or is a child of
	                // a node that has display:none. We need to temporarily move it out to a
	                // visible state to determine the size, else the legend and tooltips
	                // won't render properly. The skipClone option is used in sparklines as
	                // a micro optimization, saving about 1-2 ms each chart.
	                if (!optionsChart.skipClone && !renderTo.offsetWidth) {
	                    chart.temporaryDisplay();
	                }

	                // get the width and height
	                chart.getChartSize();
	                chartWidth = chart.chartWidth;
	                chartHeight = chart.chartHeight;

	                // Create the inner container

	                containerStyle = extend({
	                    position: 'relative',
	                    overflow: 'hidden', // needed for context menu (avoid scrollbars)
	                    // and content overflow in IE
	                    width: chartWidth + 'px',
	                    height: chartHeight + 'px',
	                    textAlign: 'left',
	                    lineHeight: 'normal', // #427
	                    zIndex: 0, // #1072
	                    '-webkit-tap-highlight-color': 'rgba(0,0,0,0)'
	                }, optionsChart.style);


	                /**
	                 * The containing HTML element of the chart. The container is
	                 * dynamically inserted into the element given as the `renderTo`
	                 * parameterin the {@link Highcharts#chart} constructor.
	                 *
	                 * @memberOf Highcharts.Chart
	                 * @type {HTMLDOMElement}
	                 */
	                container = createElement(
	                    'div', {
	                        id: containerId
	                    },
	                    containerStyle,
	                    renderTo
	                );
	                chart.container = container;

	                // cache the cursor (#1650)
	                chart._cursor = container.style.cursor;

	                // Initialize the renderer
	                Ren = H[optionsChart.renderer] || Renderer;
	                /**
	                 * The renderer instance of the chart. Each chart instance has only one
	                 * associated renderer.
	                 * @type {SVGRenderer}
	                 * @name renderer
	                 * @memberOf Chart
	                 */
	                chart.renderer = new Ren(
	                    container,
	                    chartWidth,
	                    chartHeight,
	                    null,
	                    optionsChart.forExport,
	                    options.exporting && options.exporting.allowHTML
	                );


	                chart.setClassName(optionsChart.className);

	                chart.renderer.setStyle(optionsChart.style);


	                // Add a reference to the charts index
	                chart.renderer.chartIndex = chart.index;
	            },

	            /**
	             * Calculate margins by rendering axis labels in a preliminary position.
	             * Title, subtitle and legend have already been rendered at this stage, but
	             * will be moved into their final positions.
	             *
	             * @private
	             */
	            getMargins: function(skipAxes) {
	                var chart = this,
	                    spacing = chart.spacing,
	                    margin = chart.margin,
	                    titleOffset = chart.titleOffset;

	                chart.resetMargins();

	                // Adjust for title and subtitle
	                if (titleOffset && !defined(margin[0])) {
	                    chart.plotTop = Math.max(
	                        chart.plotTop,
	                        titleOffset + chart.options.title.margin + spacing[0]
	                    );
	                }

	                // Adjust for legend
	                if (chart.legend.display) {
	                    chart.legend.adjustMargins(margin, spacing);
	                }

	                // adjust for scroller
	                if (chart.extraMargin) {
	                    chart[chart.extraMargin.type] =
	                        (chart[chart.extraMargin.type] || 0) + chart.extraMargin.value;
	                }
	                if (chart.extraTopMargin) {
	                    chart.plotTop += chart.extraTopMargin;
	                }
	                if (!skipAxes) {
	                    this.getAxisMargins();
	                }
	            },

	            getAxisMargins: function() {

	                var chart = this,
	                    // [top, right, bottom, left]
	                    axisOffset = chart.axisOffset = [0, 0, 0, 0],
	                    margin = chart.margin;

	                // pre-render axes to get labels offset width
	                if (chart.hasCartesianSeries) {
	                    each(chart.axes, function(axis) {
	                        if (axis.visible) {
	                            axis.getOffset();
	                        }
	                    });
	                }

	                // Add the axis offsets
	                each(marginNames, function(m, side) {
	                    if (!defined(margin[side])) {
	                        chart[m] += axisOffset[side];
	                    }
	                });

	                chart.setChartSize();

	            },

	            /**
	             * Reflows the chart to its container. By default, the chart reflows
	             * automatically to its container following a `window.resize` event, as per
	             * the {@link https://api.highcharts/highcharts/chart.reflow|chart.reflow}
	             * option. However, there are no reliable events for div resize, so if the
	             * container is resized without a window resize event, this must be called
	             * explicitly.
	             *
	             * @param  {Object} e
	             *         Event arguments. Used primarily when the function is called
	             *         internally as a response to window resize.
	             *
	             * @sample highcharts/members/chart-reflow/
	             *         Resize div and reflow
	             * @sample highcharts/chart/events-container/
	             *         Pop up and reflow
	             */
	            reflow: function(e) {
	                var chart = this,
	                    optionsChart = chart.options.chart,
	                    renderTo = chart.renderTo,
	                    hasUserSize = (
	                        defined(optionsChart.width) &&
	                        defined(optionsChart.height)
	                    ),
	                    width = optionsChart.width || getStyle(renderTo, 'width'),
	                    height = optionsChart.height || getStyle(renderTo, 'height'),
	                    target = e ? e.target : win;

	                // Width and height checks for display:none. Target is doc in IE8 and
	                // Opera, win in Firefox, Chrome and IE9.
	                if (!hasUserSize &&
	                    !chart.isPrinting &&
	                    width &&
	                    height &&
	                    (target === win || target === doc)
	                ) {
	                    if (
	                        width !== chart.containerWidth ||
	                        height !== chart.containerHeight
	                    ) {
	                        clearTimeout(chart.reflowTimeout);
	                        // When called from window.resize, e is set, else it's called
	                        // directly (#2224)
	                        chart.reflowTimeout = syncTimeout(function() {
	                            // Set size, it may have been destroyed in the meantime
	                            // (#1257)
	                            if (chart.container) {
	                                chart.setSize(undefined, undefined, false);
	                            }
	                        }, e ? 100 : 0);
	                    }
	                    chart.containerWidth = width;
	                    chart.containerHeight = height;
	                }
	            },

	            /**
	             * Add the event handlers necessary for auto resizing, depending on the 
	             * `chart.events.reflow` option.
	             *
	             * @private
	             */
	            initReflow: function() {
	                var chart = this,
	                    unbind;

	                unbind = addEvent(win, 'resize', function(e) {
	                    chart.reflow(e);
	                });
	                addEvent(chart, 'destroy', unbind);

	                // The following will add listeners to re-fit the chart before and after
	                // printing (#2284). However it only works in WebKit. Should have worked
	                // in Firefox, but not supported in IE.
	                /*
	                if (win.matchMedia) {
	                    win.matchMedia('print').addListener(function reflow() {
	                        chart.reflow();
	                    });
	                }
	                */
	            },

	            /**
	             * Resize the chart to a given width and height. In order to set the width
	             * only, the height argument may be skipped. To set the height only, pass
	             * `undefined for the width.
	             * @param  {Number|undefined|null} [width]
	             *         The new pixel width of the chart. Since v4.2.6, the argument can
	             *         be `undefined` in order to preserve the current value (when
	             *         setting height only), or `null` to adapt to the width of the
	             *         containing element.
	             * @param  {Number|undefined|null} [height]
	             *         The new pixel height of the chart. Since v4.2.6, the argument can
	             *         be `undefined` in order to preserve the current value, or `null`
	             *         in order to adapt to the height of the containing element.
	             * @param  {AnimationOptions} [animation=true]
	             *         Whether and how to apply animation.
	             *
	             * @sample highcharts/members/chart-setsize-button/
	             *         Test resizing from buttons
	             * @sample highcharts/members/chart-setsize-jquery-resizable/
	             *         Add a jQuery UI resizable
	             * @sample stock/members/chart-setsize/
	             *         Highstock with UI resizable
	             */
	            setSize: function(width, height, animation) {
	                var chart = this,
	                    renderer = chart.renderer,
	                    globalAnimation;

	                // Handle the isResizing counter
	                chart.isResizing += 1;

	                // set the animation for the current process
	                H.setAnimation(animation, chart);

	                chart.oldChartHeight = chart.chartHeight;
	                chart.oldChartWidth = chart.chartWidth;
	                if (width !== undefined) {
	                    chart.options.chart.width = width;
	                }
	                if (height !== undefined) {
	                    chart.options.chart.height = height;
	                }
	                chart.getChartSize();

	                // Resize the container with the global animation applied if enabled
	                // (#2503)

	                globalAnimation = renderer.globalAnimation;
	                (globalAnimation ? animate : css)(chart.container, {
	                    width: chart.chartWidth + 'px',
	                    height: chart.chartHeight + 'px'
	                }, globalAnimation);


	                chart.setChartSize(true);
	                renderer.setSize(chart.chartWidth, chart.chartHeight, animation);

	                // handle axes
	                each(chart.axes, function(axis) {
	                    axis.isDirty = true;
	                    axis.setScale();
	                });

	                chart.isDirtyLegend = true; // force legend redraw
	                chart.isDirtyBox = true; // force redraw of plot and chart border

	                chart.layOutTitles(); // #2857
	                chart.getMargins();

	                chart.redraw(animation);


	                chart.oldChartHeight = null;
	                fireEvent(chart, 'resize');

	                // Fire endResize and set isResizing back. If animation is disabled,
	                // fire without delay
	                syncTimeout(function() {
	                    if (chart) {
	                        fireEvent(chart, 'endResize', null, function() {
	                            chart.isResizing -= 1;
	                        });
	                    }
	                }, animObject(globalAnimation).duration);
	            },

	            /**
	             * Set the public chart properties. This is done before and after the
	             * pre-render to determine margin sizes.
	             *
	             * @private
	             */
	            setChartSize: function(skipAxes) {
	                var chart = this,
	                    inverted = chart.inverted,
	                    renderer = chart.renderer,
	                    chartWidth = chart.chartWidth,
	                    chartHeight = chart.chartHeight,
	                    optionsChart = chart.options.chart,
	                    spacing = chart.spacing,
	                    clipOffset = chart.clipOffset,
	                    clipX,
	                    clipY,
	                    plotLeft,
	                    plotTop,
	                    plotWidth,
	                    plotHeight,
	                    plotBorderWidth;

	                function clipOffsetSide(side) {
	                    var offset = clipOffset[side] || 0;
	                    return Math.max(plotBorderWidth || offset, offset) / 2;
	                }

	                /**
	                 * The current left position of the plot area in pixels.
	                 *
	                 * @name plotLeft
	                 * @memberOf Chart
	                 * @type {Number}
	                 */
	                chart.plotLeft = plotLeft = Math.round(chart.plotLeft);

	                /**
	                 * The current top position of the plot area in pixels.
	                 *
	                 * @name plotTop
	                 * @memberOf Chart
	                 * @type {Number}
	                 */
	                chart.plotTop = plotTop = Math.round(chart.plotTop);

	                /**
	                 * The current width of the plot area in pixels.
	                 *
	                 * @name plotWidth
	                 * @memberOf Chart
	                 * @type {Number}
	                 */
	                chart.plotWidth = plotWidth = Math.max(
	                    0,
	                    Math.round(chartWidth - plotLeft - chart.marginRight)
	                );

	                /**
	                 * The current height of the plot area in pixels.
	                 *
	                 * @name plotHeight
	                 * @memberOf Chart
	                 * @type {Number}
	                 */
	                chart.plotHeight = plotHeight = Math.max(
	                    0,
	                    Math.round(chartHeight - plotTop - chart.marginBottom)
	                );

	                chart.plotSizeX = inverted ? plotHeight : plotWidth;
	                chart.plotSizeY = inverted ? plotWidth : plotHeight;

	                chart.plotBorderWidth = optionsChart.plotBorderWidth || 0;

	                // Set boxes used for alignment
	                chart.spacingBox = renderer.spacingBox = {
	                    x: spacing[3],
	                    y: spacing[0],
	                    width: chartWidth - spacing[3] - spacing[1],
	                    height: chartHeight - spacing[0] - spacing[2]
	                };
	                chart.plotBox = renderer.plotBox = {
	                    x: plotLeft,
	                    y: plotTop,
	                    width: plotWidth,
	                    height: plotHeight
	                };

	                plotBorderWidth = 2 * Math.floor(chart.plotBorderWidth / 2);
	                clipX = Math.ceil(clipOffsetSide(3));
	                clipY = Math.ceil(clipOffsetSide(0));
	                chart.clipBox = {
	                    x: clipX,
	                    y: clipY,
	                    width: Math.floor(
	                        chart.plotSizeX -
	                        clipOffsetSide(1) -
	                        clipX
	                    ),
	                    height: Math.max(
	                        0,
	                        Math.floor(
	                            chart.plotSizeY -
	                            clipOffsetSide(2) -
	                            clipY
	                        )
	                    )
	                };

	                if (!skipAxes) {
	                    each(chart.axes, function(axis) {
	                        axis.setAxisSize();
	                        axis.setAxisTranslation();
	                    });
	                }
	            },

	            /**
	             * Initial margins before auto size margins are applied.
	             *
	             * @private
	             */
	            resetMargins: function() {
	                var chart = this,
	                    chartOptions = chart.options.chart;

	                // Create margin and spacing array
	                each(['margin', 'spacing'], function splashArrays(target) {
	                    var value = chartOptions[target],
	                        values = isObject(value) ? value : [value, value, value, value];

	                    each(['Top', 'Right', 'Bottom', 'Left'], function(sideName, side) {
	                        chart[target][side] = pick(
	                            chartOptions[target + sideName],
	                            values[side]
	                        );
	                    });
	                });

	                // Set margin names like chart.plotTop, chart.plotLeft,
	                // chart.marginRight, chart.marginBottom.
	                each(marginNames, function(m, side) {
	                    chart[m] = pick(chart.margin[side], chart.spacing[side]);
	                });
	                chart.axisOffset = [0, 0, 0, 0]; // top, right, bottom, left
	                chart.clipOffset = [];
	            },

	            /**
	             * Internal function to draw or redraw the borders and backgrounds for chart
	             * and plot area.
	             *
	             * @private
	             */
	            drawChartBox: function() {
	                var chart = this,
	                    optionsChart = chart.options.chart,
	                    renderer = chart.renderer,
	                    chartWidth = chart.chartWidth,
	                    chartHeight = chart.chartHeight,
	                    chartBackground = chart.chartBackground,
	                    plotBackground = chart.plotBackground,
	                    plotBorder = chart.plotBorder,
	                    chartBorderWidth,

	                    plotBGImage = chart.plotBGImage,
	                    chartBackgroundColor = optionsChart.backgroundColor,
	                    plotBackgroundColor = optionsChart.plotBackgroundColor,
	                    plotBackgroundImage = optionsChart.plotBackgroundImage,

	                    mgn,
	                    bgAttr,
	                    plotLeft = chart.plotLeft,
	                    plotTop = chart.plotTop,
	                    plotWidth = chart.plotWidth,
	                    plotHeight = chart.plotHeight,
	                    plotBox = chart.plotBox,
	                    clipRect = chart.clipRect,
	                    clipBox = chart.clipBox,
	                    verb = 'animate';

	                // Chart area
	                if (!chartBackground) {
	                    chart.chartBackground = chartBackground = renderer.rect()
	                        .addClass('highcharts-background')
	                        .add();
	                    verb = 'attr';
	                }


	                // Presentational
	                chartBorderWidth = optionsChart.borderWidth || 0;
	                mgn = chartBorderWidth + (optionsChart.shadow ? 8 : 0);

	                bgAttr = {
	                    fill: chartBackgroundColor || 'none'
	                };

	                if (chartBorderWidth || chartBackground['stroke-width']) { // #980
	                    bgAttr.stroke = optionsChart.borderColor;
	                    bgAttr['stroke-width'] = chartBorderWidth;
	                }
	                chartBackground
	                    .attr(bgAttr)
	                    .shadow(optionsChart.shadow);

	                chartBackground[verb]({
	                    x: mgn / 2,
	                    y: mgn / 2,
	                    width: chartWidth - mgn - chartBorderWidth % 2,
	                    height: chartHeight - mgn - chartBorderWidth % 2,
	                    r: optionsChart.borderRadius
	                });

	                // Plot background
	                verb = 'animate';
	                if (!plotBackground) {
	                    verb = 'attr';
	                    chart.plotBackground = plotBackground = renderer.rect()
	                        .addClass('highcharts-plot-background')
	                        .add();
	                }
	                plotBackground[verb](plotBox);


	                // Presentational attributes for the background
	                plotBackground
	                    .attr({
	                        fill: plotBackgroundColor || 'none'
	                    })
	                    .shadow(optionsChart.plotShadow);

	                // Create the background image
	                if (plotBackgroundImage) {
	                    if (!plotBGImage) {
	                        chart.plotBGImage = renderer.image(
	                            plotBackgroundImage,
	                            plotLeft,
	                            plotTop,
	                            plotWidth,
	                            plotHeight
	                        ).add();
	                    } else {
	                        plotBGImage.animate(plotBox);
	                    }
	                }


	                // Plot clip
	                if (!clipRect) {
	                    chart.clipRect = renderer.clipRect(clipBox);
	                } else {
	                    clipRect.animate({
	                        width: clipBox.width,
	                        height: clipBox.height
	                    });
	                }

	                // Plot area border
	                verb = 'animate';
	                if (!plotBorder) {
	                    verb = 'attr';
	                    chart.plotBorder = plotBorder = renderer.rect()
	                        .addClass('highcharts-plot-border')
	                        .attr({
	                            zIndex: 1 // Above the grid
	                        })
	                        .add();
	                }


	                // Presentational
	                plotBorder.attr({
	                    stroke: optionsChart.plotBorderColor,
	                    'stroke-width': optionsChart.plotBorderWidth || 0,
	                    fill: 'none'
	                });


	                plotBorder[verb](plotBorder.crisp({
	                    x: plotLeft,
	                    y: plotTop,
	                    width: plotWidth,
	                    height: plotHeight
	                }, -plotBorder.strokeWidth())); //#3282 plotBorder should be negative;

	                // reset
	                chart.isDirtyBox = false;
	            },

	            /**
	             * Detect whether a certain chart property is needed based on inspecting its
	             * options and series. This mainly applies to the chart.inverted property,
	             * and in extensions to the chart.angular and chart.polar properties.
	             *
	             * @private
	             */
	            propFromSeries: function() {
	                var chart = this,
	                    optionsChart = chart.options.chart,
	                    klass,
	                    seriesOptions = chart.options.series,
	                    i,
	                    value;


	                each(['inverted', 'angular', 'polar'], function(key) {

	                    // The default series type's class
	                    klass = seriesTypes[optionsChart.type ||
	                        optionsChart.defaultSeriesType];

	                    // Get the value from available chart-wide properties
	                    value =
	                        optionsChart[key] || // It is set in the options
	                        (klass && klass.prototype[key]); // The default series class
	                    // requires it

	                    // 4. Check if any the chart's series require it
	                    i = seriesOptions && seriesOptions.length;
	                    while (!value && i--) {
	                        klass = seriesTypes[seriesOptions[i].type];
	                        if (klass && klass.prototype[key]) {
	                            value = true;
	                        }
	                    }

	                    // Set the chart property
	                    chart[key] = value;
	                });

	            },

	            /**
	             * Internal function to link two or more series together, based on the 
	             * `linkedTo` option. This is done from `Chart.render`, and after
	             * `Chart.addSeries` and `Series.remove`.
	             *
	             * @private
	             */
	            linkSeries: function() {
	                var chart = this,
	                    chartSeries = chart.series;

	                // Reset links
	                each(chartSeries, function(series) {
	                    series.linkedSeries.length = 0;
	                });

	                // Apply new links
	                each(chartSeries, function(series) {
	                    var linkedTo = series.options.linkedTo;
	                    if (isString(linkedTo)) {
	                        if (linkedTo === ':previous') {
	                            linkedTo = chart.series[series.index - 1];
	                        } else {
	                            linkedTo = chart.get(linkedTo);
	                        }
	                        // #3341 avoid mutual linking
	                        if (linkedTo && linkedTo.linkedParent !== series) {
	                            linkedTo.linkedSeries.push(series);
	                            series.linkedParent = linkedTo;
	                            series.visible = pick(
	                                series.options.visible,
	                                linkedTo.options.visible,
	                                series.visible
	                            ); // #3879
	                        }
	                    }
	                });
	            },

	            /**
	             * Render series for the chart.
	             *
	             * @private
	             */
	            renderSeries: function() {
	                each(this.series, function(serie) {
	                    serie.translate();
	                    serie.render();
	                });
	            },

	            /**
	             * Render labels for the chart.
	             *
	             * @private
	             */
	            renderLabels: function() {
	                var chart = this,
	                    labels = chart.options.labels;
	                if (labels.items) {
	                    each(labels.items, function(label) {
	                        var style = extend(labels.style, label.style),
	                            x = pInt(style.left) + chart.plotLeft,
	                            y = pInt(style.top) + chart.plotTop + 12;

	                        // delete to prevent rewriting in IE
	                        delete style.left;
	                        delete style.top;

	                        chart.renderer.text(
	                                label.html,
	                                x,
	                                y
	                            )
	                            .attr({
	                                zIndex: 2
	                            })
	                            .css(style)
	                            .add();

	                    });
	                }
	            },

	            /**
	             * Render all graphics for the chart. Runs internally on initialization.
	             *
	             * @private
	             */
	            render: function() {
	                var chart = this,
	                    axes = chart.axes,
	                    renderer = chart.renderer,
	                    options = chart.options,
	                    tempWidth,
	                    tempHeight,
	                    redoHorizontal,
	                    redoVertical;

	                // Title
	                chart.setTitle();


	                // Legend
	                chart.legend = new Legend(chart, options.legend);

	                // Get stacks
	                if (chart.getStacks) {
	                    chart.getStacks();
	                }

	                // Get chart margins
	                chart.getMargins(true);
	                chart.setChartSize();

	                // Record preliminary dimensions for later comparison
	                tempWidth = chart.plotWidth;
	                tempHeight = chart.plotHeight = chart.plotHeight - 21; // 21 is the most common correction for X axis labels

	                // Get margins by pre-rendering axes
	                each(axes, function(axis) {
	                    axis.setScale();
	                });
	                chart.getAxisMargins();

	                // If the plot area size has changed significantly, calculate tick positions again
	                redoHorizontal = tempWidth / chart.plotWidth > 1.1;
	                redoVertical = tempHeight / chart.plotHeight > 1.05; // Height is more sensitive

	                if (redoHorizontal || redoVertical) {

	                    each(axes, function(axis) {
	                        if ((axis.horiz && redoHorizontal) || (!axis.horiz && redoVertical)) {
	                            axis.setTickInterval(true); // update to reflect the new margins
	                        }
	                    });
	                    chart.getMargins(); // second pass to check for new labels
	                }

	                // Draw the borders and backgrounds
	                chart.drawChartBox();


	                // Axes
	                if (chart.hasCartesianSeries) {
	                    each(axes, function(axis) {
	                        if (axis.visible) {
	                            axis.render();
	                        }
	                    });
	                }

	                // The series
	                if (!chart.seriesGroup) {
	                    chart.seriesGroup = renderer.g('series-group')
	                        .attr({
	                            zIndex: 3
	                        })
	                        .add();
	                }
	                chart.renderSeries();

	                // Labels
	                chart.renderLabels();

	                // Credits
	                chart.addCredits();

	                // Handle responsiveness
	                if (chart.setResponsive) {
	                    chart.setResponsive();
	                }

	                // Set flag
	                chart.hasRendered = true;

	            },

	            /**
	             * Set a new credits label for the chart.
	             *
	             * @param  {CreditOptions} options
	             *         A configuration object for the new credits.
	             * @sample highcharts/credits/credits-update/ Add and update credits
	             */
	            addCredits: function(credits) {
	                var chart = this;

	                credits = merge(true, this.options.credits, credits);
	                if (credits.enabled && !this.credits) {

	                    /**
	                     * The chart's credits label. The label has an `update` method that
	                     * allows setting new options as per the {@link
	                     * https://api.highcharts.com/highcharts/credits|
	                     * credits options set}.
	                     *
	                     * @memberof Highcharts.Chart
	                     * @name credits
	                     * @type {Highcharts.SVGElement}
	                     */
	                    this.credits = this.renderer.text(
	                            credits.text + (this.mapCredits || ''),
	                            0,
	                            0
	                        )
	                        .addClass('highcharts-credits')
	                        .on('click', function() {
	                            if (credits.href) {
	                                win.location.href = credits.href;
	                            }
	                        })
	                        .attr({
	                            align: credits.position.align,
	                            zIndex: 8
	                        })

	                        .css(credits.style)

	                        .add()
	                        .align(credits.position);

	                    // Dynamically update
	                    this.credits.update = function(options) {
	                        chart.credits = chart.credits.destroy();
	                        chart.addCredits(options);
	                    };
	                }
	            },

	            /**
	             * Remove the chart and purge memory. This method is called internally
	             * before adding a second chart into the same container, as well as on
	             * window unload to prevent leaks.
	             *
	             * @sample highcharts/members/chart-destroy/
	             *         Destroy the chart from a button
	             * @sample stock/members/chart-destroy/
	             *         Destroy with Highstock
	             */
	            destroy: function() {
	                var chart = this,
	                    axes = chart.axes,
	                    series = chart.series,
	                    container = chart.container,
	                    i,
	                    parentNode = container && container.parentNode;

	                // fire the chart.destoy event
	                fireEvent(chart, 'destroy');

	                // Delete the chart from charts lookup array
	                if (chart.renderer.forExport) {
	                    H.erase(charts, chart); // #6569
	                } else {
	                    charts[chart.index] = undefined;
	                }
	                H.chartCount--;
	                chart.renderTo.removeAttribute('data-highcharts-chart');

	                // remove events
	                removeEvent(chart);

	                // ==== Destroy collections:
	                // Destroy axes
	                i = axes.length;
	                while (i--) {
	                    axes[i] = axes[i].destroy();
	                }

	                // Destroy scroller & scroller series before destroying base series
	                if (this.scroller && this.scroller.destroy) {
	                    this.scroller.destroy();
	                }

	                // Destroy each series
	                i = series.length;
	                while (i--) {
	                    series[i] = series[i].destroy();
	                }

	                // ==== Destroy chart properties:
	                each([
	                    'title', 'subtitle', 'chartBackground', 'plotBackground',
	                    'plotBGImage', 'plotBorder', 'seriesGroup', 'clipRect', 'credits',
	                    'pointer', 'rangeSelector', 'legend', 'resetZoomButton', 'tooltip',
	                    'renderer'
	                ], function(name) {
	                    var prop = chart[name];

	                    if (prop && prop.destroy) {
	                        chart[name] = prop.destroy();
	                    }
	                });

	                // remove container and all SVG
	                if (container) { // can break in IE when destroyed before finished loading
	                    container.innerHTML = '';
	                    removeEvent(container);
	                    if (parentNode) {
	                        discardElement(container);
	                    }

	                }

	                // clean it all up
	                objectEach(chart, function(val, key) {
	                    delete chart[key];
	                });

	            },


	            /**
	             * VML namespaces can't be added until after complete. Listening
	             * for Perini's doScroll hack is not enough.
	             *
	             * @private
	             */
	            isReadyToRender: function() {
	                var chart = this;

	                // Note: win == win.top is required
	                if ((!svg && (win == win.top && doc.readyState !== 'complete'))) { // eslint-disable-line eqeqeq
	                    doc.attachEvent('onreadystatechange', function() {
	                        doc.detachEvent('onreadystatechange', chart.firstRender);
	                        if (doc.readyState === 'complete') {
	                            chart.firstRender();
	                        }
	                    });
	                    return false;
	                }
	                return true;
	            },

	            /**
	             * Prepare for first rendering after all data are loaded.
	             *
	             * @private
	             */
	            firstRender: function() {
	                var chart = this,
	                    options = chart.options;

	                // Check whether the chart is ready to render
	                if (!chart.isReadyToRender()) {
	                    return;
	                }

	                // Create the container
	                chart.getContainer();

	                // Run an early event after the container and renderer are established
	                fireEvent(chart, 'init');


	                chart.resetMargins();
	                chart.setChartSize();

	                // Set the common chart properties (mainly invert) from the given series
	                chart.propFromSeries();

	                // get axes
	                chart.getAxes();

	                // Initialize the series
	                each(options.series || [], function(serieOptions) {
	                    chart.initSeries(serieOptions);
	                });

	                chart.linkSeries();

	                // Run an event after axes and series are initialized, but before render. At this stage,
	                // the series data is indexed and cached in the xData and yData arrays, so we can access
	                // those before rendering. Used in Highstock.
	                fireEvent(chart, 'beforeRender');

	                // depends on inverted and on margins being set
	                if (Pointer) {

	                    /**
	                     * The Pointer that keeps track of mouse and touch interaction.
	                     *
	                     * @memberof Chart
	                     * @name pointer
	                     * @type Pointer
	                     */
	                    chart.pointer = new Pointer(chart, options);
	                }

	                chart.render();

	                // Fire the load event if there are no external images
	                if (!chart.renderer.imgCount && chart.onload) {
	                    chart.onload();
	                }

	                // If the chart was rendered outside the top container, put it back in (#3679)
	                chart.temporaryDisplay(true);

	            },

	            /** 
	             * Internal function that runs on chart load, async if any images are loaded
	             * in the chart. Runs the callbacks and triggers the `load` and `render`
	             * events.
	             *
	             * @private
	             */
	            onload: function() {

	                // Run callbacks
	                each([this.callback].concat(this.callbacks), function(fn) {
	                    if (fn && this.index !== undefined) { // Chart destroyed in its own callback (#3600)
	                        fn.apply(this, [this]);
	                    }
	                }, this);

	                fireEvent(this, 'load');
	                fireEvent(this, 'render');


	                // Set up auto resize, check for not destroyed (#6068)
	                if (defined(this.index) && this.options.chart.reflow !== false) {
	                    this.initReflow();
	                }

	                // Don't run again
	                this.onload = null;
	            }

	        }); // end Chart

	    }(Highcharts));
	    (function(Highcharts) {
	        /**
	         * (c) 2010-2017 Torstein Honsi
	         *
	         * License: www.highcharts.com/license
	         */
	        var Point,
	            H = Highcharts,

	            each = H.each,
	            extend = H.extend,
	            erase = H.erase,
	            fireEvent = H.fireEvent,
	            format = H.format,
	            isArray = H.isArray,
	            isNumber = H.isNumber,
	            pick = H.pick,
	            removeEvent = H.removeEvent;

	        /**
	         * The Point object. The point objects are generated from the `series.data` 
	         * configuration objects or raw numbers. They can be accessed from the
	         * `Series.points` array. Other ways to instaniate points are through {@link
	         * Highcharts.Series#addPoint} or {@link Highcharts.Series#setData}.
	         *
	         * @class
	         */

	        Highcharts.Point = Point = function() {};
	        Highcharts.Point.prototype = {

	            /**
	             * Initialize the point. Called internally based on the `series.data`
	             * option.
	             * @param  {Series} series
	             *         The series object containing this point.
	             * @param  {Number|Array|Object} options
	             *         The data in either number, array or object format.
	             * @param  {Number} x Optionally, the X value of the point.
	             * @return {Point} The Point instance.
	             */
	            init: function(series, options, x) {

	                var point = this,
	                    colors,
	                    colorCount = series.chart.options.chart.colorCount,
	                    colorIndex;

	                /**
	                 * The series object associated with the point.
	                 *
	                 * @name series
	                 * @memberof Highcharts.Point
	                 * @type Highcharts.Series
	                 */
	                point.series = series;


	                /**
	                 * The point's current color.
	                 * @name color
	                 * @memberof Highcharts.Point
	                 * @type {Color}
	                 */
	                point.color = series.color; // #3445

	                point.applyOptions(options, x);

	                if (series.options.colorByPoint) {

	                    colors = series.options.colors || series.chart.options.colors;
	                    point.color = point.color || colors[series.colorCounter];
	                    colorCount = colors.length;

	                    colorIndex = series.colorCounter;
	                    series.colorCounter++;
	                    // loop back to zero
	                    if (series.colorCounter === colorCount) {
	                        series.colorCounter = 0;
	                    }
	                } else {
	                    colorIndex = series.colorIndex;
	                }
	                point.colorIndex = pick(point.colorIndex, colorIndex);

	                series.chart.pointCount++;
	                return point;
	            },
	            /**
	             * Apply the options containing the x and y data and possible some extra
	             * properties. Called on point init or from point.update.
	             *
	             * @private
	             * @param {Object} options The point options as defined in series.data.
	             * @param {Number} x Optionally, the X value.
	             * @returns {Object} The Point instance.
	             */
	            applyOptions: function(options, x) {
	                var point = this,
	                    series = point.series,
	                    pointValKey = series.options.pointValKey || series.pointValKey;

	                options = Point.prototype.optionsToObject.call(this, options);

	                // copy options directly to point
	                extend(point, options);
	                point.options = point.options ? extend(point.options, options) : options;

	                // Since options are copied into the Point instance, some accidental options must be shielded (#5681)
	                if (options.group) {
	                    delete point.group;
	                }

	                // For higher dimension series types. For instance, for ranges, point.y is mapped to point.low.
	                if (pointValKey) {
	                    point.y = point[pointValKey];
	                }
	                point.isNull = pick(
	                    point.isValid && !point.isValid(),
	                    point.x === null || !isNumber(point.y, true)
	                ); // #3571, check for NaN

	                // The point is initially selected by options (#5777)
	                if (point.selected) {
	                    point.state = 'select';
	                }

	                // If no x is set by now, get auto incremented value. All points must have an
	                // x value, however the y value can be null to create a gap in the series
	                if ('name' in point && x === undefined && series.xAxis && series.xAxis.hasNames) {
	                    point.x = series.xAxis.nameToX(point);
	                }
	                if (point.x === undefined && series) {
	                    if (x === undefined) {
	                        point.x = series.autoIncrement(point);
	                    } else {
	                        point.x = x;
	                    }
	                }

	                return point;
	            },

	            /**
	             * Transform number or array configs into objects. Used internally to unify
	             * the different configuration formats for points. For example, a simple
	             * number `10` in a line series will be transformed to `{ y: 10 }`, and an
	             * array config like `[1, 10]` in a scatter series will be transformed to
	             * `{ x: 1, y: 10 }`.
	             *
	             * @param  {Number|Array|Object} options
	             *         The input options
	             * @return {Object} Transformed options.
	             */
	            optionsToObject: function(options) {
	                var ret = {},
	                    series = this.series,
	                    keys = series.options.keys,
	                    pointArrayMap = keys || series.pointArrayMap || ['y'],
	                    valueCount = pointArrayMap.length,
	                    firstItemType,
	                    i = 0,
	                    j = 0;

	                if (isNumber(options) || options === null) {
	                    ret[pointArrayMap[0]] = options;

	                } else if (isArray(options)) {
	                    // with leading x value
	                    if (!keys && options.length > valueCount) {
	                        firstItemType = typeof options[0];
	                        if (firstItemType === 'string') {
	                            ret.name = options[0];
	                        } else if (firstItemType === 'number') {
	                            ret.x = options[0];
	                        }
	                        i++;
	                    }
	                    while (j < valueCount) {
	                        if (!keys || options[i] !== undefined) { // Skip undefined positions for keys
	                            ret[pointArrayMap[j]] = options[i];
	                        }
	                        i++;
	                        j++;
	                    }
	                } else if (typeof options === 'object') {
	                    ret = options;

	                    // This is the fastest way to detect if there are individual point dataLabels that need
	                    // to be considered in drawDataLabels. These can only occur in object configs.
	                    if (options.dataLabels) {
	                        series._hasPointLabels = true;
	                    }

	                    // Same approach as above for markers
	                    if (options.marker) {
	                        series._hasPointMarkers = true;
	                    }
	                }
	                return ret;
	            },

	            /**
	             * Get the CSS class names for individual points. Used internally where the
	             * returned value is set on every point.
	             * 
	             * @returns {String} The class names.
	             */
	            getClassName: function() {
	                return 'highcharts-point' +
	                    (this.selected ? ' highcharts-point-select' : '') +
	                    (this.negative ? ' highcharts-negative' : '') +
	                    (this.isNull ? ' highcharts-null-point' : '') +
	                    (this.colorIndex !== undefined ? ' highcharts-color-' +
	                        this.colorIndex : '') +
	                    (this.options.className ? ' ' + this.options.className : '') +
	                    (this.zone && this.zone.className ? ' ' +
	                        this.zone.className.replace('highcharts-negative', '') : '');
	            },

	            /**
	             * In a series with `zones`, return the zone that the point belongs to.
	             *
	             * @return {Object}
	             *         The zone item.
	             */
	            getZone: function() {
	                var series = this.series,
	                    zones = series.zones,
	                    zoneAxis = series.zoneAxis || 'y',
	                    i = 0,
	                    zone;

	                zone = zones[i];
	                while (this[zoneAxis] >= zone.value) {
	                    zone = zones[++i];
	                }

	                if (zone && zone.color && !this.options.color) {
	                    this.color = zone.color;
	                }

	                return zone;
	            },

	            /**
	             * Destroy a point to clear memory. Its reference still stays in
	             * `series.data`.
	             *
	             * @private
	             */
	            destroy: function() {
	                var point = this,
	                    series = point.series,
	                    chart = series.chart,
	                    hoverPoints = chart.hoverPoints,
	                    prop;

	                chart.pointCount--;

	                if (hoverPoints) {
	                    point.setState();
	                    erase(hoverPoints, point);
	                    if (!hoverPoints.length) {
	                        chart.hoverPoints = null;
	                    }

	                }
	                if (point === chart.hoverPoint) {
	                    point.onMouseOut();
	                }

	                // remove all events
	                if (point.graphic || point.dataLabel) { // removeEvent and destroyElements are performance expensive
	                    removeEvent(point);
	                    point.destroyElements();
	                }

	                if (point.legendItem) { // pies have legend items
	                    chart.legend.destroyItem(point);
	                }

	                for (prop in point) {
	                    point[prop] = null;
	                }


	            },

	            /**
	             * Destroy SVG elements associated with the point.
	             *
	             * @private
	             */
	            destroyElements: function() {
	                var point = this,
	                    props = ['graphic', 'dataLabel', 'dataLabelUpper', 'connector', 'shadowGroup'],
	                    prop,
	                    i = 6;
	                while (i--) {
	                    prop = props[i];
	                    if (point[prop]) {
	                        point[prop] = point[prop].destroy();
	                    }
	                }
	            },

	            /**
	             * Return the configuration hash needed for the data label and tooltip
	             * formatters.
	             *
	             * @returns {Object}
	             *          Abstract object used in formatters and formats.
	             */
	            getLabelConfig: function() {
	                return {
	                    x: this.category,
	                    y: this.y,
	                    color: this.color,
	                    colorIndex: this.colorIndex,
	                    key: this.name || this.category,
	                    series: this.series,
	                    point: this,
	                    percentage: this.percentage,
	                    total: this.total || this.stackTotal
	                };
	            },

	            /**
	             * Extendable method for formatting each point's tooltip line.
	             *
	             * @param  {String} pointFormat
	             *         The point format.
	             * @return {String}
	             *         A string to be concatenated in to the common tooltip text.
	             */
	            tooltipFormatter: function(pointFormat) {

	                // Insert options for valueDecimals, valuePrefix, and valueSuffix
	                var series = this.series,
	                    seriesTooltipOptions = series.tooltipOptions,
	                    valueDecimals = pick(seriesTooltipOptions.valueDecimals, ''),
	                    valuePrefix = seriesTooltipOptions.valuePrefix || '',
	                    valueSuffix = seriesTooltipOptions.valueSuffix || '';

	                // Loop over the point array map and replace unformatted values with sprintf formatting markup
	                each(series.pointArrayMap || ['y'], function(key) {
	                    key = '{point.' + key; // without the closing bracket
	                    if (valuePrefix || valueSuffix) {
	                        pointFormat = pointFormat.replace(key + '}', valuePrefix + key + '}' + valueSuffix);
	                    }
	                    pointFormat = pointFormat.replace(key + '}', key + ':,.' + valueDecimals + 'f}');
	                });

	                return format(pointFormat, {
	                    point: this,
	                    series: this.series
	                });
	            },

	            /**
	             * Fire an event on the Point object.
	             *
	             * @private
	             * @param {String} eventType
	             * @param {Object} eventArgs Additional event arguments
	             * @param {Function} defaultFunction Default event handler
	             */
	            firePointEvent: function(eventType, eventArgs, defaultFunction) {
	                var point = this,
	                    series = this.series,
	                    seriesOptions = series.options;

	                // load event handlers on demand to save time on mouseover/out
	                if (seriesOptions.point.events[eventType] || (point.options && point.options.events && point.options.events[eventType])) {
	                    this.importEvents();
	                }

	                // add default handler if in selection mode
	                if (eventType === 'click' && seriesOptions.allowPointSelect) {
	                    defaultFunction = function(event) {
	                        // Control key is for Windows, meta (= Cmd key) for Mac, Shift for Opera
	                        if (point.select) { // Could be destroyed by prior event handlers (#2911)
	                            point.select(null, event.ctrlKey || event.metaKey || event.shiftKey);
	                        }
	                    };
	                }

	                fireEvent(this, eventType, eventArgs, defaultFunction);
	            },

	            /**
	             * For certain series types, like pie charts, where individual points can
	             * be shown or hidden. 
	             *
	             * @name visible
	             * @memberOf Highcharts.Point
	             * @type {Boolean}
	             */
	            visible: true
	        };

	        /**
	         * For categorized axes this property holds the category name for the 
	         * point. For other axes it holds the X value.
	         *
	         * @name category
	         * @memberOf Highcharts.Point
	         * @type {String|Number}
	         */

	        /**
	         * The percentage for points in a stacked series or pies.
	         *
	         * @name percentage
	         * @memberOf Highcharts.Point
	         * @type {Number}
	         */

	        /**
	         * The total of values in either a stack for stacked series, or a pie in a pie
	         * series.
	         *
	         * @name total
	         * @memberOf Highcharts.Point
	         * @type {Number}
	         */

	        /**
	         * The x value of the point.
	         *
	         * @name x
	         * @memberOf Highcharts.Point
	         * @type {Number}
	         */

	        /**
	         * The y value of the point.
	         *
	         * @name y
	         * @memberOf Highcharts.Point
	         * @type {Number}
	         */

	    }(Highcharts));
	    (function(H) {
	        /**
	         * (c) 2010-2017 Torstein Honsi
	         *
	         * License: www.highcharts.com/license
	         */
	        var addEvent = H.addEvent,
	            animObject = H.animObject,
	            arrayMax = H.arrayMax,
	            arrayMin = H.arrayMin,
	            correctFloat = H.correctFloat,
	            Date = H.Date,
	            defaultOptions = H.defaultOptions,
	            defaultPlotOptions = H.defaultPlotOptions,
	            defined = H.defined,
	            each = H.each,
	            erase = H.erase,
	            extend = H.extend,
	            fireEvent = H.fireEvent,
	            grep = H.grep,
	            isArray = H.isArray,
	            isNumber = H.isNumber,
	            isString = H.isString,
	            LegendSymbolMixin = H.LegendSymbolMixin, // @todo add as a requirement
	            merge = H.merge,
	            objectEach = H.objectEach,
	            pick = H.pick,
	            Point = H.Point, // @todo  add as a requirement
	            removeEvent = H.removeEvent,
	            splat = H.splat,
	            SVGElement = H.SVGElement,
	            syncTimeout = H.syncTimeout,
	            win = H.win;

	        /**
	         * This is the base series prototype that all other series types inherit from.
	         * A new series is initialized either through the {@link https://api.highcharts.com/highcharts/series|
	         * series} option structure, or after the chart is initialized, through {@link
	         * Highcharts.Chart#addSeries}.
	         *
	         * The object can be accessed in a number of ways. All series and point event
	         * handlers give a reference to the `series` object. The chart object has a
	         * {@link Highcharts.Chart.series|series} property that is a collection of all
	         * the chart's series. The point objects and axis objects also have the same
	         * reference.
	         *
	         * Another way to reference the series programmatically is by `id`. Add an id
	         * in the series configuration options, and get the series object by {@link
	         * Highcharts.Chart#get}.
	         *
	         * Configuration options for the series are given in three levels. Options for
	         * all series in a chart are given in the {@link https://api.highcharts.com/highcharts/plotOptions.series|
	         * plotOptions.series} object. Then options for all series of a specific type
	         * are given in the plotOptions of that type, for example `plotOptions.line`.
	         * Next, options for one single series are given in the series array, or as
	         * arguements to `chart.addSeries`.
	         *
	         * The data in the series is stored in various arrays.
	         *
	         * - First, `series.options.data` contains all the original config options for
	         * each point whether added by options or methods like `series.addPoint`.
	         * - Next, `series.data` contains those values converted to points, but in case
	         * the series data length exceeds the `cropThreshold`, or if the data is grouped,
	         * `series.data` doesn't contain all the points. It only contains the points that
	         * have been created on demand.
	         * - Then there's `series.points` that contains all currently visible point
	         * objects. In case of cropping, the cropped-away points are not part of this
	         * array. The `series.points` array starts at `series.cropStart` compared to
	         * `series.data` and `series.options.data`. If however the series data is grouped,
	         * these can't be correlated one to one.
	         * - `series.xData` and `series.processedXData` contain clean x values, equivalent
	         * to `series.data` and `series.points`.
	         * - `series.yData` and `series.processedYData` contain clean y values, equivalent
	         * to `series.data` and `series.points`.
	         *
	         * @class Highcharts.Series
	         * @param  {Highcharts.Chart} chart
	         *         The chart instance.
	         * @param  {Options.plotOptions.series} options
	         *         The series options.
	         *
	         */

	        /**
	         * General options for all series types.
	         * @optionparent plotOptions.series
	         */
	        H.Series = H.seriesType('line', null, { // base series options

	            //cursor: 'default',
	            //dashStyle: null,
	            //linecap: 'round',



	            /**
	             * Pixel with of the graph line.
	             * 
	             * @type {Number}
	             * @see In [styled mode](http://www.highcharts.com/docs/chart-design-and-
	             * style/style-by-css), the line stroke-width can be set with the
	             * `.highcharts-graph` class name.
	             * @sample {highcharts} highcharts/plotoptions/series-linewidth-general/ On all series
	             * @sample {highcharts} highcharts/plotoptions/series-linewidth-specific/ On one single series
	             * @default 2
	             * @product highcharts highstock
	             */
	            lineWidth: 2,
	            //shadow: false,


	            /**
	             * For some series, there is a limit that shuts down initial animation
	             * by default when the total number of points in the chart is too high.
	             * For example, for a column chart and its derivatives, animation doesn't
	             * run if there is more than 250 points totally. To disable this cap, set
	             * `animationLimit` to `Infinity`.
	             * 
	             * @type {Number}
	             * @apioption plotOptions.series.animationLimit
	             */

	            /**
	             * Allow this series' points to be selected by clicking on the graphic 
	             * (columns, point markers, pie slices, map areas etc).
	             *
	             * @see [Chart#getSelectedPoints](../class-reference/Highcharts.Chart#getSelectedPoints).
	             * 
	             * @type {Boolean}
	             * @sample {highcharts} highcharts/plotoptions/series-allowpointselect-line/
	             *         Line
	             * @sample {highcharts} highcharts/plotoptions/series-allowpointselect-column/
	             *         Column
	             * @sample {highcharts} highcharts/plotoptions/series-allowpointselect-pie/
	             *         Pie
	             * @sample {highmaps} maps/plotoptions/series-allowpointselect/
	             *         Map area
	             * @sample {highmaps} maps/plotoptions/mapbubble-allowpointselect/
	             *         Map bubble
	             * @default false
	             * @since 1.2.0
	             * @product highcharts highstock highmaps
	             */
	            allowPointSelect: false,



	            /**
	             * If true, a checkbox is displayed next to the legend item to allow
	             * selecting the series. The state of the checkbox is determined by
	             * the `selected` option.
	             *
	             * @productdesc {highmaps}
	             * Note that if a `colorAxis` is defined, the color axis is represented in
	             * the legend, not the series.
	             * 
	             * @type {Boolean}
	             * @sample {highcharts} highcharts/plotoptions/series-showcheckbox-true/
	             *         Show select box
	             * @default false
	             * @since 1.2.0
	             */
	            showCheckbox: false,



	            /**
	             * Enable or disable the initial animation when a series is displayed.
	             * The animation can also be set as a configuration object. Please
	             * note that this option only applies to the initial animation of the
	             * series itself. For other animations, see [chart.animation](#chart.
	             * animation) and the animation parameter under the API methods. The
	             * following properties are supported:
	             * 
	             * <dl>
	             * 
	             * <dt>duration</dt>
	             * 
	             * <dd>The duration of the animation in milliseconds.</dd>
	             * 
	             * <dt>easing</dt>
	             * 
	             * <dd>A string reference to an easing function set on the `Math` object.
	             * See [the easing demo](http://jsfiddle.net/gh/get/library/pure/highcharts/highcharts/tree/master/samples/highcharts/plotoptions/series-
	             * animation-easing/).</dd>
	             * 
	             * </dl>
	             * 
	             * Due to poor performance, animation is disabled in old IE browsers
	             * for several chart types.
	             * 
	             * @type {Boolean}
	             * @sample {highcharts} highcharts/plotoptions/series-animation-disabled/
	             *         Animation disabled
	             * @sample {highcharts} highcharts/plotoptions/series-animation-slower/
	             *         Slower animation
	             * @sample {highcharts} highcharts/plotoptions/series-animation-easing/
	             *         Custom easing function
	             * @sample {highstock} stock/plotoptions/animation-slower/
	             *         Slower animation
	             * @sample {highstock} stock/plotoptions/animation-easing/
	             *         Custom easing function
	             * @sample {highmaps} maps/plotoptions/series-animation-true/
	             *         Animation enabled on map series
	             * @sample {highmaps} maps/plotoptions/mapbubble-animation-false/
	             *         Disabled on mapbubble series
	             * @default {highcharts} true
	             * @default {highstock} true
	             * @default {highmaps} false
	             */
	            animation: {


	                /**
	                 */
	                duration: 1000
	            },

	            /**
	             * A class name to apply to the series' graphical elements.
	             * 
	             * @type {String}
	             * @since 5.0.0
	             * @apioption plotOptions.series.className
	             */

	            /**
	             * The main color of the series. In line type series it applies to the
	             * line and the point markers unless otherwise specified. In bar type
	             * series it applies to the bars unless a color is specified per point.
	             * The default value is pulled from the `options.colors` array.
	             * 
	             * In [styled mode](http://www.highcharts.com/docs/chart-design-and-
	             * style/style-by-css), the color can be defined by the [colorIndex](#plotOptions.
	             * series.colorIndex) option. Also, the series color can be set with
	             * the `.highcharts-series`, `.highcharts-color-{n}`, `.highcharts-{type}-
	             * series` or `.highcharts-series-{n}` class, or individual classes
	             * given by the `className` option.
	             *
	             * @productdesc {highmaps}
	             * In maps, the series color is rarely used, as most choropleth maps use the
	             * color to denote the value of each point. The series color can however be
	             * used in a map with multiple series holding categorized data.
	             * 
	             * @type {Color}
	             * @sample {highcharts} highcharts/plotoptions/series-color-general/
	             *         General plot option
	             * @sample {highcharts} highcharts/plotoptions/series-color-specific/
	             *         One specific series
	             * @sample {highcharts} highcharts/plotoptions/series-color-area/
	             *         Area color
	             * @sample {highmaps} maps/demo/category-map/
	             *         Category map by multiple series
	             * @apioption plotOptions.series.color
	             */

	            /**
	             * [Styled mode](http://www.highcharts.com/docs/chart-design-and-style/style-
	             * by-css) only. A specific color index to use for the series, so its
	             * graphic representations are given the class name `highcharts-color-
	             * {n}`.
	             * 
	             * @type {Number}
	             * @since 5.0.0
	             * @apioption plotOptions.series.colorIndex
	             */


	            /**
	             * Whether to connect a graph line across null points, or render a gap
	             * between the two points on either side of the null.
	             * 
	             * @type {Boolean}
	             * @sample {highcharts} highcharts/plotoptions/series-connectnulls-false/
	             *         False by default
	             * @sample {highcharts} highcharts/plotoptions/series-connectnulls-true/
	             *         True
	             * @product highcharts highstock
	             * @apioption plotOptions.series.connectNulls
	             */


	            /**
	             * You can set the cursor to "pointer" if you have click events attached
	             * to the series, to signal to the user that the points and lines can
	             * be clicked.
	             * 
	             * @validvalue [null, "default", "none", "help", "pointer", "crosshair"]
	             * @type {String}
	             * @see In [styled mode](http://www.highcharts.com/docs/chart-design-and-
	             * style/style-by-css), the series cursor can be set with the same classes
	             * as listed under [series.color](#plotOptions.series.color).
	             * @sample {highcharts} highcharts/plotoptions/series-cursor-line/
	             *         On line graph
	             * @sample {highcharts} highcharts/plotoptions/series-cursor-column/
	             *         On columns
	             * @sample {highcharts} highcharts/plotoptions/series-cursor-scatter/
	             *         On scatter markers
	             * @sample {highstock} stock/plotoptions/cursor/
	             *         Pointer on a line graph
	             * @sample {highmaps} maps/plotoptions/series-allowpointselect/
	             *         Map area
	             * @sample {highmaps} maps/plotoptions/mapbubble-allowpointselect/
	             *         Map bubble
	             * @apioption plotOptions.series.cursor
	             */


	            /**
	             * A name for the dash style to use for the graph, or for some series types
	             * the outline of each shape. The value for the `dashStyle` include:
	             * 
	             * *   Solid
	             * *   ShortDash
	             * *   ShortDot
	             * *   ShortDashDot
	             * *   ShortDashDotDot
	             * *   Dot
	             * *   Dash
	             * *   LongDash
	             * *   DashDot
	             * *   LongDashDot
	             * *   LongDashDotDot
	             * 
	             * @validvalue ["Solid", "ShortDash", "ShortDot", "ShortDashDot",
	             *             "ShortDashDotDot", "Dot", "Dash" ,"LongDash", "DashDot",
	             *             "LongDashDot", "LongDashDotDot"]
	             * @type {String}
	             * @see In [styled mode](http://www.highcharts.com/docs/chart-design-and-
	             * style/style-by-css), the [stroke dash-array](http://jsfiddle.net/gh/get/library/pure/highcharts/highcharts/tree/master/samples/highcharts/css/series-
	             * dashstyle/) can be set with the same classes as listed under [series.
	             * color](#plotOptions.series.color).
	             * @sample {highcharts} highcharts/plotoptions/series-dashstyle-all/
	             *         Possible values demonstrated
	             * @sample {highcharts} highcharts/plotoptions/series-dashstyle/
	             *         Chart suitable for printing in black and white
	             * @sample {highstock} highcharts/plotoptions/series-dashstyle-all/
	             *         Possible values demonstrated
	             * @sample {highmaps} highcharts/plotoptions/series-dashstyle-all/
	             *         Possible values demonstrated
	             * @sample {highmaps} maps/plotoptions/series-dashstyle/
	             *         Dotted borders on a map
	             * @default Solid
	             * @since 2.1
	             * @apioption plotOptions.series.dashStyle
	             */

	            /**
	             * Requires the Accessibility module.
	             * 
	             * A description of the series to add to the screen reader information
	             * about the series.
	             * 
	             * @type {String}
	             * @default undefined
	             * @since 5.0.0
	             * @apioption plotOptions.series.description
	             */





	            /**
	             * Enable or disable the mouse tracking for a specific series. This
	             * includes point tooltips and click events on graphs and points. For
	             * large datasets it improves performance.
	             * 
	             * @type {Boolean}
	             * @sample {highcharts} highcharts/plotoptions/series-enablemousetracking-false/ No mouse tracking
	             * @sample {highmaps} maps/plotoptions/series-enablemousetracking-false/ No mouse tracking
	             * @default true
	             * @apioption plotOptions.series.enableMouseTracking
	             */

	            /**
	             * By default, series are exposed to screen readers as regions. By enabling
	             * this option, the series element itself will be exposed in the same
	             * way as the data points. This is useful if the series is not used
	             * as a grouping entity in the chart, but you still want to attach a
	             * description to the series.
	             * 
	             * Requires the Accessibility module.
	             * 
	             * @type {Boolean}
	             * @sample {highcharts} highcharts/accessibility/art-grants/ Accessible data visualization
	             * @sample {highstock} highcharts/accessibility/art-grants/ Accessible data visualization
	             * @sample {highmaps} highcharts/accessibility/art-grants/ Accessible data visualization
	             * @default undefined
	             * @since 5.0.12
	             * @apioption plotOptions.series.exposeElementToA11y
	             */

	            /**
	             * Whether to use the Y extremes of the total chart width or only the
	             * zoomed area when zooming in on parts of the X axis. By default, the
	             * Y axis adjusts to the min and max of the visible data. Cartesian
	             * series only.
	             * 
	             * @type {Boolean}
	             * @default false
	             * @since 4.1.6
	             * @product highcharts highstock
	             * @apioption plotOptions.series.getExtremesFromAll
	             */

	            /**
	             * An array specifying which option maps to which key in the data point
	             * array. This makes it convenient to work with unstructured data arrays
	             * from different sources.
	             * 
	             * @type {Array<String>}
	             * @see [series.data](#series<line>.data)
	             * @sample {highcharts} highcharts/series/data-keys/ An extended data array with keys
	             * @sample {highstock} highcharts/series/data-keys/ An extended data array with keys
	             * @since 4.1.6
	             * @product highcharts highstock
	             * @apioption plotOptions.series.keys
	             */

	            /**
	             * The line cap used for line ends and line joins on the graph.
	             * 
	             * @validvalue ["round", "square"]
	             * @type {String}
	             * @default round
	             * @product highcharts highstock
	             * @apioption plotOptions.series.linecap
	             */

	            /**
	             * The [id](#series.id) of another series to link to. Additionally,
	             * the value can be ":previous" to link to the previous series. When
	             * two series are linked, only the first one appears in the legend.
	             * Toggling the visibility of this also toggles the linked series.
	             * 
	             * @type {String}
	             * @sample {highcharts} highcharts/demo/arearange-line/ Linked series
	             * @sample {highstock} highcharts/demo/arearange-line/ Linked series
	             * @since 3.0
	             * @product highcharts highstock
	             * @apioption plotOptions.series.linkedTo
	             */

	            /**
	             * The color for the parts of the graph or points that are below the
	             * [threshold](#plotOptions.series.threshold).
	             * 
	             * @type {Color}
	             * @see In [styled mode](http://www.highcharts.com/docs/chart-design-and-
	             * style/style-by-css), a negative color is applied by setting this
	             * option to `true` combined with the `.highcharts-negative` class name
	             * ([view live demo](http://jsfiddle.net/gh/get/library/pure/highcharts/highcharts/tree/master/samples/highcharts/css/series-
	             * negative-color/)).
	             * @sample {highcharts} highcharts/plotoptions/series-negative-color/ Spline, area and column
	             * @sample {highcharts} highcharts/plotoptions/arearange-negativecolor/ Arearange
	             * @sample {highstock} highcharts/plotoptions/series-negative-color/ Spline, area and column
	             * @sample {highstock} highcharts/plotoptions/arearange-negativecolor/ Arearange
	             * @sample {highmaps} highcharts/plotoptions/series-negative-color/ Spline, area and column
	             * @sample {highmaps} highcharts/plotoptions/arearange-negativecolor/ Arearange
	             * @default null
	             * @since 3.0
	             * @apioption plotOptions.series.negativeColor
	             */

	            /**
	             * Same as [accessibility.pointDescriptionFormatter](#accessibility.
	             * pointDescriptionFormatter), but for an individual series. Overrides
	             * the chart wide configuration.
	             * 
	             * @type {Function}
	             * @since 5.0.12
	             * @apioption plotOptions.series.pointDescriptionFormatter
	             */

	            /**
	             * If no x values are given for the points in a series, `pointInterval`
	             * defines the interval of the x values. For example, if a series contains
	             * one value every decade starting from year 0, set `pointInterval` to
	             * 10. In true `datetime` axes, the `pointInterval` is set in milliseconds.
	             * 
	             * It can be also be combined with `pointIntervalUnit` to draw irregular
	             * time intervals.
	             * 
	             * @type {Number}
	             * @sample {highcharts} highcharts/plotoptions/series-pointstart-datetime/
	             *         Datetime X axis
	             * @sample {highstock} stock/plotoptions/pointinterval-pointstart/
	             *         Using pointStart and pointInterval
	             * @default 1
	             * @product highcharts highstock
	             * @apioption plotOptions.series.pointInterval
	             */

	            /**
	             * On datetime series, this allows for setting the [pointInterval](#plotOptions.
	             * series.pointInterval) to irregular time units, `day`, `month` and
	             * `year`. A day is usually the same as 24 hours, but pointIntervalUnit
	             * also takes the DST crossover into consideration when dealing with
	             * local time. Combine this option with `pointInterval` to draw weeks,
	             *  quarters, 6 months, 10 years etc.
	             * 
	             * @validvalue [null, "day", "month", "year"]
	             * @type {String}
	             * @sample {highcharts} highcharts/plotoptions/series-pointintervalunit/ One point a month
	             * @sample {highstock} highcharts/plotoptions/series-pointintervalunit/ One point a month
	             * @since 4.1.0
	             * @product highcharts highstock
	             * @apioption plotOptions.series.pointIntervalUnit
	             */

	            /**
	             * Possible values: `null`, `"on"`, `"between"`.
	             * 
	             * In a column chart, when pointPlacement is `"on"`, the point will
	             * not create any padding of the X axis. In a polar column chart this
	             * means that the first column points directly north. If the pointPlacement
	             * is `"between"`, the columns will be laid out between ticks. This
	             * is useful for example for visualising an amount between two points
	             * in time or in a certain sector of a polar chart.
	             * 
	             * Since Highcharts 3.0.2, the point placement can also be numeric,
	             * where 0 is on the axis value, -0.5 is between this value and the
	             * previous, and 0.5 is between this value and the next. Unlike the
	             * textual options, numeric point placement options won't affect axis
	             * padding.
	             * 
	             * Note that pointPlacement needs a [pointRange](#plotOptions.series.
	             * pointRange) to work. For column series this is computed, but for
	             * line-type series it needs to be set.
	             * 
	             * Defaults to `null` in cartesian charts, `"between"` in polar charts.
	             * 
	             * @validvalue [null, "on", "between"]
	             * @type {String|Number}
	             * @see [xAxis.tickmarkPlacement](#xAxis.tickmarkPlacement)
	             * @sample {highcharts} highcharts/plotoptions/series-pointplacement-between/ Between in a column chart
	             * @sample {highcharts} highcharts/plotoptions/series-pointplacement-numeric/ Numeric placement for custom layout
	             * @sample {highstock} highcharts/plotoptions/series-pointplacement-between/ Between in a column chart
	             * @sample {highstock} highcharts/plotoptions/series-pointplacement-numeric/ Numeric placement for custom layout
	             * @default null
	             * @since 2.3.0
	             * @product highcharts highstock
	             * @apioption plotOptions.series.pointPlacement
	             */

	            /**
	             * If no x values are given for the points in a series, pointStart defines
	             * on what value to start. For example, if a series contains one yearly
	             * value starting from 1945, set pointStart to 1945.
	             * 
	             * @type {Number}
	             * @sample {highcharts} highcharts/plotoptions/series-pointstart-linear/ Linear
	             * @sample {highcharts} highcharts/plotoptions/series-pointstart-datetime/ Datetime
	             * @sample {highstock} stock/plotoptions/pointinterval-pointstart/ Using pointStart and pointInterval
	             * @default 0
	             * @product highcharts highstock
	             * @apioption plotOptions.series.pointStart
	             */

	            /**
	             * Whether to select the series initially. If `showCheckbox` is true,
	             * the checkbox next to the series name in the legend will be checked for a
	             * selected series.
	             * 
	             * @type {Boolean}
	             * @sample {highcharts} highcharts/plotoptions/series-selected/
	             *         One out of two series selected
	             * @default false
	             * @since 1.2.0
	             * @apioption plotOptions.series.selected
	             */

	            /**
	             * Whether to apply a drop shadow to the graph line. Since 2.3 the shadow
	             * can be an object configuration containing `color`, `offsetX`, `offsetY`,
	             *  `opacity` and `width`.
	             * 
	             * @type {Boolean|Object}
	             * @sample {highcharts} highcharts/plotoptions/series-shadow/ Shadow enabled
	             * @default false
	             * @apioption plotOptions.series.shadow
	             */

	            /**
	             * Whether to display this particular series or series type in the legend.
	             * The default value is `true` for standalone series, `false` for linked
	             * series.
	             * 
	             * @type {Boolean}
	             * @sample {highcharts} highcharts/plotoptions/series-showinlegend/ One series in the legend, one hidden
	             * @default true
	             * @apioption plotOptions.series.showInLegend
	             */

	            /**
	             * If set to `True`, the accessibility module will skip past the points
	             * in this series for keyboard navigation.
	             * 
	             * @type {Boolean}
	             * @since 5.0.12
	             * @apioption plotOptions.series.skipKeyboardNavigation
	             */

	            /**
	             * Whether to stack the values of each series on top of each other.
	             * Possible values are null to disable, "normal" to stack by value or
	             * "percent". When stacking is enabled, data must be sorted in ascending
	             * X order.
	             * 
	             * @validvalue [null, "normal", "percent"]
	             * @type {String}
	             * @see [yAxis.reversedStacks](#yAxis.reversedStacks)
	             * @sample {highcharts} highcharts/plotoptions/series-stacking-line/ Line
	             * @sample {highcharts} highcharts/plotoptions/series-stacking-column/ Column
	             * @sample {highcharts} highcharts/plotoptions/series-stacking-bar/ Bar
	             * @sample {highcharts} highcharts/plotoptions/series-stacking-area/ Area
	             * @sample {highcharts} highcharts/plotoptions/series-stacking-percent-line/ Line
	             * @sample {highcharts} highcharts/plotoptions/series-stacking-percent-column/ Column
	             * @sample {highcharts} highcharts/plotoptions/series-stacking-percent-bar/ Bar
	             * @sample {highcharts} highcharts/plotoptions/series-stacking-percent-area/ Area
	             * @sample {highstock} stock/plotoptions/stacking/ Area
	             * @default null
	             * @product highcharts highstock
	             * @apioption plotOptions.series.stacking
	             */

	            /**
	             * Whether to apply steps to the line. Possible values are `left`, `center`
	             * and `right`.
	             * 
	             * @validvalue [null, "left", "center", "right"]
	             * @type {String}
	             * @sample {highcharts} highcharts/plotoptions/line-step/ Different step line options
	             * @sample {highcharts} highcharts/plotoptions/area-step/ Stepped, stacked area
	             * @sample {highstock} stock/plotoptions/line-step/ Step line
	             * @default {highcharts} null
	             * @default {highstock} false
	             * @since 1.2.5
	             * @product highcharts highstock
	             * @apioption plotOptions.series.step
	             */

	            /**
	             * The threshold, also called zero level or base level. For line type
	             * series this is only used in conjunction with [negativeColor](#plotOptions.
	             * series.negativeColor).
	             * 
	             * @type {Number}
	             * @see [softThreshold](#plotOptions.series.softThreshold).
	             * @default 0
	             * @since 3.0
	             * @product highcharts highstock
	             * @apioption plotOptions.series.threshold
	             */

	            /**
	             * Set the initial visibility of the series.
	             * 
	             * @type {Boolean}
	             * @sample {highcharts} highcharts/plotoptions/series-visible/ Two series, one hidden and one visible
	             * @sample {highstock} stock/plotoptions/series-visibility/ Hidden series
	             * @default true
	             * @apioption plotOptions.series.visible
	             */

	            /**
	             * Defines the Axis on which the zones are applied.
	             * 
	             * @type {String}
	             * @see [zones](#plotOption.series.zones)
	             * @sample {highcharts} highcharts/series/color-zones-zoneaxis-x/ Zones on the X-Axis
	             * @sample {highstock} highcharts/series/color-zones-zoneaxis-x/ Zones on the X-Axis
	             * @default y
	             * @since 4.1.0
	             * @product highcharts highstock
	             * @apioption plotOptions.series.zoneAxis
	             */

	            /**
	             * @product highcharts highstock highmaps
	             */
	            events: {},



	            /**
	             * Options for the point markers of line-like series. Properties like
	             * `fillColor`, `lineColor` and `lineWidth` define the visual appearance
	             * of the markers. Other series types, like column series, don't have
	             * markers, but have visual options on the series level instead.
	             * 
	             * In [styled mode](http://www.highcharts.com/docs/chart-design-and-
	             * style/style-by-css), the markers can be styled with the `.highcharts-
	             * point`, `.highcharts-point-hover` and `.highcharts-point-select`
	             * class names.
	             * 
	             * @product highcharts highstock
	             */
	            marker: {



	                /**
	                 * The width of the point marker's outline.
	                 * 
	                 * @type {Number}
	                 * @sample {highcharts} highcharts/plotoptions/series-marker-fillcolor/ 2px blue marker
	                 * @default 0
	                 * @product highcharts highstock
	                 */
	                lineWidth: 0,


	                /**
	                 * The color of the point marker's outline. When `null`, the series'
	                 * or point's color is used.
	                 * 
	                 * @type {Color}
	                 * @sample {highcharts} highcharts/plotoptions/series-marker-fillcolor/ Inherit from series color (null)
	                 * @default #ffffff
	                 * @product highcharts highstock
	                 */
	                lineColor: '#ffffff',
	                //fillColor: null,

	                //enabled: true,
	                //symbol: null,


	                /**
	                 * The radius of the point marker.
	                 * 
	                 * @type {Number}
	                 * @sample {highcharts} highcharts/plotoptions/series-marker-radius/ Bigger markers
	                 * @default 4
	                 * @product highcharts highstock
	                 */
	                radius: 4,


	                /**
	                 * @product highcharts highstock
	                 */
	                states: { // states for a single point



	                    /**
	                     * @product highcharts highstock
	                     */
	                    hover: {



	                        /**
	                         */
	                        animation: {


	                            /**
	                             */
	                            duration: 0
	                        },



	                        /**
	                         * Enable or disable the point marker.
	                         * 
	                         * @type {Boolean}
	                         * @sample {highcharts} highcharts/plotoptions/series-marker-states-hover-enabled/ Disabled hover state
	                         * @default true
	                         * @product highcharts highstock
	                         */
	                        enabled: true,



	                        /**
	                         * The number of pixels to increase the radius of the hovered point.
	                         * 
	                         * @type {Number}
	                         * @sample {highcharts} highcharts/plotoptions/series-states-hover-linewidthplus/ 5 pixels greater radius on hover
	                         * @sample {highstock} highcharts/plotoptions/series-states-hover-linewidthplus/ 5 pixels greater radius on hover
	                         * @default 2
	                         * @since 4.0.3
	                         * @product highcharts highstock
	                         */
	                        radiusPlus: 2,




	                        /**
	                         * The additional line width for a hovered point.
	                         * 
	                         * @type {Number}
	                         * @sample {highcharts} highcharts/plotoptions/series-states-hover-linewidthplus/ 2 pixels wider on hover
	                         * @sample {highstock} highcharts/plotoptions/series-states-hover-linewidthplus/ 2 pixels wider on hover
	                         * @default 1
	                         * @since 4.0.3
	                         * @product highcharts highstock
	                         */
	                        lineWidthPlus: 1

	                    },




	                    /**
	                     * The appearance of the point marker when selected. In order to
	                     * allow a point to be selected, set the `series.allowPointSelect`
	                     * option to true.
	                     * 
	                     * @product highcharts highstock
	                     */
	                    select: {



	                        /**
	                         * The fill color of the point marker.
	                         * 
	                         * @type {Color}
	                         * @sample {highcharts} highcharts/plotoptions/series-marker-states-select-fillcolor/ Solid red discs for selected points
	                         * @default null
	                         * @product highcharts highstock
	                         */
	                        fillColor: '#cccccc',



	                        /**
	                         * The color of the point marker's outline. When `null`, the series'
	                         * or point's color is used.
	                         * 
	                         * @type {Color}
	                         * @sample {highcharts} highcharts/plotoptions/series-marker-states-select-linecolor/ Red line color for selected points
	                         * @default #000000
	                         * @product highcharts highstock
	                         */
	                        lineColor: '#000000',



	                        /**
	                         * The width of the point marker's outline.
	                         * 
	                         * @type {Number}
	                         * @sample {highcharts} highcharts/plotoptions/series-marker-states-select-linewidth/ 3px line width for selected points
	                         * @default 0
	                         * @product highcharts highstock
	                         */
	                        lineWidth: 2
	                    }

	                }
	            },



	            /**
	             * Properties for each single point
	             * 
	             * @product highcharts highstock highmaps
	             */
	            point: {


	                /**
	                 * Events for each single point
	                 * 
	                 * @product highcharts highstock highmaps
	                 */
	                events: {}
	            },



	            /**
	             * Options for the series data labels, appearing next to each data
	             * point.
	             * 
	             * In [styled mode](http://www.highcharts.com/docs/chart-design-and-
	             * style/style-by-css), the data labels can be styled wtih the `.highcharts-
	             * data-label-box` and `.highcharts-data-label` class names ([see example](http://jsfiddle.
	             * net/gh/get/library/pure/highcharts/highcharts/tree/master/samples/highcharts/css/series-
	             * datalabels)).
	             */
	            dataLabels: {


	                /**
	                 * The alignment of the data label compared to the point. If `right`,
	                 * the right side of the label should be touching the point. For
	                 * points with an extent, like columns, the alignments also dictates
	                 * how to align it inside the box, as given with the [inside](#plotOptions.
	                 * column.dataLabels.inside) option. Can be one of "left", "center"
	                 * or "right".
	                 * 
	                 * @validvalue ["left", "center", "right"]
	                 * @type {String}
	                 * @sample {highcharts} highcharts/plotoptions/series-datalabels-align-left/ Left aligned
	                 * @default center
	                 */
	                align: 'center',


	                /**
	                 * Whether to allow data labels to overlap. To make the labels less
	                 * sensitive for overlapping, the [dataLabels.padding](#plotOptions.
	                 * series.dataLabels.padding) can be set to 0.
	                 * 
	                 * @type {Boolean}
	                 * @sample {highcharts} highcharts/plotoptions/series-datalabels-allowoverlap-false/ Don't allow overlap
	                 * @sample {highstock} highcharts/plotoptions/series-datalabels-allowoverlap-false/ Don't allow overlap
	                 * @sample {highmaps} highcharts/plotoptions/series-datalabels-allowoverlap-false/ Don't allow overlap
	                 * @default false
	                 * @since 4.1.0
	                 * @apioption plotOptions.series.dataLabels.allowOverlap
	                 */


	                /**
	                 * The border radius in pixels for the data label.
	                 * 
	                 * @type {Number}
	                 * @sample {highcharts} highcharts/plotoptions/series-datalabels-box/ Data labels box options
	                 * @sample {highstock} highcharts/plotoptions/series-datalabels-box/ Data labels box options
	                 * @sample {highmaps} maps/plotoptions/series-datalabels-box/ Data labels box options
	                 * @default 0
	                 * @since 2.2.1
	                 * @apioption plotOptions.series.dataLabels.borderRadius
	                 */


	                /**
	                 * The border width in pixels for the data label.
	                 * 
	                 * @type {Number}
	                 * @sample {highcharts} highcharts/plotoptions/series-datalabels-box/ Data labels box options
	                 * @sample {highstock} highcharts/plotoptions/series-datalabels-box/ Data labels box options
	                 * @default 0
	                 * @since 2.2.1
	                 * @apioption plotOptions.series.dataLabels.borderWidth
	                 */

	                /**
	                 * A class name for the data label. Particularly in [styled mode](http://www.
	                 * highcharts.com/docs/chart-design-and-style/style-by-css), this can
	                 * be used to give each series' or point's data label unique styling.
	                 * In addition to this option, a default color class name is added
	                 * so that we can give the labels a [contrast text shadow](http://jsfiddle.
	                 * net/gh/get/library/pure/highcharts/highcharts/tree/master/samples/highcharts/css/data-
	                 * label-contrast/).
	                 * 
	                 * @type {String}
	                 * @sample {highcharts} highcharts/css/series-datalabels/ Styling by CSS
	                 * @sample {highstock} highcharts/css/series-datalabels/ Styling by CSS
	                 * @sample {highmaps} highcharts/css/series-datalabels/ Styling by CSS
	                 * @since 5.0.0
	                 * @apioption plotOptions.series.dataLabels.className
	                 */

	                /**
	                 * The text color for the data labels. Defaults to `null`. For certain series
	                 * types, like column or map, the data labels can be drawn inside the points.
	                 * In this case the data label will be drawn with maximum contrast by default.
	                 * Additionally, it will be given a `text-outline` style with the opposite
	                 * color, to further increase the contrast. This can be overridden by setting
	                 * the `text-outline` style to `none` in the `dataLabels.style` option.
	                 * 
	                 * @type {Color}
	                 * @sample {highcharts} highcharts/plotoptions/series-datalabels-color/
	                 *         Red data labels
	                 * @sample {highmaps} maps/demo/color-axis/
	                 *         White data labels
	                 * @apioption plotOptions.series.dataLabels.color
	                 */

	                /**
	                 * Whether to hide data labels that are outside the plot area. By default,
	                 * the data label is moved inside the plot area according to the [overflow](#plotOptions.
	                 * series.dataLabels.overflow) option.
	                 * 
	                 * @type {Boolean}
	                 * @default true
	                 * @since 2.3.3
	                 * @apioption plotOptions.series.dataLabels.crop
	                 */

	                /**
	                 * Whether to defer displaying the data labels until the initial series
	                 * animation has finished.
	                 * 
	                 * @type {Boolean}
	                 * @default true
	                 * @since 4.0
	                 * @product highcharts highstock
	                 * @apioption plotOptions.series.dataLabels.defer
	                 */

	                /**
	                 * Enable or disable the data labels.
	                 * 
	                 * @type {Boolean}
	                 * @sample {highcharts} highcharts/plotoptions/series-datalabels-enabled/ Data labels enabled
	                 * @sample {highmaps} maps/demo/color-axis/ Data labels enabled
	                 * @default false
	                 * @apioption plotOptions.series.dataLabels.enabled
	                 */

	                /**
	                 * A [format string](http://www.highcharts.com/docs/chart-concepts/labels-
	                 * and-string-formatting) for the data label. Available variables are
	                 * the same as for `formatter`.
	                 * 
	                 * @type {String}
	                 * @sample {highcharts} highcharts/plotoptions/series-datalabels-format/ Add a unit
	                 * @sample {highstock} highcharts/plotoptions/series-datalabels-format/ Add a unit
	                 * @sample {highmaps} maps/plotoptions/series-datalabels-format/ Formatted value in the data label
	                 * @default {highcharts} {y}
	                 * @default {highstock} {y}
	                 * @default {highmaps} {point.value}
	                 * @since 3.0
	                 * @apioption plotOptions.series.dataLabels.format
	                 */

	                /**
	                 * Callback JavaScript function to format the data label. Note that
	                 * if a `format` is defined, the format takes precedence and the formatter
	                 * is ignored. Available data are:
	                 * 
	                 * <table>
	                 * 
	                 * <tbody>
	                 * 
	                 * <tr>
	                 * 
	                 * <td>`this.percentage`</td>
	                 * 
	                 * <td>Stacked series and pies only. The point's percentage of the
	                 * total.</td>
	                 * 
	                 * </tr>
	                 * 
	                 * <tr>
	                 * 
	                 * <td>`this.point`</td>
	                 * 
	                 * <td>The point object. The point name, if defined, is available
	                 * through `this.point.name`.</td>
	                 * 
	                 * </tr>
	                 * 
	                 * <tr>
	                 * 
	                 * <td>`this.series`:</td>
	                 * 
	                 * <td>The series object. The series name is available through `this.
	                 * series.name`.</td>
	                 * 
	                 * </tr>
	                 * 
	                 * <tr>
	                 * 
	                 * <td>`this.total`</td>
	                 * 
	                 * <td>Stacked series only. The total value at this point's x value.
	                 * </td>
	                 * 
	                 * </tr>
	                 * 
	                 * <tr>
	                 * 
	                 * <td>`this.x`:</td>
	                 * 
	                 * <td>The x value.</td>
	                 * 
	                 * </tr>
	                 * 
	                 * <tr>
	                 * 
	                 * <td>`this.y`:</td>
	                 * 
	                 * <td>The y value.</td>
	                 * 
	                 * </tr>
	                 * 
	                 * </tbody>
	                 * 
	                 * </table>
	                 * 
	                 * @type {Function}
	                 * @sample {highmaps} maps/plotoptions/series-datalabels-format/ Formatted value
	                 * @product highcharts highstock highmaps
	                 */
	                formatter: function() {
	                    return this.y === null ? '' : H.numberFormat(this.y, -1);
	                },



	                /**
	                 * Styles for the label. The default `color` setting is `"contrast"`,
	                 * which is a pseudo color that Highcharts picks up and applies the
	                 * maximum contrast to the underlying point item, for example the
	                 * bar in a bar chart. The `textOutline` is a pseudo property that
	                 * applies an outline of the given width with the given color, which
	                 * by default is the maximum contrast to the text. So a bright text
	                 * color will result in a black text outline for maximum readability
	                 * on a mixed background. In some cases, especially with grayscale
	                 * text, the text outline doesn't work well, in which cases it can
	                 * be disabled by setting it to `"none"`.
	                 * 
	                 * @type {CSSObject}
	                 * @sample {highcharts} highcharts/plotoptions/series-datalabels-style/
	                 *         Bold labels
	                 * @sample {highmaps} maps/demo/color-axis/ Bold labels
	                 * @default {"color": "contrast", "fontSize": "11px", "fontWeight": "bold", "textOutline": "1px contrast" }
	                 * @since 4.1.0
	                 */
	                style: {
	                    fontSize: '11px',
	                    fontWeight: 'bold',
	                    color: 'contrast',
	                    textOutline: '1px contrast'
	                },

	                /**
	                 * The background color or gradient for the data label. Defaults to
	                 * `undefined`.
	                 * 
	                 * @type {Color}
	                 * @sample {highcharts} highcharts/plotoptions/series-datalabels-box/ Data labels box options
	                 * @sample {highmaps} maps/plotoptions/series-datalabels-box/ Data labels box options
	                 * @since 2.2.1
	                 * @apioption plotOptions.series.dataLabels.backgroundColor
	                 */

	                /**
	                 * The border color for the data label. Defaults to `undefined`.
	                 * 
	                 * @type {Color}
	                 * @sample {highcharts} highcharts/plotoptions/series-datalabels-box/ Data labels box options
	                 * @sample {highstock} highcharts/plotoptions/series-datalabels-box/ Data labels box options
	                 * @default undefined
	                 * @since 2.2.1
	                 * @apioption plotOptions.series.dataLabels.borderColor
	                 */

	                /**
	                 * The shadow of the box. Works best with `borderWidth` or `backgroundColor`.
	                 * Since 2.3 the shadow can be an object configuration containing `color`,
	                 *  `offsetX`, `offsetY`, `opacity` and `width`.
	                 * 
	                 * @type {Boolean|Object}
	                 * @sample {highcharts} highcharts/plotoptions/series-datalabels-box/ Data labels box options
	                 * @sample {highstock} highcharts/plotoptions/series-datalabels-box/ Data labels box options
	                 * @default false
	                 * @since 2.2.1
	                 * @apioption plotOptions.series.dataLabels.shadow
	                 */


	                /**
	                 * For points with an extent, like columns or map areas, whether to align the data
	                 * label inside the box or to the actual value point. Defaults to `false`
	                 * in most cases, `true` in stacked columns.
	                 * 
	                 * @type {Boolean}
	                 * @since 3.0
	                 * @apioption plotOptions.series.dataLabels.inside
	                 */

	                /**
	                 * How to handle data labels that flow outside the plot area. The default
	                 * is `justify`, which aligns them inside the plot area. For columns
	                 * and bars, this means it will be moved inside the bar. To display
	                 * data labels outside the plot area, set `crop` to `false` and `overflow`
	                 * to `"none"`.
	                 * 
	                 * @validvalue ["justify", "none"]
	                 * @type {String}
	                 * @default justify
	                 * @since 3.0.6
	                 * @apioption plotOptions.series.dataLabels.overflow
	                 */

	                /**
	                 * Text rotation in degrees. Note that due to a more complex structure,
	                 * backgrounds, borders and padding will be lost on a rotated data
	                 * label.
	                 * 
	                 * @type {Number}
	                 * @sample {highcharts} highcharts/plotoptions/series-datalabels-rotation/ Vertical labels
	                 * @default 0
	                 * @apioption plotOptions.series.dataLabels.rotation
	                 */

	                /**
	                 * The vertical alignment of a data label. Can be one of `top`, `middle`
	                 * or `bottom`. The default value depends on the data, for instance
	                 * in a column chart, the label is above positive values and below
	                 * negative values.
	                 * 
	                 * @validvalue ["top", "middle", "bottom"]
	                 * @type {String}
	                 * @since 2.3.3
	                 * @product highcharts highstock highmaps
	                 */
	                verticalAlign: 'bottom', // above singular point


	                /**
	                 * The x position offset of the label relative to the point.
	                 * 
	                 * @type {Number}
	                 * @sample {highcharts} highcharts/plotoptions/series-datalabels-rotation/ Vertical and positioned
	                 * @default 0
	                 * @product highcharts highstock highmaps
	                 */
	                x: 0,


	                /**
	                 * The y position offset of the label relative to the point.
	                 * 
	                 * @type {Number}
	                 * @sample {highcharts} highcharts/plotoptions/series-datalabels-rotation/ Vertical and positioned
	                 * @default -6
	                 * @product highcharts highstock highmaps
	                 */
	                y: 0,


	                /**
	                 * When either the `borderWidth` or the `backgroundColor` is set,
	                 * this is the padding within the box.
	                 * 
	                 * @type {Number}
	                 * @sample {highcharts} highcharts/plotoptions/series-datalabels-box/ Data labels box options
	                 * @sample {highstock} highcharts/plotoptions/series-datalabels-box/ Data labels box options
	                 * @sample {highmaps} maps/plotoptions/series-datalabels-box/ Data labels box options
	                 * @default {highcharts} 5
	                 * @default {highstock} 5
	                 * @default {highmaps} 0
	                 * @since 2.2.1
	                 * @product highcharts highstock highmaps
	                 */
	                padding: 5

	                /**
	                 * The name of a symbol to use for the border around the label. Symbols
	                 * are predefined functions on the Renderer object.
	                 * 
	                 * @type {String}
	                 * @sample {highcharts} highcharts/plotoptions/series-datalabels-shape/ A callout for annotations
	                 * @sample {highstock} highcharts/plotoptions/series-datalabels-shape/ A callout for annotations
	                 * @sample {highmaps} highcharts/plotoptions/series-datalabels-shape/ A callout for annotations (Highcharts demo)
	                 * @default square
	                 * @since 4.1.2
	                 * @apioption plotOptions.series.dataLabels.shape
	                 */

	                /**
	                 * The Z index of the data labels. The default Z index puts it above
	                 * the series. Use a Z index of 2 to display it behind the series.
	                 * 
	                 * @type {Number}
	                 * @default 6
	                 * @since 2.3.5
	                 * @apioption plotOptions.series.dataLabels.zIndex
	                 */
	            },
	            // draw points outside the plot area when the number of points is less than
	            // this



	            /**
	             * When the series contains less points than the crop threshold, all
	             * points are drawn, even if the points fall outside the visible plot
	             * area at the current zoom. The advantage of drawing all points (including
	             * markers and columns), is that animation is performed on updates.
	             * On the other hand, when the series contains more points than the
	             * crop threshold, the series data is cropped to only contain points
	             * that fall within the plot area. The advantage of cropping away invisible
	             * points is to increase performance on large series.
	             * 
	             * @type {Number}
	             * @default 300
	             * @since 2.2
	             * @product highcharts highstock
	             */
	            cropThreshold: 300,



	            /**
	             * The width of each point on the x axis. For example in a column chart
	             * with one value each day, the pointRange would be 1 day (= 24 * 3600
	             * * 1000 milliseconds). This is normally computed automatically, but
	             * this option can be used to override the automatic value.
	             * 
	             * @type {Number}
	             * @default 0
	             * @product highstock
	             */
	            pointRange: 0,
	            //pointStart: 0,
	            //pointInterval: 1,
	            //showInLegend: null, // auto = false for linked series



	            /**
	             * When this is true, the series will not cause the Y axis to cross
	             * the zero plane (or [threshold](#plotOptions.series.threshold) option)
	             * unless the data actually crosses the plane.
	             * 
	             * For example, if `softThreshold` is `false`, a series of 0, 1, 2,
	             * 3 will make the Y axis show negative values according to the `minPadding`
	             * option. If `softThreshold` is `true`, the Y axis starts at 0.
	             * 
	             * @type {Boolean}
	             * @default true
	             * @since 4.1.9
	             * @product highcharts highstock
	             */
	            softThreshold: true,



	            /**
	             * A wrapper object for all the series options in specific states.
	             * 
	             * @type {plotOptions.series.states}
	             * @product highcharts highstock highmaps
	             */
	            states: { // states for the entire series


	                /**
	                 * Options for the hovered series
	                 * 
	                 * @product highcharts highstock highmaps
	                 */
	                hover: {
	                    //enabled: false,



	                    /**
	                     * Animation setting for hovering the graph in line-type series.
	                     * 
	                     * @type {Boolean|Object}
	                     * @default { "duration": 50 }
	                     * @since 5.0.8
	                     * @product highcharts
	                     */
	                    animation: {



	                        /**
	                         */
	                        duration: 0
	                    },



	                    /**
	                     * The additional line width for the graph of a hovered series.
	                     * 
	                     * @type {Number}
	                     * @sample {highcharts} highcharts/plotoptions/series-states-hover-linewidthplus/ 5 pixels wider
	                     * @sample {highstock} highcharts/plotoptions/series-states-hover-linewidthplus/ 5 pixels wider
	                     * @default 1
	                     * @since 4.0.3
	                     * @product highcharts highstock
	                     */
	                    lineWidthPlus: 1,



	                    /**
	                     * In Highcharts 1.0, the appearance of all markers belonging to
	                     * the hovered series. For settings on the hover state of the individual
	                     * point, see [marker.states.hover](#plotOptions.series.marker.states.
	                     * hover).
	                     * 
	                     * @extends plotOptions.series.marker
	                     * @deprecated
	                     * @product highcharts highstock
	                     */
	                    marker: {
	                        // lineWidth: base + 1,
	                        // radius: base + 1
	                    },



	                    /**
	                     * Options for the halo appearing around the hovered point in line-
	                     * type series as well as outside the hovered slice in pie charts.
	                     * By default the halo is filled by the current point or series
	                     * color with an opacity of 0.25\. The halo can be disabled by setting
	                     * the `halo` option to `false`.
	                     * 
	                     * In [styled mode](http://www.highcharts.com/docs/chart-design-and-
	                     * style/style-by-css), the halo is styled with the `.highcharts-
	                     * halo` class, with colors inherited from `.highcharts-color-{n}`.
	                     * 
	                     * @type {Object}
	                     * @sample {highcharts} highcharts/plotoptions/halo/ Halo options
	                     * @sample {highstock} highcharts/plotoptions/halo/ Halo options
	                     * @since 4.0
	                     * @product highcharts highstock
	                     */
	                    halo: {



	                        /**
	                         * The pixel size of the halo. For point markers this is the radius
	                         * of the halo. For pie slices it is the width of the halo outside
	                         * the slice. For bubbles it defaults to 5 and is the width of the
	                         * halo outside the bubble.
	                         * 
	                         * @type {Number}
	                         * @default 10
	                         * @since 4.0
	                         * @product highcharts highstock
	                         */
	                        size: 10,




	                        /**
	                         * Opacity for the halo unless a specific fill is overridden using
	                         * the `attributes` setting. Note that Highcharts is only able to
	                         * apply opacity to colors of hex or rgb(a) formats.
	                         * 
	                         * @type {Number}
	                         * @default 0.25
	                         * @since 4.0
	                         * @product highcharts highstock
	                         */
	                        opacity: 0.25

	                    }
	                },


	                /**
	                 * Specific options for point in selected states, after being selected
	                 * by [allowPointSelect](#plotOptions.series.allowPointSelect) or
	                 * programmatically.
	                 * 
	                 * @type {Object}
	                 * @extends plotOptions.series.states.hover
	                 * @excluding brightness
	                 * @sample {highmaps} maps/plotoptions/series-allowpointselect/ Allow point select demo
	                 * @product highmaps
	                 */
	                select: {



	                    /**
	                     */
	                    marker: {}
	                }
	            },



	            /**
	             * Sticky tracking of mouse events. When true, the `mouseOut` event
	             * on a series isn't triggered until the mouse moves over another series,
	             * or out of the plot area. When false, the `mouseOut` event on a
	             * series is triggered when the mouse leaves the area around the series'
	             * graph or markers. This also implies the tooltip when not shared. When
	             * `stickyTracking` is false and `tooltip.shared` is false, the tooltip will
	             * be hidden when moving the mouse between series. Defaults to true for line
	             * and area type series, but to false for columns, pies etc.
	             * 
	             * @type {Boolean}
	             * @sample {highcharts} highcharts/plotoptions/series-stickytracking-true/
	             *         True by default
	             * @sample {highcharts} highcharts/plotoptions/series-stickytracking-false/
	             *         False
	             * @default {highcharts} true
	             * @default {highstock} true
	             * @default {highmaps} false
	             * @since 2.0
	             * @product highcharts highstock highmaps
	             */
	            stickyTracking: true,
	            //tooltip: {
	            //pointFormat: '<span style="color:{point.color}">\u25CF</span>' +
	            // '{series.name}: <b>{point.y}</b>'
	            //valueDecimals: null,
	            //xDateFormat: '%A, %b %e, %Y',
	            //valuePrefix: '',
	            //ySuffix: ''
	            //}



	            /**
	             * When a series contains a data array that is longer than this, only
	             * one dimensional arrays of numbers, or two dimensional arrays with
	             * x and y values are allowed. Also, only the first point is tested,
	             * and the rest are assumed to be the same format. This saves expensive
	             * data checking and indexing in long series. Set it to `0` disable.
	             * 
	             * @type {Number}
	             * @default 1000
	             * @since 2.2
	             * @product highcharts highstock
	             */
	            turboThreshold: 1000,
	            // zIndex: null



	            /**
	             * Determines whether the series should look for the nearest point
	             * in both dimensions or just the x-dimension when hovering the series.
	             * Defaults to `'xy'` for scatter series and `'x'` for most other
	             * series. If the data has duplicate x-values, it is recommended to
	             * set this to `'xy'` to allow hovering over all points.
	             * 
	             * Applies only to series types using nearest neighbor search (not
	             * direct hover) for tooltip.
	             * 
	             * @validvalue ['x', 'xy']
	             * @type {String}
	             * @sample {highcharts} highcharts/series/findnearestpointby/ Different hover behaviors
	             * @sample {highstock} highcharts/series/findnearestpointby/ Different hover behaviors
	             * @sample {highmaps} highcharts/series/findnearestpointby/ Different hover behaviors
	             * @since 5.0.10
	             * @product highcharts highstock highmaps
	             */
	            findNearestPointBy: 'x'

	        }, /** @lends Highcharts.Series.prototype */ {
	            isCartesian: true,
	            pointClass: Point,
	            sorted: true, // requires the data to be sorted
	            requireSorting: true,
	            directTouch: false,
	            axisTypes: ['xAxis', 'yAxis'],
	            colorCounter: 0,
	            // each point's x and y values are stored in this.xData and this.yData
	            parallelArrays: ['x', 'y'],
	            coll: 'series',
	            init: function(chart, options) {
	                var series = this,
	                    events,
	                    chartSeries = chart.series,
	                    lastSeries;

	                /**
	                 * Read only. The chart that the series belongs to.
	                 *
	                 * @name chart
	                 * @memberOf Series
	                 * @type {Chart}
	                 */
	                series.chart = chart;

	                /**
	                 * Read only. The series' type, like "line", "area", "column" etc. The
	                 * type in the series options anc can be altered using {@link
	                 * Series#update}.
	                 *
	                 * @name type
	                 * @memberOf Series
	                 * @type String
	                 */

	                /**
	                 * Read only. The series' current options. To update, use {@link
	                 * Series#update}.
	                 *
	                 * @name options
	                 * @memberOf Series
	                 * @type SeriesOptions
	                 */
	                series.options = options = series.setOptions(options);
	                series.linkedSeries = [];

	                // bind the axes
	                series.bindAxes();

	                // set some variables
	                extend(series, {
	                    /**
	                     * The series name as given in the options. Defaults to
	                     * "Series {n}".
	                     *
	                     * @name name
	                     * @memberOf Series
	                     * @type {String}
	                     */
	                    name: options.name,
	                    state: '',
	                    /**
	                     * Read only. The series' visibility state as set by {@link
	                     * Series#show}, {@link Series#hide}, or in the initial
	                     * configuration.
	                     *
	                     * @name visible
	                     * @memberOf Series
	                     * @type {Boolean}
	                     */
	                    visible: options.visible !== false, // true by default
	                    /**
	                     * Read only. The series' selected state as set by {@link
	                     * Highcharts.Series#select}.
	                     *
	                     * @name selected
	                     * @memberOf Series
	                     * @type {Boolean}
	                     */
	                    selected: options.selected === true // false by default
	                });

	                // register event listeners
	                events = options.events;

	                objectEach(events, function(event, eventType) {
	                    addEvent(series, eventType, event);
	                });
	                if (
	                    (events && events.click) ||
	                    (
	                        options.point &&
	                        options.point.events &&
	                        options.point.events.click
	                    ) ||
	                    options.allowPointSelect
	                ) {
	                    chart.runTrackerClick = true;
	                }

	                series.getColor();
	                series.getSymbol();

	                // Set the data
	                each(series.parallelArrays, function(key) {
	                    series[key + 'Data'] = [];
	                });
	                series.setData(options.data, false);

	                // Mark cartesian
	                if (series.isCartesian) {
	                    chart.hasCartesianSeries = true;
	                }

	                // Get the index and register the series in the chart. The index is one
	                // more than the current latest series index (#5960).
	                if (chartSeries.length) {
	                    lastSeries = chartSeries[chartSeries.length - 1];
	                }
	                series._i = pick(lastSeries && lastSeries._i, -1) + 1;

	                // Insert the series and re-order all series above the insertion point.
	                chart.orderSeries(this.insert(chartSeries));
	            },

	            /**
	             * Insert the series in a collection with other series, either the chart
	             * series or yAxis series, in the correct order according to the index
	             * option. Used internally when adding series.
	             *
	             * @private
	             * @param   {Array.<Series>} collection
	             *          A collection of series, like `chart.series` or `xAxis.series`.
	             * @returns {Number} The index of the series in the collection.
	             */
	            insert: function(collection) {
	                var indexOption = this.options.index,
	                    i;

	                // Insert by index option
	                if (isNumber(indexOption)) {
	                    i = collection.length;
	                    while (i--) {
	                        // Loop down until the interted element has higher index
	                        if (indexOption >=
	                            pick(collection[i].options.index, collection[i]._i)) {
	                            collection.splice(i + 1, 0, this);
	                            break;
	                        }
	                    }
	                    if (i === -1) {
	                        collection.unshift(this);
	                    }
	                    i = i + 1;

	                    // Or just push it to the end
	                } else {
	                    collection.push(this);
	                }
	                return pick(i, collection.length - 1);
	            },

	            /**
	             * Set the xAxis and yAxis properties of cartesian series, and register the
	             * series in the `axis.series` array.
	             *
	             * @private
	             */
	            bindAxes: function() {
	                var series = this,
	                    seriesOptions = series.options,
	                    chart = series.chart,
	                    axisOptions;

	                // repeat for xAxis and yAxis
	                each(series.axisTypes || [], function(AXIS) {

	                    // loop through the chart's axis objects
	                    each(chart[AXIS], function(axis) {
	                        axisOptions = axis.options;

	                        // apply if the series xAxis or yAxis option mathches the number
	                        // of the axis, or if undefined, use the first axis
	                        if (
	                            seriesOptions[AXIS] === axisOptions.index ||
	                            (
	                                seriesOptions[AXIS] !== undefined &&
	                                seriesOptions[AXIS] === axisOptions.id
	                            ) ||
	                            (
	                                seriesOptions[AXIS] === undefined &&
	                                axisOptions.index === 0
	                            )
	                        ) {

	                            // register this series in the axis.series lookup
	                            series.insert(axis.series);

	                            // set this series.xAxis or series.yAxis reference
	                            /**
	                             * Read only. The unique xAxis object associated with the
	                             * series.
	                             *
	                             * @name xAxis
	                             * @memberOf Series
	                             * @type Axis
	                             */
	                            /**
	                             * Read only. The unique yAxis object associated with the
	                             * series.
	                             *
	                             * @name yAxis
	                             * @memberOf Series
	                             * @type Axis
	                             */
	                            series[AXIS] = axis;

	                            // mark dirty for redraw
	                            axis.isDirty = true;
	                        }
	                    });

	                    // The series needs an X and an Y axis
	                    if (!series[AXIS] && series.optionalAxis !== AXIS) {
	                        H.error(18, true);
	                    }

	                });
	            },

	            /**
	             * For simple series types like line and column, the data values are held in
	             * arrays like xData and yData for quick lookup to find extremes and more.
	             * For multidimensional series like bubble and map, this can be extended
	             * with arrays like zData and valueData by adding to the
	             * `series.parallelArrays` array.
	             *
	             * @private
	             */
	            updateParallelArrays: function(point, i) {
	                var series = point.series,
	                    args = arguments,
	                    fn = isNumber(i) ?
	                    // Insert the value in the given position
	                    function(key) {
	                        var val = key === 'y' && series.toYData ?
	                            series.toYData(point) :
	                            point[key];
	                        series[key + 'Data'][i] = val;
	                    } :
	                    // Apply the method specified in i with the following arguments
	                    // as arguments
	                    function(key) {
	                        Array.prototype[i].apply(
	                            series[key + 'Data'],
	                            Array.prototype.slice.call(args, 2)
	                        );
	                    };

	                each(series.parallelArrays, fn);
	            },

	            /**
	             * Return an auto incremented x value based on the pointStart and
	             * pointInterval options. This is only used if an x value is not given for
	             * the point that calls autoIncrement.
	             *
	             * @private
	             */
	            autoIncrement: function() {

	                var options = this.options,
	                    xIncrement = this.xIncrement,
	                    date,
	                    pointInterval,
	                    pointIntervalUnit = options.pointIntervalUnit;

	                xIncrement = pick(xIncrement, options.pointStart, 0);

	                this.pointInterval = pointInterval = pick(
	                    this.pointInterval,
	                    options.pointInterval,
	                    1
	                );

	                // Added code for pointInterval strings
	                if (pointIntervalUnit) {
	                    date = new Date(xIncrement);

	                    if (pointIntervalUnit === 'day') {
	                        date = +date[Date.hcSetDate](
	                            date[Date.hcGetDate]() + pointInterval
	                        );
	                    } else if (pointIntervalUnit === 'month') {
	                        date = +date[Date.hcSetMonth](
	                            date[Date.hcGetMonth]() + pointInterval
	                        );
	                    } else if (pointIntervalUnit === 'year') {
	                        date = +date[Date.hcSetFullYear](
	                            date[Date.hcGetFullYear]() + pointInterval
	                        );
	                    }
	                    pointInterval = date - xIncrement;

	                }

	                this.xIncrement = xIncrement + pointInterval;
	                return xIncrement;
	            },

	            /**
	             * Set the series options by merging from the options tree. Called
	             * internally on initiating and updating series. This function will not
	             * redraw the series. For API usage, use {@link Series#update}.
	             * 
	             * @param  {Options.plotOptions.series} itemOptions
	             *         The series options.
	             */
	            setOptions: function(itemOptions) {
	                var chart = this.chart,
	                    chartOptions = chart.options,
	                    plotOptions = chartOptions.plotOptions,
	                    userOptions = chart.userOptions || {},
	                    userPlotOptions = userOptions.plotOptions || {},
	                    typeOptions = plotOptions[this.type],
	                    options,
	                    zones;

	                this.userOptions = itemOptions;

	                // General series options take precedence over type options because
	                // otherwise, default type options like column.animation would be
	                // overwritten by the general option. But issues have been raised here
	                // (#3881), and the solution may be to distinguish between default
	                // option and userOptions like in the tooltip below.
	                options = merge(
	                    typeOptions,
	                    plotOptions.series,
	                    itemOptions
	                );

	                // The tooltip options are merged between global and series specific
	                // options. Importance order asscendingly:
	                // globals: (1)tooltip, (2)plotOptions.series, (3)plotOptions[this.type]
	                // init userOptions with possible later updates: 4-6 like 1-3 and
	                // (7)this series options
	                this.tooltipOptions = merge(
	                    defaultOptions.tooltip, // 1
	                    defaultOptions.plotOptions.series &&
	                    defaultOptions.plotOptions.series.tooltip, // 2
	                    defaultOptions.plotOptions[this.type].tooltip, // 3
	                    chartOptions.tooltip.userOptions, // 4
	                    plotOptions.series && plotOptions.series.tooltip, // 5
	                    plotOptions[this.type].tooltip, // 6
	                    itemOptions.tooltip // 7
	                );

	                // When shared tooltip, stickyTracking is true by default,
	                // unless user says otherwise.
	                this.stickyTracking = pick(
	                    itemOptions.stickyTracking,
	                    userPlotOptions[this.type] &&
	                    userPlotOptions[this.type].stickyTracking,
	                    userPlotOptions.series && userPlotOptions.series.stickyTracking,
	                    (
	                        this.tooltipOptions.shared && !this.noSharedTooltip ?
	                        true :
	                        options.stickyTracking
	                    )
	                );

	                // Delete marker object if not allowed (#1125)
	                if (typeOptions.marker === null) {
	                    delete options.marker;
	                }

	                // Handle color zones
	                this.zoneAxis = options.zoneAxis;
	                zones = this.zones = (options.zones || []).slice();
	                if (
	                    (options.negativeColor || options.negativeFillColor) &&
	                    !options.zones
	                ) {
	                    zones.push({
	                        value: options[this.zoneAxis + 'Threshold'] ||
	                            options.threshold ||
	                            0,
	                        className: 'highcharts-negative',

	                        color: options.negativeColor,
	                        fillColor: options.negativeFillColor

	                    });
	                }
	                if (zones.length) { // Push one extra zone for the rest
	                    if (defined(zones[zones.length - 1].value)) {
	                        zones.push({

	                            color: this.color,
	                            fillColor: this.fillColor

	                        });
	                    }
	                }
	                return options;
	            },

	            getCyclic: function(prop, value, defaults) {
	                var i,
	                    chart = this.chart,
	                    userOptions = this.userOptions,
	                    indexName = prop + 'Index',
	                    counterName = prop + 'Counter',
	                    len = defaults ? defaults.length : pick(
	                        chart.options.chart[prop + 'Count'],
	                        chart[prop + 'Count']
	                    ),
	                    setting;

	                if (!value) {
	                    // Pick up either the colorIndex option, or the _colorIndex after
	                    // Series.update()
	                    setting = pick(
	                        userOptions[indexName],
	                        userOptions['_' + indexName]
	                    );
	                    if (defined(setting)) { // after Series.update()
	                        i = setting;
	                    } else {
	                        // #6138
	                        if (!chart.series.length) {
	                            chart[counterName] = 0;
	                        }
	                        userOptions['_' + indexName] = i = chart[counterName] % len;
	                        chart[counterName] += 1;
	                    }
	                    if (defaults) {
	                        value = defaults[i];
	                    }
	                }
	                // Set the colorIndex
	                if (i !== undefined) {
	                    this[indexName] = i;
	                }
	                this[prop] = value;
	            },

	            /**
	             * Get the series' color based on either the options or pulled from global
	             * options.
	             *
	             * @return  {Color} The series color.
	             */

	            getColor: function() {
	                if (this.options.colorByPoint) {
	                    // #4359, selected slice got series.color even when colorByPoint was
	                    // set.
	                    this.options.color = null;
	                } else {
	                    this.getCyclic(
	                        'color',
	                        this.options.color || defaultPlotOptions[this.type].color,
	                        this.chart.options.colors
	                    );
	                }
	            },

	            /**
	             * Get the series' symbol based on either the options or pulled from global
	             * options.
	             */
	            getSymbol: function() {
	                var seriesMarkerOption = this.options.marker;

	                this.getCyclic(
	                    'symbol',
	                    seriesMarkerOption.symbol,
	                    this.chart.options.symbols
	                );
	            },

	            drawLegendSymbol: LegendSymbolMixin.drawLineMarker,

	            /**
	             * Apply a new set of data to the series and optionally redraw it. The new
	             * data array is passed by reference (except in case of `updatePoints`), and
	             * may later be mutated when updating the chart data.
	             *
	             * Note the difference in behaviour when setting the same amount of points,
	             * or a different amount of points, as handled by the `updatePoints`
	             * parameter.
	             *
	             * @param  {SeriesDataOptions} data
	             *         Takes an array of data in the same format as described under
	             *         `series<type>data` for the given series type.
	             * @param  {Boolean} [redraw=true]
	             *         Whether to redraw the chart after the series is altered. If doing
	             *         more operations on the chart, it is a good idea to set redraw to
	             *         false and call {@link Chart#redraw} after.
	             * @param  {AnimationOptions} [animation]
	             *         When the updated data is the same length as the existing data,
	             *         points will be updated by default, and animation visualizes how
	             *         the points are changed. Set false to disable animation, or a
	             *         configuration object to set duration or easing.
	             * @param  {Boolean} [updatePoints=true]
	             *         When the updated data is the same length as the existing data,
	             *         points will be updated instead of replaced. This allows updating
	             *         with animation and performs better. In this case, the original
	             *         array is not passed by reference. Set false to prevent.
	             *
	             * @sample highcharts/members/series-setdata/
	             *         Set new data from a button
	             * @sample highcharts/members/series-setdata-pie/
	             *         Set data in a pie
	             * @sample stock/members/series-setdata/
	             *         Set new data in Highstock
	             * @sample maps/members/series-setdata/
	             *         Set new data in Highmaps
	             */
	            setData: function(data, redraw, animation, updatePoints) {
	                var series = this,
	                    oldData = series.points,
	                    oldDataLength = (oldData && oldData.length) || 0,
	                    dataLength,
	                    options = series.options,
	                    chart = series.chart,
	                    firstPoint = null,
	                    xAxis = series.xAxis,
	                    i,
	                    turboThreshold = options.turboThreshold,
	                    pt,
	                    xData = this.xData,
	                    yData = this.yData,
	                    pointArrayMap = series.pointArrayMap,
	                    valueCount = pointArrayMap && pointArrayMap.length;

	                data = data || [];
	                dataLength = data.length;
	                redraw = pick(redraw, true);

	                // If the point count is the same as is was, just run Point.update which
	                // is cheaper, allows animation, and keeps references to points.
	                if (
	                    updatePoints !== false &&
	                    dataLength &&
	                    oldDataLength === dataLength &&
	                    !series.cropped &&
	                    !series.hasGroupedData &&
	                    series.visible
	                ) {
	                    each(data, function(point, i) {
	                        // .update doesn't exist on a linked, hidden series (#3709)
	                        if (oldData[i].update && point !== options.data[i]) {
	                            oldData[i].update(point, false, null, false);
	                        }
	                    });

	                } else {

	                    // Reset properties
	                    series.xIncrement = null;

	                    series.colorCounter = 0; // for series with colorByPoint (#1547)

	                    // Update parallel arrays
	                    each(this.parallelArrays, function(key) {
	                        series[key + 'Data'].length = 0;
	                    });

	                    // In turbo mode, only one- or twodimensional arrays of numbers are
	                    // allowed. The first value is tested, and we assume that all the
	                    // rest are defined the same way. Although the 'for' loops are
	                    // similar, they are repeated inside each if-else conditional for
	                    // max performance.
	                    if (turboThreshold && dataLength > turboThreshold) {

	                        // find the first non-null point
	                        i = 0;
	                        while (firstPoint === null && i < dataLength) {
	                            firstPoint = data[i];
	                            i++;
	                        }


	                        if (isNumber(firstPoint)) { // assume all points are numbers
	                            for (i = 0; i < dataLength; i++) {
	                                xData[i] = this.autoIncrement();
	                                yData[i] = data[i];
	                            }

	                            // Assume all points are arrays when first point is
	                        } else if (isArray(firstPoint)) {
	                            if (valueCount) { // [x, low, high] or [x, o, h, l, c]
	                                for (i = 0; i < dataLength; i++) {
	                                    pt = data[i];
	                                    xData[i] = pt[0];
	                                    yData[i] = pt.slice(1, valueCount + 1);
	                                }
	                            } else { // [x, y]
	                                for (i = 0; i < dataLength; i++) {
	                                    pt = data[i];
	                                    xData[i] = pt[0];
	                                    yData[i] = pt[1];
	                                }
	                            }
	                        } else {
	                            // Highcharts expects configs to be numbers or arrays in
	                            // turbo mode
	                            H.error(12);
	                        }
	                    } else {
	                        for (i = 0; i < dataLength; i++) {
	                            if (data[i] !== undefined) { // stray commas in oldIE
	                                pt = {
	                                    series: series
	                                };
	                                series.pointClass.prototype.applyOptions.apply(
	                                    pt, [data[i]]
	                                );
	                                series.updateParallelArrays(pt, i);
	                            }
	                        }
	                    }

	                    // Forgetting to cast strings to numbers is a common caveat when
	                    // handling CSV or JSON
	                    if (isString(yData[0])) {
	                        H.error(14, true);
	                    }

	                    series.data = [];
	                    series.options.data = series.userOptions.data = data;

	                    // destroy old points
	                    i = oldDataLength;
	                    while (i--) {
	                        if (oldData[i] && oldData[i].destroy) {
	                            oldData[i].destroy();
	                        }
	                    }

	                    // reset minRange (#878)
	                    if (xAxis) {
	                        xAxis.minRange = xAxis.userMinRange;
	                    }

	                    // redraw
	                    series.isDirty = chart.isDirtyBox = true;
	                    series.isDirtyData = !!oldData;
	                    animation = false;
	                }

	                // Typically for pie series, points need to be processed and generated
	                // prior to rendering the legend
	                if (options.legendType === 'point') {
	                    this.processData();
	                    this.generatePoints();
	                }

	                if (redraw) {
	                    chart.redraw(animation);
	                }
	            },

	            /**
	             * Internal function to process the data by cropping away unused data points
	             * if the series is longer than the crop threshold. This saves computing
	             * time for large series. In Highstock, this function is extended to
	             * provide data grouping.
	             *
	             * @private
	             * @param  {Boolean} force
	             *         Force data grouping.
	             */
	            processData: function(force) {
	                var series = this,
	                    processedXData = series.xData, // copied during slice operation
	                    processedYData = series.yData,
	                    dataLength = processedXData.length,
	                    croppedData,
	                    cropStart = 0,
	                    cropped,
	                    distance,
	                    closestPointRange,
	                    xAxis = series.xAxis,
	                    i, // loop variable
	                    options = series.options,
	                    cropThreshold = options.cropThreshold,
	                    getExtremesFromAll =
	                    series.getExtremesFromAll ||
	                    options.getExtremesFromAll, // #4599
	                    isCartesian = series.isCartesian,
	                    xExtremes,
	                    val2lin = xAxis && xAxis.val2lin,
	                    isLog = xAxis && xAxis.isLog,
	                    min,
	                    max;

	                // If the series data or axes haven't changed, don't go through this.
	                // Return false to pass the message on to override methods like in data
	                // grouping.
	                if (
	                    isCartesian &&
	                    !series.isDirty &&
	                    !xAxis.isDirty &&
	                    !series.yAxis.isDirty &&
	                    !force
	                ) {
	                    return false;
	                }

	                if (xAxis) {
	                    xExtremes = xAxis.getExtremes(); // corrected for log axis (#3053)
	                    min = xExtremes.min;
	                    max = xExtremes.max;
	                }

	                // optionally filter out points outside the plot area
	                if (
	                    isCartesian &&
	                    series.sorted &&
	                    !getExtremesFromAll &&
	                    (!cropThreshold || dataLength > cropThreshold || series.forceCrop)
	                ) {

	                    // it's outside current extremes
	                    if (
	                        processedXData[dataLength - 1] < min ||
	                        processedXData[0] > max
	                    ) {
	                        processedXData = [];
	                        processedYData = [];

	                        // only crop if it's actually spilling out
	                    } else if (
	                        processedXData[0] < min ||
	                        processedXData[dataLength - 1] > max
	                    ) {
	                        croppedData = this.cropData(
	                            series.xData,
	                            series.yData,
	                            min,
	                            max
	                        );
	                        processedXData = croppedData.xData;
	                        processedYData = croppedData.yData;
	                        cropStart = croppedData.start;
	                        cropped = true;
	                    }
	                }


	                // Find the closest distance between processed points
	                i = processedXData.length || 1;
	                while (--i) {
	                    distance = isLog ?
	                        val2lin(processedXData[i]) - val2lin(processedXData[i - 1]) :
	                        processedXData[i] - processedXData[i - 1];

	                    if (
	                        distance > 0 &&
	                        (
	                            closestPointRange === undefined ||
	                            distance < closestPointRange
	                        )
	                    ) {
	                        closestPointRange = distance;

	                        // Unsorted data is not supported by the line tooltip, as well as
	                        // data grouping and navigation in Stock charts (#725) and width
	                        // calculation of columns (#1900)
	                    } else if (distance < 0 && series.requireSorting) {
	                        H.error(15);
	                    }
	                }

	                // Record the properties
	                series.cropped = cropped; // undefined or true
	                series.cropStart = cropStart;
	                series.processedXData = processedXData;
	                series.processedYData = processedYData;

	                series.closestPointRange = closestPointRange;

	            },

	            /**
	             * Iterate over xData and crop values between min and max. Returns object
	             * containing crop start/end cropped xData with corresponding part of yData,
	             * dataMin and dataMax within the cropped range.
	             *
	             * @private
	             */
	            cropData: function(xData, yData, min, max) {
	                var dataLength = xData.length,
	                    cropStart = 0,
	                    cropEnd = dataLength,
	                    // line-type series need one point outside
	                    cropShoulder = pick(this.cropShoulder, 1),
	                    i,
	                    j;

	                // iterate up to find slice start
	                for (i = 0; i < dataLength; i++) {
	                    if (xData[i] >= min) {
	                        cropStart = Math.max(0, i - cropShoulder);
	                        break;
	                    }
	                }

	                // proceed to find slice end
	                for (j = i; j < dataLength; j++) {
	                    if (xData[j] > max) {
	                        cropEnd = j + cropShoulder;
	                        break;
	                    }
	                }

	                return {
	                    xData: xData.slice(cropStart, cropEnd),
	                    yData: yData.slice(cropStart, cropEnd),
	                    start: cropStart,
	                    end: cropEnd
	                };
	            },


	            /**
	             * Generate the data point after the data has been processed by cropping
	             * away unused points and optionally grouped in Highcharts Stock.
	             *
	             * @private
	             */
	            generatePoints: function() {
	                var series = this,
	                    options = series.options,
	                    dataOptions = options.data,
	                    data = series.data,
	                    dataLength,
	                    processedXData = series.processedXData,
	                    processedYData = series.processedYData,
	                    PointClass = series.pointClass,
	                    processedDataLength = processedXData.length,
	                    cropStart = series.cropStart || 0,
	                    cursor,
	                    hasGroupedData = series.hasGroupedData,
	                    keys = options.keys,
	                    point,
	                    points = [],
	                    i;

	                if (!data && !hasGroupedData) {
	                    var arr = [];
	                    arr.length = dataOptions.length;
	                    data = series.data = arr;
	                }

	                if (keys && hasGroupedData) {
	                    // grouped data has already applied keys (#6590)
	                    series.options.keys = false;
	                }

	                for (i = 0; i < processedDataLength; i++) {
	                    cursor = cropStart + i;
	                    if (!hasGroupedData) {
	                        point = data[cursor];
	                        if (!point && dataOptions[cursor] !== undefined) { // #970
	                            data[cursor] = point = (new PointClass()).init(
	                                series,
	                                dataOptions[cursor],
	                                processedXData[i]
	                            );
	                        }
	                    } else {
	                        // splat the y data in case of ohlc data array
	                        point = (new PointClass()).init(
	                            series, [processedXData[i]].concat(splat(processedYData[i]))
	                        );

	                        /**
	                         * Highstock only. If a point object is created by data
	                         * grouping, it doesn't reflect actual points in the raw data.
	                         * In this case, the `dataGroup` property holds information
	                         * that points back to the raw data.
	                         *
	                         * - `dataGroup.start` is the index of the first raw data point
	                         * in the group.
	                         * - `dataGroup.length` is the amount of points in the group.
	                         *
	                         * @name dataGroup
	                         * @memberOf Point
	                         * @type {Object}
	                         *
	                         */
	                        point.dataGroup = series.groupMap[i];
	                    }
	                    if (point) { // #6279
	                        point.index = cursor; // For faster access in Point.update
	                        points[i] = point;
	                    }
	                }

	                // restore keys options (#6590)
	                series.options.keys = keys;

	                // Hide cropped-away points - this only runs when the number of points
	                // is above cropThreshold, or when swithching view from non-grouped
	                // data to grouped data (#637)
	                if (
	                    data &&
	                    (
	                        processedDataLength !== (dataLength = data.length) ||
	                        hasGroupedData
	                    )
	                ) {
	                    for (i = 0; i < dataLength; i++) {
	                        // when has grouped data, clear all points
	                        if (i === cropStart && !hasGroupedData) {
	                            i += processedDataLength;
	                        }
	                        if (data[i]) {
	                            data[i].destroyElements();
	                            data[i].plotX = undefined; // #1003
	                        }
	                    }
	                }

	                /**
	                 * Read only. An array containing the series' data point objects. To
	                 * modify the data, use {@link Highcharts.Series#setData} or {@link
	                 * Highcharts.Point#update}.
	                 *
	                 * @name data
	                 * @memberOf Highcharts.Series
	                 * @type {Array.<Highcharts.Point>}
	                 */
	                series.data = data;

	                /**
	                 * An array containing all currently visible point objects. In case of
	                 * cropping, the cropped-away points are not part of this array. The
	                 * `series.points` array starts at `series.cropStart` compared to
	                 * `series.data` and `series.options.data`. If however the series data
	                 * is grouped, these can't be correlated one to one. To
	                 * modify the data, use {@link Highcharts.Series#setData} or {@link
	                 * Highcharts.Point#update}.
	                 * @name point
	                 * @memberof Series
	                 * @type {Array.<Point>}
	                 */
	                series.points = points;
	            },

	            /**
	             * Calculate Y extremes for the visible data. The result is set as 
	             * `dataMin` and `dataMax` on the Series item.
	             *
	             * @param  {Array.<Number>} [yData]
	             *         The data to inspect. Defaults to the current data within the
	             *         visible range.
	             * 
	             */
	            getExtremes: function(yData) {
	                var xAxis = this.xAxis,
	                    yAxis = this.yAxis,
	                    xData = this.processedXData,
	                    yDataLength,
	                    activeYData = [],
	                    activeCounter = 0,
	                    // #2117, need to compensate for log X axis
	                    xExtremes = xAxis.getExtremes(),
	                    xMin = xExtremes.min,
	                    xMax = xExtremes.max,
	                    validValue,
	                    withinRange,
	                    x,
	                    y,
	                    i,
	                    j;

	                yData = yData || this.stackedYData || this.processedYData || [];
	                yDataLength = yData.length;

	                for (i = 0; i < yDataLength; i++) {

	                    x = xData[i];
	                    y = yData[i];

	                    // For points within the visible range, including the first point
	                    // outside the visible range, consider y extremes
	                    validValue =
	                        (isNumber(y, true) || isArray(y)) &&
	                        (!yAxis.positiveValuesOnly || (y.length || y > 0));
	                    withinRange =
	                        this.getExtremesFromAll ||
	                        this.options.getExtremesFromAll ||
	                        this.cropped ||
	                        ((xData[i] || x) >= xMin && (xData[i] || x) <= xMax);

	                    if (validValue && withinRange) {

	                        j = y.length;
	                        if (j) { // array, like ohlc or range data
	                            while (j--) {
	                                if (y[j] !== null) {
	                                    activeYData[activeCounter++] = y[j];
	                                }
	                            }
	                        } else {
	                            activeYData[activeCounter++] = y;
	                        }
	                    }
	                }

	                this.dataMin = arrayMin(activeYData);
	                this.dataMax = arrayMax(activeYData);
	            },

	            /**
	             * Translate data points from raw data values to chart specific positioning
	             * data needed later in the `drawPoints` and `drawGraph` functions. This
	             * function can be overridden in plugins and custom series type
	             * implementations.
	             */
	            translate: function() {
	                if (!this.processedXData) { // hidden series
	                    this.processData();
	                }
	                this.generatePoints();
	                var series = this,
	                    options = series.options,
	                    stacking = options.stacking,
	                    xAxis = series.xAxis,
	                    categories = xAxis.categories,
	                    yAxis = series.yAxis,
	                    points = series.points,
	                    dataLength = points.length,
	                    hasModifyValue = !!series.modifyValue,
	                    i,
	                    pointPlacement = options.pointPlacement,
	                    dynamicallyPlaced =
	                    pointPlacement === 'between' ||
	                    isNumber(pointPlacement),
	                    threshold = options.threshold,
	                    stackThreshold = options.startFromThreshold ? threshold : 0,
	                    plotX,
	                    plotY,
	                    lastPlotX,
	                    stackIndicator,
	                    closestPointRangePx = Number.MAX_VALUE;

	                // Point placement is relative to each series pointRange (#5889)
	                if (pointPlacement === 'between') {
	                    pointPlacement = 0.5;
	                }
	                if (isNumber(pointPlacement)) {
	                    pointPlacement *= pick(options.pointRange || xAxis.pointRange);
	                }

	                // Translate each point
	                for (i = 0; i < dataLength; i++) {
	                    var point = points[i],
	                        xValue = point.x,
	                        yValue = point.y,
	                        yBottom = point.low,
	                        stack = stacking && yAxis.stacks[(
	                            series.negStacks &&
	                            yValue < (stackThreshold ? 0 : threshold) ? '-' : ''
	                        ) + series.stackKey],
	                        pointStack,
	                        stackValues;

	                    // Discard disallowed y values for log axes (#3434)
	                    if (yAxis.positiveValuesOnly && yValue !== null && yValue <= 0) {
	                        point.isNull = true;
	                    }

	                    // Get the plotX translation
	                    point.plotX = plotX = correctFloat( // #5236
	                        Math.min(Math.max(-1e5, xAxis.translate(
	                            xValue,
	                            0,
	                            0,
	                            0,
	                            1,
	                            pointPlacement,
	                            this.type === 'flags'
	                        )), 1e5) // #3923
	                    );

	                    // Calculate the bottom y value for stacked series
	                    if (
	                        stacking &&
	                        series.visible &&
	                        !point.isNull &&
	                        stack &&
	                        stack[xValue]
	                    ) {
	                        stackIndicator = series.getStackIndicator(
	                            stackIndicator,
	                            xValue,
	                            series.index
	                        );
	                        pointStack = stack[xValue];
	                        stackValues = pointStack.points[stackIndicator.key];
	                        yBottom = stackValues[0];
	                        yValue = stackValues[1];

	                        if (
	                            yBottom === stackThreshold &&
	                            stackIndicator.key === stack[xValue].base
	                        ) {
	                            yBottom = pick(threshold, yAxis.min);
	                        }
	                        if (yAxis.positiveValuesOnly && yBottom <= 0) { // #1200, #1232
	                            yBottom = null;
	                        }

	                        point.total = point.stackTotal = pointStack.total;
	                        point.percentage =
	                            pointStack.total &&
	                            (point.y / pointStack.total * 100);
	                        point.stackY = yValue;

	                        // Place the stack label
	                        pointStack.setOffset(
	                            series.pointXOffset || 0,
	                            series.barW || 0
	                        );

	                    }

	                    // Set translated yBottom or remove it
	                    point.yBottom = defined(yBottom) ?
	                        yAxis.translate(yBottom, 0, 1, 0, 1) :
	                        null;

	                    // general hook, used for Highstock compare mode
	                    if (hasModifyValue) {
	                        yValue = series.modifyValue(yValue, point);
	                    }

	                    // Set the the plotY value, reset it for redraws
	                    point.plotY = plotY =
	                        (typeof yValue === 'number' && yValue !== Infinity) ?
	                        Math.min(Math.max(-1e5,
	                            yAxis.translate(yValue, 0, 1, 0, 1)), 1e5) : // #3201
	                        undefined;

	                    point.isInside =
	                        plotY !== undefined &&
	                        plotY >= 0 &&
	                        plotY <= yAxis.len && // #3519
	                        plotX >= 0 &&
	                        plotX <= xAxis.len;


	                    // Set client related positions for mouse tracking
	                    point.clientX = dynamicallyPlaced ?
	                        correctFloat(
	                            xAxis.translate(xValue, 0, 0, 0, 1, pointPlacement)
	                        ) :
	                        plotX; // #1514, #5383, #5518

	                    point.negative = point.y < (threshold || 0);

	                    // some API data
	                    point.category = categories && categories[point.x] !== undefined ?
	                        categories[point.x] : point.x;

	                    // Determine auto enabling of markers (#3635, #5099)
	                    if (!point.isNull) {
	                        if (lastPlotX !== undefined) {
	                            closestPointRangePx = Math.min(
	                                closestPointRangePx,
	                                Math.abs(plotX - lastPlotX)
	                            );
	                        }
	                        lastPlotX = plotX;
	                    }

	                    // Find point zone
	                    point.zone = this.zones.length && point.getZone();
	                }
	                series.closestPointRangePx = closestPointRangePx;
	            },

	            /**
	             * Return the series points with null points filtered out.
	             *
	             * @param  {Array.<Point>} [points]
	             *         The points to inspect, defaults to {@link Series.points}.
	             * @param  {Boolean} [insideOnly=false]
	             *         Whether to inspect only the points that are inside the visible
	             *         view.
	             *
	             * @return {Array.<Point>}
	             *         The valid points.
	             */
	            getValidPoints: function(points, insideOnly) {
	                var chart = this.chart;
	                // #3916, #5029, #5085
	                return grep(points || this.points || [], function isValidPoint(point) {
	                    if (insideOnly && !chart.isInsidePlot(
	                            point.plotX,
	                            point.plotY,
	                            chart.inverted
	                        )) {
	                        return false;
	                    }
	                    return !point.isNull;
	                });
	            },

	            /**
	             * Set the clipping for the series. For animated series it is called twice,
	             * first to initiate animating the clip then the second time without the
	             * animation to set the final clip.
	             *
	             * @private
	             */
	            setClip: function(animation) {
	                var chart = this.chart,
	                    options = this.options,
	                    renderer = chart.renderer,
	                    inverted = chart.inverted,
	                    seriesClipBox = this.clipBox,
	                    clipBox = seriesClipBox || chart.clipBox,
	                    sharedClipKey =
	                    this.sharedClipKey || [
	                        '_sharedClip',
	                        animation && animation.duration,
	                        animation && animation.easing,
	                        clipBox.height,
	                        options.xAxis,
	                        options.yAxis
	                    ].join(','), // #4526
	                    clipRect = chart[sharedClipKey],
	                    markerClipRect = chart[sharedClipKey + 'm'];

	                // If a clipping rectangle with the same properties is currently present
	                // in the chart, use that.
	                if (!clipRect) {

	                    // When animation is set, prepare the initial positions
	                    if (animation) {
	                        clipBox.width = 0;

	                        chart[sharedClipKey + 'm'] = markerClipRect = renderer.clipRect(-99, // include the width of the first marker
	                            inverted ? -chart.plotLeft : -chart.plotTop,
	                            99,
	                            inverted ? chart.chartWidth : chart.chartHeight
	                        );
	                    }
	                    chart[sharedClipKey] = clipRect = renderer.clipRect(clipBox);
	                    // Create hashmap for series indexes
	                    clipRect.count = {
	                        length: 0
	                    };

	                }
	                if (animation) {
	                    if (!clipRect.count[this.index]) {
	                        clipRect.count[this.index] = true;
	                        clipRect.count.length += 1;
	                    }
	                }

	                if (options.clip !== false) {
	                    this.group.clip(animation || seriesClipBox ? clipRect : chart.clipRect);
	                    this.markerGroup.clip(markerClipRect);
	                    this.sharedClipKey = sharedClipKey;
	                }

	                // Remove the shared clipping rectangle when all series are shown
	                if (!animation) {
	                    if (clipRect.count[this.index]) {
	                        delete clipRect.count[this.index];
	                        clipRect.count.length -= 1;
	                    }

	                    if (clipRect.count.length === 0 && sharedClipKey && chart[sharedClipKey]) {
	                        if (!seriesClipBox) {
	                            chart[sharedClipKey] = chart[sharedClipKey].destroy();
	                        }
	                        if (chart[sharedClipKey + 'm']) {
	                            chart[sharedClipKey + 'm'] = chart[sharedClipKey + 'm'].destroy();
	                        }
	                    }
	                }
	            },

	            /**
	             * Animate in the series. Called internally twice. First with the `init`
	             * parameter set to true, which sets up the initial state of the animation.
	             * Then when ready, it is called with the `init` parameter undefined, in 
	             * order to perform the actual animation. After the second run, the function
	             * is removed.
	             *
	             * @param  {Boolean} init
	             *         Initialize the animation.
	             */
	            animate: function(init) {
	                var series = this,
	                    chart = series.chart,
	                    clipRect,
	                    animation = animObject(series.options.animation),
	                    sharedClipKey;

	                // Initialize the animation. Set up the clipping rectangle.
	                if (init) {

	                    series.setClip(animation);

	                    // Run the animation
	                } else {
	                    sharedClipKey = this.sharedClipKey;
	                    clipRect = chart[sharedClipKey];
	                    if (clipRect) {
	                        clipRect.animate({
	                            width: chart.plotSizeX
	                        }, animation);
	                    }
	                    if (chart[sharedClipKey + 'm']) {
	                        chart[sharedClipKey + 'm'].animate({
	                            width: chart.plotSizeX + 99
	                        }, animation);
	                    }

	                    // Delete this function to allow it only once
	                    series.animate = null;

	                }
	            },

	            /**
	             * This runs after animation to land on the final plot clipping.
	             *
	             * @private
	             */
	            afterAnimate: function() {
	                this.setClip();
	                fireEvent(this, 'afterAnimate');
	                this.finishedAnimating = true;
	            },

	            /**
	             * Draw the markers for line-like series types, and columns or other
	             * graphical representation for {@link Point} objects for other series
	             * types. The resulting element is typically stored as {@link
	             * Point.graphic}, and is created on the first call and updated and moved on
	             * subsequent calls.
	             */
	            drawPoints: function() {
	                var series = this,
	                    points = series.points,
	                    chart = series.chart,
	                    plotY,
	                    i,
	                    point,
	                    symbol,
	                    graphic,
	                    options = series.options,
	                    seriesMarkerOptions = options.marker,
	                    pointMarkerOptions,
	                    hasPointMarker,
	                    enabled,
	                    isInside,
	                    markerGroup = series[series.specialGroup] || series.markerGroup,
	                    xAxis = series.xAxis,
	                    markerAttribs,
	                    globallyEnabled = pick(
	                        seriesMarkerOptions.enabled,
	                        xAxis.isRadial ? true : null,
	                        // Use larger or equal as radius is null in bubbles (#6321)
	                        series.closestPointRangePx >= 2 * seriesMarkerOptions.radius
	                    );

	                if (seriesMarkerOptions.enabled !== false || series._hasPointMarkers) {

	                    for (i = 0; i < points.length; i++) {
	                        point = points[i];
	                        plotY = point.plotY;
	                        graphic = point.graphic;
	                        pointMarkerOptions = point.marker || {};
	                        hasPointMarker = !!point.marker;
	                        enabled = (globallyEnabled && pointMarkerOptions.enabled === undefined) || pointMarkerOptions.enabled;
	                        isInside = point.isInside;

	                        // only draw the point if y is defined
	                        if (enabled && isNumber(plotY) && point.y !== null) {

	                            // Shortcuts
	                            symbol = pick(pointMarkerOptions.symbol, series.symbol);
	                            point.hasImage = symbol.indexOf('url') === 0;

	                            markerAttribs = series.markerAttribs(
	                                point,
	                                point.selected && 'select'
	                            );

	                            if (graphic) { // update
	                                graphic[isInside ? 'show' : 'hide'](true) // Since the marker group isn't clipped, each individual marker must be toggled
	                                    .animate(markerAttribs);
	                            } else if (isInside && (markerAttribs.width > 0 || point.hasImage)) {

	                                /**
	                                 * The graphic representation of the point. Typically
	                                 * this is a simple shape, like a `rect` for column
	                                 * charts or `path` for line markers, but for some 
	                                 * complex series types like boxplot or 3D charts, the
	                                 * graphic may be a `g` element containing other shapes.
	                                 * The graphic is generated the first time {@link
	                                 * Series#drawPoints} runs, and updated and moved on
	                                 * subsequent runs.
	                                 *
	                                 * @memberof Point
	                                 * @name graphic
	                                 * @type {SVGElement}
	                                 */
	                                point.graphic = graphic = chart.renderer.symbol(
	                                        symbol,
	                                        markerAttribs.x,
	                                        markerAttribs.y,
	                                        markerAttribs.width,
	                                        markerAttribs.height,
	                                        hasPointMarker ? pointMarkerOptions : seriesMarkerOptions
	                                    )
	                                    .add(markerGroup);
	                            }


	                            // Presentational attributes
	                            if (graphic) {
	                                graphic.attr(series.pointAttribs(point, point.selected && 'select'));
	                            }


	                            if (graphic) {
	                                graphic.addClass(point.getClassName(), true);
	                            }

	                        } else if (graphic) {
	                            point.graphic = graphic.destroy(); // #1269
	                        }
	                    }
	                }

	            },

	            /**
	             * Get non-presentational attributes for a point. Used internally for both
	             * styled mode and classic. Can be overridden for different series types.
	             *
	             * @see    Series#pointAttribs
	             *
	             * @param  {Point} point
	             *         The Point to inspect.
	             * @param  {String} [state]
	             *         The state, can be either `hover`, `select` or undefined.
	             *
	             * @return {SVGAttributes}
	             *         A hash containing those attributes that are not settable from
	             *         CSS.
	             */
	            markerAttribs: function(point, state) {
	                var seriesMarkerOptions = this.options.marker,
	                    seriesStateOptions,
	                    pointMarkerOptions = point.marker || {},
	                    pointStateOptions,
	                    radius = pick(
	                        pointMarkerOptions.radius,
	                        seriesMarkerOptions.radius
	                    ),
	                    attribs;

	                // Handle hover and select states
	                if (state) {
	                    seriesStateOptions = seriesMarkerOptions.states[state];
	                    pointStateOptions = pointMarkerOptions.states &&
	                        pointMarkerOptions.states[state];

	                    radius = pick(
	                        pointStateOptions && pointStateOptions.radius,
	                        seriesStateOptions && seriesStateOptions.radius,
	                        radius + (seriesStateOptions && seriesStateOptions.radiusPlus || 0)
	                    );
	                }

	                if (point.hasImage) {
	                    radius = 0; // and subsequently width and height is not set
	                }

	                attribs = {
	                    x: Math.floor(point.plotX) - radius, // Math.floor for #1843
	                    y: point.plotY - radius
	                };

	                if (radius) {
	                    attribs.width = attribs.height = 2 * radius;
	                }

	                return attribs;

	            },


	            /**
	             * Internal function to get presentational attributes for each point. Unlike
	             * {@link Series#markerAttribs}, this function should return those
	             * attributes that can also be set in CSS. In styled mode, `pointAttribs`
	             * won't be called.
	             *
	             * @param  {Point} point
	             *         The point instance to inspect.
	             * @param  {String} [state]
	             *         The point state, can be either `hover`, `select` or undefined for
	             *         normal state.
	             *
	             * @return {SVGAttributes}
	             *         The presentational attributes to be set on the point.
	             */
	            pointAttribs: function(point, state) {
	                var seriesMarkerOptions = this.options.marker,
	                    seriesStateOptions,
	                    pointOptions = point && point.options,
	                    pointMarkerOptions = (pointOptions && pointOptions.marker) || {},
	                    pointStateOptions,
	                    color = this.color,
	                    pointColorOption = pointOptions && pointOptions.color,
	                    pointColor = point && point.color,
	                    strokeWidth = pick(
	                        pointMarkerOptions.lineWidth,
	                        seriesMarkerOptions.lineWidth
	                    ),
	                    zoneColor = point && point.zone && point.zone.color,
	                    fill,
	                    stroke;

	                color = pointColorOption || zoneColor || pointColor || color;
	                fill = pointMarkerOptions.fillColor || seriesMarkerOptions.fillColor || color;
	                stroke = pointMarkerOptions.lineColor || seriesMarkerOptions.lineColor || color;

	                // Handle hover and select states
	                if (state) {
	                    seriesStateOptions = seriesMarkerOptions.states[state];
	                    pointStateOptions = (pointMarkerOptions.states && pointMarkerOptions.states[state]) || {};
	                    strokeWidth = pick(
	                        pointStateOptions.lineWidth,
	                        seriesStateOptions.lineWidth,
	                        strokeWidth + pick(
	                            pointStateOptions.lineWidthPlus,
	                            seriesStateOptions.lineWidthPlus,
	                            0
	                        )
	                    );
	                    fill = pointStateOptions.fillColor || seriesStateOptions.fillColor || fill;
	                    stroke = pointStateOptions.lineColor || seriesStateOptions.lineColor || stroke;
	                }

	                return {
	                    'stroke': stroke,
	                    'stroke-width': strokeWidth,
	                    'fill': fill
	                };
	            },

	            /**
	             * Clear DOM objects and free up memory.
	             *
	             * @private
	             */
	            destroy: function() {
	                var series = this,
	                    chart = series.chart,
	                    issue134 = /AppleWebKit\/533/.test(win.navigator.userAgent),
	                    destroy,
	                    i,
	                    data = series.data || [],
	                    point,
	                    axis;

	                // add event hook
	                fireEvent(series, 'destroy');

	                // remove all events
	                removeEvent(series);

	                // erase from axes
	                each(series.axisTypes || [], function(AXIS) {
	                    axis = series[AXIS];
	                    if (axis && axis.series) {
	                        erase(axis.series, series);
	                        axis.isDirty = axis.forceRedraw = true;
	                    }
	                });

	                // remove legend items
	                if (series.legendItem) {
	                    series.chart.legend.destroyItem(series);
	                }

	                // destroy all points with their elements
	                i = data.length;
	                while (i--) {
	                    point = data[i];
	                    if (point && point.destroy) {
	                        point.destroy();
	                    }
	                }
	                series.points = null;

	                // Clear the animation timeout if we are destroying the series during initial animation
	                clearTimeout(series.animationTimeout);

	                // Destroy all SVGElements associated to the series
	                objectEach(series, function(val, prop) {
	                    if (val instanceof SVGElement && !val.survive) { // Survive provides a hook for not destroying

	                        // issue 134 workaround
	                        destroy = issue134 && prop === 'group' ?
	                            'hide' :
	                            'destroy';

	                        val[destroy]();
	                    }
	                });

	                // remove from hoverSeries
	                if (chart.hoverSeries === series) {
	                    chart.hoverSeries = null;
	                }
	                erase(chart.series, series);
	                chart.orderSeries();

	                // clear all members
	                objectEach(series, function(val, prop) {
	                    delete series[prop];
	                });
	            },

	            /**
	             * Get the graph path.
	             *
	             * @private
	             */
	            getGraphPath: function(points, nullsAsZeroes, connectCliffs) {
	                var series = this,
	                    options = series.options,
	                    step = options.step,
	                    reversed,
	                    graphPath = [],
	                    xMap = [],
	                    gap;

	                points = points || series.points;

	                // Bottom of a stack is reversed
	                reversed = points.reversed;
	                if (reversed) {
	                    points.reverse();
	                }
	                // Reverse the steps (#5004)
	                step = {
	                    right: 1,
	                    center: 2
	                }[step] || (step && 3);
	                if (step && reversed) {
	                    step = 4 - step;
	                }

	                // Remove invalid points, especially in spline (#5015)
	                if (options.connectNulls && !nullsAsZeroes && !connectCliffs) {
	                    points = this.getValidPoints(points);
	                }

	                // Build the line
	                each(points, function(point, i) {

	                    var plotX = point.plotX,
	                        plotY = point.plotY,
	                        lastPoint = points[i - 1],
	                        pathToPoint; // the path to this point from the previous

	                    if ((point.leftCliff || (lastPoint && lastPoint.rightCliff)) && !connectCliffs) {
	                        gap = true; // ... and continue
	                    }

	                    // Line series, nullsAsZeroes is not handled
	                    if (point.isNull && !defined(nullsAsZeroes) && i > 0) {
	                        gap = !options.connectNulls;

	                        // Area series, nullsAsZeroes is set
	                    } else if (point.isNull && !nullsAsZeroes) {
	                        gap = true;

	                    } else {

	                        if (i === 0 || gap) {
	                            pathToPoint = ['M', point.plotX, point.plotY];

	                        } else if (series.getPointSpline) { // generate the spline as defined in the SplineSeries object

	                            pathToPoint = series.getPointSpline(points, point, i);

	                        } else if (step) {

	                            if (step === 1) { // right
	                                pathToPoint = [
	                                    'L',
	                                    lastPoint.plotX,
	                                    plotY
	                                ];

	                            } else if (step === 2) { // center
	                                pathToPoint = [
	                                    'L',
	                                    (lastPoint.plotX + plotX) / 2,
	                                    lastPoint.plotY,
	                                    'L',
	                                    (lastPoint.plotX + plotX) / 2,
	                                    plotY
	                                ];

	                            } else {
	                                pathToPoint = [
	                                    'L',
	                                    plotX,
	                                    lastPoint.plotY
	                                ];
	                            }
	                            pathToPoint.push('L', plotX, plotY);

	                        } else {
	                            // normal line to next point
	                            pathToPoint = [
	                                'L',
	                                plotX,
	                                plotY
	                            ];
	                        }

	                        // Prepare for animation. When step is enabled, there are two path nodes for each x value.
	                        xMap.push(point.x);
	                        if (step) {
	                            xMap.push(point.x);
	                        }

	                        graphPath.push.apply(graphPath, pathToPoint);
	                        gap = false;
	                    }
	                });

	                graphPath.xMap = xMap;
	                series.graphPath = graphPath;

	                return graphPath;

	            },

	            /**
	             * Draw the graph. Called internally when rendering line-like series types.
	             * The first time it generates the `series.graph` item and optionally other
	             * series-wide items like `series.area` for area charts. On subsequent calls
	             * these items are updated with new positions and attributes.
	             */
	            drawGraph: function() {
	                var series = this,
	                    options = this.options,
	                    graphPath = (this.gappedPath || this.getGraphPath).call(this),
	                    props = [
	                        [
	                            'graph',
	                            'highcharts-graph',

	                            options.lineColor || this.color,
	                            options.dashStyle

	                        ]
	                    ];

	                // Add the zone properties if any
	                each(this.zones, function(zone, i) {
	                    props.push([
	                        'zone-graph-' + i,
	                        'highcharts-graph highcharts-zone-graph-' + i + ' ' + (zone.className || ''),

	                        zone.color || series.color,
	                        zone.dashStyle || options.dashStyle

	                    ]);
	                });

	                // Draw the graph
	                each(props, function(prop, i) {
	                    var graphKey = prop[0],
	                        graph = series[graphKey],
	                        attribs;

	                    if (graph) {
	                        graph.endX = graphPath.xMap;
	                        graph.animate({
	                            d: graphPath
	                        });

	                    } else if (graphPath.length) { // #1487

	                        series[graphKey] = series.chart.renderer.path(graphPath)
	                            .addClass(prop[1])
	                            .attr({
	                                zIndex: 1
	                            }) // #1069
	                            .add(series.group);


	                        attribs = {
	                            'stroke': prop[2],
	                            'stroke-width': options.lineWidth,
	                            'fill': (series.fillGraph && series.color) || 'none' // Polygon series use filled graph
	                        };

	                        if (prop[3]) {
	                            attribs.dashstyle = prop[3];
	                        } else if (options.linecap !== 'square') {
	                            attribs['stroke-linecap'] = attribs['stroke-linejoin'] = 'round';
	                        }

	                        graph = series[graphKey]
	                            .attr(attribs)
	                            .shadow((i < 2) && options.shadow); // add shadow to normal series (0) or to first zone (1) #3932

	                    }

	                    // Helpers for animation
	                    if (graph) {
	                        graph.startX = graphPath.xMap;
	                        //graph.shiftUnit = options.step ? 2 : 1;
	                        graph.isArea = graphPath.isArea; // For arearange animation
	                    }
	                });
	            },

	            /**
	             * Clip the graphs into zones for colors and styling.
	             *
	             * @private
	             */
	            applyZones: function() {
	                var series = this,
	                    chart = this.chart,
	                    renderer = chart.renderer,
	                    zones = this.zones,
	                    translatedFrom,
	                    translatedTo,
	                    clips = this.clips || [],
	                    clipAttr,
	                    graph = this.graph,
	                    area = this.area,
	                    chartSizeMax = Math.max(chart.chartWidth, chart.chartHeight),
	                    axis = this[(this.zoneAxis || 'y') + 'Axis'],
	                    extremes,
	                    reversed,
	                    inverted = chart.inverted,
	                    horiz,
	                    pxRange,
	                    pxPosMin,
	                    pxPosMax,
	                    ignoreZones = false;

	                if (zones.length && (graph || area) && axis && axis.min !== undefined) {
	                    reversed = axis.reversed;
	                    horiz = axis.horiz;
	                    // The use of the Color Threshold assumes there are no gaps
	                    // so it is safe to hide the original graph and area
	                    if (graph) {
	                        graph.hide();
	                    }
	                    if (area) {
	                        area.hide();
	                    }

	                    // Create the clips
	                    extremes = axis.getExtremes();
	                    each(zones, function(threshold, i) {

	                        translatedFrom = reversed ?
	                            (horiz ? chart.plotWidth : 0) :
	                            (horiz ? 0 : axis.toPixels(extremes.min));
	                        translatedFrom = Math.min(Math.max(pick(translatedTo, translatedFrom), 0), chartSizeMax);
	                        translatedTo = Math.min(Math.max(Math.round(axis.toPixels(pick(threshold.value, extremes.max), true)), 0), chartSizeMax);

	                        if (ignoreZones) {
	                            translatedFrom = translatedTo = axis.toPixels(extremes.max);
	                        }

	                        pxRange = Math.abs(translatedFrom - translatedTo);
	                        pxPosMin = Math.min(translatedFrom, translatedTo);
	                        pxPosMax = Math.max(translatedFrom, translatedTo);
	                        if (axis.isXAxis) {
	                            clipAttr = {
	                                x: inverted ? pxPosMax : pxPosMin,
	                                y: 0,
	                                width: pxRange,
	                                height: chartSizeMax
	                            };
	                            if (!horiz) {
	                                clipAttr.x = chart.plotHeight - clipAttr.x;
	                            }
	                        } else {
	                            clipAttr = {
	                                x: 0,
	                                y: inverted ? pxPosMax : pxPosMin,
	                                width: chartSizeMax,
	                                height: pxRange
	                            };
	                            if (horiz) {
	                                clipAttr.y = chart.plotWidth - clipAttr.y;
	                            }
	                        }


	                        /// VML SUPPPORT
	                        if (inverted && renderer.isVML) {
	                            if (axis.isXAxis) {
	                                clipAttr = {
	                                    x: 0,
	                                    y: reversed ? pxPosMin : pxPosMax,
	                                    height: clipAttr.width,
	                                    width: chart.chartWidth
	                                };
	                            } else {
	                                clipAttr = {
	                                    x: clipAttr.y - chart.plotLeft - chart.spacingBox.x,
	                                    y: 0,
	                                    width: clipAttr.height,
	                                    height: chart.chartHeight
	                                };
	                            }
	                        }
	                        /// END OF VML SUPPORT


	                        if (clips[i]) {
	                            clips[i].animate(clipAttr);
	                        } else {
	                            clips[i] = renderer.clipRect(clipAttr);

	                            if (graph) {
	                                series['zone-graph-' + i].clip(clips[i]);
	                            }

	                            if (area) {
	                                series['zone-area-' + i].clip(clips[i]);
	                            }
	                        }
	                        // if this zone extends out of the axis, ignore the others
	                        ignoreZones = threshold.value > extremes.max;
	                    });
	                    this.clips = clips;
	                }
	            },

	            /**
	             * Initialize and perform group inversion on series.group and
	             * series.markerGroup.
	             *
	             * @private
	             */
	            invertGroups: function(inverted) {
	                var series = this,
	                    chart = series.chart,
	                    remover;

	                function setInvert() {
	                    each(['group', 'markerGroup'], function(groupName) {
	                        if (series[groupName]) {

	                            // VML/HTML needs explicit attributes for flipping
	                            if (chart.renderer.isVML) {
	                                series[groupName].attr({
	                                    width: series.yAxis.len,
	                                    height: series.xAxis.len
	                                });
	                            }

	                            series[groupName].width = series.yAxis.len;
	                            series[groupName].height = series.xAxis.len;
	                            series[groupName].invert(inverted);
	                        }
	                    });
	                }

	                // Pie, go away (#1736)
	                if (!series.xAxis) {
	                    return;
	                }

	                // A fixed size is needed for inversion to work
	                remover = addEvent(chart, 'resize', setInvert);
	                addEvent(series, 'destroy', remover);

	                // Do it now
	                setInvert(inverted); // do it now

	                // On subsequent render and redraw, just do setInvert without setting up events again
	                series.invertGroups = setInvert;
	            },

	            /**
	             * General abstraction for creating plot groups like series.group,
	             * series.dataLabelsGroup and series.markerGroup. On subsequent calls, the
	             * group will only be adjusted to the updated plot size.
	             *
	             * @private
	             */
	            plotGroup: function(prop, name, visibility, zIndex, parent) {
	                var group = this[prop],
	                    isNew = !group;

	                // Generate it on first call
	                if (isNew) {
	                    this[prop] = group = this.chart.renderer.g()
	                        .attr({
	                            zIndex: zIndex || 0.1 // IE8 and pointer logic use this
	                        })
	                        .add(parent);

	                }

	                // Add the class names, and replace existing ones as response to
	                // Series.update (#6660)
	                group.addClass(
	                    (
	                        'highcharts-' + name +
	                        ' highcharts-series-' + this.index +
	                        ' highcharts-' + this.type + '-series ' +
	                        'highcharts-color-' + this.colorIndex + ' ' +
	                        (this.options.className || '')
	                    ),
	                    true
	                );

	                // Place it on first and subsequent (redraw) calls
	                group.attr({
	                    visibility: visibility
	                })[isNew ? 'attr' : 'animate'](
	                    this.getPlotBox()
	                );
	                return group;
	            },

	            /**
	             * Get the translation and scale for the plot area of this series.
	             */
	            getPlotBox: function() {
	                var chart = this.chart,
	                    xAxis = this.xAxis,
	                    yAxis = this.yAxis;

	                // Swap axes for inverted (#2339)
	                if (chart.inverted) {
	                    xAxis = yAxis;
	                    yAxis = this.xAxis;
	                }
	                return {
	                    translateX: xAxis ? xAxis.left : chart.plotLeft,
	                    translateY: yAxis ? yAxis.top : chart.plotTop,
	                    scaleX: 1, // #1623
	                    scaleY: 1
	                };
	            },

	            /**
	             * Render the graph and markers. Called internally when first rendering and
	             * later when redrawing the chart. This function can be extended in plugins,
	             * but normally shouldn't be called directly.
	             */
	            render: function() {
	                var series = this,
	                    chart = series.chart,
	                    group,
	                    options = series.options,
	                    // Animation doesn't work in IE8 quirks when the group div is
	                    // hidden, and looks bad in other oldIE
	                    animDuration = (!!series.animate &&
	                        chart.renderer.isSVG &&
	                        animObject(options.animation).duration
	                    ),
	                    visibility = series.visible ? 'inherit' : 'hidden', // #2597
	                    zIndex = options.zIndex,
	                    hasRendered = series.hasRendered,
	                    chartSeriesGroup = chart.seriesGroup,
	                    inverted = chart.inverted;

	                // the group
	                group = series.plotGroup(
	                    'group',
	                    'series',
	                    visibility,
	                    zIndex,
	                    chartSeriesGroup
	                );

	                series.markerGroup = series.plotGroup(
	                    'markerGroup',
	                    'markers',
	                    visibility,
	                    zIndex,
	                    chartSeriesGroup
	                );

	                // initiate the animation
	                if (animDuration) {
	                    series.animate(true);
	                }

	                // SVGRenderer needs to know this before drawing elements (#1089, #1795)
	                group.inverted = series.isCartesian ? inverted : false;

	                // draw the graph if any
	                if (series.drawGraph) {
	                    series.drawGraph();
	                    series.applyZones();
	                }

	                /*      each(series.points, function (point) {
	                            if (point.redraw) {
	                                point.redraw();
	                            }
	                        });*/

	                // draw the data labels (inn pies they go before the points)
	                if (series.drawDataLabels) {
	                    series.drawDataLabels();
	                }

	                // draw the points
	                if (series.visible) {
	                    series.drawPoints();
	                }


	                // draw the mouse tracking area
	                if (
	                    series.drawTracker &&
	                    series.options.enableMouseTracking !== false
	                ) {
	                    series.drawTracker();
	                }

	                // Handle inverted series and tracker groups
	                series.invertGroups(inverted);

	                // Initial clipping, must be defined after inverting groups for VML.
	                // Applies to columns etc. (#3839).
	                if (options.clip !== false && !series.sharedClipKey && !hasRendered) {
	                    group.clip(chart.clipRect);
	                }

	                // Run the animation
	                if (animDuration) {
	                    series.animate();
	                }

	                // Call the afterAnimate function on animation complete (but don't
	                // overwrite the animation.complete option which should be available to
	                // the user).
	                if (!hasRendered) {
	                    series.animationTimeout = syncTimeout(function() {
	                        series.afterAnimate();
	                    }, animDuration);
	                }

	                series.isDirty = false; // means data is in accordance with what you see
	                // (See #322) series.isDirty = series.isDirtyData = false; // means
	                // data is in accordance with what you see
	                series.hasRendered = true;
	            },

	            /**
	             * Redraw the series. This function is called internally from `chart.redraw`
	             * and normally shouldn't be called directly.
	             *
	             * @private
	             */
	            redraw: function() {
	                var series = this,
	                    chart = series.chart,
	                    // cache it here as it is set to false in render, but used after
	                    wasDirty = series.isDirty || series.isDirtyData,
	                    group = series.group,
	                    xAxis = series.xAxis,
	                    yAxis = series.yAxis;

	                // reposition on resize
	                if (group) {
	                    if (chart.inverted) {
	                        group.attr({
	                            width: chart.plotWidth,
	                            height: chart.plotHeight
	                        });
	                    }

	                    group.animate({
	                        translateX: pick(xAxis && xAxis.left, chart.plotLeft),
	                        translateY: pick(yAxis && yAxis.top, chart.plotTop)
	                    });
	                }

	                series.translate();
	                series.render();
	                if (wasDirty) { // #3868, #3945
	                    delete this.kdTree;
	                }
	            },

	            kdAxisArray: ['clientX', 'plotY'],

	            searchPoint: function(e, compareX) {
	                var series = this,
	                    xAxis = series.xAxis,
	                    yAxis = series.yAxis,
	                    inverted = series.chart.inverted;

	                return this.searchKDTree({
	                    clientX: inverted ?
	                        xAxis.len - e.chartY + xAxis.pos : e.chartX - xAxis.pos,
	                    plotY: inverted ?
	                        yAxis.len - e.chartX + yAxis.pos : e.chartY - yAxis.pos
	                }, compareX);
	            },

	            /**
	             * Build the k-d-tree that is used by mouse and touch interaction to get the
	             * closest point. Line-like series typically have a one-dimensional tree
	             * where points are searched along the X axis, while scatter-like series
	             * typically search in two dimensions, X and Y.
	             *
	             * @private
	             */
	            buildKDTree: function() {

	                // Prevent multiple k-d-trees from being built simultaneously (#6235)
	                this.buildingKdTree = true;

	                var series = this,
	                    dimensions = series.options.findNearestPointBy.indexOf('y') > -1 ?
	                    2 : 1;

	                // Internal function
	                function _kdtree(points, depth, dimensions) {
	                    var axis,
	                        median,
	                        length = points && points.length;

	                    if (length) {

	                        // alternate between the axis
	                        axis = series.kdAxisArray[depth % dimensions];

	                        // sort point array
	                        points.sort(function(a, b) {
	                            return a[axis] - b[axis];
	                        });

	                        median = Math.floor(length / 2);

	                        // build and return nod
	                        return {
	                            point: points[median],
	                            left: _kdtree(
	                                points.slice(0, median), depth + 1, dimensions
	                            ),
	                            right: _kdtree(
	                                points.slice(median + 1), depth + 1, dimensions
	                            )
	                        };

	                    }
	                }

	                // Start the recursive build process with a clone of the points array
	                // and null points filtered out (#3873)
	                function startRecursive() {
	                    series.kdTree = _kdtree(
	                        series.getValidPoints(
	                            null,
	                            // For line-type series restrict to plot area, but
	                            // column-type series not (#3916, #4511)
	                            !series.directTouch
	                        ),
	                        dimensions,
	                        dimensions
	                    );
	                    series.buildingKdTree = false;
	                }
	                delete series.kdTree;

	                // For testing tooltips, don't build async
	                syncTimeout(startRecursive, series.options.kdNow ? 0 : 1);
	            },

	            searchKDTree: function(point, compareX) {
	                var series = this,
	                    kdX = this.kdAxisArray[0],
	                    kdY = this.kdAxisArray[1],
	                    kdComparer = compareX ? 'distX' : 'dist',
	                    kdDimensions = series.options.findNearestPointBy.indexOf('y') > -1 ?
	                    2 : 1;

	                // Set the one and two dimensional distance on the point object
	                function setDistance(p1, p2) {
	                    var x = (defined(p1[kdX]) && defined(p2[kdX])) ?
	                        Math.pow(p1[kdX] - p2[kdX], 2) :
	                        null,
	                        y = (defined(p1[kdY]) && defined(p2[kdY])) ?
	                        Math.pow(p1[kdY] - p2[kdY], 2) :
	                        null,
	                        r = (x || 0) + (y || 0);

	                    p2.dist = defined(r) ? Math.sqrt(r) : Number.MAX_VALUE;
	                    p2.distX = defined(x) ? Math.sqrt(x) : Number.MAX_VALUE;
	                }

	                function _search(search, tree, depth, dimensions) {
	                    var point = tree.point,
	                        axis = series.kdAxisArray[depth % dimensions],
	                        tdist,
	                        sideA,
	                        sideB,
	                        ret = point,
	                        nPoint1,
	                        nPoint2;

	                    setDistance(search, point);

	                    // Pick side based on distance to splitting point
	                    tdist = search[axis] - point[axis];
	                    sideA = tdist < 0 ? 'left' : 'right';
	                    sideB = tdist < 0 ? 'right' : 'left';

	                    // End of tree
	                    if (tree[sideA]) {
	                        nPoint1 = _search(search, tree[sideA], depth + 1, dimensions);

	                        ret = (nPoint1[kdComparer] < ret[kdComparer] ? nPoint1 : point);
	                    }
	                    if (tree[sideB]) {
	                        // compare distance to current best to splitting point to decide
	                        // wether to check side B or not
	                        if (Math.sqrt(tdist * tdist) < ret[kdComparer]) {
	                            nPoint2 = _search(
	                                search,
	                                tree[sideB],
	                                depth + 1,
	                                dimensions
	                            );
	                            ret = nPoint2[kdComparer] < ret[kdComparer] ?
	                                nPoint2 :
	                                ret;
	                        }
	                    }

	                    return ret;
	                }

	                if (!this.kdTree && !this.buildingKdTree) {
	                    this.buildKDTree();
	                }

	                if (this.kdTree) {
	                    return _search(point, this.kdTree, kdDimensions, kdDimensions);
	                }
	            }

	        }); // end Series prototype

	    }(Highcharts));
	    (function(H) {
	        /**
	         * (c) 2010-2017 Torstein Honsi
	         *
	         * License: www.highcharts.com/license
	         */
	        var Axis = H.Axis,
	            Chart = H.Chart,
	            correctFloat = H.correctFloat,
	            defined = H.defined,
	            destroyObjectProperties = H.destroyObjectProperties,
	            each = H.each,
	            format = H.format,
	            objectEach = H.objectEach,
	            pick = H.pick,
	            Series = H.Series;

	        /**
	         * The class for stacks. Each stack, on a specific X value and either negative
	         * or positive, has its own stack item.
	         *
	         * @class
	         */
	        H.StackItem = function(axis, options, isNegative, x, stackOption) {

	            var inverted = axis.chart.inverted;

	            this.axis = axis;

	            // Tells if the stack is negative
	            this.isNegative = isNegative;

	            // Save the options to be able to style the label
	            this.options = options;

	            // Save the x value to be able to position the label later
	            this.x = x;

	            // Initialize total value
	            this.total = null;

	            // This will keep each points' extremes stored by series.index and point 
	            // index
	            this.points = {};

	            // Save the stack option on the series configuration object, and whether to 
	            // treat it as percent
	            this.stack = stackOption;
	            this.leftCliff = 0;
	            this.rightCliff = 0;

	            // The align options and text align varies on whether the stack is negative 
	            // and if the chart is inverted or not.
	            // First test the user supplied value, then use the dynamic.
	            this.alignOptions = {
	                align: options.align ||
	                    (inverted ? (isNegative ? 'left' : 'right') : 'center'),
	                verticalAlign: options.verticalAlign ||
	                    (inverted ? 'middle' : (isNegative ? 'bottom' : 'top')),
	                y: pick(options.y, inverted ? 4 : (isNegative ? 14 : -6)),
	                x: pick(options.x, inverted ? (isNegative ? -6 : 6) : 0)
	            };

	            this.textAlign = options.textAlign ||
	                (inverted ? (isNegative ? 'right' : 'left') : 'center');
	        };

	        H.StackItem.prototype = {
	            destroy: function() {
	                destroyObjectProperties(this, this.axis);
	            },

	            /**
	             * Renders the stack total label and adds it to the stack label group.
	             */
	            render: function(group) {
	                var options = this.options,
	                    formatOption = options.format,
	                    str = formatOption ?
	                    format(formatOption, this) :
	                    options.formatter.call(this); // format the text in the label

	                // Change the text to reflect the new total and set visibility to hidden
	                // in case the serie is hidden
	                if (this.label) {
	                    this.label.attr({
	                        text: str,
	                        visibility: 'hidden'
	                    });
	                    // Create new label
	                } else {
	                    this.label =
	                        this.axis.chart.renderer.text(str, null, null, options.useHTML)
	                        .css(options.style)
	                        .attr({
	                            align: this.textAlign,
	                            rotation: options.rotation,
	                            visibility: 'hidden' // hidden until setOffset is called
	                        })
	                        .add(group); // add to the labels-group
	                }
	            },

	            /**
	             * Sets the offset that the stack has from the x value and repositions the
	             * label.
	             */
	            setOffset: function(xOffset, xWidth) {
	                var stackItem = this,
	                    axis = stackItem.axis,
	                    chart = axis.chart,
	                    // stack value translated mapped to chart coordinates
	                    y = axis.translate(
	                        axis.usePercentage ? 100 : stackItem.total,
	                        0,
	                        0,
	                        0,
	                        1
	                    ),
	                    yZero = axis.translate(0), // stack origin
	                    h = Math.abs(y - yZero), // stack height
	                    x = chart.xAxis[0].translate(stackItem.x) + xOffset, // stack x position
	                    stackBox = stackItem.getStackBox(chart, stackItem, x, y, xWidth, h),
	                    label = stackItem.label,
	                    alignAttr;

	                if (label) {
	                    // Align the label to the box
	                    label.align(stackItem.alignOptions, null, stackBox);

	                    // Set visibility (#678)
	                    alignAttr = label.alignAttr;
	                    label[
	                        stackItem.options.crop === false || chart.isInsidePlot(
	                            alignAttr.x,
	                            alignAttr.y
	                        ) ? 'show' : 'hide'](true);
	                }
	            },
	            getStackBox: function(chart, stackItem, x, y, xWidth, h) {
	                var reversed = stackItem.axis.reversed,
	                    inverted = chart.inverted,
	                    plotHeight = chart.plotHeight,
	                    neg = (stackItem.isNegative && !reversed) ||
	                    (!stackItem.isNegative && reversed); // #4056

	                return { // this is the box for the complete stack
	                    x: inverted ? (neg ? y : y - h) : x,
	                    y: inverted ?
	                        plotHeight - x - xWidth :
	                        (neg ?
	                            (plotHeight - y - h) :
	                            plotHeight - y
	                        ),
	                    width: inverted ? h : xWidth,
	                    height: inverted ? xWidth : h
	                };
	            }
	        };

	        /**
	         * Generate stacks for each series and calculate stacks total values
	         */
	        Chart.prototype.getStacks = function() {
	            var chart = this;

	            // reset stacks for each yAxis
	            each(chart.yAxis, function(axis) {
	                if (axis.stacks && axis.hasVisibleSeries) {
	                    axis.oldStacks = axis.stacks;
	                }
	            });

	            each(chart.series, function(series) {
	                if (series.options.stacking && (series.visible === true ||
	                        chart.options.chart.ignoreHiddenSeries === false)) {
	                    series.stackKey = series.type + pick(series.options.stack, '');
	                }
	            });
	        };


	        // Stacking methods defined on the Axis prototype

	        /**
	         * Build the stacks from top down
	         */
	        Axis.prototype.buildStacks = function() {
	            var axisSeries = this.series,
	                reversedStacks = pick(this.options.reversedStacks, true),
	                len = axisSeries.length,
	                i;
	            if (!this.isXAxis) {
	                this.usePercentage = false;
	                i = len;
	                while (i--) {
	                    axisSeries[reversedStacks ? i : len - i - 1].setStackedPoints();
	                }

	                // Loop up again to compute percent stack
	                if (this.usePercentage) {
	                    for (i = 0; i < len; i++) {
	                        axisSeries[i].setPercentStacks();
	                    }
	                }
	            }
	        };

	        Axis.prototype.renderStackTotals = function() {
	            var axis = this,
	                chart = axis.chart,
	                renderer = chart.renderer,
	                stacks = axis.stacks,
	                stackTotalGroup = axis.stackTotalGroup;

	            // Create a separate group for the stack total labels
	            if (!stackTotalGroup) {
	                axis.stackTotalGroup = stackTotalGroup =
	                    renderer.g('stack-labels')
	                    .attr({
	                        visibility: 'visible',
	                        zIndex: 6
	                    })
	                    .add();
	            }

	            // plotLeft/Top will change when y axis gets wider so we need to translate
	            // the stackTotalGroup at every render call. See bug #506 and #516
	            stackTotalGroup.translate(chart.plotLeft, chart.plotTop);

	            // Render each stack total
	            objectEach(stacks, function(type) {
	                objectEach(type, function(stack) {
	                    stack.render(stackTotalGroup);
	                });
	            });
	        };

	        /**
	         * Set all the stacks to initial states and destroy unused ones.
	         */
	        Axis.prototype.resetStacks = function() {
	            var axis = this,
	                stacks = axis.stacks;
	            if (!axis.isXAxis) {
	                objectEach(stacks, function(type) {
	                    objectEach(type, function(stack, key) {
	                        // Clean up memory after point deletion (#1044, #4320)
	                        if (stack.touched < axis.stacksTouched) {
	                            stack.destroy();
	                            delete type[key];

	                            // Reset stacks
	                        } else {
	                            stack.total = null;
	                            stack.cum = null;
	                        }
	                    });
	                });
	            }
	        };

	        Axis.prototype.cleanStacks = function() {
	            var stacks;

	            if (!this.isXAxis) {
	                if (this.oldStacks) {
	                    stacks = this.stacks = this.oldStacks;
	                }

	                // reset stacks
	                objectEach(stacks, function(type) {
	                    objectEach(type, function(stack) {
	                        stack.cum = stack.total;
	                    });
	                });
	            }
	        };


	        // Stacking methods defnied for Series prototype

	        /**
	         * Adds series' points value to corresponding stack
	         */
	        Series.prototype.setStackedPoints = function() {
	            if (!this.options.stacking || (this.visible !== true &&
	                    this.chart.options.chart.ignoreHiddenSeries !== false)) {
	                return;
	            }

	            var series = this,
	                xData = series.processedXData,
	                yData = series.processedYData,
	                stackedYData = [],
	                yDataLength = yData.length,
	                seriesOptions = series.options,
	                threshold = seriesOptions.threshold,
	                stackThreshold = seriesOptions.startFromThreshold ? threshold : 0,
	                stackOption = seriesOptions.stack,
	                stacking = seriesOptions.stacking,
	                stackKey = series.stackKey,
	                negKey = '-' + stackKey,
	                negStacks = series.negStacks,
	                yAxis = series.yAxis,
	                stacks = yAxis.stacks,
	                oldStacks = yAxis.oldStacks,
	                stackIndicator,
	                isNegative,
	                stack,
	                other,
	                key,
	                pointKey,
	                i,
	                x,
	                y;


	            yAxis.stacksTouched += 1;

	            // loop over the non-null y values and read them into a local array
	            for (i = 0; i < yDataLength; i++) {
	                x = xData[i];
	                y = yData[i];
	                stackIndicator = series.getStackIndicator(
	                    stackIndicator,
	                    x,
	                    series.index
	                );
	                pointKey = stackIndicator.key;
	                // Read stacked values into a stack based on the x value,
	                // the sign of y and the stack key. Stacking is also handled for null
	                // values (#739)
	                isNegative = negStacks && y < (stackThreshold ? 0 : threshold);
	                key = isNegative ? negKey : stackKey;

	                // Create empty object for this stack if it doesn't exist yet
	                if (!stacks[key]) {
	                    stacks[key] = {};
	                }

	                // Initialize StackItem for this x
	                if (!stacks[key][x]) {
	                    if (oldStacks[key] && oldStacks[key][x]) {
	                        stacks[key][x] = oldStacks[key][x];
	                        stacks[key][x].total = null;
	                    } else {
	                        stacks[key][x] = new H.StackItem(
	                            yAxis,
	                            yAxis.options.stackLabels,
	                            isNegative,
	                            x,
	                            stackOption
	                        );
	                    }
	                }

	                // If the StackItem doesn't exist, create it first
	                stack = stacks[key][x];
	                if (y !== null) {
	                    stack.points[pointKey] = stack.points[series.index] = [pick(stack.cum, stackThreshold)];

	                    // Record the base of the stack
	                    if (!defined(stack.cum)) {
	                        stack.base = pointKey;
	                    }
	                    stack.touched = yAxis.stacksTouched;


	                    // In area charts, if there are multiple points on the same X value,
	                    // let the area fill the full span of those points
	                    if (stackIndicator.index > 0 && series.singleStacks === false) {
	                        stack.points[pointKey][0] =
	                            stack.points[series.index + ',' + x + ',0'][0];
	                    }
	                }

	                // Add value to the stack total
	                if (stacking === 'percent') {

	                    // Percent stacked column, totals are the same for the positive and
	                    // negative stacks
	                    other = isNegative ? stackKey : negKey;
	                    if (negStacks && stacks[other] && stacks[other][x]) {
	                        other = stacks[other][x];
	                        stack.total = other.total =
	                            Math.max(other.total, stack.total) + Math.abs(y) || 0;

	                        // Percent stacked areas
	                    } else {
	                        stack.total = correctFloat(stack.total + (Math.abs(y) || 0));
	                    }
	                } else {
	                    stack.total = correctFloat(stack.total + (y || 0));
	                }

	                stack.cum = pick(stack.cum, stackThreshold) + (y || 0);

	                if (y !== null) {
	                    stack.points[pointKey].push(stack.cum);
	                    stackedYData[i] = stack.cum;
	                }

	            }

	            if (stacking === 'percent') {
	                yAxis.usePercentage = true;
	            }

	            this.stackedYData = stackedYData; // To be used in getExtremes

	            // Reset old stacks
	            yAxis.oldStacks = {};
	        };

	        /**
	         * Iterate over all stacks and compute the absolute values to percent
	         */
	        Series.prototype.setPercentStacks = function() {
	            var series = this,
	                stackKey = series.stackKey,
	                stacks = series.yAxis.stacks,
	                processedXData = series.processedXData,
	                stackIndicator;

	            each([stackKey, '-' + stackKey], function(key) {
	                var i = processedXData.length,
	                    x,
	                    stack,
	                    pointExtremes,
	                    totalFactor;

	                while (i--) {
	                    x = processedXData[i];
	                    stackIndicator = series.getStackIndicator(
	                        stackIndicator,
	                        x,
	                        series.index,
	                        key
	                    );
	                    stack = stacks[key] && stacks[key][x];
	                    pointExtremes = stack && stack.points[stackIndicator.key];
	                    if (pointExtremes) {
	                        totalFactor = stack.total ? 100 / stack.total : 0;
	                        // Y bottom value
	                        pointExtremes[0] = correctFloat(pointExtremes[0] * totalFactor);
	                        // Y value
	                        pointExtremes[1] = correctFloat(pointExtremes[1] * totalFactor);
	                        series.stackedYData[i] = pointExtremes[1];
	                    }
	                }
	            });
	        };

	        /**
	         * Get stack indicator, according to it's x-value, to determine points with the
	         * same x-value
	         */
	        Series.prototype.getStackIndicator = function(stackIndicator, x, index, key) {
	            // Update stack indicator, when:
	            // first point in a stack || x changed || stack type (negative vs positive)
	            // changed:
	            if (!defined(stackIndicator) || stackIndicator.x !== x ||
	                (key && stackIndicator.key !== key)) {
	                stackIndicator = {
	                    x: x,
	                    index: 0,
	                    key: key
	                };
	            } else {
	                stackIndicator.index++;
	            }

	            stackIndicator.key = [index, x, stackIndicator.index].join(',');

	            return stackIndicator;
	        };

	    }(Highcharts));
	    (function(H) {
	        /**
	         * (c) 2010-2017 Torstein Honsi
	         *
	         * License: www.highcharts.com/license
	         */
	        var addEvent = H.addEvent,
	            animate = H.animate,
	            Axis = H.Axis,
	            Chart = H.Chart,
	            createElement = H.createElement,
	            css = H.css,
	            defined = H.defined,
	            each = H.each,
	            erase = H.erase,
	            extend = H.extend,
	            fireEvent = H.fireEvent,
	            inArray = H.inArray,
	            isNumber = H.isNumber,
	            isObject = H.isObject,
	            isArray = H.isArray,
	            merge = H.merge,
	            objectEach = H.objectEach,
	            pick = H.pick,
	            Point = H.Point,
	            Series = H.Series,
	            seriesTypes = H.seriesTypes,
	            setAnimation = H.setAnimation,
	            splat = H.splat;

	        // Extend the Chart prototype for dynamic methods
	        extend(Chart.prototype, /** @lends Highcharts.Chart.prototype */ {

	            /**
	             * Add a series to the chart after render time. Note that this method should
	             * never be used when adding data synchronously at chart render time, as it
	             * adds expense to the calculations and rendering. When adding data at the
	             * same time as the chart is initialized, add the series as a configuration
	             * option instead. With multiple axes, the `offset` is dynamically adjusted.
	             *
	             * @param  {SeriesOptions} options
	             *         The config options for the series.
	             * @param  {Boolean} [redraw=true]
	             *         Whether to redraw the chart after adding.
	             * @param  {AnimationOptions} animation
	             *         Whether to apply animation, and optionally animation
	             *         configuration.
	             *
	             * @return {Highcharts.Series}
	             *         The newly created series object.
	             *
	             * @sample highcharts/members/chart-addseries/
	             *         Add a series from a button
	             * @sample stock/members/chart-addseries/
	             *         Add a series in Highstock
	             */
	            addSeries: function(options, redraw, animation) {
	                var series,
	                    chart = this;

	                if (options) {
	                    redraw = pick(redraw, true); // defaults to true

	                    fireEvent(chart, 'addSeries', {
	                        options: options
	                    }, function() {
	                        series = chart.initSeries(options);

	                        chart.isDirtyLegend = true; // the series array is out of sync with the display
	                        chart.linkSeries();
	                        if (redraw) {
	                            chart.redraw(animation);
	                        }
	                    });
	                }

	                return series;
	            },

	            /**
	             * Add an axis to the chart after render time. Note that this method should
	             * never be used when adding data synchronously at chart render time, as it
	             * adds expense to the calculations and rendering. When adding data at the
	             * same time as the chart is initialized, add the axis as a configuration
	             * option instead.
	             * @param  {AxisOptions} options
	             *         The axis options.
	             * @param  {Boolean} [isX=false]
	             *         Whether it is an X axis or a value axis.
	             * @param  {Boolean} [redraw=true]
	             *         Whether to redraw the chart after adding.
	             * @param  {AnimationOptions} [animation=true]
	             *         Whether and how to apply animation in the redraw.
	             *
	             * @sample highcharts/members/chart-addaxis/ Add and remove axes
	             *
	             * @return {Axis}
	             *         The newly generated Axis object.
	             */
	            addAxis: function(options, isX, redraw, animation) {
	                var key = isX ? 'xAxis' : 'yAxis',
	                    chartOptions = this.options,
	                    userOptions = merge(options, {
	                        index: this[key].length,
	                        isX: isX
	                    }),
	                    axis;

	                axis = new Axis(this, userOptions);

	                // Push the new axis options to the chart options
	                chartOptions[key] = splat(chartOptions[key] || {});
	                chartOptions[key].push(userOptions);

	                if (pick(redraw, true)) {
	                    this.redraw(animation);
	                }

	                return axis;
	            },

	            /**
	             * Dim the chart and show a loading text or symbol. Options for the loading
	             * screen are defined in {@link
	             * https://api.highcharts.com/highcharts/loading|the loading options}.
	             * 
	             * @param  {String} str
	             *         An optional text to show in the loading label instead of the
	             *         default one. The default text is set in {@link
	             *         http://api.highcharts.com/highcharts/lang.loading|lang.loading}.
	             *
	             * @sample highcharts/members/chart-hideloading/
	             *         Show and hide loading from a button
	             * @sample highcharts/members/chart-showloading/
	             *         Apply different text labels
	             * @sample stock/members/chart-show-hide-loading/
	             *         Toggle loading in Highstock
	             */
	            showLoading: function(str) {
	                var chart = this,
	                    options = chart.options,
	                    loadingDiv = chart.loadingDiv,
	                    loadingOptions = options.loading,
	                    setLoadingSize = function() {
	                        if (loadingDiv) {
	                            css(loadingDiv, {
	                                left: chart.plotLeft + 'px',
	                                top: chart.plotTop + 'px',
	                                width: chart.plotWidth + 'px',
	                                height: chart.plotHeight + 'px'
	                            });
	                        }
	                    };

	                // create the layer at the first call
	                if (!loadingDiv) {
	                    chart.loadingDiv = loadingDiv = createElement('div', {
	                        className: 'highcharts-loading highcharts-loading-hidden'
	                    }, null, chart.container);

	                    chart.loadingSpan = createElement(
	                        'span', {
	                            className: 'highcharts-loading-inner'
	                        },
	                        null,
	                        loadingDiv
	                    );
	                    addEvent(chart, 'redraw', setLoadingSize); // #1080
	                }

	                loadingDiv.className = 'highcharts-loading';

	                // Update text
	                chart.loadingSpan.innerHTML = str || options.lang.loading;


	                // Update visuals
	                css(loadingDiv, extend(loadingOptions.style, {
	                    zIndex: 10
	                }));
	                css(chart.loadingSpan, loadingOptions.labelStyle);

	                // Show it
	                if (!chart.loadingShown) {
	                    css(loadingDiv, {
	                        opacity: 0,
	                        display: ''
	                    });
	                    animate(loadingDiv, {
	                        opacity: loadingOptions.style.opacity || 0.5
	                    }, {
	                        duration: loadingOptions.showDuration || 0
	                    });
	                }


	                chart.loadingShown = true;
	                setLoadingSize();
	            },

	            /**
	             * Hide the loading layer.
	             *
	             * @see    Highcharts.Chart#showLoading
	             * @sample highcharts/members/chart-hideloading/
	             *         Show and hide loading from a button
	             * @sample stock/members/chart-show-hide-loading/
	             *         Toggle loading in Highstock
	             */
	            hideLoading: function() {
	                var options = this.options,
	                    loadingDiv = this.loadingDiv;

	                if (loadingDiv) {
	                    loadingDiv.className = 'highcharts-loading highcharts-loading-hidden';

	                    animate(loadingDiv, {
	                        opacity: 0
	                    }, {
	                        duration: options.loading.hideDuration || 100,
	                        complete: function() {
	                            css(loadingDiv, {
	                                display: 'none'
	                            });
	                        }
	                    });

	                }
	                this.loadingShown = false;
	            },

	            /** 
	             * These properties cause isDirtyBox to be set to true when updating. Can be extended from plugins.
	             */
	            propsRequireDirtyBox: ['backgroundColor', 'borderColor', 'borderWidth', 'margin', 'marginTop', 'marginRight',
	                'marginBottom', 'marginLeft', 'spacing', 'spacingTop', 'spacingRight', 'spacingBottom', 'spacingLeft',
	                'borderRadius', 'plotBackgroundColor', 'plotBackgroundImage', 'plotBorderColor', 'plotBorderWidth',
	                'plotShadow', 'shadow'
	            ],

	            /** 
	             * These properties cause all series to be updated when updating. Can be
	             * extended from plugins.
	             */
	            propsRequireUpdateSeries: ['chart.inverted', 'chart.polar',
	                'chart.ignoreHiddenSeries', 'chart.type', 'colors', 'plotOptions',
	                'tooltip'
	            ],

	            /**
	             * A generic function to update any element of the chart. Elements can be
	             * enabled and disabled, moved, re-styled, re-formatted etc.
	             *
	             * A special case is configuration objects that take arrays, for example
	             * {@link https://api.highcharts.com/highcharts/xAxis|xAxis}, 
	             * {@link https://api.highcharts.com/highcharts/yAxis|yAxis} or 
	             * {@link https://api.highcharts.com/highcharts/series|series}. For these
	             * collections, an `id` option is used to map the new option set to an
	             * existing object. If an existing object of the same id is not found, the
	             * corresponding item is updated. So for example, running `chart.update`
	             * with a series item without an id, will cause the existing chart's series
	             * with the same index in the series array to be updated. When the
	             * `oneToOne` parameter is true, `chart.update` will also take care of
	             * adding and removing items from the collection. Read more under the
	             * parameter description below.
	             *
	             * See also the {@link https://api.highcharts.com/highcharts/responsive|
	             * responsive option set}. Switching between `responsive.rules` basically
	             * runs `chart.update` under the hood.
	             *
	             * @param  {Options} options
	             *         A configuration object for the new chart options.
	             * @param  {Boolean} [redraw=true]
	             *         Whether to redraw the chart.
	             * @param  {Boolean} [oneToOne=false]
	             *         When `true`, the `series`, `xAxis` and `yAxis` collections will
	             *         be updated one to one, and items will be either added or removed
	             *         to match the new updated options. For example, if the chart has
	             *         two series and we call `chart.update` with a configuration 
	             *         containing three series, one will be added. If we call
	             *         `chart.update` with one series, one will be removed. Setting an
	             *         empty `series` array will remove all series, but leaving out the
	             *         `series` property will leave all series untouched. If the series
	             *         have id's, the new series options will be matched by id, and the
	             *         remaining ones removed.
	             *
	             * @sample highcharts/members/chart-update/
	             *         Update chart geometry 
	             */
	            update: function(options, redraw, oneToOne) {
	                var chart = this,
	                    adders = {
	                        credits: 'addCredits',
	                        title: 'setTitle',
	                        subtitle: 'setSubtitle'
	                    },
	                    optionsChart = options.chart,
	                    updateAllAxes,
	                    updateAllSeries,
	                    newWidth,
	                    newHeight,
	                    itemsForRemoval = [];

	                // If the top-level chart option is present, some special updates are required      
	                if (optionsChart) {
	                    merge(true, chart.options.chart, optionsChart);

	                    // Setter function
	                    if ('className' in optionsChart) {
	                        chart.setClassName(optionsChart.className);
	                    }

	                    if ('inverted' in optionsChart || 'polar' in optionsChart) {
	                        // Parse options.chart.inverted and options.chart.polar together
	                        // with the available series.
	                        chart.propFromSeries();
	                        updateAllAxes = true;
	                    }

	                    if ('alignTicks' in optionsChart) { // #6452
	                        updateAllAxes = true;
	                    }

	                    objectEach(optionsChart, function(val, key) {
	                        if (inArray('chart.' + key, chart.propsRequireUpdateSeries) !== -1) {
	                            updateAllSeries = true;
	                        }
	                        // Only dirty box
	                        if (inArray(key, chart.propsRequireDirtyBox) !== -1) {
	                            chart.isDirtyBox = true;
	                        }
	                    });


	                    if ('style' in optionsChart) {
	                        chart.renderer.setStyle(optionsChart.style);
	                    }

	                }

	                // Moved up, because tooltip needs updated plotOptions (#6218)

	                if (options.colors) {
	                    this.options.colors = options.colors;
	                }


	                if (options.plotOptions) {
	                    merge(true, this.options.plotOptions, options.plotOptions);
	                }

	                // Some option stuctures correspond one-to-one to chart objects that
	                // have update methods, for example
	                // options.credits => chart.credits
	                // options.legend => chart.legend
	                // options.title => chart.title
	                // options.tooltip => chart.tooltip
	                // options.subtitle => chart.subtitle
	                // options.mapNavigation => chart.mapNavigation
	                // options.navigator => chart.navigator
	                // options.scrollbar => chart.scrollbar
	                objectEach(options, function(val, key) {
	                    if (chart[key] && typeof chart[key].update === 'function') {
	                        chart[key].update(val, false);

	                        // If a one-to-one object does not exist, look for an adder function
	                    } else if (typeof chart[adders[key]] === 'function') {
	                        chart[adders[key]](val);
	                    }

	                    if (
	                        key !== 'chart' &&
	                        inArray(key, chart.propsRequireUpdateSeries) !== -1
	                    ) {
	                        updateAllSeries = true;
	                    }
	                });

	                // Setters for collections. For axes and series, each item is referred
	                // by an id. If the id is not found, it defaults to the corresponding
	                // item in the collection, so setting one series without an id, will
	                // update the first series in the chart. Setting two series without
	                // an id will update the first and the second respectively (#6019)
	                // chart.update and responsive.
	                each([
	                    'xAxis',
	                    'yAxis',
	                    'zAxis',
	                    'series',
	                    'colorAxis',
	                    'pane'
	                ], function(coll) {
	                    if (options[coll]) {
	                        each(splat(options[coll]), function(newOptions, i) {
	                            var item = (
	                                defined(newOptions.id) &&
	                                chart.get(newOptions.id)
	                            ) || chart[coll][i];
	                            if (item && item.coll === coll) {
	                                item.update(newOptions, false);

	                                if (oneToOne) {
	                                    item.touched = true;
	                                }
	                            }

	                            // If oneToOne and no matching item is found, add one
	                            if (!item && oneToOne) {
	                                if (coll === 'series') {
	                                    chart.addSeries(newOptions, false)
	                                        .touched = true;
	                                } else if (coll === 'xAxis' || coll === 'yAxis') {
	                                    chart.addAxis(newOptions, coll === 'xAxis', false)
	                                        .touched = true;
	                                }
	                            }

	                        });

	                        // Add items for removal
	                        if (oneToOne) {
	                            each(chart[coll], function(item) {
	                                if (!item.touched) {
	                                    itemsForRemoval.push(item);
	                                } else {
	                                    delete item.touched;
	                                }
	                            });
	                        }


	                    }
	                });

	                each(itemsForRemoval, function(item) {
	                    item.remove(false);
	                });

	                if (updateAllAxes) {
	                    each(chart.axes, function(axis) {
	                        axis.update({}, false);
	                    });
	                }

	                // Certain options require the whole series structure to be thrown away
	                // and rebuilt
	                if (updateAllSeries) {
	                    each(chart.series, function(series) {
	                        series.update({}, false);
	                    });
	                }

	                // For loading, just update the options, do not redraw
	                if (options.loading) {
	                    merge(true, chart.options.loading, options.loading);
	                }

	                // Update size. Redraw is forced.
	                newWidth = optionsChart && optionsChart.width;
	                newHeight = optionsChart && optionsChart.height;
	                if ((isNumber(newWidth) && newWidth !== chart.chartWidth) ||
	                    (isNumber(newHeight) && newHeight !== chart.chartHeight)) {
	                    chart.setSize(newWidth, newHeight);
	                } else if (pick(redraw, true)) {
	                    chart.redraw();
	                }
	            },

	            /**
	             * Shortcut to set the subtitle options. This can also be done from {@link
	             * Chart#update} or {@link Chart#setTitle}.
	             *
	             * @param  {SubtitleOptions} options
	             *         New subtitle options. The subtitle text itself is set by the
	             *         `options.text` property.
	             */
	            setSubtitle: function(options) {
	                this.setTitle(undefined, options);
	            }


	        });

	        // extend the Point prototype for dynamic methods
	        extend(Point.prototype, /** @lends Highcharts.Point.prototype */ {
	            /**
	             * Update point with new options (typically x/y data) and optionally redraw
	             * the series.
	             *
	             * @param  {Object} options
	             *         The point options. Point options are handled as described under
	             *         the `series<type>.data` item for each series type. For example
	             *         for a line series, if options is a single number, the point will
	             *         be given that number as the main y value. If it is an array, it
	             *         will be interpreted as x and y values respectively. If it is an
	             *         object, advanced options are applied. 
	             * @param  {Boolean} [redraw=true]
	             *          Whether to redraw the chart after the point is updated. If doing
	             *          more operations on the chart, it is best practice to set
	             *          `redraw` to false and call `chart.redraw()` after.
	             * @param  {AnimationOptions} [animation=true]
	             *         Whether to apply animation, and optionally animation
	             *         configuration.
	             *
	             * @sample highcharts/members/point-update-column/
	             *         Update column value
	             * @sample highcharts/members/point-update-pie/
	             *         Update pie slice
	             * @sample maps/members/point-update/
	             *         Update map area value in Highmaps
	             */
	            update: function(options, redraw, animation, runEvent) {
	                var point = this,
	                    series = point.series,
	                    graphic = point.graphic,
	                    i,
	                    chart = series.chart,
	                    seriesOptions = series.options;

	                redraw = pick(redraw, true);

	                function update() {

	                    point.applyOptions(options);

	                    // Update visuals
	                    if (point.y === null && graphic) { // #4146
	                        point.graphic = graphic.destroy();
	                    }
	                    if (isObject(options, true)) {
	                        // Destroy so we can get new elements
	                        if (graphic && graphic.element) {
	                            // "null" is also a valid symbol
	                            if (options && options.marker && options.marker.symbol !== undefined) {
	                                point.graphic = graphic.destroy();
	                            }
	                        }
	                        if (options && options.dataLabels && point.dataLabel) { // #2468
	                            point.dataLabel = point.dataLabel.destroy();
	                        }
	                    }

	                    // record changes in the parallel arrays
	                    i = point.index;
	                    series.updateParallelArrays(point, i);

	                    // Record the options to options.data. If the old or the new config
	                    // is an object, use point options, otherwise use raw options
	                    // (#4701, #4916).
	                    seriesOptions.data[i] = (
	                            isObject(seriesOptions.data[i], true) ||
	                            isObject(options, true)
	                        ) ?
	                        point.options :
	                        options;

	                    // redraw
	                    series.isDirty = series.isDirtyData = true;
	                    if (!series.fixedBox && series.hasCartesianSeries) { // #1906, #2320
	                        chart.isDirtyBox = true;
	                    }

	                    if (seriesOptions.legendType === 'point') { // #1831, #1885
	                        chart.isDirtyLegend = true;
	                    }
	                    if (redraw) {
	                        chart.redraw(animation);
	                    }
	                }

	                // Fire the event with a default handler of doing the update
	                if (runEvent === false) { // When called from setData
	                    update();
	                } else {
	                    point.firePointEvent('update', {
	                        options: options
	                    }, update);
	                }
	            },

	            /**
	             * Remove a point and optionally redraw the series and if necessary the axes
	             * @param  {Boolean} redraw
	             *         Whether to redraw the chart or wait for an explicit call. When
	             *         doing more operations on the chart, for example running
	             *         `point.remove()` in a loop, it is best practice to set `redraw`
	             *         to false and call `chart.redraw()` after.         
	             * @param  {AnimationOptions} [animation=false]
	             *         Whether to apply animation, and optionally animation
	             *         configuration.
	             *
	             * @sample highcharts/plotoptions/series-point-events-remove/
	             *         Remove point and confirm
	             * @sample highcharts/members/point-remove/
	             *         Remove pie slice
	             * @sample maps/members/point-remove/
	             *         Remove selected points in Highmaps
	             */
	            remove: function(redraw, animation) {
	                this.series.removePoint(inArray(this, this.series.data), redraw, animation);
	            }
	        });

	        // Extend the series prototype for dynamic methods
	        extend(Series.prototype, /** @lends Series.prototype */ {
	            /**
	             * Add a point to the series after render time. The point can be added at
	             * the end, or by giving it an X value, to the start or in the middle of the
	             * series.
	             * 
	             * @param  {Number|Array|Object} options
	             *         The point options. If options is a single number, a point with
	             *         that y value is appended to the series.If it is an array, it will
	             *         be interpreted as x and y values respectively. If it is an
	             *         object, advanced options as outlined under `series.data` are
	             *         applied.
	             * @param  {Boolean} [redraw=true]
	             *         Whether to redraw the chart after the point is added. When adding
	             *         more than one point, it is highly recommended that the redraw
	             *         option be set to false, and instead {@link Chart#redraw}
	             *         is explicitly called after the adding of points is finished.
	             *         Otherwise, the chart will redraw after adding each point.
	             * @param  {Boolean} [shift=false]
	             *         If true, a point is shifted off the start of the series as one is
	             *         appended to the end.
	             * @param  {AnimationOptions} [animation]
	             *         Whether to apply animation, and optionally animation
	             *         configuration.
	             *
	             * @sample highcharts/members/series-addpoint-append/
	             *         Append point
	             * @sample highcharts/members/series-addpoint-append-and-shift/
	             *         Append and shift
	             * @sample highcharts/members/series-addpoint-x-and-y/
	             *         Both X and Y values given
	             * @sample highcharts/members/series-addpoint-pie/
	             *         Append pie slice
	             * @sample stock/members/series-addpoint/
	             *         Append 100 points in Highstock
	             * @sample stock/members/series-addpoint-shift/
	             *         Append and shift in Highstock
	             * @sample maps/members/series-addpoint/
	             *         Add a point in Highmaps
	             */
	            addPoint: function(options, redraw, shift, animation) {
	                var series = this,
	                    seriesOptions = series.options,
	                    data = series.data,
	                    chart = series.chart,
	                    xAxis = series.xAxis,
	                    names = xAxis && xAxis.hasNames && xAxis.names,
	                    dataOptions = seriesOptions.data,
	                    point,
	                    isInTheMiddle,
	                    xData = series.xData,
	                    i,
	                    x;

	                // Optional redraw, defaults to true
	                redraw = pick(redraw, true);

	                // Get options and push the point to xData, yData and series.options. In series.generatePoints
	                // the Point instance will be created on demand and pushed to the series.data array.
	                point = {
	                    series: series
	                };
	                series.pointClass.prototype.applyOptions.apply(point, [options]);
	                x = point.x;

	                // Get the insertion point
	                i = xData.length;
	                if (series.requireSorting && x < xData[i - 1]) {
	                    isInTheMiddle = true;
	                    while (i && xData[i - 1] > x) {
	                        i--;
	                    }
	                }

	                series.updateParallelArrays(point, 'splice', i, 0, 0); // insert undefined item
	                series.updateParallelArrays(point, i); // update it

	                if (names && point.name) {
	                    names[x] = point.name;
	                }
	                dataOptions.splice(i, 0, options);

	                if (isInTheMiddle) {
	                    series.data.splice(i, 0, null);
	                    series.processData();
	                }

	                // Generate points to be added to the legend (#1329)
	                if (seriesOptions.legendType === 'point') {
	                    series.generatePoints();
	                }

	                // Shift the first point off the parallel arrays
	                if (shift) {
	                    if (data[0] && data[0].remove) {
	                        data[0].remove(false);
	                    } else {
	                        data.shift();
	                        series.updateParallelArrays(point, 'shift');

	                        dataOptions.shift();
	                    }
	                }

	                // redraw
	                series.isDirty = true;
	                series.isDirtyData = true;

	                if (redraw) {
	                    chart.redraw(animation); // Animation is set anyway on redraw, #5665
	                }
	            },

	            /**
	             * Remove a point from the series. Unlike the {@link Highcharts.Point#remove}
	             * method, this can also be done on a point that is not instanciated because
	             * it is outside the view or subject to Highstock data grouping.
	             *
	             * @param  {Number} i
	             *         The index of the point in the {@link Highcharts.Series.data|data}
	             *         array.
	             * @param  {Boolean} [redraw=true]
	             *         Whether to redraw the chart after the point is added. When 
	             *         removing more than one point, it is highly recommended that the
	             *         `redraw` option be set to `false`, and instead {@link
	             *         Highcharts.Chart#redraw} is explicitly called after the adding of
	             *         points is finished.
	             * @param  {AnimationOptions} [animation]
	             *         Whether and optionally how the series should be animated.
	             *
	             * @sample highcharts/members/series-removepoint/
	             *         Remove cropped point
	             */
	            removePoint: function(i, redraw, animation) {

	                var series = this,
	                    data = series.data,
	                    point = data[i],
	                    points = series.points,
	                    chart = series.chart,
	                    remove = function() {

	                        if (points && points.length === data.length) { // #4935
	                            points.splice(i, 1);
	                        }
	                        data.splice(i, 1);
	                        series.options.data.splice(i, 1);
	                        series.updateParallelArrays(point || {
	                            series: series
	                        }, 'splice', i, 1);

	                        if (point) {
	                            point.destroy();
	                        }

	                        // redraw
	                        series.isDirty = true;
	                        series.isDirtyData = true;
	                        if (redraw) {
	                            chart.redraw();
	                        }
	                    };

	                setAnimation(animation, chart);
	                redraw = pick(redraw, true);

	                // Fire the event with a default handler of removing the point
	                if (point) {
	                    point.firePointEvent('remove', null, remove);
	                } else {
	                    remove();
	                }
	            },

	            /**
	             * Remove a series and optionally redraw the chart.
	             *
	             * @param  {Boolean} [redraw=true]
	             *         Whether to redraw the chart or wait for an explicit call to
	             *         {@link Highcharts.Chart#redraw}.
	             * @param  {AnimationOptions} [animation]
	             *         Whether to apply animation, and optionally animation
	             *         configuration
	             * @param  {Boolean} [withEvent=true]
	             *         Used internally, whether to fire the series `remove` event.
	             *
	             * @sample highcharts/members/series-remove/
	             *         Remove first series from a button
	             */
	            remove: function(redraw, animation, withEvent) {
	                var series = this,
	                    chart = series.chart;

	                function remove() {

	                    // Destroy elements
	                    series.destroy();

	                    // Redraw
	                    chart.isDirtyLegend = chart.isDirtyBox = true;
	                    chart.linkSeries();

	                    if (pick(redraw, true)) {
	                        chart.redraw(animation);
	                    }
	                }

	                // Fire the event with a default handler of removing the point
	                if (withEvent !== false) {
	                    fireEvent(series, 'remove', null, remove);
	                } else {
	                    remove();
	                }
	            },

	            /**
	             * Update the series with a new set of options. For a clean and precise
	             * handling of new options, all methods and elements from the series are
	             * removed, and it is initiated from scratch. Therefore, this method is more
	             * performance expensive than some other utility methods like {@link
	             * Series#setData} or {@link Series#setVisible}.
	             *
	             * @param  {SeriesOptions} options
	             *         New options that will be merged with the series' existing
	             *         options.
	             * @param  {Boolean} [redraw=true]
	             *         Whether to redraw the chart after the series is altered. If doing
	             *         more operations on the chart, it is a good idea to set redraw to
	             *         false and call {@link Chart#redraw} after.
	             *
	             * @sample highcharts/members/series-update/
	             *         Updating series options
	             * @sample maps/members/series-update/
	             *         Update series options in Highmaps
	             */
	            update: function(newOptions, redraw) {
	                var series = this,
	                    chart = series.chart,
	                    // must use user options when changing type because series.options
	                    // is merged in with type specific plotOptions
	                    oldOptions = series.userOptions,
	                    oldType = series.oldType || series.type,
	                    newType = newOptions.type || oldOptions.type || chart.options.chart.type,
	                    proto = seriesTypes[oldType].prototype,
	                    n,
	                    preserve = [
	                        'group',
	                        'markerGroup',
	                        'dataLabelsGroup',
	                        'navigatorSeries',
	                        'baseSeries'
	                    ],

	                    // Animation must be enabled when calling update before the initial
	                    // animation has first run. This happens when calling update
	                    // directly after chart initialization, or when applying responsive
	                    // rules (#6912).
	                    animation = series.finishedAnimating && {
	                        animation: false
	                    };

	                // Running Series.update to update the data only is an intuitive usage,
	                // so we want to make sure that when used like this, we run the
	                // cheaper setData function and allow animation instead of completely
	                // recreating the series instance.
	                if (Object.keys && Object.keys(newOptions).toString() === 'data') {
	                    return this.setData(newOptions.data, redraw);
	                }

	                // If we're changing type or zIndex, create new groups (#3380, #3404)
	                if ((newType && newType !== oldType) || newOptions.zIndex !== undefined) {
	                    preserve.length = 0;
	                }

	                // Make sure groups are not destroyed (#3094)
	                each(preserve, function(prop) {
	                    preserve[prop] = series[prop];
	                    delete series[prop];
	                });

	                // Do the merge, with some forced options
	                newOptions = merge(oldOptions, animation, {
	                    index: series.index,
	                    pointStart: series.xData[0] // when updating after addPoint
	                }, {
	                    data: series.options.data
	                }, newOptions);

	                // Destroy the series and delete all properties. Reinsert all methods
	                // and properties from the new type prototype (#2270, #3719)
	                series.remove(false, null, false);
	                for (n in proto) {
	                    series[n] = undefined;
	                }
	                extend(series, seriesTypes[newType || oldType].prototype);

	                // Re-register groups (#3094) and other preserved properties
	                each(preserve, function(prop) {
	                    series[prop] = preserve[prop];
	                });

	                series.init(chart, newOptions);
	                series.oldType = oldType;
	                chart.linkSeries(); // Links are lost in series.remove (#3028)
	                if (pick(redraw, true)) {
	                    chart.redraw(false);
	                }
	            }
	        });

	        // Extend the Axis.prototype for dynamic methods
	        extend(Axis.prototype, /** @lends Highcharts.Axis.prototype */ {

	            /**
	             * Update an axis object with a new set of options. The options are merged
	             * with the existing options, so only new or altered options need to be
	             * specified.
	             *
	             * @param  {Object} options
	             *         The new options that will be merged in with existing options on
	             *         the axis.
	             * @sample highcharts/members/axis-update/ Axis update demo
	             */
	            update: function(options, redraw) {
	                var chart = this.chart;

	                options = chart.options[this.coll][this.options.index] =
	                    merge(this.userOptions, options);

	                this.destroy(true);

	                this.init(chart, extend(options, {
	                    events: undefined
	                }));

	                chart.isDirtyBox = true;
	                if (pick(redraw, true)) {
	                    chart.redraw();
	                }
	            },

	            /**
	             * Remove the axis from the chart.
	             *
	             * @param {Boolean} [redraw=true] Whether to redraw the chart following the
	             * remove.
	             *
	             * @sample highcharts/members/chart-addaxis/ Add and remove axes
	             */
	            remove: function(redraw) {
	                var chart = this.chart,
	                    key = this.coll, // xAxis or yAxis
	                    axisSeries = this.series,
	                    i = axisSeries.length;

	                // Remove associated series (#2687)
	                while (i--) {
	                    if (axisSeries[i]) {
	                        axisSeries[i].remove(false);
	                    }
	                }

	                // Remove the axis
	                erase(chart.axes, this);
	                erase(chart[key], this);

	                if (isArray(chart.options[key])) {
	                    chart.options[key].splice(this.options.index, 1);
	                } else { // color axis, #6488
	                    delete chart.options[key];
	                }

	                each(chart[key], function(axis, i) { // Re-index, #1706
	                    axis.options.index = i;
	                });
	                this.destroy();
	                chart.isDirtyBox = true;

	                if (pick(redraw, true)) {
	                    chart.redraw();
	                }
	            },

	            /**
	             * Update the axis title by options after render time.
	             *
	             * @param  {TitleOptions} titleOptions
	             *         The additional title options.
	             * @param  {Boolean} [redraw=true]
	             *         Whether to redraw the chart after setting the title.
	             * @sample highcharts/members/axis-settitle/ Set a new Y axis title
	             */
	            setTitle: function(titleOptions, redraw) {
	                this.update({
	                    title: titleOptions
	                }, redraw);
	            },

	            /**
	             * Set new axis categories and optionally redraw.
	             * @param {Array.<String>} categories - The new categories.
	             * @param {Boolean} [redraw=true] - Whether to redraw the chart.
	             * @sample highcharts/members/axis-setcategories/ Set categories by click on
	             * a button
	             */
	            setCategories: function(categories, redraw) {
	                this.update({
	                    categories: categories
	                }, redraw);
	            }

	        });

	    }(Highcharts));
	    (function(H) {
	        /**
	         * (c) 2010-2017 Torstein Honsi
	         *
	         * License: www.highcharts.com/license
	         */
	        var color = H.color,
	            each = H.each,
	            LegendSymbolMixin = H.LegendSymbolMixin,
	            map = H.map,
	            pick = H.pick,
	            Series = H.Series,
	            seriesType = H.seriesType;

	        /**
	         * Area series type.
	         * @constructor seriesTypes.area
	         * @extends {Series}
	         */
	        /**
	         * @extends {plotOptions.line}
	         * @optionparent plotOptions.area
	         */
	        seriesType('area', 'line', {

	            /**
	             * When this is true, the series will not cause the Y axis to cross
	             * the zero plane (or [threshold](#plotOptions.series.threshold) option)
	             * unless the data actually crosses the plane.
	             * 
	             * For example, if `softThreshold` is `false`, a series of 0, 1, 2,
	             * 3 will make the Y axis show negative values according to the `minPadding`
	             * option. If `softThreshold` is `true`, the Y axis starts at 0.
	             * 
	             * @type {Boolean}
	             * @default false
	             * @since 4.1.9
	             * @product highcharts highstock
	             */
	            softThreshold: false,

	            /**
	             * The Y axis value to serve as the base for the area, for distinguishing
	             * between values above and below a threshold. If `null`, the area
	             * behaves like a line series with fill between the graph and the Y
	             * axis minimum.
	             * 
	             * @type {Number}
	             * @sample {highcharts} highcharts/plotoptions/area-threshold/ A threshold of 100
	             * @default 0
	             * @since 2.0
	             * @product highcharts highstock
	             */
	            threshold: 0
	            // trackByArea: false,
	            // lineColor: null, // overrides color, but lets fillColor be unaltered
	            // fillOpacity: 0.75,
	            // fillColor: null
	        }, /** @lends seriesTypes.area.prototype */ {
	            singleStacks: false,
	            /** 
	             * Return an array of stacked points, where null and missing points are replaced by 
	             * dummy points in order for gaps to be drawn correctly in stacks.
	             */
	            getStackPoints: function(points) {
	                var series = this,
	                    segment = [],
	                    keys = [],
	                    xAxis = this.xAxis,
	                    yAxis = this.yAxis,
	                    stack = yAxis.stacks[this.stackKey],
	                    pointMap = {},
	                    seriesIndex = series.index,
	                    yAxisSeries = yAxis.series,
	                    seriesLength = yAxisSeries.length,
	                    visibleSeries,
	                    upOrDown = pick(yAxis.options.reversedStacks, true) ? 1 : -1,
	                    i;


	                points = points || this.points;

	                if (this.options.stacking) {
	                    // Create a map where we can quickly look up the points by their X value.
	                    for (i = 0; i < points.length; i++) {
	                        pointMap[points[i].x] = points[i];
	                    }

	                    // Sort the keys (#1651)
	                    H.objectEach(stack, function(stackX, x) {
	                        if (stackX.total !== null) { // nulled after switching between grouping and not (#1651, #2336)
	                            keys.push(x);
	                        }
	                    });
	                    keys.sort(function(a, b) {
	                        return a - b;
	                    });

	                    visibleSeries = map(yAxisSeries, function() {
	                        return this.visible;
	                    });

	                    each(keys, function(x, idx) {
	                        var y = 0,
	                            stackPoint,
	                            stackedValues;

	                        if (pointMap[x] && !pointMap[x].isNull) {
	                            segment.push(pointMap[x]);

	                            // Find left and right cliff. -1 goes left, 1 goes right.
	                            each([-1, 1], function(direction) {
	                                var nullName = direction === 1 ? 'rightNull' : 'leftNull',
	                                    cliffName = direction === 1 ? 'rightCliff' : 'leftCliff',
	                                    cliff = 0,
	                                    otherStack = stack[keys[idx + direction]];

	                                // If there is a stack next to this one, to the left or to the right...
	                                if (otherStack) {
	                                    i = seriesIndex;
	                                    while (i >= 0 && i < seriesLength) { // Can go either up or down, depending on reversedStacks
	                                        stackPoint = otherStack.points[i];
	                                        if (!stackPoint) {
	                                            // If the next point in this series is missing, mark the point
	                                            // with point.leftNull or point.rightNull = true.
	                                            if (i === seriesIndex) {
	                                                pointMap[x][nullName] = true;

	                                                // If there are missing points in the next stack in any of the 
	                                                // series below this one, we need to substract the missing values
	                                                // and add a hiatus to the left or right.
	                                            } else if (visibleSeries[i]) {
	                                                stackedValues = stack[x].points[i];
	                                                if (stackedValues) {
	                                                    cliff -= stackedValues[1] - stackedValues[0];
	                                                }
	                                            }
	                                        }
	                                        // When reversedStacks is true, loop up, else loop down
	                                        i += upOrDown;
	                                    }
	                                }
	                                pointMap[x][cliffName] = cliff;
	                            });


	                            // There is no point for this X value in this series, so we 
	                            // insert a dummy point in order for the areas to be drawn
	                            // correctly.
	                        } else {

	                            // Loop down the stack to find the series below this one that has
	                            // a value (#1991)
	                            i = seriesIndex;
	                            while (i >= 0 && i < seriesLength) {
	                                stackPoint = stack[x].points[i];
	                                if (stackPoint) {
	                                    y = stackPoint[1];
	                                    break;
	                                }
	                                // When reversedStacks is true, loop up, else loop down
	                                i += upOrDown;
	                            }
	                            y = yAxis.translate(y, 0, 1, 0, 1); // #6272
	                            segment.push({
	                                isNull: true,
	                                plotX: xAxis.translate(x, 0, 0, 0, 1), // #6272
	                                x: x,
	                                plotY: y,
	                                yBottom: y
	                            });
	                        }
	                    });

	                }

	                return segment;
	            },

	            getGraphPath: function(points) {
	                var getGraphPath = Series.prototype.getGraphPath,
	                    graphPath,
	                    options = this.options,
	                    stacking = options.stacking,
	                    yAxis = this.yAxis,
	                    topPath,
	                    //topPoints = [],
	                    bottomPath,
	                    bottomPoints = [],
	                    graphPoints = [],
	                    seriesIndex = this.index,
	                    i,
	                    areaPath,
	                    plotX,
	                    stacks = yAxis.stacks[this.stackKey],
	                    threshold = options.threshold,
	                    translatedThreshold = yAxis.getThreshold(options.threshold),
	                    isNull,
	                    yBottom,
	                    connectNulls = options.connectNulls || stacking === 'percent',
	                    /**
	                     * To display null points in underlying stacked series, this series graph must be 
	                     * broken, and the area also fall down to fill the gap left by the null point. #2069
	                     */
	                    addDummyPoints = function(i, otherI, side) {
	                        var point = points[i],
	                            stackedValues = stacking && stacks[point.x].points[seriesIndex],
	                            nullVal = point[side + 'Null'] || 0,
	                            cliffVal = point[side + 'Cliff'] || 0,
	                            top,
	                            bottom,
	                            isNull = true;

	                        if (cliffVal || nullVal) {

	                            top = (nullVal ? stackedValues[0] : stackedValues[1]) + cliffVal;
	                            bottom = stackedValues[0] + cliffVal;
	                            isNull = !!nullVal;

	                        } else if (!stacking && points[otherI] && points[otherI].isNull) {
	                            top = bottom = threshold;
	                        }

	                        // Add to the top and bottom line of the area
	                        if (top !== undefined) {
	                            graphPoints.push({
	                                plotX: plotX,
	                                plotY: top === null ? translatedThreshold : yAxis.getThreshold(top),
	                                isNull: isNull,
	                                isCliff: true
	                            });
	                            bottomPoints.push({
	                                plotX: plotX,
	                                plotY: bottom === null ? translatedThreshold : yAxis.getThreshold(bottom),
	                                doCurve: false // #1041, gaps in areaspline areas
	                            });
	                        }
	                    };

	                // Find what points to use
	                points = points || this.points;

	                // Fill in missing points
	                if (stacking) {
	                    points = this.getStackPoints(points);
	                }

	                for (i = 0; i < points.length; i++) {
	                    isNull = points[i].isNull;
	                    plotX = pick(points[i].rectPlotX, points[i].plotX);
	                    yBottom = pick(points[i].yBottom, translatedThreshold);

	                    if (!isNull || connectNulls) {

	                        if (!connectNulls) {
	                            addDummyPoints(i, i - 1, 'left');
	                        }

	                        if (!(isNull && !stacking && connectNulls)) { // Skip null point when stacking is false and connectNulls true
	                            graphPoints.push(points[i]);
	                            bottomPoints.push({
	                                x: i,
	                                plotX: plotX,
	                                plotY: yBottom
	                            });
	                        }

	                        if (!connectNulls) {
	                            addDummyPoints(i, i + 1, 'right');
	                        }
	                    }
	                }

	                topPath = getGraphPath.call(this, graphPoints, true, true);

	                bottomPoints.reversed = true;
	                bottomPath = getGraphPath.call(this, bottomPoints, true, true);
	                if (bottomPath.length) {
	                    bottomPath[0] = 'L';
	                }

	                areaPath = topPath.concat(bottomPath);
	                graphPath = getGraphPath.call(this, graphPoints, false, connectNulls); // TODO: don't set leftCliff and rightCliff when connectNulls?

	                areaPath.xMap = topPath.xMap;
	                this.areaPath = areaPath;

	                return graphPath;
	            },

	            /**
	             * Draw the graph and the underlying area. This method calls the Series base
	             * function and adds the area. The areaPath is calculated in the getSegmentPath
	             * method called from Series.prototype.drawGraph.
	             */
	            drawGraph: function() {

	                // Define or reset areaPath
	                this.areaPath = [];

	                // Call the base method
	                Series.prototype.drawGraph.apply(this);

	                // Define local variables
	                var series = this,
	                    areaPath = this.areaPath,
	                    options = this.options,
	                    zones = this.zones,
	                    props = [
	                        [
	                            'area',
	                            'highcharts-area',

	                            this.color,
	                            options.fillColor

	                        ]
	                    ]; // area name, main color, fill color

	                each(zones, function(zone, i) {
	                    props.push([
	                        'zone-area-' + i,
	                        'highcharts-area highcharts-zone-area-' + i + ' ' + zone.className,

	                        zone.color || series.color,
	                        zone.fillColor || options.fillColor

	                    ]);
	                });

	                each(props, function(prop) {
	                    var areaKey = prop[0],
	                        area = series[areaKey];

	                    // Create or update the area
	                    if (area) { // update
	                        area.endX = areaPath.xMap;
	                        area.animate({
	                            d: areaPath
	                        });

	                    } else { // create
	                        area = series[areaKey] = series.chart.renderer.path(areaPath)
	                            .addClass(prop[1])
	                            .attr({

	                                fill: pick(
	                                    prop[3],
	                                    color(prop[2]).setOpacity(pick(options.fillOpacity, 0.75)).get()
	                                ),

	                                zIndex: 0 // #1069
	                            }).add(series.group);
	                        area.isArea = true;
	                    }
	                    area.startX = areaPath.xMap;
	                    area.shiftUnit = options.step ? 2 : 1;
	                });
	            },

	            drawLegendSymbol: LegendSymbolMixin.drawRectangle
	        });

	    }(Highcharts));
	    (function(H) {
	        /**
	         * (c) 2010-2017 Torstein Honsi
	         *
	         * License: www.highcharts.com/license
	         */
	        var pick = H.pick,
	            seriesType = H.seriesType;

	        /**
	         * Spline series type.
	         * @constructor seriesTypes.spline
	         * @extends {Series}
	         */
	        seriesType('spline', 'line', {}, /** @lends seriesTypes.spline.prototype */ {
	            /**
	             * Get the spline segment from a given point's previous neighbour to the given point
	             */
	            getPointSpline: function(points, point, i) {
	                var smoothing = 1.5, // 1 means control points midway between points, 2 means 1/3 from the point, 3 is 1/4 etc
	                    denom = smoothing + 1,
	                    plotX = point.plotX,
	                    plotY = point.plotY,
	                    lastPoint = points[i - 1],
	                    nextPoint = points[i + 1],
	                    leftContX,
	                    leftContY,
	                    rightContX,
	                    rightContY,
	                    ret;

	                function doCurve(otherPoint) {
	                    return otherPoint &&
	                        !otherPoint.isNull &&
	                        otherPoint.doCurve !== false &&
	                        !point.isCliff; // #6387, area splines next to null
	                }

	                // Find control points
	                if (doCurve(lastPoint) && doCurve(nextPoint)) {
	                    var lastX = lastPoint.plotX,
	                        lastY = lastPoint.plotY,
	                        nextX = nextPoint.plotX,
	                        nextY = nextPoint.plotY,
	                        correction = 0;

	                    leftContX = (smoothing * plotX + lastX) / denom;
	                    leftContY = (smoothing * plotY + lastY) / denom;
	                    rightContX = (smoothing * plotX + nextX) / denom;
	                    rightContY = (smoothing * plotY + nextY) / denom;

	                    // Have the two control points make a straight line through main point
	                    if (rightContX !== leftContX) { // #5016, division by zero
	                        correction = ((rightContY - leftContY) * (rightContX - plotX)) /
	                            (rightContX - leftContX) + plotY - rightContY;
	                    }

	                    leftContY += correction;
	                    rightContY += correction;

	                    // to prevent false extremes, check that control points are between
	                    // neighbouring points' y values
	                    if (leftContY > lastY && leftContY > plotY) {
	                        leftContY = Math.max(lastY, plotY);
	                        rightContY = 2 * plotY - leftContY; // mirror of left control point
	                    } else if (leftContY < lastY && leftContY < plotY) {
	                        leftContY = Math.min(lastY, plotY);
	                        rightContY = 2 * plotY - leftContY;
	                    }
	                    if (rightContY > nextY && rightContY > plotY) {
	                        rightContY = Math.max(nextY, plotY);
	                        leftContY = 2 * plotY - rightContY;
	                    } else if (rightContY < nextY && rightContY < plotY) {
	                        rightContY = Math.min(nextY, plotY);
	                        leftContY = 2 * plotY - rightContY;
	                    }

	                    // record for drawing in next point
	                    point.rightContX = rightContX;
	                    point.rightContY = rightContY;


	                }

	                // Visualize control points for debugging
	                /*
	                if (leftContX) {
	                    this.chart.renderer.circle(leftContX + this.chart.plotLeft, leftContY + this.chart.plotTop, 2)
	                        .attr({
	                            stroke: 'red',
	                            'stroke-width': 2,
	                            fill: 'none',
	                            zIndex: 9
	                        })
	                        .add();
	                    this.chart.renderer.path(['M', leftContX + this.chart.plotLeft, leftContY + this.chart.plotTop,
	                        'L', plotX + this.chart.plotLeft, plotY + this.chart.plotTop])
	                        .attr({
	                            stroke: 'red',
	                            'stroke-width': 2,
	                            zIndex: 9
	                        })
	                        .add();
	                }
	                if (rightContX) {
	                    this.chart.renderer.circle(rightContX + this.chart.plotLeft, rightContY + this.chart.plotTop, 2)
	                        .attr({
	                            stroke: 'green',
	                            'stroke-width': 2,
	                            fill: 'none',
	                            zIndex: 9
	                        })
	                        .add();
	                    this.chart.renderer.path(['M', rightContX + this.chart.plotLeft, rightContY + this.chart.plotTop,
	                        'L', plotX + this.chart.plotLeft, plotY + this.chart.plotTop])
	                        .attr({
	                            stroke: 'green',
	                            'stroke-width': 2,
	                            zIndex: 9
	                        })
	                        .add();
	                }
	                // */
	                ret = [
	                    'C',
	                    pick(lastPoint.rightContX, lastPoint.plotX),
	                    pick(lastPoint.rightContY, lastPoint.plotY),
	                    pick(leftContX, plotX),
	                    pick(leftContY, plotY),
	                    plotX,
	                    plotY
	                ];
	                lastPoint.rightContX = lastPoint.rightContY = null; // reset for updating series later
	                return ret;
	            }
	        });

	    }(Highcharts));
	    (function(H) {
	        /**
	         * (c) 2010-2017 Torstein Honsi
	         *
	         * License: www.highcharts.com/license
	         */
	        var areaProto = H.seriesTypes.area.prototype,
	            defaultPlotOptions = H.defaultPlotOptions,
	            LegendSymbolMixin = H.LegendSymbolMixin,
	            seriesType = H.seriesType;
	        /**
	         * AreaSplineSeries object
	         */
	        seriesType('areaspline', 'spline', defaultPlotOptions.area, {
	            getStackPoints: areaProto.getStackPoints,
	            getGraphPath: areaProto.getGraphPath,
	            drawGraph: areaProto.drawGraph,
	            drawLegendSymbol: LegendSymbolMixin.drawRectangle
	        });

	    }(Highcharts));
	    (function(H) {
	        /**
	         * (c) 2010-2017 Torstein Honsi
	         *
	         * License: www.highcharts.com/license
	         */
	        var animObject = H.animObject,
	            color = H.color,
	            each = H.each,
	            extend = H.extend,
	            isNumber = H.isNumber,
	            LegendSymbolMixin = H.LegendSymbolMixin,
	            merge = H.merge,
	            noop = H.noop,
	            pick = H.pick,
	            Series = H.Series,
	            seriesType = H.seriesType,
	            svg = H.svg;
	        /**
	         * The column series type.
	         *
	         * @constructor seriesTypes.column
	         * @augments Series
	         */

	        /**
	         * @extends {plotOptions.line}
	         * @optionparent plotOptions.column
	         * @excluding connectNulls,dashStyle,linecap,lineWidth,marker,connectEnds,step
	         */
	        seriesType('column', 'line', {

	            /**
	             * The corner radius of the border surrounding each column or bar.
	             * 
	             * @type {Number}
	             * @sample {highcharts} highcharts/plotoptions/column-borderradius/ Rounded columns
	             * @default 0
	             * @product highcharts highstock
	             */
	            borderRadius: 0,
	            //colorByPoint: undefined,

	            /**
	             * When true, each column edge is rounded to its nearest pixel in order
	             * to render sharp on screen. In some cases, when there are a lot of
	             * densely packed columns, this leads to visible difference in column
	             * widths or distance between columns. In these cases, setting `crisp`
	             * to `false` may look better, even though each column is rendered
	             * blurry.
	             * 
	             * @type {Boolean}
	             * @sample {highcharts} highcharts/plotoptions/column-crisp-false/ Crisp is false
	             * @default true
	             * @since 5.0.10
	             * @product highcharts highstock
	             */
	            crisp: true,

	            /**
	             * Padding between each value groups, in x axis units.
	             * 
	             * @type {Number}
	             * @sample {highcharts} highcharts/plotoptions/column-grouppadding-default/ 0.2 by default
	             * @sample {highcharts} highcharts/plotoptions/column-grouppadding-none/ No group padding - all     columns are evenly spaced
	             * @default 0.2
	             * @product highcharts highstock
	             */
	            groupPadding: 0.2,
	            //grouping: true,

	            /**
	             */
	            marker: null, // point options are specified in the base options

	            /**
	             * Padding between each column or bar, in x axis units.
	             * 
	             * @type {Number}
	             * @sample {highcharts} highcharts/plotoptions/column-pointpadding-default/ 0.1 by default
	             * @sample {highcharts} highcharts/plotoptions/column-pointpadding-025/ 0.25
	             * @sample {highcharts} highcharts/plotoptions/column-pointpadding-none/ 0 for tightly packed columns
	             * @default 0.1
	             * @product highcharts highstock
	             */
	            pointPadding: 0.1,
	            //pointWidth: null,

	            /**
	             * The minimal height for a column or width for a bar. By default,
	             * 0 values are not shown. To visualize a 0 (or close to zero) point,
	             * set the minimal point length to a pixel value like 3\. In stacked
	             * column charts, minPointLength might not be respected for tightly
	             * packed values.
	             * 
	             * @type {Number}
	             * @sample {highcharts} highcharts/plotoptions/column-minpointlength/ Zero base value
	             * @sample {highcharts} highcharts/plotoptions/column-minpointlength-pos-and-neg/ Positive and negative close to zero values
	             * @default 0
	             * @product highcharts highstock
	             */
	            minPointLength: 0,

	            /**
	             * When the series contains less points than the crop threshold, all
	             * points are drawn, event if the points fall outside the visible plot
	             * area at the current zoom. The advantage of drawing all points (including
	             * markers and columns), is that animation is performed on updates.
	             * On the other hand, when the series contains more points than the
	             * crop threshold, the series data is cropped to only contain points
	             * that fall within the plot area. The advantage of cropping away invisible
	             * points is to increase performance on large series. .
	             * 
	             * @type {Number}
	             * @default 50
	             * @product highcharts highstock
	             */
	            cropThreshold: 50,

	            /**
	             * The X axis range that each point is valid for. This determines the
	             * width of the column. On a categorized axis, the range will be 1
	             * by default (one category unit). On linear and datetime axes, the
	             * range will be computed as the distance between the two closest data
	             * points.
	             *
	             * The default `null` means it is computed automatically, but this option
	             * can be used to override the automatic value.
	             * 
	             * @type {Number}
	             * @sample {highcharts} highcharts/plotoptions/column-pointrange/
	             *         Set the point range to one day on a data set with one week
	             *         between the points
	             * @default null
	             * @since 2.3
	             * @product highcharts highstock
	             */
	            pointRange: null,

	            /**
	             */
	            states: {

	                /**
	                 * @extends plotOptions.series.states.hover
	                 * @excluding lineWidth,lineWidthPlus,marker
	                 * @product highcharts highstock
	                 */
	                hover: {

	                    /**
	                     */
	                    halo: false,


	                    /**
	                     * How much to brighten the point on interaction. Requires the main
	                     * color to be defined in hex or rgb(a) format.
	                     * 
	                     * In [styled mode](http://www.highcharts.com/docs/chart-design-and-
	                     * style/style-by-css), the hover brightening is by default replaced
	                     * with a fill-opacity set in the `.highcharts-point:hover` rule.
	                     * 
	                     * @type {Number}
	                     * @sample {highcharts} highcharts/plotoptions/column-states-hover-brightness/ Brighten by 0.5
	                     * @default 0.1
	                     * @product highcharts highstock
	                     */
	                    brightness: 0.1,

	                    /**
	                     */
	                    shadow: false

	                },


	                /**
	                 */
	                select: {

	                    /**
	                     */
	                    color: '#cccccc',

	                    /**
	                     */
	                    borderColor: '#000000',

	                    /**
	                     */
	                    shadow: false
	                }

	            },

	            /**
	             */
	            dataLabels: {

	                /**
	                 */
	                align: null, // auto

	                /**
	                 */
	                verticalAlign: null, // auto

	                /**
	                 */
	                y: null
	            },

	            /**
	             * When this is true, the series will not cause the Y axis to cross
	             * the zero plane (or [threshold](#plotOptions.series.threshold) option)
	             * unless the data actually crosses the plane.
	             * 
	             * For example, if `softThreshold` is `false`, a series of 0, 1, 2,
	             * 3 will make the Y axis show negative values according to the `minPadding`
	             * option. If `softThreshold` is `true`, the Y axis starts at 0.
	             * 
	             * @type {Boolean}
	             * @default {highcharts} true
	             * @default {highstock} false
	             * @since 4.1.9
	             * @product highcharts highstock
	             */
	            softThreshold: false,

	            /**
	             */
	            startFromThreshold: true, // false doesn't work well: http://jsfiddle.net/highcharts/hz8fopan/14/

	            /**
	             */
	            stickyTracking: false,

	            /**
	             */
	            tooltip: {

	                /**
	                 */
	                distance: 6
	            },

	            /**
	             * The Y axis value to serve as the base for the columns, for distinguishing
	             * between values above and below a threshold. If `null`, the columns
	             * extend from the padding Y axis minimum.
	             * 
	             * @type {Number}
	             * @default 0
	             * @since 2.0
	             * @product highcharts
	             */
	            threshold: 0,


	            /**
	             * The color of the border surrounding each column or bar.
	             * 
	             * In [styled mode](http://www.highcharts.com/docs/chart-design-and-
	             * style/style-by-css), the border stroke can be set with the `.highcharts-
	             * point` rule.
	             * 
	             * @type {Color}
	             * @sample {highcharts} highcharts/plotoptions/column-bordercolor/ Dark gray border
	             * @default #ffffff
	             * @product highcharts highstock
	             */
	            borderColor: '#ffffff'
	            // borderWidth: 1


	        }, /** @lends seriesTypes.column.prototype */ {
	            cropShoulder: 0,
	            directTouch: true, // When tooltip is not shared, this series (and derivatives) requires direct touch/hover. KD-tree does not apply.
	            trackerGroups: ['group', 'dataLabelsGroup'],
	            negStacks: true, // use separate negative stacks, unlike area stacks where a negative
	            // point is substracted from previous (#1910)

	            /**
	             * Initialize the series. Extends the basic Series.init method by
	             * marking other series of the same type as dirty.
	             *
	             * @function #init
	             * @memberOf seriesTypes.column
	             * 
	             */
	            init: function() {
	                Series.prototype.init.apply(this, arguments);

	                var series = this,
	                    chart = series.chart;

	                // if the series is added dynamically, force redraw of other
	                // series affected by a new column
	                if (chart.hasRendered) {
	                    each(chart.series, function(otherSeries) {
	                        if (otherSeries.type === series.type) {
	                            otherSeries.isDirty = true;
	                        }
	                    });
	                }
	            },

	            /**
	             * Return the width and x offset of the columns adjusted for grouping, groupPadding, pointPadding,
	             * pointWidth etc.
	             */
	            getColumnMetrics: function() {

	                var series = this,
	                    options = series.options,
	                    xAxis = series.xAxis,
	                    yAxis = series.yAxis,
	                    reversedXAxis = xAxis.reversed,
	                    stackKey,
	                    stackGroups = {},
	                    columnCount = 0;

	                // Get the total number of column type series.
	                // This is called on every series. Consider moving this logic to a
	                // chart.orderStacks() function and call it on init, addSeries and removeSeries
	                if (options.grouping === false) {
	                    columnCount = 1;
	                } else {
	                    each(series.chart.series, function(otherSeries) {
	                        var otherOptions = otherSeries.options,
	                            otherYAxis = otherSeries.yAxis,
	                            columnIndex;
	                        if (
	                            otherSeries.type === series.type &&
	                            (
	                                otherSeries.visible ||
	                                !series.chart.options.chart.ignoreHiddenSeries
	                            ) &&
	                            yAxis.len === otherYAxis.len &&
	                            yAxis.pos === otherYAxis.pos
	                        ) { // #642, #2086
	                            if (otherOptions.stacking) {
	                                stackKey = otherSeries.stackKey;
	                                if (stackGroups[stackKey] === undefined) {
	                                    stackGroups[stackKey] = columnCount++;
	                                }
	                                columnIndex = stackGroups[stackKey];
	                            } else if (otherOptions.grouping !== false) { // #1162
	                                columnIndex = columnCount++;
	                            }
	                            otherSeries.columnIndex = columnIndex;
	                        }
	                    });
	                }

	                var categoryWidth = Math.min(
	                        Math.abs(xAxis.transA) * (xAxis.ordinalSlope || options.pointRange || xAxis.closestPointRange || xAxis.tickInterval || 1), // #2610
	                        xAxis.len // #1535
	                    ),
	                    groupPadding = categoryWidth * options.groupPadding,
	                    groupWidth = categoryWidth - 2 * groupPadding,
	                    pointOffsetWidth = groupWidth / (columnCount || 1),
	                    pointWidth = Math.min(
	                        options.maxPointWidth || xAxis.len,
	                        pick(options.pointWidth, pointOffsetWidth * (1 - 2 * options.pointPadding))
	                    ),
	                    pointPadding = (pointOffsetWidth - pointWidth) / 2,
	                    colIndex = (series.columnIndex || 0) + (reversedXAxis ? 1 : 0), // #1251, #3737
	                    pointXOffset = pointPadding + (groupPadding + colIndex *
	                        pointOffsetWidth - (categoryWidth / 2)) *
	                    (reversedXAxis ? -1 : 1);

	                // Save it for reading in linked series (Error bars particularly)
	                series.columnMetrics = {
	                    width: pointWidth,
	                    offset: pointXOffset
	                };
	                return series.columnMetrics;

	            },

	            /**
	             * Make the columns crisp. The edges are rounded to the nearest full pixel.
	             */
	            crispCol: function(x, y, w, h) {
	                var chart = this.chart,
	                    borderWidth = this.borderWidth,
	                    xCrisp = -(borderWidth % 2 ? 0.5 : 0),
	                    yCrisp = borderWidth % 2 ? 0.5 : 1,
	                    right,
	                    bottom,
	                    fromTop;

	                if (chart.inverted && chart.renderer.isVML) {
	                    yCrisp += 1;
	                }

	                // Horizontal. We need to first compute the exact right edge, then round it
	                // and compute the width from there.
	                if (this.options.crisp) {
	                    right = Math.round(x + w) + xCrisp;
	                    x = Math.round(x) + xCrisp;
	                    w = right - x;
	                }

	                // Vertical
	                bottom = Math.round(y + h) + yCrisp;
	                fromTop = Math.abs(y) <= 0.5 && bottom > 0.5; // #4504, #4656
	                y = Math.round(y) + yCrisp;
	                h = bottom - y;

	                // Top edges are exceptions
	                if (fromTop && h) { // #5146
	                    y -= 1;
	                    h += 1;
	                }

	                return {
	                    x: x,
	                    y: y,
	                    width: w,
	                    height: h
	                };
	            },

	            /**
	             * Translate each point to the plot area coordinate system and find shape positions
	             */
	            translate: function() {
	                var series = this,
	                    chart = series.chart,
	                    options = series.options,
	                    dense = series.dense = series.closestPointRange * series.xAxis.transA < 2,
	                    borderWidth = series.borderWidth = pick(
	                        options.borderWidth,
	                        dense ? 0 : 1 // #3635
	                    ),
	                    yAxis = series.yAxis,
	                    threshold = options.threshold,
	                    translatedThreshold = series.translatedThreshold = yAxis.getThreshold(threshold),
	                    minPointLength = pick(options.minPointLength, 5),
	                    metrics = series.getColumnMetrics(),
	                    pointWidth = metrics.width,
	                    seriesBarW = series.barW = Math.max(pointWidth, 1 + 2 * borderWidth), // postprocessed for border width
	                    pointXOffset = series.pointXOffset = metrics.offset;

	                if (chart.inverted) {
	                    translatedThreshold -= 0.5; // #3355
	                }

	                // When the pointPadding is 0, we want the columns to be packed tightly, so we allow individual
	                // columns to have individual sizes. When pointPadding is greater, we strive for equal-width
	                // columns (#2694).
	                if (options.pointPadding) {
	                    seriesBarW = Math.ceil(seriesBarW);
	                }

	                Series.prototype.translate.apply(series);

	                // Record the new values
	                each(series.points, function(point) {
	                    var yBottom = pick(point.yBottom, translatedThreshold),
	                        safeDistance = 999 + Math.abs(yBottom),
	                        plotY = Math.min(Math.max(-safeDistance, point.plotY), yAxis.len + safeDistance), // Don't draw too far outside plot area (#1303, #2241, #4264)
	                        barX = point.plotX + pointXOffset,
	                        barW = seriesBarW,
	                        barY = Math.min(plotY, yBottom),
	                        up,
	                        barH = Math.max(plotY, yBottom) - barY;

	                    // Handle options.minPointLength
	                    if (Math.abs(barH) < minPointLength) {
	                        if (minPointLength) {
	                            barH = minPointLength;
	                            up = (!yAxis.reversed && !point.negative) || (yAxis.reversed && point.negative);
	                            barY = Math.abs(barY - translatedThreshold) > minPointLength ? // stacked
	                                yBottom - minPointLength : // keep position
	                                translatedThreshold - (up ? minPointLength : 0); // #1485, #4051
	                        }
	                    }

	                    // Cache for access in polar
	                    point.barX = barX;
	                    point.pointWidth = pointWidth;

	                    // Fix the tooltip on center of grouped columns (#1216, #424, #3648)
	                    point.tooltipPos = chart.inverted ? [yAxis.len + yAxis.pos - chart.plotLeft - plotY, series.xAxis.len - barX - barW / 2, barH] : [barX + barW / 2, plotY + yAxis.pos - chart.plotTop, barH];

	                    // Register shape type and arguments to be used in drawPoints
	                    point.shapeType = 'rect';
	                    point.shapeArgs = series.crispCol.apply(
	                        series,
	                        point.isNull ?
	                        // #3169, drilldown from null must have a position to work from
	                        // #6585, dataLabel should be placed on xAxis, not floating in the middle of the chart
	                        [barX, translatedThreshold, barW, 0] : [barX, barY, barW, barH]
	                    );
	                });

	            },

	            getSymbol: noop,

	            /**
	             * Use a solid rectangle like the area series types
	             */
	            drawLegendSymbol: LegendSymbolMixin.drawRectangle,


	            /**
	             * Columns have no graph
	             */
	            drawGraph: function() {
	                this.group[this.dense ? 'addClass' : 'removeClass']('highcharts-dense-data');
	            },


	            /**
	             * Get presentational attributes
	             */
	            pointAttribs: function(point, state) {
	                var options = this.options,
	                    stateOptions,
	                    ret,
	                    p2o = this.pointAttrToOptions || {},
	                    strokeOption = p2o.stroke || 'borderColor',
	                    strokeWidthOption = p2o['stroke-width'] || 'borderWidth',
	                    fill = (point && point.color) || this.color,
	                    stroke = point[strokeOption] || options[strokeOption] ||
	                    this.color || fill, // set to fill when borderColor null
	                    strokeWidth = point[strokeWidthOption] ||
	                    options[strokeWidthOption] || this[strokeWidthOption] || 0,
	                    dashstyle = options.dashStyle,
	                    zone,
	                    brightness;

	                // Handle zone colors
	                if (point && this.zones.length) {
	                    zone = point.getZone();
	                    fill = point.options.color || (zone && zone.color) || this.color; // When zones are present, don't use point.color (#4267). Changed order (#6527)
	                }

	                // Select or hover states
	                if (state) {
	                    stateOptions = merge(
	                        options.states[state],
	                        point.options.states && point.options.states[state] || {} // #6401
	                    );
	                    brightness = stateOptions.brightness;
	                    fill = stateOptions.color ||
	                        (brightness !== undefined && color(fill).brighten(stateOptions.brightness).get()) ||
	                        fill;
	                    stroke = stateOptions[strokeOption] || stroke;
	                    strokeWidth = stateOptions[strokeWidthOption] || strokeWidth;
	                    dashstyle = stateOptions.dashStyle || dashstyle;
	                }

	                ret = {
	                    'fill': fill,
	                    'stroke': stroke,
	                    'stroke-width': strokeWidth
	                };

	                if (dashstyle) {
	                    ret.dashstyle = dashstyle;
	                }

	                return ret;
	            },


	            /**
	             * Draw the columns. For bars, the series.group is rotated, so the same coordinates
	             * apply for columns and bars. This method is inherited by scatter series.
	             *
	             */
	            drawPoints: function() {
	                var series = this,
	                    chart = this.chart,
	                    options = series.options,
	                    renderer = chart.renderer,
	                    animationLimit = options.animationLimit || 250,
	                    shapeArgs;

	                // draw the columns
	                each(series.points, function(point) {
	                    var plotY = point.plotY,
	                        graphic = point.graphic;

	                    if (isNumber(plotY) && point.y !== null) {
	                        shapeArgs = point.shapeArgs;

	                        if (graphic) { // update
	                            graphic[chart.pointCount < animationLimit ? 'animate' : 'attr'](
	                                merge(shapeArgs)
	                            );

	                        } else {
	                            point.graphic = graphic = renderer[point.shapeType](shapeArgs)
	                                .add(point.group || series.group);
	                        }

	                        // Border radius is not stylable (#6900)
	                        if (options.borderRadius) {
	                            graphic.attr({
	                                r: options.borderRadius
	                            });
	                        }


	                        // Presentational
	                        graphic
	                            .attr(series.pointAttribs(point, point.selected && 'select'))
	                            .shadow(options.shadow, null, options.stacking && !options.borderRadius);


	                        graphic.addClass(point.getClassName(), true);


	                    } else if (graphic) {
	                        point.graphic = graphic.destroy(); // #1269
	                    }
	                });
	            },

	            /**
	             * Animate the column heights one by one from zero
	             * @param {Boolean} init Whether to initialize the animation or run it
	             */
	            animate: function(init) {
	                var series = this,
	                    yAxis = this.yAxis,
	                    options = series.options,
	                    inverted = this.chart.inverted,
	                    attr = {},
	                    translatedThreshold;

	                if (svg) { // VML is too slow anyway
	                    if (init) {
	                        attr.scaleY = 0.001;
	                        translatedThreshold = Math.min(yAxis.pos + yAxis.len, Math.max(yAxis.pos, yAxis.toPixels(options.threshold)));
	                        if (inverted) {
	                            attr.translateX = translatedThreshold - yAxis.len;
	                        } else {
	                            attr.translateY = translatedThreshold;
	                        }
	                        series.group.attr(attr);

	                    } else { // run the animation

	                        attr[inverted ? 'translateX' : 'translateY'] = yAxis.pos;
	                        series.group.animate(attr, extend(animObject(series.options.animation), {
	                            // Do the scale synchronously to ensure smooth updating (#5030)
	                            step: function(val, fx) {
	                                series.group.attr({
	                                    scaleY: Math.max(0.001, fx.pos) // #5250
	                                });
	                            }
	                        }));

	                        // delete this function to allow it only once
	                        series.animate = null;
	                    }
	                }
	            },

	            /**
	             * Remove this series from the chart
	             */
	            remove: function() {
	                var series = this,
	                    chart = series.chart;

	                // column and bar series affects other series of the same type
	                // as they are either stacked or grouped
	                if (chart.hasRendered) {
	                    each(chart.series, function(otherSeries) {
	                        if (otherSeries.type === series.type) {
	                            otherSeries.isDirty = true;
	                        }
	                    });
	                }

	                Series.prototype.remove.apply(series, arguments);
	            }
	        });

	    }(Highcharts));
	    (function(H) {
	        /**
	         * (c) 2010-2017 Torstein Honsi
	         *
	         * License: www.highcharts.com/license
	         */

	        var seriesType = H.seriesType;

	        /**
	         * The Bar series class
	         */
	        seriesType('bar', 'column', null, {
	            /**
	             */
	            inverted: true
	        });
	        /**
	         * @extends {plotOptions.column}
	         * @optionparent plotOptions.bar
	         */

	    }(Highcharts));
	    (function(H) {
	        /**
	         * (c) 2010-2017 Torstein Honsi
	         *
	         * License: www.highcharts.com/license
	         */
	        var Series = H.Series,
	            seriesType = H.seriesType;
	        /**
	         * The scatter series type
	         */

	        /**
	         * @extends {plotOptions.line}
	         * @optionparent plotOptions.scatter
	         */
	        seriesType('scatter', 'line', {

	            /**
	             * The width of the line connecting the data points.
	             * 
	             * @type {Number}
	             * @sample {highcharts} highcharts/plotoptions/scatter-linewidth-none/ 0 by default
	             * @sample {highcharts} highcharts/plotoptions/scatter-linewidth-1/ 1px
	             * @default 0
	             * @product highcharts highstock
	             */
	            lineWidth: 0,

	            /**
	             */
	            findNearestPointBy: 'xy',

	            /**
	             */
	            marker: {

	                /**
	                 */
	                enabled: true // Overrides auto-enabling in line series (#3647)
	            },

	            /**
	             * A configuration object for the tooltip rendering of each single
	             * series. Properties are inherited from <a class="internal">#tooltip</a>.
	             * Overridable properties are `headerFormat`, `pointFormat`, `yDecimals`,
	             * `xDateFormat`, `yPrefix` and `ySuffix`. Unlike other series, in
	             * a scatter plot the series.name by default shows in the headerFormat
	             * and point.x and point.y in the pointFormat.
	             * 
	             * @product highcharts highstock
	             */
	            tooltip: {

	                headerFormat: '<span style="color:{point.color}">\u25CF</span> ' +
	                    '<span style="font-size: 0.85em"> {series.name}</span><br/>',


	                /**
	                 */
	                pointFormat: 'x: <b>{point.x}</b><br/>y: <b>{point.y}</b><br/>'
	            }

	            // Prototype members
	        }, {
	            sorted: false,
	            requireSorting: false,
	            noSharedTooltip: true,
	            trackerGroups: ['group', 'markerGroup', 'dataLabelsGroup'],
	            takeOrdinalPosition: false, // #2342
	            drawGraph: function() {
	                if (this.options.lineWidth) {
	                    Series.prototype.drawGraph.call(this);
	                }
	            }
	        });

	    }(Highcharts));
	    (function(H) {
	        /**
	         * (c) 2010-2017 Torstein Honsi
	         *
	         * License: www.highcharts.com/license
	         */
	        var pick = H.pick,
	            relativeLength = H.relativeLength;

	        H.CenteredSeriesMixin = {
	            /**
	             * Get the center of the pie based on the size and center options relative to the
	             * plot area. Borrowed by the polar and gauge series types.
	             */
	            getCenter: function() {

	                var options = this.options,
	                    chart = this.chart,
	                    slicingRoom = 2 * (options.slicedOffset || 0),
	                    handleSlicingRoom,
	                    plotWidth = chart.plotWidth - 2 * slicingRoom,
	                    plotHeight = chart.plotHeight - 2 * slicingRoom,
	                    centerOption = options.center,
	                    positions = [pick(centerOption[0], '50%'), pick(centerOption[1], '50%'), options.size || '100%', options.innerSize || 0],
	                    smallestSize = Math.min(plotWidth, plotHeight),
	                    i,
	                    value;

	                for (i = 0; i < 4; ++i) {
	                    value = positions[i];
	                    handleSlicingRoom = i < 2 || (i === 2 && /%$/.test(value));

	                    // i == 0: centerX, relative to width
	                    // i == 1: centerY, relative to height
	                    // i == 2: size, relative to smallestSize
	                    // i == 3: innerSize, relative to size
	                    positions[i] = relativeLength(value, [plotWidth, plotHeight, smallestSize, positions[2]][i]) +
	                        (handleSlicingRoom ? slicingRoom : 0);

	                }
	                // innerSize cannot be larger than size (#3632)
	                if (positions[3] > positions[2]) {
	                    positions[3] = positions[2];
	                }
	                return positions;
	            }
	        };

	    }(Highcharts));
	    (function(H) {
	        /**
	         * (c) 2010-2017 Torstein Honsi
	         *
	         * License: www.highcharts.com/license
	         */
	        var addEvent = H.addEvent,
	            CenteredSeriesMixin = H.CenteredSeriesMixin,
	            defined = H.defined,
	            each = H.each,
	            extend = H.extend,
	            inArray = H.inArray,
	            LegendSymbolMixin = H.LegendSymbolMixin,
	            noop = H.noop,
	            pick = H.pick,
	            Point = H.Point,
	            Series = H.Series,
	            seriesType = H.seriesType,
	            seriesTypes = H.seriesTypes,
	            setAnimation = H.setAnimation;

	        /**
	         * The pie series type.
	         *
	         * @constructor seriesTypes.pie
	         * @augments Series
	         */

	        /**
	         * @extends {plotOptions.line}
	         * @optionparent plotOptions.pie
	         */
	        seriesType('pie', 'line', {

	            /**
	             * The center of the pie chart relative to the plot area. Can be percentages
	             * or pixel values. The default behaviour (as of 3.0) is to center
	             * the pie so that all slices and data labels are within the plot area.
	             * As a consequence, the pie may actually jump around in a chart with
	             * dynamic values, as the data labels move. In that case, the center
	             * should be explicitly set, for example to `["50%", "50%"]`.
	             * 
	             * @type {Array<String|Number>}
	             * @sample {highcharts} highcharts/plotoptions/pie-center/ Centered at 100, 100
	             * @default [null, null]
	             * @product highcharts
	             */
	            center: [null, null],

	            /**
	             */
	            clip: false,

	            /**
	             */
	            colorByPoint: true, // always true for pies

	            /**
	             * @extends plotOptions.series.dataLabels
	             * @excluding align,allowOverlap,staggerLines,step
	             * @product highcharts
	             */
	            dataLabels: {
	                // align: null,
	                // connectorWidth: 1,
	                // connectorColor: point.color,
	                // connectorPadding: 5,

	                /**
	                 * The distance of the data label from the pie's edge. Negative numbers
	                 * put the data label on top of the pie slices. Connectors are only
	                 * shown for data labels outside the pie.
	                 * 
	                 * @type {Number}
	                 * @sample {highcharts} highcharts/plotoptions/pie-datalabels-distance/ Data labels on top of the pie
	                 * @default 30
	                 * @since 2.1
	                 * @product highcharts
	                 */
	                distance: 30,

	                /**
	                 * Enable or disable the data labels.
	                 * 
	                 * @type {Boolean}
	                 * @since 2.1
	                 * @product highcharts
	                 */
	                enabled: true,

	                /**
	                 */
	                formatter: function() { // #2945
	                    return this.point.isNull ? undefined : this.point.name;
	                },
	                // softConnector: true,

	                /**
	                 */
	                x: 0
	                // y: 0
	            },

	            /**
	             * Equivalent to [chart.ignoreHiddenSeries](#chart.ignoreHiddenSeries),
	             * this option tells whether the series shall be redrawn as if the
	             * hidden point were `null`.
	             * 
	             * The default value changed from `false` to `true` with Highcharts
	             * 3.0.
	             * 
	             * @type {Boolean}
	             * @sample {highcharts} highcharts/plotoptions/pie-ignorehiddenpoint/ True, the hiddden point is ignored
	             * @default true
	             * @since 2.3.0
	             * @product highcharts
	             */
	            ignoreHiddenPoint: true,
	            //innerSize: 0,

	            /**
	             */
	            legendType: 'point',

	            /**
	             */
	            marker: null, // point options are specified in the base options

	            /**
	             * The diameter of the pie relative to the plot area. Can be a percentage
	             * or pixel value. Pixel values are given as integers. The default
	             * behaviour (as of 3.0) is to scale to the plot area and give room
	             * for data labels within the plot area. As a consequence, the size
	             * of the pie may vary when points are updated and data labels more
	             * around. In that case it is best to set a fixed value, for example
	             * `"75%"`.
	             * 
	             * @type {String|Number}
	             * @sample {highcharts} highcharts/plotoptions/pie-size/ Smaller pie
	             * @default  
	             * @product highcharts
	             */
	            size: null,

	            /**
	             * Whether to display this particular series or series type in the
	             * legend. Since 2.1, pies are not shown in the legend by default.
	             * 
	             * @type {Boolean}
	             * @sample {highcharts} highcharts/plotoptions/series-showinlegend/ One series in the legend, one hidden
	             * @product highcharts
	             */
	            showInLegend: false,

	            /**
	             * If a point is sliced, moved out from the center, how many pixels
	             * should it be moved?.
	             * 
	             * @type {Number}
	             * @sample {highcharts} highcharts/plotoptions/pie-slicedoffset-20/ 20px offset
	             * @default 10
	             * @product highcharts
	             */
	            slicedOffset: 10,

	            /**
	             * Sticky tracking of mouse events. When true, the `mouseOut` event
	             * on a series isn't triggered until the mouse moves over another series,
	             * or out of the plot area. When false, the `mouseOut` event on a
	             * series is triggered when the mouse leaves the area around the series'
	             * graph or markers. This also implies the tooltip. When `stickyTracking`
	             * is false and `tooltip.shared` is false, the tooltip will be hidden
	             * when moving the mouse between series.
	             * 
	             * @type {Boolean}
	             * @default false
	             * @product highcharts
	             */
	            stickyTracking: false,

	            /**
	             */
	            tooltip: {

	                /**
	                 */
	                followPointer: true
	            },


	            /**
	             * The color of the border surrounding each slice. When `null`, the
	             * border takes the same color as the slice fill. This can be used
	             * together with a `borderWidth` to fill drawing gaps created by antialiazing
	             * artefacts in borderless pies.
	             * 
	             * In [styled mode](http://www.highcharts.com/docs/chart-design-and-
	             * style/style-by-css), the border stroke is given in the `.highcharts-
	             * point` class.
	             * 
	             * @type {Color}
	             * @sample {highcharts} highcharts/plotoptions/pie-bordercolor-black/ Black border
	             * @default #ffffff
	             * @product highcharts
	             */
	            borderColor: '#ffffff',

	            /**
	             * The width of the border surrounding each slice.
	             * 
	             * When setting the border width to 0, there may be small gaps between
	             * the slices due to SVG antialiasing artefacts. To work around this,
	             * keep the border width at 0.5 or 1, but set the `borderColor` to
	             * `null` instead.
	             * 
	             * In [styled mode](http://www.highcharts.com/docs/chart-design-and-
	             * style/style-by-css), the border stroke width is given in the `.highcharts-
	             * point` class.
	             * 
	             * @type {Number}
	             * @sample {highcharts} highcharts/plotoptions/pie-borderwidth/ 3px border
	             * @default 1
	             * @product highcharts
	             */
	            borderWidth: 1,

	            /**
	             */
	            states: {

	                /**
	                 * @extends plotOptions.series.states.hover
	                 * @product highcharts
	                 */
	                hover: {

	                    /**
	                     * How much to brighten the point on interaction. Requires the main
	                     * color to be defined in hex or rgb(a) format.
	                     * 
	                     * In [styled mode](http://www.highcharts.com/docs/chart-design-and-
	                     * style/style-by-css), the hover brightness is by default replaced
	                     * by a fill-opacity given in the `.highcharts-point-hover` class.
	                     * 
	                     * @type {Number}
	                     * @sample {highcharts} highcharts/plotoptions/pie-states-hover-brightness/ Brightened by 0.5
	                     * @default 0.1
	                     * @product highcharts
	                     */
	                    brightness: 0.1,

	                    /**
	                     */
	                    shadow: false
	                }
	            }


	        }, /** @lends seriesTypes.pie.prototype */ {
	            isCartesian: false,
	            requireSorting: false,
	            directTouch: true,
	            noSharedTooltip: true,
	            trackerGroups: ['group', 'dataLabelsGroup'],
	            axisTypes: [],
	            pointAttribs: seriesTypes.column.prototype.pointAttribs,
	            /**
	             * Animate the pies in
	             */
	            animate: function(init) {
	                var series = this,
	                    points = series.points,
	                    startAngleRad = series.startAngleRad;

	                if (!init) {
	                    each(points, function(point) {
	                        var graphic = point.graphic,
	                            args = point.shapeArgs;

	                        if (graphic) {
	                            // start values
	                            graphic.attr({
	                                r: point.startR || (series.center[3] / 2), // animate from inner radius (#779)
	                                start: startAngleRad,
	                                end: startAngleRad
	                            });

	                            // animate
	                            graphic.animate({
	                                r: args.r,
	                                start: args.start,
	                                end: args.end
	                            }, series.options.animation);
	                        }
	                    });

	                    // delete this function to allow it only once
	                    series.animate = null;
	                }
	            },

	            /**
	             * Recompute total chart sum and update percentages of points.
	             */
	            updateTotals: function() {
	                var i,
	                    total = 0,
	                    points = this.points,
	                    len = points.length,
	                    point,
	                    ignoreHiddenPoint = this.options.ignoreHiddenPoint;

	                // Get the total sum
	                for (i = 0; i < len; i++) {
	                    point = points[i];
	                    total += (ignoreHiddenPoint && !point.visible) ?
	                        0 :
	                        point.isNull ? 0 : point.y;
	                }
	                this.total = total;

	                // Set each point's properties
	                for (i = 0; i < len; i++) {
	                    point = points[i];
	                    point.percentage = (total > 0 && (point.visible || !ignoreHiddenPoint)) ? point.y / total * 100 : 0;
	                    point.total = total;
	                }
	            },

	            /**
	             * Extend the generatePoints method by adding total and percentage properties to each point
	             */
	            generatePoints: function() {
	                Series.prototype.generatePoints.call(this);
	                this.updateTotals();
	            },

	            /**
	             * Do translation for pie slices
	             */
	            translate: function(positions) {
	                this.generatePoints();

	                var series = this,
	                    cumulative = 0,
	                    precision = 1000, // issue #172
	                    options = series.options,
	                    slicedOffset = options.slicedOffset,
	                    connectorOffset = slicedOffset + (options.borderWidth || 0),
	                    finalConnectorOffset,
	                    start,
	                    end,
	                    angle,
	                    startAngle = options.startAngle || 0,
	                    startAngleRad = series.startAngleRad = Math.PI / 180 * (startAngle - 90),
	                    endAngleRad = series.endAngleRad = Math.PI / 180 * ((pick(options.endAngle, startAngle + 360)) - 90),
	                    circ = endAngleRad - startAngleRad, //2 * Math.PI,
	                    points = series.points,
	                    radiusX, // the x component of the radius vector for a given point
	                    radiusY,
	                    labelDistance = options.dataLabels.distance,
	                    ignoreHiddenPoint = options.ignoreHiddenPoint,
	                    i,
	                    len = points.length,
	                    point;

	                // Get positions - either an integer or a percentage string must be given.
	                // If positions are passed as a parameter, we're in a recursive loop for adjusting
	                // space for data labels.
	                if (!positions) {
	                    series.center = positions = series.getCenter();
	                }

	                // Utility for getting the x value from a given y, used for anticollision
	                // logic in data labels.
	                // Added point for using specific points' label distance.
	                series.getX = function(y, left, point) {
	                    angle = Math.asin(Math.min((y - positions[1]) / (positions[2] / 2 + point.labelDistance), 1));
	                    return positions[0] +
	                        (left ? -1 : 1) *
	                        (Math.cos(angle) * (positions[2] / 2 + point.labelDistance));
	                };

	                // Calculate the geometry for each point
	                for (i = 0; i < len; i++) {

	                    point = points[i];

	                    // Used for distance calculation for specific point.
	                    point.labelDistance = pick(
	                        point.options.dataLabels && point.options.dataLabels.distance,
	                        labelDistance
	                    );

	                    // Saved for later dataLabels distance calculation.
	                    series.maxLabelDistance = Math.max(series.maxLabelDistance || 0, point.labelDistance);

	                    // set start and end angle
	                    start = startAngleRad + (cumulative * circ);
	                    if (!ignoreHiddenPoint || point.visible) {
	                        cumulative += point.percentage / 100;
	                    }
	                    end = startAngleRad + (cumulative * circ);

	                    // set the shape
	                    point.shapeType = 'arc';
	                    point.shapeArgs = {
	                        x: positions[0],
	                        y: positions[1],
	                        r: positions[2] / 2,
	                        innerR: positions[3] / 2,
	                        start: Math.round(start * precision) / precision,
	                        end: Math.round(end * precision) / precision
	                    };

	                    // The angle must stay within -90 and 270 (#2645)
	                    angle = (end + start) / 2;
	                    if (angle > 1.5 * Math.PI) {
	                        angle -= 2 * Math.PI;
	                    } else if (angle < -Math.PI / 2) {
	                        angle += 2 * Math.PI;
	                    }

	                    // Center for the sliced out slice
	                    point.slicedTranslation = {
	                        translateX: Math.round(Math.cos(angle) * slicedOffset),
	                        translateY: Math.round(Math.sin(angle) * slicedOffset)
	                    };

	                    // set the anchor point for tooltips
	                    radiusX = Math.cos(angle) * positions[2] / 2;
	                    radiusY = Math.sin(angle) * positions[2] / 2;
	                    point.tooltipPos = [
	                        positions[0] + radiusX * 0.7,
	                        positions[1] + radiusY * 0.7
	                    ];

	                    point.half = angle < -Math.PI / 2 || angle > Math.PI / 2 ? 1 : 0;
	                    point.angle = angle;

	                    // Set the anchor point for data labels. Use point.labelDistance 
	                    // instead of labelDistance // #1174
	                    // finalConnectorOffset - not override connectorOffset value.
	                    finalConnectorOffset = Math.min(connectorOffset, point.labelDistance / 5); // #1678
	                    point.labelPos = [
	                        positions[0] + radiusX + Math.cos(angle) * point.labelDistance, // first break of connector
	                        positions[1] + radiusY + Math.sin(angle) * point.labelDistance, // a/a
	                        positions[0] + radiusX + Math.cos(angle) * finalConnectorOffset, // second break, right outside pie
	                        positions[1] + radiusY + Math.sin(angle) * finalConnectorOffset, // a/a
	                        positions[0] + radiusX, // landing point for connector
	                        positions[1] + radiusY, // a/a
	                        point.labelDistance < 0 ? // alignment
	                        'center' :
	                        point.half ? 'right' : 'left', // alignment
	                        angle // center angle
	                    ];

	                }
	            },

	            drawGraph: null,

	            /**
	             * Draw the data points
	             */
	            drawPoints: function() {
	                var series = this,
	                    chart = series.chart,
	                    renderer = chart.renderer,
	                    groupTranslation,
	                    //center,
	                    graphic,
	                    //group,
	                    pointAttr,
	                    shapeArgs;


	                var shadow = series.options.shadow;
	                if (shadow && !series.shadowGroup) {
	                    series.shadowGroup = renderer.g('shadow')
	                        .add(series.group);
	                }


	                // draw the slices
	                each(series.points, function(point) {
	                    if (!point.isNull) {
	                        graphic = point.graphic;
	                        shapeArgs = point.shapeArgs;


	                        // If the point is sliced, use special translation, else use
	                        // plot area traslation
	                        groupTranslation = point.getTranslate();


	                        // Put the shadow behind all points
	                        var shadowGroup = point.shadowGroup;
	                        if (shadow && !shadowGroup) {
	                            shadowGroup = point.shadowGroup = renderer.g('shadow')
	                                .add(series.shadowGroup);
	                        }

	                        if (shadowGroup) {
	                            shadowGroup.attr(groupTranslation);
	                        }
	                        pointAttr = series.pointAttribs(point, point.selected && 'select');


	                        // Draw the slice
	                        if (graphic) {
	                            graphic
	                                .setRadialReference(series.center)

	                                .attr(pointAttr)

	                                .animate(extend(shapeArgs, groupTranslation));
	                        } else {

	                            point.graphic = graphic = renderer[point.shapeType](shapeArgs)
	                                .setRadialReference(series.center)
	                                .attr(groupTranslation)
	                                .add(series.group);

	                            if (!point.visible) {
	                                graphic.attr({
	                                    visibility: 'hidden'
	                                });
	                            }


	                            graphic
	                                .attr(pointAttr)
	                                .attr({
	                                    'stroke-linejoin': 'round'
	                                })
	                                .shadow(shadow, shadowGroup);

	                        }

	                        graphic.addClass(point.getClassName());

	                    }
	                });

	            },


	            searchPoint: noop,

	            /**
	             * Utility for sorting data labels
	             */
	            sortByAngle: function(points, sign) {
	                points.sort(function(a, b) {
	                    return a.angle !== undefined && (b.angle - a.angle) * sign;
	                });
	            },

	            /**
	             * Use a simple symbol from LegendSymbolMixin
	             */
	            drawLegendSymbol: LegendSymbolMixin.drawRectangle,

	            /**
	             * Use the getCenter method from drawLegendSymbol
	             */
	            getCenter: CenteredSeriesMixin.getCenter,

	            /**
	             * Pies don't have point marker symbols
	             */
	            getSymbol: noop


	            /**
	             * @constructor seriesTypes.pie.prototype.pointClass
	             * @extends {Point}
	             */
	        }, /** @lends seriesTypes.pie.prototype.pointClass.prototype */ {
	            /**
	             * Initiate the pie slice
	             */
	            init: function() {

	                Point.prototype.init.apply(this, arguments);

	                var point = this,
	                    toggleSlice;

	                point.name = pick(point.name, 'Slice');

	                // add event listener for select
	                toggleSlice = function(e) {
	                    point.slice(e.type === 'select');
	                };
	                addEvent(point, 'select', toggleSlice);
	                addEvent(point, 'unselect', toggleSlice);

	                return point;
	            },

	            /**
	             * Negative points are not valid (#1530, #3623, #5322)
	             */
	            isValid: function() {
	                return H.isNumber(this.y, true) && this.y >= 0;
	            },

	            /**
	             * Toggle the visibility of the pie slice
	             * @param {Boolean} vis Whether to show the slice or not. If undefined, the
	             *    visibility is toggled
	             */
	            setVisible: function(vis, redraw) {
	                var point = this,
	                    series = point.series,
	                    chart = series.chart,
	                    ignoreHiddenPoint = series.options.ignoreHiddenPoint;

	                redraw = pick(redraw, ignoreHiddenPoint);

	                if (vis !== point.visible) {

	                    // If called without an argument, toggle visibility
	                    point.visible = point.options.visible = vis = vis === undefined ? !point.visible : vis;
	                    series.options.data[inArray(point, series.data)] = point.options; // update userOptions.data

	                    // Show and hide associated elements. This is performed regardless of redraw or not,
	                    // because chart.redraw only handles full series.
	                    each(['graphic', 'dataLabel', 'connector', 'shadowGroup'], function(key) {
	                        if (point[key]) {
	                            point[key][vis ? 'show' : 'hide'](true);
	                        }
	                    });

	                    if (point.legendItem) {
	                        chart.legend.colorizeItem(point, vis);
	                    }

	                    // #4170, hide halo after hiding point
	                    if (!vis && point.state === 'hover') {
	                        point.setState('');
	                    }

	                    // Handle ignore hidden slices
	                    if (ignoreHiddenPoint) {
	                        series.isDirty = true;
	                    }

	                    if (redraw) {
	                        chart.redraw();
	                    }
	                }
	            },

	            /**
	             * Set or toggle whether the slice is cut out from the pie
	             * @param {Boolean} sliced When undefined, the slice state is toggled
	             * @param {Boolean} redraw Whether to redraw the chart. True by default.
	             */
	            slice: function(sliced, redraw, animation) {
	                var point = this,
	                    series = point.series,
	                    chart = series.chart;

	                setAnimation(animation, chart);

	                // redraw is true by default
	                redraw = pick(redraw, true);

	                // if called without an argument, toggle
	                point.sliced = point.options.sliced = sliced = defined(sliced) ? sliced : !point.sliced;
	                series.options.data[inArray(point, series.data)] = point.options; // update userOptions.data

	                point.graphic.animate(this.getTranslate());


	                if (point.shadowGroup) {
	                    point.shadowGroup.animate(this.getTranslate());
	                }

	            },

	            getTranslate: function() {
	                return this.sliced ? this.slicedTranslation : {
	                    translateX: 0,
	                    translateY: 0
	                };
	            },

	            haloPath: function(size) {
	                var shapeArgs = this.shapeArgs;

	                return this.sliced || !this.visible ? [] :
	                    this.series.chart.renderer.symbols.arc(
	                        shapeArgs.x,
	                        shapeArgs.y,
	                        shapeArgs.r + size,
	                        shapeArgs.r + size, {
	                            innerR: this.shapeArgs.r,
	                            start: shapeArgs.start,
	                            end: shapeArgs.end
	                        }
	                    );
	            }
	        });

	    }(Highcharts));
	    (function(H) {
	        /**
	         * (c) 2010-2017 Torstein Honsi
	         *
	         * License: www.highcharts.com/license
	         */
	        var addEvent = H.addEvent,
	            arrayMax = H.arrayMax,
	            defined = H.defined,
	            each = H.each,
	            extend = H.extend,
	            format = H.format,
	            map = H.map,
	            merge = H.merge,
	            noop = H.noop,
	            pick = H.pick,
	            relativeLength = H.relativeLength,
	            Series = H.Series,
	            seriesTypes = H.seriesTypes,
	            stableSort = H.stableSort;


	        /**
	         * Generatl distribution algorithm for distributing labels of differing size along a
	         * confined length in two dimensions. The algorithm takes an array of objects containing
	         * a size, a target and a rank. It will place the labels as close as possible to their 
	         * targets, skipping the lowest ranked labels if necessary.
	         */
	        H.distribute = function(boxes, len) {

	            var i,
	                overlapping = true,
	                origBoxes = boxes, // Original array will be altered with added .pos
	                restBoxes = [], // The outranked overshoot
	                box,
	                target,
	                total = 0;

	            function sortByTarget(a, b) {
	                return a.target - b.target;
	            }

	            // If the total size exceeds the len, remove those boxes with the lowest rank
	            i = boxes.length;
	            while (i--) {
	                total += boxes[i].size;
	            }

	            // Sort by rank, then slice away overshoot
	            if (total > len) {
	                stableSort(boxes, function(a, b) {
	                    return (b.rank || 0) - (a.rank || 0);
	                });
	                i = 0;
	                total = 0;
	                while (total <= len) {
	                    total += boxes[i].size;
	                    i++;
	                }
	                restBoxes = boxes.splice(i - 1, boxes.length);
	            }

	            // Order by target
	            stableSort(boxes, sortByTarget);


	            // So far we have been mutating the original array. Now
	            // create a copy with target arrays
	            boxes = map(boxes, function(box) {
	                return {
	                    size: box.size,
	                    targets: [box.target]
	                };
	            });

	            while (overlapping) {
	                // Initial positions: target centered in box
	                i = boxes.length;
	                while (i--) {
	                    box = boxes[i];
	                    // Composite box, average of targets
	                    target = (Math.min.apply(0, box.targets) + Math.max.apply(0, box.targets)) / 2;
	                    box.pos = Math.min(Math.max(0, target - box.size / 2), len - box.size);
	                }

	                // Detect overlap and join boxes
	                i = boxes.length;
	                overlapping = false;
	                while (i--) {
	                    if (i > 0 && boxes[i - 1].pos + boxes[i - 1].size > boxes[i].pos) { // Overlap
	                        boxes[i - 1].size += boxes[i].size; // Add this size to the previous box
	                        boxes[i - 1].targets = boxes[i - 1].targets.concat(boxes[i].targets);

	                        // Overlapping right, push left
	                        if (boxes[i - 1].pos + boxes[i - 1].size > len) {
	                            boxes[i - 1].pos = len - boxes[i - 1].size;
	                        }
	                        boxes.splice(i, 1); // Remove this item
	                        overlapping = true;
	                    }
	                }
	            }

	            // Now the composite boxes are placed, we need to put the original boxes within them
	            i = 0;
	            each(boxes, function(box) {
	                var posInCompositeBox = 0;
	                each(box.targets, function() {
	                    origBoxes[i].pos = box.pos + posInCompositeBox;
	                    posInCompositeBox += origBoxes[i].size;
	                    i++;
	                });
	            });

	            // Add the rest (hidden) boxes and sort by target
	            origBoxes.push.apply(origBoxes, restBoxes);
	            stableSort(origBoxes, sortByTarget);
	        };


	        /**
	         * Draw the data labels
	         */
	        Series.prototype.drawDataLabels = function() {
	            var series = this,
	                seriesOptions = series.options,
	                options = seriesOptions.dataLabels,
	                points = series.points,
	                pointOptions,
	                generalOptions,
	                hasRendered = series.hasRendered || 0,
	                str,
	                dataLabelsGroup,
	                defer = pick(options.defer, !!seriesOptions.animation),
	                renderer = series.chart.renderer;

	            if (options.enabled || series._hasPointLabels) {

	                // Process default alignment of data labels for columns
	                if (series.dlProcessOptions) {
	                    series.dlProcessOptions(options);
	                }

	                // Create a separate group for the data labels to avoid rotation
	                dataLabelsGroup = series.plotGroup(
	                    'dataLabelsGroup',
	                    'data-labels',
	                    defer && !hasRendered ? 'hidden' : 'visible', // #5133
	                    options.zIndex || 6
	                );

	                if (defer) {
	                    dataLabelsGroup.attr({
	                        opacity: +hasRendered
	                    }); // #3300
	                    if (!hasRendered) {
	                        addEvent(series, 'afterAnimate', function() {
	                            if (series.visible) { // #2597, #3023, #3024
	                                dataLabelsGroup.show(true);
	                            }
	                            dataLabelsGroup[seriesOptions.animation ? 'animate' : 'attr']({
	                                opacity: 1
	                            }, {
	                                duration: 200
	                            });
	                        });
	                    }
	                }

	                // Make the labels for each point
	                generalOptions = options;
	                each(points, function(point) {
	                    var enabled,
	                        dataLabel = point.dataLabel,
	                        labelConfig,
	                        attr,
	                        rotation,
	                        connector = point.connector,
	                        isNew = !dataLabel,
	                        style;
	                    // Determine if each data label is enabled
	                    // @note dataLabelAttribs (like pointAttribs) would eradicate
	                    // the need for dlOptions, and simplify the section below.
	                    pointOptions = point.dlOptions || (point.options && point.options.dataLabels); // dlOptions is used in treemaps
	                    enabled = pick(pointOptions && pointOptions.enabled, generalOptions.enabled) && point.y !== null; // #2282, #4641
	                    if (enabled) {
	                        // Create individual options structure that can be extended without
	                        // affecting others
	                        options = merge(generalOptions, pointOptions);
	                        labelConfig = point.getLabelConfig();
	                        str = options.format ?
	                            format(options.format, labelConfig) :
	                            options.formatter.call(labelConfig, options);
	                        style = options.style;
	                        rotation = options.rotation;

	                        // Determine the color
	                        style.color = pick(options.color, style.color, series.color, '#000000');
	                        // Get automated contrast color
	                        if (style.color === 'contrast') {
	                            point.contrastColor = renderer.getContrast(point.color || series.color);
	                            style.color = options.inside || pick(point.labelDistance, options.distance) < 0 ||
	                                !!seriesOptions.stacking ? point.contrastColor : '#000000';
	                        }
	                        if (seriesOptions.cursor) {
	                            style.cursor = seriesOptions.cursor;
	                        }


	                        attr = {
	                            //align: align,

	                            fill: options.backgroundColor,
	                            stroke: options.borderColor,
	                            'stroke-width': options.borderWidth,

	                            r: options.borderRadius || 0,
	                            rotation: rotation,
	                            padding: options.padding,
	                            zIndex: 1
	                        };

	                        // Remove unused attributes (#947)
	                        H.objectEach(attr, function(val, name) {
	                            if (val === undefined) {
	                                delete attr[name];
	                            }
	                        });
	                    }
	                    // If the point is outside the plot area, destroy it. #678, #820
	                    if (dataLabel && (!enabled || !defined(str))) {
	                        point.dataLabel = dataLabel = dataLabel.destroy();
	                        if (connector) {
	                            point.connector = connector.destroy();
	                        }
	                        // Individual labels are disabled if the are explicitly disabled
	                        // in the point options, or if they fall outside the plot area.
	                    } else if (enabled && defined(str)) {
	                        // create new label
	                        if (!dataLabel) {
	                            dataLabel = point.dataLabel = renderer[rotation ? 'text' : 'label']( // labels don't support rotation
	                                str,
	                                0, -9999,
	                                options.shape,
	                                null,
	                                null,
	                                options.useHTML,
	                                null,
	                                'data-label'
	                            );
	                            dataLabel.addClass(
	                                'highcharts-data-label-color-' + point.colorIndex +
	                                ' ' + (options.className || '') +
	                                (options.useHTML ? 'highcharts-tracker' : '') // #3398
	                            );
	                        } else {
	                            attr.text = str;
	                        }
	                        dataLabel.attr(attr);

	                        // Styles must be applied before add in order to read text bounding box
	                        dataLabel.css(style).shadow(options.shadow);


	                        if (!dataLabel.added) {
	                            dataLabel.add(dataLabelsGroup);
	                        }
	                        // Now the data label is created and placed at 0,0, so we need to align it
	                        series.alignDataLabel(point, dataLabel, options, null, isNew);
	                    }
	                });
	            }
	        };

	        /**
	         * Align each individual data label
	         */
	        Series.prototype.alignDataLabel = function(point, dataLabel, options, alignTo, isNew) {
	            var chart = this.chart,
	                inverted = chart.inverted,
	                plotX = pick(point.plotX, -9999),
	                plotY = pick(point.plotY, -9999),
	                bBox = dataLabel.getBBox(),
	                fontSize,
	                baseline,
	                rotation = options.rotation,
	                normRotation,
	                negRotation,
	                align = options.align,
	                rotCorr, // rotation correction
	                // Math.round for rounding errors (#2683), alignTo to allow column labels (#2700)
	                visible =
	                this.visible &&
	                (
	                    point.series.forceDL ||
	                    chart.isInsidePlot(plotX, Math.round(plotY), inverted) ||
	                    (
	                        alignTo && chart.isInsidePlot(
	                            plotX,
	                            inverted ? alignTo.x + 1 : alignTo.y + alignTo.height - 1,
	                            inverted
	                        )
	                    )
	                ),
	                alignAttr, // the final position;
	                justify = pick(options.overflow, 'justify') === 'justify';

	            if (visible) {


	                fontSize = options.style.fontSize;


	                baseline = chart.renderer.fontMetrics(fontSize, dataLabel).b;

	                // The alignment box is a singular point
	                alignTo = extend({
	                    x: inverted ? this.yAxis.len - plotY : plotX,
	                    y: Math.round(inverted ? this.xAxis.len - plotX : plotY),
	                    width: 0,
	                    height: 0
	                }, alignTo);

	                // Add the text size for alignment calculation
	                extend(options, {
	                    width: bBox.width,
	                    height: bBox.height
	                });

	                // Allow a hook for changing alignment in the last moment, then do the alignment
	                if (rotation) {
	                    justify = false; // Not supported for rotated text
	                    rotCorr = chart.renderer.rotCorr(baseline, rotation); // #3723
	                    alignAttr = {
	                        x: alignTo.x + options.x + alignTo.width / 2 + rotCorr.x,
	                        y: alignTo.y + options.y + {
	                            top: 0,
	                            middle: 0.5,
	                            bottom: 1
	                        }[options.verticalAlign] * alignTo.height
	                    };
	                    dataLabel[isNew ? 'attr' : 'animate'](alignAttr)
	                        .attr({ // #3003
	                            align: align
	                        });

	                    // Compensate for the rotated label sticking out on the sides
	                    normRotation = (rotation + 720) % 360;
	                    negRotation = normRotation > 180 && normRotation < 360;

	                    if (align === 'left') {
	                        alignAttr.y -= negRotation ? bBox.height : 0;
	                    } else if (align === 'center') {
	                        alignAttr.x -= bBox.width / 2;
	                        alignAttr.y -= bBox.height / 2;
	                    } else if (align === 'right') {
	                        alignAttr.x -= bBox.width;
	                        alignAttr.y -= negRotation ? 0 : bBox.height;
	                    }


	                } else {
	                    dataLabel.align(options, null, alignTo);
	                    alignAttr = dataLabel.alignAttr;
	                }

	                // Handle justify or crop
	                if (justify) {
	                    point.isLabelJustified = this.justifyDataLabel(
	                        dataLabel,
	                        options,
	                        alignAttr,
	                        bBox,
	                        alignTo,
	                        isNew
	                    );

	                    // Now check that the data label is within the plot area
	                } else if (pick(options.crop, true)) {
	                    visible = chart.isInsidePlot(alignAttr.x, alignAttr.y) && chart.isInsidePlot(alignAttr.x + bBox.width, alignAttr.y + bBox.height);
	                }

	                // When we're using a shape, make it possible with a connector or an arrow pointing to thie point
	                if (options.shape && !rotation) {
	                    dataLabel[isNew ? 'attr' : 'animate']({
	                        anchorX: inverted ? chart.plotWidth - point.plotY : point.plotX,
	                        anchorY: inverted ? chart.plotHeight - point.plotX : point.plotY
	                    });
	                }
	            }

	            // Show or hide based on the final aligned position
	            if (!visible) {
	                dataLabel.attr({
	                    y: -9999
	                });
	                dataLabel.placed = false; // don't animate back in
	            }

	        };

	        /**
	         * If data labels fall partly outside the plot area, align them back in, in a way that
	         * doesn't hide the point.
	         */
	        Series.prototype.justifyDataLabel = function(dataLabel, options, alignAttr, bBox, alignTo, isNew) {
	            var chart = this.chart,
	                align = options.align,
	                verticalAlign = options.verticalAlign,
	                off,
	                justified,
	                padding = dataLabel.box ? 0 : (dataLabel.padding || 0);

	            // Off left
	            off = alignAttr.x + padding;
	            if (off < 0) {
	                if (align === 'right') {
	                    options.align = 'left';
	                } else {
	                    options.x = -off;
	                }
	                justified = true;
	            }

	            // Off right
	            off = alignAttr.x + bBox.width - padding;
	            if (off > chart.plotWidth) {
	                if (align === 'left') {
	                    options.align = 'right';
	                } else {
	                    options.x = chart.plotWidth - off;
	                }
	                justified = true;
	            }

	            // Off top
	            off = alignAttr.y + padding;
	            if (off < 0) {
	                if (verticalAlign === 'bottom') {
	                    options.verticalAlign = 'top';
	                } else {
	                    options.y = -off;
	                }
	                justified = true;
	            }

	            // Off bottom
	            off = alignAttr.y + bBox.height - padding;
	            if (off > chart.plotHeight) {
	                if (verticalAlign === 'top') {
	                    options.verticalAlign = 'bottom';
	                } else {
	                    options.y = chart.plotHeight - off;
	                }
	                justified = true;
	            }

	            if (justified) {
	                dataLabel.placed = !isNew;
	                dataLabel.align(options, null, alignTo);
	            }

	            return justified;
	        };

	        /**
	         * Override the base drawDataLabels method by pie specific functionality
	         */
	        if (seriesTypes.pie) {
	            seriesTypes.pie.prototype.drawDataLabels = function() {
	                var series = this,
	                    data = series.data,
	                    point,
	                    chart = series.chart,
	                    options = series.options.dataLabels,
	                    connectorPadding = pick(options.connectorPadding, 10),
	                    connectorWidth = pick(options.connectorWidth, 1),
	                    plotWidth = chart.plotWidth,
	                    plotHeight = chart.plotHeight,
	                    connector,
	                    seriesCenter = series.center,
	                    radius = seriesCenter[2] / 2,
	                    centerY = seriesCenter[1],
	                    dataLabel,
	                    dataLabelWidth,
	                    labelPos,
	                    labelHeight,
	                    halves = [ // divide the points into right and left halves for anti collision
	                        [], // right
	                        [] // left
	                    ],
	                    x,
	                    y,
	                    visibility,
	                    j,
	                    overflow = [0, 0, 0, 0]; // top, right, bottom, left

	                // get out if not enabled
	                if (!series.visible || (!options.enabled && !series._hasPointLabels)) {
	                    return;
	                }

	                // Reset all labels that have been shortened
	                each(data, function(point) {
	                    if (point.dataLabel && point.visible && point.dataLabel.shortened) {
	                        point.dataLabel
	                            .attr({
	                                width: 'auto'
	                            }).css({
	                                width: 'auto',
	                                textOverflow: 'clip'
	                            });
	                        point.dataLabel.shortened = false;
	                    }
	                });


	                // run parent method
	                Series.prototype.drawDataLabels.apply(series);

	                each(data, function(point) {
	                    if (point.dataLabel && point.visible) { // #407, #2510

	                        // Arrange points for detection collision
	                        halves[point.half].push(point);

	                        // Reset positions (#4905)
	                        point.dataLabel._pos = null;
	                    }
	                });

	                /* Loop over the points in each half, starting from the top and bottom
	                 * of the pie to detect overlapping labels.
	                 */
	                each(halves, function(points, i) {

	                    var top,
	                        bottom,
	                        length = points.length,
	                        positions = [],
	                        naturalY,
	                        sideOverflow,
	                        positionsIndex, // Point index in positions array.
	                        size;

	                    if (!length) {
	                        return;
	                    }

	                    // Sort by angle
	                    series.sortByAngle(points, i - 0.5);
	                    // Only do anti-collision when we have dataLabels outside the pie 
	                    // and have connectors. (#856)
	                    if (series.maxLabelDistance > 0) {
	                        top = Math.max(
	                            0,
	                            centerY - radius - series.maxLabelDistance
	                        );
	                        bottom = Math.min(
	                            centerY + radius + series.maxLabelDistance,
	                            chart.plotHeight
	                        );
	                        each(points, function(point) {
	                            // check if specific points' label is outside the pie
	                            if (point.labelDistance > 0 && point.dataLabel) {
	                                // point.top depends on point.labelDistance value
	                                // Used for calculation of y value in getX method 
	                                point.top = Math.max(
	                                    0,
	                                    centerY - radius - point.labelDistance
	                                );
	                                point.bottom = Math.min(
	                                    centerY + radius + point.labelDistance,
	                                    chart.plotHeight
	                                );
	                                size = point.dataLabel.getBBox().height || 21;

	                                // point.positionsIndex is needed for getting index of 
	                                // parameter related to specific point inside positions 
	                                // array - not every point is in positions array.
	                                point.positionsIndex = positions.push({
	                                    target: point.labelPos[1] - point.top + size / 2,
	                                    size: size,
	                                    rank: point.y
	                                }) - 1;
	                            }
	                        });
	                        H.distribute(positions, bottom + size - top);
	                    }

	                    // Now the used slots are sorted, fill them up sequentially
	                    for (j = 0; j < length; j++) {

	                        point = points[j];
	                        positionsIndex = point.positionsIndex;
	                        labelPos = point.labelPos;
	                        dataLabel = point.dataLabel;
	                        visibility = point.visible === false ? 'hidden' : 'inherit';
	                        naturalY = labelPos[1];

	                        if (positions && defined(positions[positionsIndex])) {
	                            if (positions[positionsIndex].pos === undefined) {
	                                visibility = 'hidden';
	                            } else {
	                                labelHeight = positions[positionsIndex].size;
	                                y = point.top + positions[positionsIndex].pos;
	                            }

	                        } else {
	                            y = naturalY;
	                        }

	                        // It is needed to delete point.positionIndex for 
	                        // dynamically added points etc.

	                        delete point.positionIndex;

	                        // get the x - use the natural x position for labels near the 
	                        // top and bottom, to prevent the top and botton slice connectors 
	                        // from touching each other on either side
	                        if (options.justify) {
	                            x = seriesCenter[0] + (i ? -1 : 1) * (radius + point.labelDistance);
	                        } else {
	                            x = series.getX(y < point.top + 2 || y > point.bottom - 2 ? naturalY : y, i, point);
	                        }


	                        // Record the placement and visibility
	                        dataLabel._attr = {
	                            visibility: visibility,
	                            align: labelPos[6]
	                        };
	                        dataLabel._pos = {
	                            x: x + options.x +
	                                ({
	                                    left: connectorPadding,
	                                    right: -connectorPadding
	                                }[labelPos[6]] || 0),
	                            y: y + options.y - 10 // 10 is for the baseline (label vs text)
	                        };
	                        labelPos.x = x;
	                        labelPos.y = y;


	                        // Detect overflowing data labels
	                        if (pick(options.crop, true)) {
	                            dataLabelWidth = dataLabel.getBBox().width;

	                            sideOverflow = null;
	                            // Overflow left
	                            if (x - dataLabelWidth < connectorPadding) {
	                                sideOverflow = Math.round(
	                                    dataLabelWidth - x + connectorPadding
	                                );
	                                overflow[3] = Math.max(sideOverflow, overflow[3]);

	                                // Overflow right
	                            } else if (
	                                x + dataLabelWidth >
	                                plotWidth - connectorPadding
	                            ) {
	                                sideOverflow = Math.round(
	                                    x + dataLabelWidth - plotWidth + connectorPadding
	                                );
	                                overflow[1] = Math.max(sideOverflow, overflow[1]);
	                            }

	                            // Overflow top
	                            if (y - labelHeight / 2 < 0) {
	                                overflow[0] = Math.max(
	                                    Math.round(-y + labelHeight / 2),
	                                    overflow[0]
	                                );

	                                // Overflow left
	                            } else if (y + labelHeight / 2 > plotHeight) {
	                                overflow[2] = Math.max(
	                                    Math.round(y + labelHeight / 2 - plotHeight),
	                                    overflow[2]
	                                );
	                            }
	                            dataLabel.sideOverflow = sideOverflow;
	                        }
	                    } // for each point
	                }); // for each half

	                // Do not apply the final placement and draw the connectors until we have verified
	                // that labels are not spilling over.
	                if (arrayMax(overflow) === 0 || this.verifyDataLabelOverflow(overflow)) {

	                    // Place the labels in the final position
	                    this.placeDataLabels();

	                    // Draw the connectors
	                    if (connectorWidth) {
	                        each(this.points, function(point) {
	                            var isNew;

	                            connector = point.connector;
	                            dataLabel = point.dataLabel;

	                            if (
	                                dataLabel &&
	                                dataLabel._pos &&
	                                point.visible &&
	                                point.labelDistance > 0
	                            ) {
	                                visibility = dataLabel._attr.visibility;

	                                isNew = !connector;

	                                if (isNew) {
	                                    point.connector = connector = chart.renderer.path()
	                                        .addClass('highcharts-data-label-connector highcharts-color-' + point.colorIndex)
	                                        .add(series.dataLabelsGroup);


	                                    connector.attr({
	                                        'stroke-width': connectorWidth,
	                                        'stroke': options.connectorColor || point.color || '#666666'
	                                    });

	                                }
	                                connector[isNew ? 'attr' : 'animate']({
	                                    d: series.connectorPath(point.labelPos)
	                                });
	                                connector.attr('visibility', visibility);

	                            } else if (connector) {
	                                point.connector = connector.destroy();
	                            }
	                        });
	                    }
	                }
	            };

	            /**
	             * Extendable method for getting the path of the connector between the data label
	             * and the pie slice.
	             */
	            seriesTypes.pie.prototype.connectorPath = function(labelPos) {
	                var x = labelPos.x,
	                    y = labelPos.y;
	                return pick(this.options.dataLabels.softConnector, true) ? [
	                    'M',
	                    x + (labelPos[6] === 'left' ? 5 : -5), y, // end of the string at the label
	                    'C',
	                    x, y, // first break, next to the label
	                    2 * labelPos[2] - labelPos[4], 2 * labelPos[3] - labelPos[5],
	                    labelPos[2], labelPos[3], // second break
	                    'L',
	                    labelPos[4], labelPos[5] // base
	                ] : [
	                    'M',
	                    x + (labelPos[6] === 'left' ? 5 : -5), y, // end of the string at the label
	                    'L',
	                    labelPos[2], labelPos[3], // second break
	                    'L',
	                    labelPos[4], labelPos[5] // base
	                ];
	            };

	            /**
	             * Perform the final placement of the data labels after we have verified that they
	             * fall within the plot area.
	             */
	            seriesTypes.pie.prototype.placeDataLabels = function() {
	                each(this.points, function(point) {
	                    var dataLabel = point.dataLabel,
	                        _pos;
	                    if (dataLabel && point.visible) {
	                        _pos = dataLabel._pos;
	                        if (_pos) {

	                            // Shorten data labels with ellipsis if they still overflow
	                            // after the pie has reached minSize (#223).
	                            if (dataLabel.sideOverflow) {
	                                dataLabel._attr.width =
	                                    dataLabel.getBBox().width - dataLabel.sideOverflow;
	                                dataLabel.css({
	                                    width: dataLabel._attr.width + 'px',
	                                    textOverflow: 'ellipsis'
	                                });
	                                dataLabel.shortened = true;
	                            }

	                            dataLabel.attr(dataLabel._attr);
	                            dataLabel[dataLabel.moved ? 'animate' : 'attr'](_pos);
	                            dataLabel.moved = true;
	                        } else if (dataLabel) {
	                            dataLabel.attr({
	                                y: -9999
	                            });
	                        }
	                    }
	                }, this);
	            };

	            seriesTypes.pie.prototype.alignDataLabel = noop;

	            /**
	             * Verify whether the data labels are allowed to draw, or we should run more translation and data
	             * label positioning to keep them inside the plot area. Returns true when data labels are ready
	             * to draw.
	             */
	            seriesTypes.pie.prototype.verifyDataLabelOverflow = function(overflow) {

	                var center = this.center,
	                    options = this.options,
	                    centerOption = options.center,
	                    minSize = options.minSize || 80,
	                    newSize = minSize,
	                    // If a size is set, return true and don't try to shrink the pie
	                    // to fit the labels.
	                    ret = options.size !== null;

	                if (!ret) {
	                    // Handle horizontal size and center
	                    if (centerOption[0] !== null) { // Fixed center
	                        newSize = Math.max(center[2] -
	                            Math.max(overflow[1], overflow[3]), minSize);

	                    } else { // Auto center
	                        newSize = Math.max(
	                            // horizontal overflow
	                            center[2] - overflow[1] - overflow[3],
	                            minSize
	                        );
	                        // horizontal center
	                        center[0] += (overflow[3] - overflow[1]) / 2;
	                    }

	                    // Handle vertical size and center
	                    if (centerOption[1] !== null) { // Fixed center
	                        newSize = Math.max(Math.min(newSize, center[2] -
	                            Math.max(overflow[0], overflow[2])), minSize);

	                    } else { // Auto center
	                        newSize = Math.max(
	                            Math.min(
	                                newSize,
	                                // vertical overflow
	                                center[2] - overflow[0] - overflow[2]
	                            ),
	                            minSize
	                        );
	                        // vertical center
	                        center[1] += (overflow[0] - overflow[2]) / 2;
	                    }

	                    // If the size must be decreased, we need to run translate and
	                    // drawDataLabels again
	                    if (newSize < center[2]) {
	                        center[2] = newSize;
	                        center[3] = Math.min( // #3632
	                            relativeLength(options.innerSize || 0, newSize),
	                            newSize
	                        );
	                        this.translate(center);

	                        if (this.drawDataLabels) {
	                            this.drawDataLabels();
	                        }
	                        // Else, return true to indicate that the pie and its labels is
	                        // within the plot area
	                    } else {
	                        ret = true;
	                    }
	                }
	                return ret;
	            };
	        }

	        if (seriesTypes.column) {

	            /**
	             * Override the basic data label alignment by adjusting for the position of the column
	             */
	            seriesTypes.column.prototype.alignDataLabel = function(point, dataLabel, options, alignTo, isNew) {
	                var inverted = this.chart.inverted,
	                    series = point.series,
	                    dlBox = point.dlBox || point.shapeArgs, // data label box for alignment
	                    below = pick(point.below, point.plotY > pick(this.translatedThreshold, series.yAxis.len)), // point.below is used in range series
	                    inside = pick(options.inside, !!this.options.stacking), // draw it inside the box?
	                    overshoot;

	                // Align to the column itself, or the top of it
	                if (dlBox) { // Area range uses this method but not alignTo
	                    alignTo = merge(dlBox);

	                    if (alignTo.y < 0) {
	                        alignTo.height += alignTo.y;
	                        alignTo.y = 0;
	                    }
	                    overshoot = alignTo.y + alignTo.height - series.yAxis.len;
	                    if (overshoot > 0) {
	                        alignTo.height -= overshoot;
	                    }

	                    if (inverted) {
	                        alignTo = {
	                            x: series.yAxis.len - alignTo.y - alignTo.height,
	                            y: series.xAxis.len - alignTo.x - alignTo.width,
	                            width: alignTo.height,
	                            height: alignTo.width
	                        };
	                    }

	                    // Compute the alignment box
	                    if (!inside) {
	                        if (inverted) {
	                            alignTo.x += below ? 0 : alignTo.width;
	                            alignTo.width = 0;
	                        } else {
	                            alignTo.y += below ? alignTo.height : 0;
	                            alignTo.height = 0;
	                        }
	                    }
	                }


	                // When alignment is undefined (typically columns and bars), display the individual
	                // point below or above the point depending on the threshold
	                options.align = pick(
	                    options.align, !inverted || inside ? 'center' : below ? 'right' : 'left'
	                );
	                options.verticalAlign = pick(
	                    options.verticalAlign,
	                    inverted || inside ? 'middle' : below ? 'top' : 'bottom'
	                );

	                // Call the parent method
	                Series.prototype.alignDataLabel.call(this, point, dataLabel, options, alignTo, isNew);

	                // If label was justified and we have contrast, set it:
	                if (point.isLabelJustified && point.contrastColor) {
	                    point.dataLabel.css({
	                        color: point.contrastColor
	                    });
	                }
	            };
	        }

	    }(Highcharts));
	    (function(H) {
	        /**
	         * (c) 2009-2017 Torstein Honsi
	         *
	         * License: www.highcharts.com/license
	         */
	        /**
	         * Highcharts module to hide overlapping data labels. This module is included in
	         * Highcharts.
	         */
	        var Chart = H.Chart,
	            each = H.each,
	            objectEach = H.objectEach,
	            pick = H.pick,
	            addEvent = H.addEvent;

	        // Collect potensial overlapping data labels. Stack labels probably don't need
	        // to be considered because they are usually accompanied by data labels that lie
	        // inside the columns.
	        Chart.prototype.callbacks.push(function(chart) {
	            function collectAndHide() {
	                var labels = [];

	                each(chart.yAxis || [], function(yAxis) {
	                    if (
	                        yAxis.options.stackLabels &&
	                        !yAxis.options.stackLabels.allowOverlap
	                    ) {
	                        objectEach(yAxis.stacks, function(stack) {
	                            objectEach(stack, function(stackItem) {
	                                labels.push(stackItem.label);
	                            });
	                        });
	                    }
	                });

	                each(chart.series || [], function(series) {
	                    var dlOptions = series.options.dataLabels,
	                        // Range series have two collections
	                        collections = series.dataLabelCollections || ['dataLabel'];

	                    if (
	                        (dlOptions.enabled || series._hasPointLabels) &&
	                        !dlOptions.allowOverlap &&
	                        series.visible
	                    ) { // #3866
	                        each(collections, function(coll) {
	                            each(series.points, function(point) {
	                                if (point[coll]) {
	                                    point[coll].labelrank = pick(
	                                        point.labelrank,
	                                        point.shapeArgs && point.shapeArgs.height
	                                    ); // #4118
	                                    labels.push(point[coll]);
	                                }
	                            });
	                        });
	                    }
	                });
	                chart.hideOverlappingLabels(labels);
	            }

	            // Do it now ...
	            collectAndHide();

	            // ... and after each chart redraw
	            addEvent(chart, 'redraw', collectAndHide);

	        });

	        /**
	         * Hide overlapping labels. Labels are moved and faded in and out on zoom to
	         * provide a smooth visual imression.
	         */
	        Chart.prototype.hideOverlappingLabels = function(labels) {

	            var len = labels.length,
	                label,
	                i,
	                j,
	                label1,
	                label2,
	                isIntersecting,
	                pos1,
	                pos2,
	                parent1,
	                parent2,
	                padding,
	                bBox,
	                intersectRect = function(x1, y1, w1, h1, x2, y2, w2, h2) {
	                    return !(
	                        x2 > x1 + w1 ||
	                        x2 + w2 < x1 ||
	                        y2 > y1 + h1 ||
	                        y2 + h2 < y1
	                    );
	                };

	            for (i = 0; i < len; i++) {
	                label = labels[i];
	                if (label) {

	                    // Mark with initial opacity
	                    label.oldOpacity = label.opacity;
	                    label.newOpacity = 1;

	                    // Get width and height if pure text nodes (stack labels)
	                    if (!label.width) {
	                        bBox = label.getBBox();
	                        label.width = bBox.width;
	                        label.height = bBox.height;
	                    }
	                }
	            }

	            // Prevent a situation in a gradually rising slope, that each label will
	            // hide the previous one because the previous one always has lower rank.
	            labels.sort(function(a, b) {
	                return (b.labelrank || 0) - (a.labelrank || 0);
	            });

	            // Detect overlapping labels
	            for (i = 0; i < len; i++) {
	                label1 = labels[i];

	                for (j = i + 1; j < len; ++j) {
	                    label2 = labels[j];
	                    if (
	                        label1 && label2 &&
	                        label1 !== label2 && // #6465, polar chart with connectEnds
	                        label1.placed && label2.placed &&
	                        label1.newOpacity !== 0 && label2.newOpacity !== 0
	                    ) {
	                        pos1 = label1.alignAttr;
	                        pos2 = label2.alignAttr;
	                        // Different panes have different positions
	                        parent1 = label1.parentGroup;
	                        parent2 = label2.parentGroup;
	                        // Substract the padding if no background or border (#4333)
	                        padding = 2 * (label1.box ? 0 : (label1.padding || 0));
	                        isIntersecting = intersectRect(
	                            pos1.x + parent1.translateX,
	                            pos1.y + parent1.translateY,
	                            label1.width - padding,
	                            label1.height - padding,
	                            pos2.x + parent2.translateX,
	                            pos2.y + parent2.translateY,
	                            label2.width - padding,
	                            label2.height - padding
	                        );

	                        if (isIntersecting) {
	                            (label1.labelrank < label2.labelrank ? label1 : label2)
	                            .newOpacity = 0;
	                        }
	                    }
	                }
	            }

	            // Hide or show
	            each(labels, function(label) {
	                var complete,
	                    newOpacity;

	                if (label) {
	                    newOpacity = label.newOpacity;

	                    if (label.oldOpacity !== newOpacity && label.placed) {

	                        // Make sure the label is completely hidden to avoid catching
	                        // clicks (#4362)
	                        if (newOpacity) {
	                            label.show(true);
	                        } else {
	                            complete = function() {
	                                label.hide();
	                            };
	                        }

	                        // Animate or set the opacity                   
	                        label.alignAttr.opacity = newOpacity;
	                        label[label.isOld ? 'animate' : 'attr'](
	                            label.alignAttr,
	                            null,
	                            complete
	                        );

	                    }
	                    label.isOld = true;
	                }
	            });
	        };

	    }(Highcharts));
	    (function(H) {
	        /**
	         * (c) 2010-2017 Torstein Honsi
	         *
	         * License: www.highcharts.com/license
	         */
	        var addEvent = H.addEvent,
	            Chart = H.Chart,
	            createElement = H.createElement,
	            css = H.css,
	            defaultOptions = H.defaultOptions,
	            defaultPlotOptions = H.defaultPlotOptions,
	            each = H.each,
	            extend = H.extend,
	            fireEvent = H.fireEvent,
	            hasTouch = H.hasTouch,
	            inArray = H.inArray,
	            isObject = H.isObject,
	            Legend = H.Legend,
	            merge = H.merge,
	            pick = H.pick,
	            Point = H.Point,
	            Series = H.Series,
	            seriesTypes = H.seriesTypes,
	            svg = H.svg,
	            TrackerMixin;

	        /**
	         * TrackerMixin for points and graphs.
	         */
	        TrackerMixin = H.TrackerMixin = {

	            /**
	             * Draw the tracker for a point.
	             */
	            drawTrackerPoint: function() {
	                var series = this,
	                    chart = series.chart,
	                    pointer = chart.pointer,
	                    onMouseOver = function(e) {
	                        var point = pointer.getPointFromEvent(e);
	                        // undefined on graph in scatterchart
	                        if (point !== undefined) {
	                            pointer.isDirectTouch = true;
	                            point.onMouseOver(e);
	                        }
	                    };

	                // Add reference to the point
	                each(series.points, function(point) {
	                    if (point.graphic) {
	                        point.graphic.element.point = point;
	                    }
	                    if (point.dataLabel) {
	                        if (point.dataLabel.div) {
	                            point.dataLabel.div.point = point;
	                        } else {
	                            point.dataLabel.element.point = point;
	                        }
	                    }
	                });

	                // Add the event listeners, we need to do this only once
	                if (!series._hasTracking) {
	                    each(series.trackerGroups, function(key) {
	                        if (series[key]) { // we don't always have dataLabelsGroup
	                            series[key]
	                                .addClass('highcharts-tracker')
	                                .on('mouseover', onMouseOver)
	                                .on('mouseout', function(e) {
	                                    pointer.onTrackerMouseOut(e);
	                                });
	                            if (hasTouch) {
	                                series[key].on('touchstart', onMouseOver);
	                            }


	                            if (series.options.cursor) {
	                                series[key]
	                                    .css(css)
	                                    .css({
	                                        cursor: series.options.cursor
	                                    });
	                            }

	                        }
	                    });
	                    series._hasTracking = true;
	                }
	            },

	            /**
	             * Draw the tracker object that sits above all data labels and markers to
	             * track mouse events on the graph or points. For the line type charts
	             * the tracker uses the same graphPath, but with a greater stroke width
	             * for better control.
	             */
	            drawTrackerGraph: function() {
	                var series = this,
	                    options = series.options,
	                    trackByArea = options.trackByArea,
	                    trackerPath = [].concat(trackByArea ? series.areaPath : series.graphPath),
	                    trackerPathLength = trackerPath.length,
	                    chart = series.chart,
	                    pointer = chart.pointer,
	                    renderer = chart.renderer,
	                    snap = chart.options.tooltip.snap,
	                    tracker = series.tracker,
	                    i,
	                    onMouseOver = function() {
	                        if (chart.hoverSeries !== series) {
	                            series.onMouseOver();
	                        }
	                    },
	                    /*
	                     * Empirical lowest possible opacities for TRACKER_FILL for an element to stay invisible but clickable
	                     * IE6: 0.002
	                     * IE7: 0.002
	                     * IE8: 0.002
	                     * IE9: 0.00000000001 (unlimited)
	                     * IE10: 0.0001 (exporting only)
	                     * FF: 0.00000000001 (unlimited)
	                     * Chrome: 0.000001
	                     * Safari: 0.000001
	                     * Opera: 0.00000000001 (unlimited)
	                     */
	                    TRACKER_FILL = 'rgba(192,192,192,' + (svg ? 0.0001 : 0.002) + ')';

	                // Extend end points. A better way would be to use round linecaps,
	                // but those are not clickable in VML.
	                if (trackerPathLength && !trackByArea) {
	                    i = trackerPathLength + 1;
	                    while (i--) {
	                        if (trackerPath[i] === 'M') { // extend left side
	                            trackerPath.splice(i + 1, 0, trackerPath[i + 1] - snap, trackerPath[i + 2], 'L');
	                        }
	                        if ((i && trackerPath[i] === 'M') || i === trackerPathLength) { // extend right side
	                            trackerPath.splice(i, 0, 'L', trackerPath[i - 2] + snap, trackerPath[i - 1]);
	                        }
	                    }
	                }

	                // handle single points
	                /*for (i = 0; i < singlePoints.length; i++) {
	                    singlePoint = singlePoints[i];
	                    trackerPath.push(M, singlePoint.plotX - snap, singlePoint.plotY,
	                    L, singlePoint.plotX + snap, singlePoint.plotY);
	                }*/

	                // draw the tracker
	                if (tracker) {
	                    tracker.attr({
	                        d: trackerPath
	                    });
	                } else if (series.graph) { // create

	                    series.tracker = renderer.path(trackerPath)
	                        .attr({
	                            'stroke-linejoin': 'round', // #1225
	                            visibility: series.visible ? 'visible' : 'hidden',
	                            stroke: TRACKER_FILL,
	                            fill: trackByArea ? TRACKER_FILL : 'none',
	                            'stroke-width': series.graph.strokeWidth() + (trackByArea ? 0 : 2 * snap),
	                            zIndex: 2
	                        })
	                        .add(series.group);

	                    // The tracker is added to the series group, which is clipped, but is covered
	                    // by the marker group. So the marker group also needs to capture events.
	                    each([series.tracker, series.markerGroup], function(tracker) {
	                        tracker.addClass('highcharts-tracker')
	                            .on('mouseover', onMouseOver)
	                            .on('mouseout', function(e) {
	                                pointer.onTrackerMouseOut(e);
	                            });


	                        if (options.cursor) {
	                            tracker.css({
	                                cursor: options.cursor
	                            });
	                        }


	                        if (hasTouch) {
	                            tracker.on('touchstart', onMouseOver);
	                        }
	                    });
	                }
	            }
	        };
	        /* End TrackerMixin */


	        /**
	         * Add tracking event listener to the series group, so the point graphics
	         * themselves act as trackers
	         */

	        if (seriesTypes.column) {
	            seriesTypes.column.prototype.drawTracker = TrackerMixin.drawTrackerPoint;
	        }

	        if (seriesTypes.pie) {
	            seriesTypes.pie.prototype.drawTracker = TrackerMixin.drawTrackerPoint;
	        }

	        if (seriesTypes.scatter) {
	            seriesTypes.scatter.prototype.drawTracker = TrackerMixin.drawTrackerPoint;
	        }

	        /*
	         * Extend Legend for item events
	         */
	        extend(Legend.prototype, {

	            setItemEvents: function(item, legendItem, useHTML) {
	                var legend = this,
	                    boxWrapper = legend.chart.renderer.boxWrapper,
	                    activeClass = 'highcharts-legend-' + (item.series ? 'point' : 'series') + '-active';

	                // Set the events on the item group, or in case of useHTML, the item itself (#1249)
	                (useHTML ? legendItem : item.legendGroup).on('mouseover', function() {
	                        item.setState('hover');

	                        // A CSS class to dim or hide other than the hovered series
	                        boxWrapper.addClass(activeClass);


	                        legendItem.css(legend.options.itemHoverStyle);

	                    })
	                    .on('mouseout', function() {

	                        legendItem.css(merge(item.visible ? legend.itemStyle : legend.itemHiddenStyle));


	                        // A CSS class to dim or hide other than the hovered series
	                        boxWrapper.removeClass(activeClass);

	                        item.setState();
	                    })
	                    .on('click', function(event) {
	                        var strLegendItemClick = 'legendItemClick',
	                            fnLegendItemClick = function() {
	                                if (item.setVisible) {
	                                    item.setVisible();
	                                }
	                            };

	                        // Pass over the click/touch event. #4.
	                        event = {
	                            browserEvent: event
	                        };

	                        // click the name or symbol
	                        if (item.firePointEvent) { // point
	                            item.firePointEvent(strLegendItemClick, event, fnLegendItemClick);
	                        } else {
	                            fireEvent(item, strLegendItemClick, event, fnLegendItemClick);
	                        }
	                    });
	            },

	            createCheckboxForItem: function(item) {
	                var legend = this;

	                item.checkbox = createElement('input', {
	                    type: 'checkbox',
	                    checked: item.selected,
	                    defaultChecked: item.selected // required by IE7
	                }, legend.options.itemCheckboxStyle, legend.chart.container);

	                addEvent(item.checkbox, 'click', function(event) {
	                    var target = event.target;
	                    fireEvent(
	                        item.series || item,
	                        'checkboxClick', { // #3712
	                            checked: target.checked,
	                            item: item
	                        },
	                        function() {
	                            item.select();
	                        }
	                    );
	                });
	            }
	        });



	        // Add pointer cursor to legend itemstyle in defaultOptions
	        defaultOptions.legend.itemStyle.cursor = 'pointer';



	        /*
	         * Extend the Chart object with interaction
	         */

	        extend(Chart.prototype, /** @lends Chart.prototype */ {
	            /**
	             * Display the zoom button.
	             *
	             * @private
	             */
	            showResetZoom: function() {
	                var chart = this,
	                    lang = defaultOptions.lang,
	                    btnOptions = chart.options.chart.resetZoomButton,
	                    theme = btnOptions.theme,
	                    states = theme.states,
	                    alignTo = btnOptions.relativeTo === 'chart' ? null : 'plotBox';

	                function zoomOut() {
	                    chart.zoomOut();
	                }

	                this.resetZoomButton = chart.renderer.button(lang.resetZoom, null, null, zoomOut, theme, states && states.hover)
	                    .attr({
	                        align: btnOptions.position.align,
	                        title: lang.resetZoomTitle
	                    })
	                    .addClass('highcharts-reset-zoom')
	                    .add()
	                    .align(btnOptions.position, false, alignTo);

	            },

	            /**
	             * Zoom out to 1:1.
	             *
	             * @private
	             */
	            zoomOut: function() {
	                var chart = this;
	                fireEvent(chart, 'selection', {
	                    resetSelection: true
	                }, function() {
	                    chart.zoom();
	                });
	            },

	            /**
	             * Zoom into a given portion of the chart given by axis coordinates.
	             * @param {Object} event
	             *
	             * @private
	             */
	            zoom: function(event) {
	                var chart = this,
	                    hasZoomed,
	                    pointer = chart.pointer,
	                    displayButton = false,
	                    resetZoomButton;

	                // If zoom is called with no arguments, reset the axes
	                if (!event || event.resetSelection) {
	                    each(chart.axes, function(axis) {
	                        hasZoomed = axis.zoom();
	                    });
	                    pointer.initiated = false; // #6804

	                } else { // else, zoom in on all axes
	                    each(event.xAxis.concat(event.yAxis), function(axisData) {
	                        var axis = axisData.axis,
	                            isXAxis = axis.isXAxis;

	                        // don't zoom more than minRange
	                        if (pointer[isXAxis ? 'zoomX' : 'zoomY']) {
	                            hasZoomed = axis.zoom(axisData.min, axisData.max);
	                            if (axis.displayBtn) {
	                                displayButton = true;
	                            }
	                        }
	                    });
	                }

	                // Show or hide the Reset zoom button
	                resetZoomButton = chart.resetZoomButton;
	                if (displayButton && !resetZoomButton) {
	                    chart.showResetZoom();
	                } else if (!displayButton && isObject(resetZoomButton)) {
	                    chart.resetZoomButton = resetZoomButton.destroy();
	                }


	                // Redraw
	                if (hasZoomed) {
	                    chart.redraw(
	                        pick(chart.options.chart.animation, event && event.animation, chart.pointCount < 100) // animation
	                    );
	                }
	            },

	            /**
	             * Pan the chart by dragging the mouse across the pane. This function is
	             * called on mouse move, and the distance to pan is computed from chartX
	             * compared to the first chartX position in the dragging operation.
	             *
	             * @private
	             */
	            pan: function(e, panning) {

	                var chart = this,
	                    hoverPoints = chart.hoverPoints,
	                    doRedraw;

	                // remove active points for shared tooltip
	                if (hoverPoints) {
	                    each(hoverPoints, function(point) {
	                        point.setState();
	                    });
	                }

	                each(panning === 'xy' ? [1, 0] : [1], function(isX) { // xy is used in maps
	                    var axis = chart[isX ? 'xAxis' : 'yAxis'][0],
	                        horiz = axis.horiz,
	                        mousePos = e[horiz ? 'chartX' : 'chartY'],
	                        mouseDown = horiz ? 'mouseDownX' : 'mouseDownY',
	                        startPos = chart[mouseDown],
	                        halfPointRange = (axis.pointRange || 0) / 2,
	                        extremes = axis.getExtremes(),
	                        panMin = axis.toValue(startPos - mousePos, true) +
	                        halfPointRange,
	                        panMax = axis.toValue(startPos + axis.len - mousePos, true) -
	                        halfPointRange,
	                        flipped = panMax < panMin,
	                        newMin = flipped ? panMax : panMin,
	                        newMax = flipped ? panMin : panMax,
	                        paddedMin = Math.min(
	                            extremes.dataMin,
	                            axis.toValue(
	                                axis.toPixels(extremes.min) - axis.minPixelPadding
	                            )
	                        ),
	                        paddedMax = Math.max(
	                            extremes.dataMax,
	                            axis.toValue(
	                                axis.toPixels(extremes.max) + axis.minPixelPadding
	                            )
	                        ),
	                        spill;

	                    // If the new range spills over, either to the min or max, adjust
	                    // the new range.
	                    spill = paddedMin - newMin;
	                    if (spill > 0) {
	                        newMax += spill;
	                        newMin = paddedMin;
	                    }
	                    spill = newMax - paddedMax;
	                    if (spill > 0) {
	                        newMax = paddedMax;
	                        newMin -= spill;
	                    }

	                    // Set new extremes if they are actually new
	                    if (axis.series.length && newMin !== extremes.min && newMax !== extremes.max) {
	                        axis.setExtremes(
	                            newMin,
	                            newMax,
	                            false,
	                            false, {
	                                trigger: 'pan'
	                            }
	                        );
	                        doRedraw = true;
	                    }

	                    chart[mouseDown] = mousePos; // set new reference for next run
	                });

	                if (doRedraw) {
	                    chart.redraw(false);
	                }
	                css(chart.container, {
	                    cursor: 'move'
	                });
	            }
	        });

	        /*
	         * Extend the Point object with interaction
	         */
	        extend(Point.prototype, /** @lends Highcharts.Point.prototype */ {
	            /**
	             * Toggle the selection status of a point.
	             * @param  {Boolean} [selected]
	             *         When `true`, the point is selected. When `false`, the point is
	             *         unselected. When `null` or `undefined`, the selection state is
	             *         toggled.
	             * @param  {Boolean} [accumulate=false]
	             *         When `true`, the selection is added to other selected points.
	             *         When `false`, other selected points are deselected. Internally in
	             *         Highcharts, when {@link http://api.highcharts.com/highcharts/plotOptions.series.allowPointSelect|allowPointSelect}
	             *         is `true`, selected points are accumulated on Control, Shift or
	             *         Cmd clicking the point.
	             *
	             * @see    Highcharts.Chart#getSelectedPoints
	             *
	             * @sample highcharts/members/point-select/
	             *         Select a point from a button
	             * @sample highcharts/chart/events-selection-points/
	             *         Select a range of points through a drag selection
	             * @sample maps/series/data-id/
	             *         Select a point in Highmaps
	             */
	            select: function(selected, accumulate) {
	                var point = this,
	                    series = point.series,
	                    chart = series.chart;

	                selected = pick(selected, !point.selected);

	                // fire the event with the default handler
	                point.firePointEvent(selected ? 'select' : 'unselect', {
	                    accumulate: accumulate
	                }, function() {

	                    /**
	                     * Whether the point is selected or not. 
	                     * @see Point#select
	                     * @see Chart#getSelectedPoints
	                     * @memberof Point
	                     * @name selected
	                     * @type {Boolean}
	                     */
	                    point.selected = point.options.selected = selected;
	                    series.options.data[inArray(point, series.data)] = point.options;

	                    point.setState(selected && 'select');

	                    // unselect all other points unless Ctrl or Cmd + click
	                    if (!accumulate) {
	                        each(chart.getSelectedPoints(), function(loopPoint) {
	                            if (loopPoint.selected && loopPoint !== point) {
	                                loopPoint.selected = loopPoint.options.selected = false;
	                                series.options.data[inArray(loopPoint, series.data)] = loopPoint.options;
	                                loopPoint.setState('');
	                                loopPoint.firePointEvent('unselect');
	                            }
	                        });
	                    }
	                });
	            },

	            /**
	             * Runs on mouse over the point. Called internally from mouse and touch
	             * events.
	             * 
	             * @param {Object} e The event arguments
	             */
	            onMouseOver: function(e) {
	                var point = this,
	                    series = point.series,
	                    chart = series.chart,
	                    pointer = chart.pointer;
	                e = e ?
	                    pointer.normalize(e) :
	                    // In cases where onMouseOver is called directly without an event
	                    pointer.getChartCoordinatesFromPoint(point, chart.inverted);
	                pointer.runPointActions(e, point);
	            },

	            /**
	             * Runs on mouse out from the point. Called internally from mouse and touch
	             * events.
	             */
	            onMouseOut: function() {
	                var point = this,
	                    chart = point.series.chart;
	                point.firePointEvent('mouseOut');
	                each(chart.hoverPoints || [], function(p) {
	                    p.setState();
	                });
	                chart.hoverPoints = chart.hoverPoint = null;
	            },

	            /**
	             * Import events from the series' and point's options. Only do it on
	             * demand, to save processing time on hovering.
	             *
	             * @private
	             */
	            importEvents: function() {
	                if (!this.hasImportedEvents) {
	                    var point = this,
	                        options = merge(point.series.options.point, point.options),
	                        events = options.events;

	                    point.events = events;

	                    H.objectEach(events, function(event, eventType) {
	                        addEvent(point, eventType, event);
	                    });
	                    this.hasImportedEvents = true;

	                }
	            },

	            /**
	             * Set the point's state.
	             * @param  {String} [state]
	             *         The new state, can be one of `''` (an empty string), `hover` or
	             *         `select`.
	             */
	            setState: function(state, move) {
	                var point = this,
	                    plotX = Math.floor(point.plotX), // #4586
	                    plotY = point.plotY,
	                    series = point.series,
	                    stateOptions = series.options.states[state] || {},
	                    markerOptions = defaultPlotOptions[series.type].marker &&
	                    series.options.marker,
	                    normalDisabled = markerOptions && markerOptions.enabled === false,
	                    markerStateOptions = (markerOptions && markerOptions.states &&
	                        markerOptions.states[state]) || {},
	                    stateDisabled = markerStateOptions.enabled === false,
	                    stateMarkerGraphic = series.stateMarkerGraphic,
	                    pointMarker = point.marker || {},
	                    chart = series.chart,
	                    halo = series.halo,
	                    haloOptions,
	                    markerAttribs,
	                    hasMarkers = markerOptions && series.markerAttribs,
	                    newSymbol;

	                state = state || ''; // empty string

	                if (
	                    // already has this state
	                    (state === point.state && !move) ||

	                    // selected points don't respond to hover
	                    (point.selected && state !== 'select') ||

	                    // series' state options is disabled
	                    (stateOptions.enabled === false) ||

	                    // general point marker's state options is disabled
	                    (state && (
	                        stateDisabled ||
	                        (normalDisabled && markerStateOptions.enabled === false)
	                    )) ||

	                    // individual point marker's state options is disabled
	                    (
	                        state &&
	                        pointMarker.states &&
	                        pointMarker.states[state] &&
	                        pointMarker.states[state].enabled === false
	                    ) // #1610

	                ) {
	                    return;
	                }

	                if (hasMarkers) {
	                    markerAttribs = series.markerAttribs(point, state);
	                }

	                // Apply hover styles to the existing point
	                if (point.graphic) {

	                    if (point.state) {
	                        point.graphic.removeClass('highcharts-point-' + point.state);
	                    }
	                    if (state) {
	                        point.graphic.addClass('highcharts-point-' + state);
	                    }

	                    /*attribs = radius ? { // new symbol attributes (#507, #612)
	                        x: plotX - radius,
	                        y: plotY - radius,
	                        width: 2 * radius,
	                        height: 2 * radius
	                    } : {};*/


	                    //attribs = merge(series.pointAttribs(point, state), attribs);
	                    point.graphic.animate(
	                        series.pointAttribs(point, state),
	                        pick(
	                            chart.options.chart.animation,
	                            stateOptions.animation
	                        )
	                    );


	                    if (markerAttribs) {
	                        point.graphic.animate(
	                            markerAttribs,
	                            pick(
	                                chart.options.chart.animation, // Turn off globally
	                                markerStateOptions.animation,
	                                markerOptions.animation
	                            )
	                        );
	                    }

	                    // Zooming in from a range with no markers to a range with markers
	                    if (stateMarkerGraphic) {
	                        stateMarkerGraphic.hide();
	                    }
	                } else {
	                    // if a graphic is not applied to each point in the normal state, create a shared
	                    // graphic for the hover state
	                    if (state && markerStateOptions) {
	                        newSymbol = pointMarker.symbol || series.symbol;

	                        // If the point has another symbol than the previous one, throw away the
	                        // state marker graphic and force a new one (#1459)
	                        if (stateMarkerGraphic && stateMarkerGraphic.currentSymbol !== newSymbol) {
	                            stateMarkerGraphic = stateMarkerGraphic.destroy();
	                        }

	                        // Add a new state marker graphic
	                        if (!stateMarkerGraphic) {
	                            if (newSymbol) {
	                                series.stateMarkerGraphic = stateMarkerGraphic = chart.renderer.symbol(
	                                        newSymbol,
	                                        markerAttribs.x,
	                                        markerAttribs.y,
	                                        markerAttribs.width,
	                                        markerAttribs.height
	                                    )
	                                    .add(series.markerGroup);
	                                stateMarkerGraphic.currentSymbol = newSymbol;
	                            }

	                            // Move the existing graphic
	                        } else {
	                            stateMarkerGraphic[move ? 'animate' : 'attr']({ // #1054
	                                x: markerAttribs.x,
	                                y: markerAttribs.y
	                            });
	                        }

	                        if (stateMarkerGraphic) {
	                            stateMarkerGraphic.attr(series.pointAttribs(point, state));
	                        }

	                    }

	                    if (stateMarkerGraphic) {
	                        stateMarkerGraphic[state && chart.isInsidePlot(plotX, plotY, chart.inverted) ? 'show' : 'hide'](); // #2450
	                        stateMarkerGraphic.element.point = point; // #4310
	                    }
	                }

	                // Show me your halo
	                haloOptions = stateOptions.halo;
	                if (haloOptions && haloOptions.size) {
	                    if (!halo) {
	                        series.halo = halo = chart.renderer.path()
	                            // #5818, #5903, #6705
	                            .add((point.graphic || stateMarkerGraphic).parentGroup);
	                    }
	                    halo[move ? 'animate' : 'attr']({
	                        d: point.haloPath(haloOptions.size)
	                    });
	                    halo.attr({
	                        'class': 'highcharts-halo highcharts-color-' +
	                            pick(point.colorIndex, series.colorIndex)
	                    });
	                    halo.point = point; // #6055


	                    halo.attr(extend({
	                        'fill': point.color || series.color,
	                        'fill-opacity': haloOptions.opacity,
	                        'zIndex': -1 // #4929, IE8 added halo above everything
	                    }, haloOptions.attributes));


	                } else if (halo && halo.point && halo.point.haloPath) {
	                    // Animate back to 0 on the current halo point (#6055)
	                    halo.animate({
	                        d: halo.point.haloPath(0)
	                    });
	                }

	                point.state = state;
	            },

	            /**
	             * Get the path definition for the halo, which is usually a shadow-like
	             * circle around the currently hovered point.
	             * @param  {Number} size
	             *         The radius of the circular halo.
	             * @return {Array} The path definition
	             */
	            haloPath: function(size) {
	                var series = this.series,
	                    chart = series.chart;

	                return chart.renderer.symbols.circle(
	                    Math.floor(this.plotX) - size,
	                    this.plotY - size,
	                    size * 2,
	                    size * 2
	                );
	            }
	        });

	        /*
	         * Extend the Series object with interaction
	         */

	        extend(Series.prototype, /** @lends Highcharts.Series.prototype */ {
	            /**
	             * Runs on mouse over the series graphical items.
	             */
	            onMouseOver: function() {
	                var series = this,
	                    chart = series.chart,
	                    hoverSeries = chart.hoverSeries;

	                // set normal state to previous series
	                if (hoverSeries && hoverSeries !== series) {
	                    hoverSeries.onMouseOut();
	                }

	                // trigger the event, but to save processing time,
	                // only if defined
	                if (series.options.events.mouseOver) {
	                    fireEvent(series, 'mouseOver');
	                }

	                // hover this
	                series.setState('hover');
	                chart.hoverSeries = series;
	            },

	            /**
	             * Runs on mouse out of the series graphical items.
	             */
	            onMouseOut: function() {
	                // trigger the event only if listeners exist
	                var series = this,
	                    options = series.options,
	                    chart = series.chart,
	                    tooltip = chart.tooltip,
	                    hoverPoint = chart.hoverPoint;

	                chart.hoverSeries = null; // #182, set to null before the mouseOut event fires

	                // trigger mouse out on the point, which must be in this series
	                if (hoverPoint) {
	                    hoverPoint.onMouseOut();
	                }

	                // fire the mouse out event
	                if (series && options.events.mouseOut) {
	                    fireEvent(series, 'mouseOut');
	                }


	                // hide the tooltip
	                if (tooltip && !series.stickyTracking && (!tooltip.shared || series.noSharedTooltip)) {
	                    tooltip.hide();
	                }

	                // set normal state
	                series.setState();
	            },

	            /**
	             * Set the state of the series. Called internally on mouse interaction and
	             * select operations, but it can also be called directly to visually
	             * highlight a series.
	             *
	             * @param  {String} [state]
	             *         Can be either `hover`, `select` or undefined to set to normal
	             *         state.
	             */
	            setState: function(state) {
	                var series = this,
	                    options = series.options,
	                    graph = series.graph,
	                    stateOptions = options.states,
	                    lineWidth = options.lineWidth,
	                    attribs,
	                    i = 0;

	                state = state || '';

	                if (series.state !== state) {

	                    // Toggle class names
	                    each([
	                        series.group,
	                        series.markerGroup,
	                        series.dataLabelsGroup
	                    ], function(group) {
	                        if (group) {
	                            // Old state
	                            if (series.state) {
	                                group.removeClass('highcharts-series-' + series.state);
	                            }
	                            // New state
	                            if (state) {
	                                group.addClass('highcharts-series-' + state);
	                            }
	                        }
	                    });

	                    series.state = state;



	                    if (stateOptions[state] && stateOptions[state].enabled === false) {
	                        return;
	                    }

	                    if (state) {
	                        lineWidth = stateOptions[state].lineWidth || lineWidth + (stateOptions[state].lineWidthPlus || 0); // #4035
	                    }

	                    if (graph && !graph.dashstyle) { // hover is turned off for dashed lines in VML
	                        attribs = {
	                            'stroke-width': lineWidth
	                        };

	                        // Animate the graph stroke-width. By default a quick animation
	                        // to hover, slower to un-hover.
	                        graph.animate(
	                            attribs,
	                            pick(
	                                series.chart.options.chart.animation,
	                                stateOptions[state] && stateOptions[state].animation
	                            )
	                        );
	                        while (series['zone-graph-' + i]) {
	                            series['zone-graph-' + i].attr(attribs);
	                            i = i + 1;
	                        }
	                    }

	                }
	            },

	            /**
	             * Show or hide the series.
	             *
	             * @param  {Boolean} [visible]
	             *         True to show the series, false to hide. If undefined, the
	             *         visibility is toggled.
	             * @param  {Boolean} [redraw=true]
	             *         Whether to redraw the chart after the series is altered. If doing
	             *         more operations on the chart, it is a good idea to set redraw to
	             *         false and call {@link Chart#redraw|chart.redraw()} after.
	             */
	            setVisible: function(vis, redraw) {
	                var series = this,
	                    chart = series.chart,
	                    legendItem = series.legendItem,
	                    showOrHide,
	                    ignoreHiddenSeries = chart.options.chart.ignoreHiddenSeries,
	                    oldVisibility = series.visible;

	                // if called without an argument, toggle visibility
	                series.visible = vis = series.options.visible = series.userOptions.visible = vis === undefined ? !oldVisibility : vis; // #5618
	                showOrHide = vis ? 'show' : 'hide';

	                // show or hide elements
	                each(['group', 'dataLabelsGroup', 'markerGroup', 'tracker', 'tt'], function(key) {
	                    if (series[key]) {
	                        series[key][showOrHide]();
	                    }
	                });


	                // hide tooltip (#1361)
	                if (chart.hoverSeries === series || (chart.hoverPoint && chart.hoverPoint.series) === series) {
	                    series.onMouseOut();
	                }


	                if (legendItem) {
	                    chart.legend.colorizeItem(series, vis);
	                }


	                // rescale or adapt to resized chart
	                series.isDirty = true;
	                // in a stack, all other series are affected
	                if (series.options.stacking) {
	                    each(chart.series, function(otherSeries) {
	                        if (otherSeries.options.stacking && otherSeries.visible) {
	                            otherSeries.isDirty = true;
	                        }
	                    });
	                }

	                // show or hide linked series
	                each(series.linkedSeries, function(otherSeries) {
	                    otherSeries.setVisible(vis, false);
	                });

	                if (ignoreHiddenSeries) {
	                    chart.isDirtyBox = true;
	                }
	                if (redraw !== false) {
	                    chart.redraw();
	                }

	                fireEvent(series, showOrHide);
	            },

	            /**
	             * Show the series if hidden.
	             *
	             * @sample highcharts/members/series-hide/
	             *         Toggle visibility from a button
	             */
	            show: function() {
	                this.setVisible(true);
	            },

	            /**
	             * Hide the series if visible. If the {@link
	             * https://api.highcharts.com/highcharts/chart.ignoreHiddenSeries|
	             * chart.ignoreHiddenSeries} option is true, the chart is redrawn without
	             * this series.
	             *
	             * @sample highcharts/members/series-hide/
	             *         Toggle visibility from a button
	             */
	            hide: function() {
	                this.setVisible(false);
	            },


	            /**
	             * Select or unselect the series. This means its {@link
	             * Highcharts.Series.selected|selected} property is set, the checkbox in the
	             * legend is toggled and when selected, the series is returned by the
	             * {@link Highcharts.Chart#getSelectedSeries} function.
	             *
	             * @param  {Boolean} [selected]
	             *         True to select the series, false to unselect. If undefined, the
	             *         selection state is toggled.
	             *
	             * @sample highcharts/members/series-select/
	             *         Select a series from a button
	             */
	            select: function(selected) {
	                var series = this;

	                series.selected = selected = (selected === undefined) ?
	                    !series.selected :
	                    selected;

	                if (series.checkbox) {
	                    series.checkbox.checked = selected;
	                }

	                fireEvent(series, selected ? 'select' : 'unselect');
	            },

	            drawTracker: TrackerMixin.drawTrackerGraph
	        });

	    }(Highcharts));
	    (function(H) {
	        /**
	         * (c) 2010-2017 Torstein Honsi
	         *
	         * License: www.highcharts.com/license
	         */
	        var Chart = H.Chart,
	            each = H.each,
	            inArray = H.inArray,
	            isArray = H.isArray,
	            isObject = H.isObject,
	            pick = H.pick,
	            splat = H.splat;

	        /**
	         * Update the chart based on the current chart/document size and options for
	         * responsiveness.
	         */
	        Chart.prototype.setResponsive = function(redraw) {
	            var options = this.options.responsive,
	                ruleIds = [],
	                currentResponsive = this.currentResponsive,
	                currentRuleIds;

	            if (options && options.rules) {
	                each(options.rules, function(rule) {
	                    if (rule._id === undefined) {
	                        rule._id = H.uniqueKey();
	                    }

	                    this.matchResponsiveRule(rule, ruleIds, redraw);
	                }, this);
	            }

	            // Merge matching rules
	            var mergedOptions = H.merge.apply(0, H.map(ruleIds, function(ruleId) {
	                return H.find(options.rules, function(rule) {
	                    return rule._id === ruleId;
	                }).chartOptions;
	            }));

	            // Stringified key for the rules that currently apply.
	            ruleIds = ruleIds.toString() || undefined;
	            currentRuleIds = currentResponsive && currentResponsive.ruleIds;


	            // Changes in what rules apply
	            if (ruleIds !== currentRuleIds) {

	                // Undo previous rules. Before we apply a new set of rules, we need to
	                // roll back completely to base options (#6291).
	                if (currentResponsive) {
	                    this.update(currentResponsive.undoOptions, redraw);
	                }

	                if (ruleIds) {
	                    // Get undo-options for matching rules
	                    this.currentResponsive = {
	                        ruleIds: ruleIds,
	                        mergedOptions: mergedOptions,
	                        undoOptions: this.currentOptions(mergedOptions)
	                    };

	                    this.update(mergedOptions, redraw);

	                } else {
	                    this.currentResponsive = undefined;
	                }
	            }
	        };

	        /**
	         * Handle a single responsiveness rule
	         */
	        Chart.prototype.matchResponsiveRule = function(rule, matches) {
	            var condition = rule.condition,
	                fn = condition.callback || function() {
	                    return this.chartWidth <= pick(condition.maxWidth, Number.MAX_VALUE) &&
	                        this.chartHeight <= pick(condition.maxHeight, Number.MAX_VALUE) &&
	                        this.chartWidth >= pick(condition.minWidth, 0) &&
	                        this.chartHeight >= pick(condition.minHeight, 0);
	                };

	            if (fn.call(this)) {
	                matches.push(rule._id);
	            }

	        };

	        /**
	         * Get the current values for a given set of options. Used before we update
	         * the chart with a new responsiveness rule.
	         * TODO: Restore axis options (by id?)
	         */
	        Chart.prototype.currentOptions = function(options) {

	            var ret = {};

	            /**
	             * Recurse over a set of options and its current values,
	             * and store the current values in the ret object.
	             */
	            function getCurrent(options, curr, ret, depth) {
	                var i;
	                H.objectEach(options, function(val, key) {
	                    if (!depth && inArray(key, ['series', 'xAxis', 'yAxis']) > -1) {
	                        options[key] = splat(options[key]);

	                        ret[key] = [];

	                        // Iterate over collections like series, xAxis or yAxis and map
	                        // the items by index.
	                        for (i = 0; i < options[key].length; i++) {
	                            if (curr[key][i]) { // Item exists in current data (#6347)
	                                ret[key][i] = {};
	                                getCurrent(
	                                    val[i],
	                                    curr[key][i],
	                                    ret[key][i],
	                                    depth + 1
	                                );
	                            }
	                        }
	                    } else if (isObject(val)) {
	                        ret[key] = isArray(val) ? [] : {};
	                        getCurrent(val, curr[key] || {}, ret[key], depth + 1);
	                    } else {
	                        ret[key] = curr[key] || null;
	                    }
	                });
	            }

	            getCurrent(options, this.options, ret, 0);
	            return ret;
	        };

	    }(Highcharts));

	    // column chart: rounded corner plugin
	    (function (H) {
	        var rel = H.relativeLength;

	        H.wrap(H.seriesTypes.column.prototype, 'translate', function (proceed) {
	            var options = this.options,
	                topMargin = options.topMargin || 0,
	                bottomMargin = options.bottomMargin || 0;

	            proceed.call(this);

	            H.each(this.points, function (point) {
	                var shapeArgs = point.shapeArgs,
	                    w = shapeArgs.width,
	                    h = shapeArgs.height,
	                    x = shapeArgs.x,
	                    y = shapeArgs.y;

	                // Get the radius
	                var rTopLeft = rel(options.borderRadiusTopLeft || 0, w),
	                    rTopRight = rel(options.borderRadiusTopRight || 0, w),
	                    rBottomRight = rel(options.borderRadiusBottomRight || 0, w),
	                    rBottomLeft = rel(options.borderRadiusBottomLeft || 0, w);
	            
	                if (rTopLeft || rTopRight || rBottomRight || rBottomLeft) {
	                    var maxR = Math.min(w, h) / 2
	                        
	                    if (rTopLeft > maxR) {
	                        rTopLeft = maxR;
	                    }

	                    if (rTopRight > maxR) {
	                        rTopRight = maxR;
	                    }

	                    if (rBottomRight > maxR) {
	                        rBottomRight = maxR;
	                    }

	                    if (rBottomLeft > maxR) {
	                        rBottomLeft = maxR;
	                    }

	                    // Preserve the box for data labels
	                    point.dlBox = point.shapeArgs;

	                    point.shapeType = 'path';
	                    point.shapeArgs = {
	                        d: [
	                            'M', x + rTopLeft, y + topMargin,
	                            // top side
	                            'L', x + w - rTopRight, y + topMargin,
	                            // top right corner
	                            'C', x + w - rTopRight / 2, y, x + w, y + rTopRight / 2, x + w, y + rTopRight,
	                            // right side
	                            'L', x + w, y + h - rBottomRight,
	                            // bottom right corner
	                            'C', x + w, y + h - rBottomRight / 2, x + w - rBottomRight / 2, y + h, x + w - rBottomRight, y + h + bottomMargin,
	                            // bottom side
	                            'L', x + rBottomLeft, y + h + bottomMargin,
	                            // bottom left corner
	                            'C', x + rBottomLeft / 2, y + h, x, y + h - rBottomLeft / 2, x, y + h - rBottomLeft,
	                            // left side
	                            'L', x, y + rTopLeft,
	                            // top left corner
	                            'C', x, y + rTopLeft / 2, x + rTopLeft / 2, y, x + rTopLeft, y,
	                            'Z'
	                        ]
	                    };
	                }
	                    
	            });
	        });
	    }(Highcharts));
	    return Highcharts
	}));

/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*
	 Highcharts JS v7.2.0 (2019-09-03)

	 (c) 2009-2018 Torstein Honsi

	 License: www.highcharts.com/license
	*/
	(function(P,N){"object"===typeof module&&module.exports?(N["default"]=N,module.exports=P.document?N(P):N): true?!(__WEBPACK_AMD_DEFINE_RESULT__ = function(){return N(P)}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)):(P.Highcharts&&P.Highcharts.error(16,!0),P.Highcharts=N(P))})("undefined"!==typeof window?window:this,function(P){function N(c,n,A,D){c.hasOwnProperty(n)||(c[n]=D.apply(null,A))}var H={};N(H,"parts/Globals.js",[],function(){var c="undefined"!==typeof P?P:"undefined"!==typeof window?window:{},n=c.document,
	A=c.navigator&&c.navigator.userAgent||"",D=n&&n.createElementNS&&!!n.createElementNS("http://www.w3.org/2000/svg","svg").createSVGRect,F=/(edge|msie|trident)/i.test(A)&&!c.opera,z=-1!==A.indexOf("Firefox"),u=-1!==A.indexOf("Chrome"),L=z&&4>parseInt(A.split("Firefox/")[1],10);return{product:"Highcharts",version:"7.2.0",deg2rad:2*Math.PI/360,doc:n,hasBidiBug:L,hasTouch:!!c.TouchEvent,isMS:F,isWebKit:-1!==A.indexOf("AppleWebKit"),isFirefox:z,isChrome:u,isSafari:!u&&-1!==A.indexOf("Safari"),isTouchDevice:/(Mobile|Android|Windows Phone)/.test(A),
	SVG_NS:"http://www.w3.org/2000/svg",chartCount:0,seriesTypes:{},symbolSizes:{},svg:D,win:c,marginNames:["plotTop","marginRight","marginBottom","plotLeft"],noop:function(){},charts:[],dateFormats:{}}});N(H,"parts/Utilities.js",[H["parts/Globals.js"]],function(c){function n(b,a){return parseInt(b,a||10)}function A(b){return"string"===typeof b}function D(b){b=Object.prototype.toString.call(b);return"[object Array]"===b||"[object Array Iterator]"===b}function F(b,a){return!!b&&"object"===typeof b&&(!a||
	!D(b))}function z(b){return F(b)&&"number"===typeof b.nodeType}function u(b){var a=b&&b.constructor;return!(!F(b,!0)||z(b)||!a||!a.name||"Object"===a.name)}function L(b){return"number"===typeof b&&!isNaN(b)&&Infinity>b&&-Infinity<b}function y(b){return"undefined"!==typeof b&&null!==b}function C(b,a,d){var f;A(a)?y(d)?b.setAttribute(a,d):b&&b.getAttribute&&((f=b.getAttribute(a))||"class"!==a||(f=b.getAttribute(a+"Name"))):x(a,function(a,d){b.setAttribute(d,a)});return f}function x(b,a,d){for(var f in b)Object.hasOwnProperty.call(b,
	f)&&a.call(d||b[f],b[f],f,b)}c.timers=[];var m=c.charts,p=c.doc,g=c.win;c.error=function(b,a,d){var f=L(b)?"Highcharts error #"+b+": www.highcharts.com/errors/"+b:b,e=function(){if(a)throw Error(f);g.console&&console.log(f)};d?c.fireEvent(d,"displayError",{code:b,message:f},e):e()};c.Fx=function(b,a,d){this.options=a;this.elem=b;this.prop=d};c.Fx.prototype={dSetter:function(){var b=this.paths[0],a=this.paths[1],d=[],f=this.now,e=b.length;if(1===f)d=this.toD;else if(e===a.length&&1>f)for(;e--;){var c=
	parseFloat(b[e]);d[e]=isNaN(c)?a[e]:f*parseFloat(""+(a[e]-c))+c}else d=a;this.elem.attr("d",d,null,!0)},update:function(){var b=this.elem,a=this.prop,d=this.now,f=this.options.step;if(this[a+"Setter"])this[a+"Setter"]();else b.attr?b.element&&b.attr(a,d,null,!0):b.style[a]=d+this.unit;f&&f.call(b,d,this)},run:function(b,a,d){var f=this,e=f.options,h=function(a){return h.stopped?!1:f.step(a)},r=g.requestAnimationFrame||function(a){setTimeout(a,13)},E=function(){for(var a=0;a<c.timers.length;a++)c.timers[a]()||
	c.timers.splice(a--,1);c.timers.length&&r(E)};b!==a||this.elem["forceAnimate:"+this.prop]?(this.startTime=+new Date,this.start=b,this.end=a,this.unit=d,this.now=this.start,this.pos=0,h.elem=this.elem,h.prop=this.prop,h()&&1===c.timers.push(h)&&r(E)):(delete e.curAnim[this.prop],e.complete&&0===Object.keys(e.curAnim).length&&e.complete.call(this.elem))},step:function(b){var a=+new Date,d=this.options,f=this.elem,e=d.complete,c=d.duration,r=d.curAnim;if(f.attr&&!f.element)b=!1;else if(b||a>=c+this.startTime){this.now=
	this.end;this.pos=1;this.update();var E=r[this.prop]=!0;x(r,function(a){!0!==a&&(E=!1)});E&&e&&e.call(f);b=!1}else this.pos=d.easing((a-this.startTime)/c),this.now=this.start+(this.end-this.start)*this.pos,this.update(),b=!0;return b},initPath:function(b,a,d){function f(a){for(t=a.length;t--;){var b="M"===a[t]||"L"===a[t];var d=/[a-zA-Z]/.test(a[t+3]);b&&d&&a.splice(t+1,0,a[t+1],a[t+2],a[t+1],a[t+2])}}function e(a,b){for(;a.length<J;){a[0]=b[J-a.length];var d=a.slice(0,v);[].splice.apply(a,[0,0].concat(d));
	B&&(d=a.slice(a.length-v),[].splice.apply(a,[a.length,0].concat(d)),t--)}a[0]="M"}function c(a,b){for(var d=(J-a.length)/v;0<d&&d--;)k=a.slice().splice(a.length/I-v,v*I),k[0]=b[J-v-d*v],q&&(k[v-6]=k[v-2],k[v-5]=k[v-1]),[].splice.apply(a,[a.length/I,0].concat(k)),B&&d--}a=a||"";var r=b.startX,E=b.endX,q=-1<a.indexOf("C"),v=q?7:3,k,t;a=a.split(" ");d=d.slice();var B=b.isArea,I=B?2:1;q&&(f(a),f(d));if(r&&E){for(t=0;t<r.length;t++)if(r[t]===E[0]){var w=t;break}else if(r[0]===E[E.length-r.length+t]){w=
	t;var l=!0;break}else if(r[r.length-1]===E[E.length-r.length+t]){w=r.length-t;break}"undefined"===typeof w&&(a=[])}if(a.length&&L(w)){var J=d.length+w*I*v;l?(e(a,d),c(d,a)):(e(d,a),c(a,d))}return[a,d]},fillSetter:function(){c.Fx.prototype.strokeSetter.apply(this,arguments)},strokeSetter:function(){this.elem.attr(this.prop,c.color(this.start).tweenTo(c.color(this.end),this.pos),null,!0)}};c.merge=function(){var b,a=arguments,d={},f=function(a,b){"object"!==typeof a&&(a={});x(b,function(d,e){!F(d,!0)||
	u(d)||z(d)?a[e]=b[e]:a[e]=f(a[e]||{},d)});return a};!0===a[0]&&(d=a[1],a=Array.prototype.slice.call(a,2));var e=a.length;for(b=0;b<e;b++)d=f(d,a[b]);return d};c.syncTimeout=function(b,a,d){if(a)return setTimeout(b,a,d);b.call(0,d)};c.clearTimeout=function(b){y(b)&&clearTimeout(b)};c.extend=function(b,a){var d;b||(b={});for(d in a)b[d]=a[d];return b};c.pick=function(){var b=arguments,a,d=b.length;for(a=0;a<d;a++){var f=b[a];if("undefined"!==typeof f&&null!==f)return f}};c.css=function(b,a){c.isMS&&
	!c.svg&&a&&"undefined"!==typeof a.opacity&&(a.filter="alpha(opacity="+100*a.opacity+")");c.extend(b.style,a)};c.createElement=function(b,a,d,f,e){b=p.createElement(b);var h=c.css;a&&c.extend(b,a);e&&h(b,{padding:"0",border:"none",margin:"0"});d&&h(b,d);f&&f.appendChild(b);return b};c.extendClass=function(b,a){var d=function(){};d.prototype=new b;c.extend(d.prototype,a);return d};c.pad=function(b,a,d){return Array((a||2)+1-String(b).replace("-","").length).join(d||"0")+b};c.relativeLength=function(b,
	a,d){return/%$/.test(b)?a*parseFloat(b)/100+(d||0):parseFloat(b)};c.wrap=function(b,a,d){var f=b[a];b[a]=function(){var a=Array.prototype.slice.call(arguments),b=arguments,c=this;c.proceed=function(){f.apply(c,arguments.length?arguments:b)};a.unshift(f);a=d.apply(this,a);c.proceed=null;return a}};c.datePropsToTimestamps=function(b){x(b,function(a,d){F(a)&&"function"===typeof a.getTime?b[d]=a.getTime():(F(a)||D(a))&&c.datePropsToTimestamps(a)})};c.formatSingle=function(b,a,d){var f=/\.([0-9])/,e=c.defaultOptions.lang;
	/f$/.test(b)?(d=(d=b.match(f))?d[1]:-1,null!==a&&(a=c.numberFormat(a,d,e.decimalPoint,-1<b.indexOf(",")?e.thousandsSep:""))):a=(d||c.time).dateFormat(b,a);return a};c.format=function(b,a,d){for(var f="{",e=!1,h,r,E,q,v=[],k;b;){f=b.indexOf(f);if(-1===f)break;h=b.slice(0,f);if(e){h=h.split(":");r=h.shift().split(".");q=r.length;k=a;for(E=0;E<q;E++)k&&(k=k[r[E]]);h.length&&(k=c.formatSingle(h.join(":"),k,d));v.push(k)}else v.push(h);b=b.slice(f+1);f=(e=!e)?"}":"{"}v.push(b);return v.join("")};c.getMagnitude=
	function(b){return Math.pow(10,Math.floor(Math.log(b)/Math.LN10))};c.normalizeTickInterval=function(b,a,d,f,e){var h=b;d=c.pick(d,1);var r=b/d;a||(a=e?[1,1.2,1.5,2,2.5,3,4,5,6,8,10]:[1,2,2.5,5,10],!1===f&&(1===d?a=a.filter(function(a){return 0===a%1}):.1>=d&&(a=[1/d])));for(f=0;f<a.length&&!(h=a[f],e&&h*d>=b||!e&&r<=(a[f]+(a[f+1]||a[f]))/2);f++);return h=c.correctFloat(h*d,-Math.round(Math.log(.001)/Math.LN10))};c.stableSort=function(b,a){var d=b.length,f,e;for(e=0;e<d;e++)b[e].safeI=e;b.sort(function(b,
	d){f=a(b,d);return 0===f?b.safeI-d.safeI:f});for(e=0;e<d;e++)delete b[e].safeI};c.arrayMin=function(b){for(var a=b.length,d=b[0];a--;)b[a]<d&&(d=b[a]);return d};c.arrayMax=function(b){for(var a=b.length,d=b[0];a--;)b[a]>d&&(d=b[a]);return d};c.destroyObjectProperties=function(b,a){x(b,function(d,f){d&&d!==a&&d.destroy&&d.destroy();delete b[f]})};c.discardElement=function(b){var a=c.garbageBin;a||(a=c.createElement("div"));b&&a.appendChild(b);a.innerHTML=""};c.correctFloat=function(b,a){return parseFloat(b.toPrecision(a||
	14))};c.setAnimation=function(b,a){a.renderer.globalAnimation=c.pick(b,a.options.chart.animation,!0)};c.animObject=function(b){return F(b)?c.merge(b):{duration:b?500:0}};c.timeUnits={millisecond:1,second:1E3,minute:6E4,hour:36E5,day:864E5,week:6048E5,month:24192E5,year:314496E5};c.numberFormat=function(b,a,d,f){b=+b||0;a=+a;var e=c.defaultOptions.lang,h=(b.toString().split(".")[1]||"").split("e")[0].length,r=b.toString().split("e");if(-1===a)a=Math.min(h,20);else if(!L(a))a=2;else if(a&&r[1]&&0>r[1]){var m=
	a+ +r[1];0<=m?(r[0]=(+r[0]).toExponential(m).split("e")[0],a=m):(r[0]=r[0].split(".")[0]||0,b=20>a?(r[0]*Math.pow(10,r[1])).toFixed(a):0,r[1]=0)}var q=(Math.abs(r[1]?r[0]:b)+Math.pow(10,-Math.max(a,h)-1)).toFixed(a);h=String(n(q));m=3<h.length?h.length%3:0;d=c.pick(d,e.decimalPoint);f=c.pick(f,e.thousandsSep);b=(0>b?"-":"")+(m?h.substr(0,m)+f:"");b+=h.substr(m).replace(/(\d{3})(?=\d)/g,"$1"+f);a&&(b+=d+q.slice(-a));r[1]&&0!==+b&&(b+="e"+r[1]);return b};Math.easeInOutSine=function(b){return-.5*(Math.cos(Math.PI*
	b)-1)};c.getStyle=function(b,a,d){if("width"===a)return a=Math.min(b.offsetWidth,b.scrollWidth),d=b.getBoundingClientRect&&b.getBoundingClientRect().width,d<a&&d>=a-1&&(a=Math.floor(d)),Math.max(0,a-c.getStyle(b,"padding-left")-c.getStyle(b,"padding-right"));if("height"===a)return Math.max(0,Math.min(b.offsetHeight,b.scrollHeight)-c.getStyle(b,"padding-top")-c.getStyle(b,"padding-bottom"));g.getComputedStyle||c.error(27,!0);if(b=g.getComputedStyle(b,void 0))b=b.getPropertyValue(a),c.pick(d,"opacity"!==
	a)&&(b=n(b));return b};c.inArray=function(b,a,d){return a.indexOf(b,d)};c.find=Array.prototype.find?function(b,a){return b.find(a)}:function(b,a){var d,f=b.length;for(d=0;d<f;d++)if(a(b[d],d))return b[d]};c.keys=Object.keys;c.offset=function(b){var a=p.documentElement;b=b.parentElement||b.parentNode?b.getBoundingClientRect():{top:0,left:0};return{top:b.top+(g.pageYOffset||a.scrollTop)-(a.clientTop||0),left:b.left+(g.pageXOffset||a.scrollLeft)-(a.clientLeft||0)}};c.stop=function(b,a){for(var d=c.timers.length;d--;)c.timers[d].elem!==
	b||a&&a!==c.timers[d].prop||(c.timers[d].stopped=!0)};x({map:"map",each:"forEach",grep:"filter",reduce:"reduce",some:"some"},function(b,a){c[a]=function(a){return Array.prototype[b].apply(a,[].slice.call(arguments,1))}});c.addEvent=function(b,a,d,f){void 0===f&&(f={});var e=b.addEventListener||c.addEventListenerPolyfill;var h="function"===typeof b&&b.prototype?b.prototype.protoEvents=b.prototype.protoEvents||{}:b.hcEvents=b.hcEvents||{};c.Point&&b instanceof c.Point&&b.series&&b.series.chart&&(b.series.chart.runTrackerClick=
	!0);e&&e.call(b,a,d,!1);h[a]||(h[a]=[]);h[a].push({fn:d,order:"number"===typeof f.order?f.order:Infinity});h[a].sort(function(a,b){return a.order-b.order});return function(){c.removeEvent(b,a,d)}};c.removeEvent=function(b,a,d){function f(a,d){var e=b.removeEventListener||c.removeEventListenerPolyfill;e&&e.call(b,a,d,!1)}function e(d){var e;if(b.nodeName){if(a){var c={};c[a]=!0}else c=d;x(c,function(a,b){if(d[b])for(e=d[b].length;e--;)f(b,d[b][e].fn)})}}var h;["protoEvents","hcEvents"].forEach(function(c){var r=
	b[c];r&&(a?(h=r[a]||[],d?(r[a]=h.filter(function(a){return d!==a.fn}),f(a,d)):(e(r),r[a]=[])):(e(r),b[c]={}))})};c.fireEvent=function(b,a,d,f){var e;d=d||{};if(p.createEvent&&(b.dispatchEvent||b.fireEvent)){var h=p.createEvent("Events");h.initEvent(a,!0,!0);c.extend(h,d);b.dispatchEvent?b.dispatchEvent(h):b.fireEvent(a,h)}else d.target||c.extend(d,{preventDefault:function(){d.defaultPrevented=!0},target:b,type:a}),function(a,f){void 0===a&&(a=[]);void 0===f&&(f=[]);var c=0,h=0,k=a.length+f.length;
	for(e=0;e<k;e++)!1===(a[c]?f[h]?a[c].order<=f[h].order?a[c++]:f[h++]:a[c++]:f[h++]).fn.call(b,d)&&d.preventDefault()}(b.protoEvents&&b.protoEvents[a],b.hcEvents&&b.hcEvents[a]);f&&!d.defaultPrevented&&f.call(b,d)};c.animate=function(b,a,d){var f,e="",h,r;if(!F(d)){var m=arguments;d={duration:m[2],easing:m[3],complete:m[4]}}L(d.duration)||(d.duration=400);d.easing="function"===typeof d.easing?d.easing:Math[d.easing]||Math.easeInOutSine;d.curAnim=c.merge(a);x(a,function(q,v){c.stop(b,v);r=new c.Fx(b,
	d,v);h=null;"d"===v?(r.paths=r.initPath(b,b.d,a.d),r.toD=a.d,f=0,h=1):b.attr?f=b.attr(v):(f=parseFloat(c.getStyle(b,v))||0,"opacity"!==v&&(e="px"));h||(h=q);h&&h.match&&h.match("px")&&(h=h.replace(/px/g,""));r.run(f,h,e)})};c.seriesType=function(b,a,d,f,e){var h=c.getOptions(),r=c.seriesTypes;h.plotOptions[b]=c.merge(h.plotOptions[a],d);r[b]=c.extendClass(r[a]||function(){},f);r[b].prototype.type=b;e&&(r[b].prototype.pointClass=c.extendClass(c.Point,e));return r[b]};c.uniqueKey=function(){var b=Math.random().toString(36).substring(2,
	9),a=0;return function(){return"highcharts-"+b+"-"+a++}}();c.isFunction=function(b){return"function"===typeof b};g.jQuery&&(g.jQuery.fn.highcharts=function(){var b=[].slice.call(arguments);if(this[0])return b[0]?(new (c[A(b[0])?b.shift():"Chart"])(this[0],b[0],b[1]),this):m[C(this[0],"data-highcharts-chart")]});return{attr:C,defined:y,erase:function(b,a){for(var d=b.length;d--;)if(b[d]===a){b.splice(d,1);break}},isArray:D,isClass:u,isDOMElement:z,isNumber:L,isObject:F,isString:A,objectEach:x,pInt:n,
	splat:function(b){return D(b)?b:[b]}}});N(H,"parts/Color.js",[H["parts/Globals.js"],H["parts/Utilities.js"]],function(c,n){var A=n.isNumber,D=n.pInt,F=c.merge;c.Color=function(z){if(!(this instanceof c.Color))return new c.Color(z);this.init(z)};c.Color.prototype={parsers:[{regex:/rgba\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]?(?:\.[0-9]+)?)\s*\)/,parse:function(c){return[D(c[1]),D(c[2]),D(c[3]),parseFloat(c[4],10)]}},{regex:/rgb\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*\)/,
	parse:function(c){return[D(c[1]),D(c[2]),D(c[3]),1]}}],names:{white:"#ffffff",black:"#000000"},init:function(z){var u,n;if((this.input=z=this.names[z&&z.toLowerCase?z.toLowerCase():""]||z)&&z.stops)this.stops=z.stops.map(function(x){return new c.Color(x[1])});else{if(z&&z.charAt&&"#"===z.charAt()){var y=z.length;z=parseInt(z.substr(1),16);7===y?u=[(z&16711680)>>16,(z&65280)>>8,z&255,1]:4===y&&(u=[(z&3840)>>4|(z&3840)>>8,(z&240)>>4|z&240,(z&15)<<4|z&15,1])}if(!u)for(n=this.parsers.length;n--&&!u;){var C=
	this.parsers[n];(y=C.regex.exec(z))&&(u=C.parse(y))}}this.rgba=u||[]},get:function(c){var u=this.input,z=this.rgba;if(this.stops){var y=F(u);y.stops=[].concat(y.stops);this.stops.forEach(function(u,x){y.stops[x]=[y.stops[x][0],u.get(c)]})}else y=z&&A(z[0])?"rgb"===c||!c&&1===z[3]?"rgb("+z[0]+","+z[1]+","+z[2]+")":"a"===c?z[3]:"rgba("+z.join(",")+")":u;return y},brighten:function(c){var u,z=this.rgba;if(this.stops)this.stops.forEach(function(u){u.brighten(c)});else if(A(c)&&0!==c)for(u=0;3>u;u++)z[u]+=
	D(255*c),0>z[u]&&(z[u]=0),255<z[u]&&(z[u]=255);return this},setOpacity:function(c){this.rgba[3]=c;return this},tweenTo:function(c,u){var z=this.rgba,y=c.rgba;y.length&&z&&z.length?(c=1!==y[3]||1!==z[3],u=(c?"rgba(":"rgb(")+Math.round(y[0]+(z[0]-y[0])*(1-u))+","+Math.round(y[1]+(z[1]-y[1])*(1-u))+","+Math.round(y[2]+(z[2]-y[2])*(1-u))+(c?","+(y[3]+(z[3]-y[3])*(1-u)):"")+")"):u=c.input||"none";return u}};c.color=function(z){return new c.Color(z)}});N(H,"parts/SvgRenderer.js",[H["parts/Globals.js"],
	H["parts/Utilities.js"]],function(c,n){var A=n.attr,D=n.defined,F=n.erase,z=n.isArray,u=n.isNumber,L=n.isObject,y=n.isString,C=n.objectEach,x=n.pInt,m=n.splat,p=c.addEvent,g=c.animate,b=c.charts,a=c.color,d=c.css,f=c.createElement,e=c.deg2rad,h=c.destroyObjectProperties,r=c.doc,E=c.extend,q=c.hasTouch,v=c.isFirefox,k=c.isMS,t=c.isWebKit,B=c.merge,I=c.noop,w=c.pick,l=c.removeEvent,J=c.stop,K=c.svg,T=c.SVG_NS,R=c.symbolSizes,S=c.win;var M=c.SVGElement=function(){return this};E(M.prototype,{opacity:1,
	SVG_NS:T,textProps:"direction fontSize fontWeight fontFamily fontStyle color lineHeight width textAlign textDecoration textOverflow textOutline cursor".split(" "),init:function(a,b){this.element="span"===b?f(b):r.createElementNS(this.SVG_NS,b);this.renderer=a;c.fireEvent(this,"afterInit")},animate:function(a,b,d){var G=c.animObject(w(b,this.renderer.globalAnimation,!0));w(r.hidden,r.msHidden,r.webkitHidden,!1)&&(G.duration=0);0!==G.duration?(d&&(G.complete=d),g(this,a,G)):(this.attr(a,void 0,d),C(a,
	function(a,b){G.step&&G.step.call(this,a,{prop:b,pos:1})},this));return this},complexColor:function(a,b,d){var G=this.renderer,l,w,e,f,k,O,t,h,J,K,r,Q=[],M;c.fireEvent(this.renderer,"complexColor",{args:arguments},function(){a.radialGradient?w="radialGradient":a.linearGradient&&(w="linearGradient");w&&(e=a[w],k=G.gradients,t=a.stops,K=d.radialReference,z(e)&&(a[w]=e={x1:e[0],y1:e[1],x2:e[2],y2:e[3],gradientUnits:"userSpaceOnUse"}),"radialGradient"===w&&K&&!D(e.gradientUnits)&&(f=e,e=B(e,G.getRadialAttr(K,
	f),{gradientUnits:"userSpaceOnUse"})),C(e,function(a,G){"id"!==G&&Q.push(G,a)}),C(t,function(a){Q.push(a)}),Q=Q.join(","),k[Q]?r=k[Q].attr("id"):(e.id=r=c.uniqueKey(),k[Q]=O=G.createElement(w).attr(e).add(G.defs),O.radAttr=f,O.stops=[],t.forEach(function(a){0===a[1].indexOf("rgba")?(l=c.color(a[1]),h=l.get("rgb"),J=l.get("a")):(h=a[1],J=1);a=G.createElement("stop").attr({offset:a[0],"stop-color":h,"stop-opacity":J}).add(O);O.stops.push(a)})),M="url("+G.url+"#"+r+")",d.setAttribute(b,M),d.gradient=
	Q,a.toString=function(){return M})})},applyTextOutline:function(a){var b=this.element,G;-1!==a.indexOf("contrast")&&(a=a.replace(/contrast/g,this.renderer.getContrast(b.style.fill)));a=a.split(" ");var d=a[a.length-1];if((G=a[0])&&"none"!==G&&c.svg){this.fakeTS=!0;a=[].slice.call(b.getElementsByTagName("tspan"));this.ySetter=this.xSetter;G=G.replace(/(^[\d\.]+)(.*?)$/g,function(a,b,G){return 2*b+G});this.removeTextOutline(a);var w=b.firstChild;a.forEach(function(a,l){0===l&&(a.setAttribute("x",b.getAttribute("x")),
	l=b.getAttribute("y"),a.setAttribute("y",l||0),null===l&&b.setAttribute("y",0));a=a.cloneNode(1);A(a,{"class":"highcharts-text-outline",fill:d,stroke:d,"stroke-width":G,"stroke-linejoin":"round"});b.insertBefore(a,w)})}},removeTextOutline:function(a){for(var b=a.length,G;b--;)G=a[b],"highcharts-text-outline"===G.getAttribute("class")&&F(a,this.element.removeChild(G))},symbolCustomAttribs:"x y width height r start end innerR anchorX anchorY rounded".split(" "),attr:function(a,b,d,l){var G=this.element,
	w,e=this,f,k,O=this.symbolCustomAttribs;if("string"===typeof a&&void 0!==b){var t=a;a={};a[t]=b}"string"===typeof a?e=(this[a+"Getter"]||this._defaultGetter).call(this,a,G):(C(a,function(b,d){f=!1;l||J(this,d);this.symbolName&&-1!==c.inArray(d,O)&&(w||(this.symbolAttr(a),w=!0),f=!0);!this.rotation||"x"!==d&&"y"!==d||(this.doTransform=!0);f||(k=this[d+"Setter"]||this._defaultSetter,k.call(this,b,d,G),!this.styledMode&&this.shadows&&/^(width|height|visibility|x|y|d|transform|cx|cy|r)$/.test(d)&&this.updateShadows(d,
	b,k))},this),this.afterSetters());d&&d.call(this);return e},afterSetters:function(){this.doTransform&&(this.updateTransform(),this.doTransform=!1)},updateShadows:function(a,b,d){for(var G=this.shadows,l=G.length;l--;)d.call(G[l],"height"===a?Math.max(b-(G[l].cutHeight||0),0):"d"===a?this.d:b,a,G[l])},addClass:function(a,b){var d=this.attr("class")||"";b||(a=(a||"").split(/ /g).reduce(function(a,b){-1===d.indexOf(b)&&a.push(b);return a},d?[d]:[]).join(" "));a!==d&&this.attr("class",a);return this},
	hasClass:function(a){return-1!==(this.attr("class")||"").split(" ").indexOf(a)},removeClass:function(a){return this.attr("class",(this.attr("class")||"").replace(a,""))},symbolAttr:function(a){var b=this;"x y r start end width height innerR anchorX anchorY clockwise".split(" ").forEach(function(d){b[d]=w(a[d],b[d])});b.attr({d:b.renderer.symbols[b.symbolName](b.x,b.y,b.width,b.height,b)})},clip:function(a){return this.attr("clip-path",a?"url("+this.renderer.url+"#"+a.id+")":"none")},crisp:function(a,
	b){b=b||a.strokeWidth||0;var d=Math.round(b)%2/2;a.x=Math.floor(a.x||this.x||0)+d;a.y=Math.floor(a.y||this.y||0)+d;a.width=Math.floor((a.width||this.width||0)-2*d);a.height=Math.floor((a.height||this.height||0)-2*d);D(a.strokeWidth)&&(a.strokeWidth=b);return a},css:function(a){var b=this.styles,G={},l=this.element,w="",e=!b,f=["textOutline","textOverflow","width"];a&&a.color&&(a.fill=a.color);b&&C(a,function(a,d){a!==b[d]&&(G[d]=a,e=!0)});if(e){b&&(a=E(b,G));if(a)if(null===a.width||"auto"===a.width)delete this.textWidth;
	else if("text"===l.nodeName.toLowerCase()&&a.width)var k=this.textWidth=x(a.width);this.styles=a;k&&!K&&this.renderer.forExport&&delete a.width;if(l.namespaceURI===this.SVG_NS){var c=function(a,b){return"-"+b.toLowerCase()};C(a,function(a,b){-1===f.indexOf(b)&&(w+=b.replace(/([A-Z])/g,c)+":"+a+";")});w&&A(l,"style",w)}else d(l,a);this.added&&("text"===this.element.nodeName&&this.renderer.buildText(this),a&&a.textOutline&&this.applyTextOutline(a.textOutline))}return this},getStyle:function(a){return S.getComputedStyle(this.element||
	this,"").getPropertyValue(a)},strokeWidth:function(){if(!this.renderer.styledMode)return this["stroke-width"]||0;var a=this.getStyle("stroke-width");if(a.indexOf("px")===a.length-2)a=x(a);else{var b=r.createElementNS(T,"rect");A(b,{width:a,"stroke-width":0});this.element.parentNode.appendChild(b);a=b.getBBox().width;b.parentNode.removeChild(b)}return a},on:function(a,b){var d=this,l=d.element;q&&"click"===a?(l.ontouchstart=function(a){d.touchEventFired=Date.now();a.preventDefault();b.call(l,a)},l.onclick=
	function(a){(-1===S.navigator.userAgent.indexOf("Android")||1100<Date.now()-(d.touchEventFired||0))&&b.call(l,a)}):l["on"+a]=b;return this},setRadialReference:function(a){var b=this.renderer.gradients[this.element.gradient];this.element.radialReference=a;b&&b.radAttr&&b.animate(this.renderer.getRadialAttr(a,b.radAttr));return this},translate:function(a,b){return this.attr({translateX:a,translateY:b})},invert:function(a){this.inverted=a;this.updateTransform();return this},updateTransform:function(){var a=
	this.translateX||0,b=this.translateY||0,d=this.scaleX,l=this.scaleY,e=this.inverted,f=this.rotation,k=this.matrix,c=this.element;e&&(a+=this.width,b+=this.height);a=["translate("+a+","+b+")"];D(k)&&a.push("matrix("+k.join(",")+")");e?a.push("rotate(90) scale(-1,1)"):f&&a.push("rotate("+f+" "+w(this.rotationOriginX,c.getAttribute("x"),0)+" "+w(this.rotationOriginY,c.getAttribute("y")||0)+")");(D(d)||D(l))&&a.push("scale("+w(d,1)+" "+w(l,1)+")");a.length&&c.setAttribute("transform",a.join(" "))},toFront:function(){var a=
	this.element;a.parentNode.appendChild(a);return this},align:function(a,b,d){var l,G={};var e=this.renderer;var f=e.alignedObjects;var k,c;if(a){if(this.alignOptions=a,this.alignByTranslate=b,!d||y(d))this.alignTo=l=d||"renderer",F(f,this),f.push(this),d=null}else a=this.alignOptions,b=this.alignByTranslate,l=this.alignTo;d=w(d,e[l],e);l=a.align;e=a.verticalAlign;f=(d.x||0)+(a.x||0);var t=(d.y||0)+(a.y||0);"right"===l?k=1:"center"===l&&(k=2);k&&(f+=(d.width-(a.width||0))/k);G[b?"translateX":"x"]=Math.round(f);
	"bottom"===e?c=1:"middle"===e&&(c=2);c&&(t+=(d.height-(a.height||0))/c);G[b?"translateY":"y"]=Math.round(t);this[this.placed?"animate":"attr"](G);this.placed=!0;this.alignAttr=G;return this},getBBox:function(a,b){var d,l=this.renderer,G=this.element,f=this.styles,k=this.textStr,c,t=l.cache,h=l.cacheKeys,O=G.namespaceURI===this.SVG_NS;b=w(b,this.rotation);var B=b*e;var J=l.styledMode?G&&M.prototype.getStyle.call(G,"font-size"):f&&f.fontSize;if(D(k)){var K=k.toString();-1===K.indexOf("<")&&(K=K.replace(/[0-9]/g,
	"0"));K+=["",b||0,J,this.textWidth,f&&f.textOverflow].join()}K&&!a&&(d=t[K]);if(!d){if(O||l.forExport){try{(c=this.fakeTS&&function(a){[].forEach.call(G.querySelectorAll(".highcharts-text-outline"),function(b){b.style.display=a})})&&c("none"),d=G.getBBox?E({},G.getBBox()):{width:G.offsetWidth,height:G.offsetHeight},c&&c("")}catch(Z){""}if(!d||0>d.width)d={width:0,height:0}}else d=this.htmlGetBBox();l.isSVG&&(a=d.width,l=d.height,O&&(d.height=l={"11px,17":14,"13px,20":16}[f&&f.fontSize+","+Math.round(l)]||
	l),b&&(d.width=Math.abs(l*Math.sin(B))+Math.abs(a*Math.cos(B)),d.height=Math.abs(l*Math.cos(B))+Math.abs(a*Math.sin(B))));if(K&&0<d.height){for(;250<h.length;)delete t[h.shift()];t[K]||h.push(K);t[K]=d}}return d},show:function(a){return this.attr({visibility:a?"inherit":"visible"})},hide:function(a){a?this.attr({y:-9999}):this.attr({visibility:"hidden"});return this},fadeOut:function(a){var b=this;b.animate({opacity:0},{duration:a||150,complete:function(){b.attr({y:-9999})}})},add:function(a){var b=
	this.renderer,d=this.element;a&&(this.parentGroup=a);this.parentInverted=a&&a.inverted;void 0!==this.textStr&&b.buildText(this);this.added=!0;if(!a||a.handleZ||this.zIndex)var l=this.zIndexSetter();l||(a?a.element:b.box).appendChild(d);if(this.onAdd)this.onAdd();return this},safeRemoveChild:function(a){var b=a.parentNode;b&&b.removeChild(a)},destroy:function(){var a=this,b=a.element||{},d=a.renderer,l=d.isSVG&&"SPAN"===b.nodeName&&a.parentGroup,w=b.ownerSVGElement,e=a.clipPath;b.onclick=b.onmouseout=
	b.onmouseover=b.onmousemove=b.point=null;J(a);e&&w&&([].forEach.call(w.querySelectorAll("[clip-path],[CLIP-PATH]"),function(a){-1<a.getAttribute("clip-path").indexOf(e.element.id)&&a.removeAttribute("clip-path")}),a.clipPath=e.destroy());if(a.stops){for(w=0;w<a.stops.length;w++)a.stops[w]=a.stops[w].destroy();a.stops=null}a.safeRemoveChild(b);for(d.styledMode||a.destroyShadows();l&&l.div&&0===l.div.childNodes.length;)b=l.parentGroup,a.safeRemoveChild(l.div),delete l.div,l=b;a.alignTo&&F(d.alignedObjects,
	a);C(a,function(b,d){a[d]&&a[d].parentGroup===a&&a[d].destroy&&a[d].destroy();delete a[d]})},shadow:function(a,b,d){var l=[],e,f=this.element;if(!a)this.destroyShadows();else if(!this.shadows){var G=w(a.width,3);var k=(a.opacity||.15)/G;var c=this.parentInverted?"(-1,-1)":"("+w(a.offsetX,1)+", "+w(a.offsetY,1)+")";for(e=1;e<=G;e++){var t=f.cloneNode(0);var h=2*G+1-2*e;A(t,{stroke:a.color||"#000000","stroke-opacity":k*e,"stroke-width":h,transform:"translate"+c,fill:"none"});t.setAttribute("class",
	(t.getAttribute("class")||"")+" highcharts-shadow");d&&(A(t,"height",Math.max(A(t,"height")-h,0)),t.cutHeight=h);b?b.element.appendChild(t):f.parentNode&&f.parentNode.insertBefore(t,f);l.push(t)}this.shadows=l}return this},destroyShadows:function(){(this.shadows||[]).forEach(function(a){this.safeRemoveChild(a)},this);this.shadows=void 0},xGetter:function(a){"circle"===this.element.nodeName&&("x"===a?a="cx":"y"===a&&(a="cy"));return this._defaultGetter(a)},_defaultGetter:function(a){a=w(this[a+"Value"],
	this[a],this.element?this.element.getAttribute(a):null,0);/^[\-0-9\.]+$/.test(a)&&(a=parseFloat(a));return a},dSetter:function(a,b,d){a&&a.join&&(a=a.join(" "));/(NaN| {2}|^$)/.test(a)&&(a="M 0 0");this[b]!==a&&(d.setAttribute(b,a),this[b]=a)},dashstyleSetter:function(a){var b,d=this["stroke-width"];"inherit"===d&&(d=1);if(a=a&&a.toLowerCase()){a=a.replace("shortdashdotdot","3,1,1,1,1,1,").replace("shortdashdot","3,1,1,1").replace("shortdot","1,1,").replace("shortdash","3,1,").replace("longdash",
	"8,3,").replace(/dot/g,"1,3,").replace("dash","4,3,").replace(/,$/,"").split(",");for(b=a.length;b--;)a[b]=x(a[b])*d;a=a.join(",").replace(/NaN/g,"none");this.element.setAttribute("stroke-dasharray",a)}},alignSetter:function(a){var b={left:"start",center:"middle",right:"end"};b[a]&&(this.alignValue=a,this.element.setAttribute("text-anchor",b[a]))},opacitySetter:function(a,b,d){this[b]=a;d.setAttribute(b,a)},titleSetter:function(a){var b=this.element.getElementsByTagName("title")[0];b||(b=r.createElementNS(this.SVG_NS,
	"title"),this.element.appendChild(b));b.firstChild&&b.removeChild(b.firstChild);b.appendChild(r.createTextNode(String(w(a,"")).replace(/<[^>]*>/g,"").replace(/&lt;/g,"<").replace(/&gt;/g,">")))},textSetter:function(a){a!==this.textStr&&(delete this.bBox,delete this.textPxLength,this.textStr=a,this.added&&this.renderer.buildText(this))},setTextPath:function(a,b){var d=this.element,l={textAnchor:"text-anchor"},w=!1,e=this.textPathWrapper,f=!e;b=B(!0,{enabled:!0,attributes:{dy:-5,startOffset:"50%",textAnchor:"middle"}},
	b);var k=b.attributes;if(a&&b&&b.enabled){this.options&&this.options.padding&&(k.dx=-this.options.padding);e||(this.textPathWrapper=e=this.renderer.createElement("textPath"),w=!0);var G=e.element;(b=a.element.getAttribute("id"))||a.element.setAttribute("id",b=c.uniqueKey());if(f)for(a=d.getElementsByTagName("tspan");a.length;)a[0].setAttribute("y",0),G.appendChild(a[0]);w&&e.add({element:this.text?this.text.element:d});G.setAttributeNS("http://www.w3.org/1999/xlink","href",this.renderer.url+"#"+b);
	D(k.dy)&&(G.parentNode.setAttribute("dy",k.dy),delete k.dy);D(k.dx)&&(G.parentNode.setAttribute("dx",k.dx),delete k.dx);C(k,function(a,b){G.setAttribute(l[b]||b,a)});d.removeAttribute("transform");this.removeTextOutline.call(e,[].slice.call(d.getElementsByTagName("tspan")));this.text&&!this.renderer.styledMode&&this.attr({fill:"none","stroke-width":0});this.applyTextOutline=this.updateTransform=I}else e&&(delete this.updateTransform,delete this.applyTextOutline,this.destroyTextPath(d,a));return this},
	destroyTextPath:function(a,b){var d;b.element.setAttribute("id","");for(d=this.textPathWrapper.element.childNodes;d.length;)a.firstChild.appendChild(d[0]);a.firstChild.removeChild(this.textPathWrapper.element);delete b.textPathWrapper},fillSetter:function(a,b,d){"string"===typeof a?d.setAttribute(b,a):a&&this.complexColor(a,b,d)},visibilitySetter:function(a,b,d){"inherit"===a?d.removeAttribute(b):this[b]!==a&&d.setAttribute(b,a);this[b]=a},zIndexSetter:function(a,b){var d=this.renderer,l=this.parentGroup,
	w=(l||d).element||d.box,e=this.element,f=!1;d=w===d.box;var k=this.added;var c;D(a)?(e.setAttribute("data-z-index",a),a=+a,this[b]===a&&(k=!1)):D(this[b])&&e.removeAttribute("data-z-index");this[b]=a;if(k){(a=this.zIndex)&&l&&(l.handleZ=!0);b=w.childNodes;for(c=b.length-1;0<=c&&!f;c--){l=b[c];k=l.getAttribute("data-z-index");var G=!D(k);if(l!==e)if(0>a&&G&&!d&&!c)w.insertBefore(e,b[c]),f=!0;else if(x(k)<=a||G&&(!D(a)||0<=a))w.insertBefore(e,b[c+1]||null),f=!0}f||(w.insertBefore(e,b[d?3:0]||null),
	f=!0)}return f},_defaultSetter:function(a,b,d){d.setAttribute(b,a)}});M.prototype.yGetter=M.prototype.xGetter;M.prototype.translateXSetter=M.prototype.translateYSetter=M.prototype.rotationSetter=M.prototype.verticalAlignSetter=M.prototype.rotationOriginXSetter=M.prototype.rotationOriginYSetter=M.prototype.scaleXSetter=M.prototype.scaleYSetter=M.prototype.matrixSetter=function(a,b){this[b]=a;this.doTransform=!0};M.prototype["stroke-widthSetter"]=M.prototype.strokeSetter=function(a,b,d){this[b]=a;this.stroke&&
	this["stroke-width"]?(M.prototype.fillSetter.call(this,this.stroke,"stroke",d),d.setAttribute("stroke-width",this["stroke-width"]),this.hasStroke=!0):"stroke-width"===b&&0===a&&this.hasStroke?(d.removeAttribute("stroke"),this.hasStroke=!1):this.renderer.styledMode&&this["stroke-width"]&&(d.setAttribute("stroke-width",this["stroke-width"]),this.hasStroke=!0)};n=c.SVGRenderer=function(){this.init.apply(this,arguments)};E(n.prototype,{Element:M,SVG_NS:T,init:function(a,b,l,w,e,f,k){var c=this.createElement("svg").attr({version:"1.1",
	"class":"highcharts-root"});k||c.css(this.getStyle(w));w=c.element;a.appendChild(w);A(a,"dir","ltr");-1===a.innerHTML.indexOf("xmlns")&&A(w,"xmlns",this.SVG_NS);this.isSVG=!0;this.box=w;this.boxWrapper=c;this.alignedObjects=[];this.url=(v||t)&&r.getElementsByTagName("base").length?S.location.href.split("#")[0].replace(/<[^>]*>/g,"").replace(/([\('\)])/g,"\\$1").replace(/ /g,"%20"):"";this.createElement("desc").add().element.appendChild(r.createTextNode("Created with Highcharts 7.2.0"));this.defs=
	this.createElement("defs").add();this.allowHTML=f;this.forExport=e;this.styledMode=k;this.gradients={};this.cache={};this.cacheKeys=[];this.imgCount=0;this.setSize(b,l,!1);var G;v&&a.getBoundingClientRect&&(b=function(){d(a,{left:0,top:0});G=a.getBoundingClientRect();d(a,{left:Math.ceil(G.left)-G.left+"px",top:Math.ceil(G.top)-G.top+"px"})},b(),this.unSubPixelFix=p(S,"resize",b))},definition:function(a){function b(a,l){var w;m(a).forEach(function(a){var e=d.createElement(a.tagName),f={};C(a,function(a,
	b){"tagName"!==b&&"children"!==b&&"textContent"!==b&&(f[b]=a)});e.attr(f);e.add(l||d.defs);a.textContent&&e.element.appendChild(r.createTextNode(a.textContent));b(a.children||[],e);w=e});return w}var d=this;return b(a)},getStyle:function(a){return this.style=E({fontFamily:'"Lucida Grande", "Lucida Sans Unicode", Arial, Helvetica, sans-serif',fontSize:"12px"},a)},setStyle:function(a){this.boxWrapper.css(this.getStyle(a))},isHidden:function(){return!this.boxWrapper.getBBox().width},destroy:function(){var a=
	this.defs;this.box=null;this.boxWrapper=this.boxWrapper.destroy();h(this.gradients||{});this.gradients=null;a&&(this.defs=a.destroy());this.unSubPixelFix&&this.unSubPixelFix();return this.alignedObjects=null},createElement:function(a){var b=new this.Element;b.init(this,a);return b},draw:I,getRadialAttr:function(a,b){return{cx:a[0]-a[2]/2+b.cx*a[2],cy:a[1]-a[2]/2+b.cy*a[2],r:b.r*a[2]}},truncate:function(a,b,d,l,w,e,f){var k=this,c=a.rotation,t,G=l?1:0,h=(d||l).length,B=h,J=[],K=function(a){b.firstChild&&
	b.removeChild(b.firstChild);a&&b.appendChild(r.createTextNode(a))},M=function(e,c){c=c||e;if(void 0===J[c])if(b.getSubStringLength)try{J[c]=w+b.getSubStringLength(0,l?c+1:c)}catch(aa){""}else k.getSpanWidth&&(K(f(d||l,e)),J[c]=w+k.getSpanWidth(a,b));return J[c]},O;a.rotation=0;var q=M(b.textContent.length);if(O=w+q>e){for(;G<=h;)B=Math.ceil((G+h)/2),l&&(t=f(l,B)),q=M(B,t&&t.length-1),G===h?G=h+1:q>e?h=B-1:G=B;0===h?K(""):d&&h===d.length-1||K(t||f(d||l,B))}l&&l.splice(0,B);a.actualWidth=q;a.rotation=
	c;return O},escapes:{"&":"&amp;","<":"&lt;",">":"&gt;","'":"&#39;",'"':"&quot;"},buildText:function(a){var b=a.element,l=this,e=l.forExport,f=w(a.textStr,"").toString(),k=-1!==f.indexOf("<"),c=b.childNodes,t,h=A(b,"x"),G=a.styles,B=a.textWidth,J=G&&G.lineHeight,M=G&&G.textOutline,q=G&&"ellipsis"===G.textOverflow,v=G&&"nowrap"===G.whiteSpace,I=G&&G.fontSize,m,g=c.length;G=B&&!a.added&&this.box;var E=function(a){var d;l.styledMode||(d=/(px|em)$/.test(a&&a.style.fontSize)?a.style.fontSize:I||l.style.fontSize||
	12);return J?x(J):l.fontMetrics(d,a.getAttribute("style")?a:b).h},p=function(a,b){C(l.escapes,function(d,l){b&&-1!==b.indexOf(d)||(a=a.toString().replace(new RegExp(d,"g"),l))});return a},R=function(a,b){var d=a.indexOf("<");a=a.substring(d,a.indexOf(">")-d);d=a.indexOf(b+"=");if(-1!==d&&(d=d+b.length+1,b=a.charAt(d),'"'===b||"'"===b))return a=a.substring(d+1),a.substring(0,a.indexOf(b))},S=/<br.*?>/g;var u=[f,q,v,J,M,I,B].join();if(u!==a.textCache){for(a.textCache=u;g--;)b.removeChild(c[g]);k||M||
	q||B||-1!==f.indexOf(" ")&&(!v||S.test(f))?(G&&G.appendChild(b),k?(f=l.styledMode?f.replace(/<(b|strong)>/g,'<span class="highcharts-strong">').replace(/<(i|em)>/g,'<span class="highcharts-emphasized">'):f.replace(/<(b|strong)>/g,'<span style="font-weight:bold">').replace(/<(i|em)>/g,'<span style="font-style:italic">'),f=f.replace(/<a/g,"<span").replace(/<\/(b|strong|i|em|a)>/g,"</span>").split(S)):f=[f],f=f.filter(function(a){return""!==a}),f.forEach(function(w,f){var k=0,c=0;w=w.replace(/^\s+|\s+$/g,
	"").replace(/<span/g,"|||<span").replace(/<\/span>/g,"</span>|||");var G=w.split("|||");G.forEach(function(w){if(""!==w||1===G.length){var J={},M=r.createElementNS(l.SVG_NS,"tspan"),O,g;(O=R(w,"class"))&&A(M,"class",O);if(O=R(w,"style"))O=O.replace(/(;| |^)color([ :])/,"$1fill$2"),A(M,"style",O);(g=R(w,"href"))&&!e&&(A(M,"onclick",'location.href="'+g+'"'),A(M,"class","highcharts-anchor"),l.styledMode||d(M,{cursor:"pointer"}));w=p(w.replace(/<[a-zA-Z\/](.|\n)*?>/g,"")||" ");if(" "!==w){M.appendChild(r.createTextNode(w));
	k?J.dx=0:f&&null!==h&&(J.x=h);A(M,J);b.appendChild(M);!k&&m&&(!K&&e&&d(M,{display:"block"}),A(M,"dy",E(M)));if(B){var Q=w.replace(/([^\^])-/g,"$1- ").split(" ");J=!v&&(1<G.length||f||1<Q.length);g=0;var x=E(M);if(q)t=l.truncate(a,M,w,void 0,0,Math.max(0,B-parseInt(I||12,10)),function(a,b){return a.substring(0,b)+"\u2026"});else if(J)for(;Q.length;)Q.length&&!v&&0<g&&(M=r.createElementNS(T,"tspan"),A(M,{dy:x,x:h}),O&&A(M,"style",O),M.appendChild(r.createTextNode(Q.join(" ").replace(/- /g,"-"))),b.appendChild(M)),
	l.truncate(a,M,null,Q,0===g?c:0,B,function(a,b){return Q.slice(0,b).join(" ").replace(/- /g,"-")}),c=a.actualWidth,g++}k++}}});m=m||b.childNodes.length}),q&&t&&a.attr("title",p(a.textStr,["&lt;","&gt;"])),G&&G.removeChild(b),M&&a.applyTextOutline&&a.applyTextOutline(M)):b.appendChild(r.createTextNode(p(f)))}},getContrast:function(b){b=a(b).rgba;b[0]*=1;b[1]*=1.2;b[2]*=.5;return 459<b[0]+b[1]+b[2]?"#000000":"#FFFFFF"},button:function(a,b,d,l,w,e,f,c,t,h){var G=this.label(a,b,d,t,null,null,h,null,"button"),
	J=0,K=this.styledMode;G.attr(B({padding:8,r:2},w));if(!K){w=B({fill:"#f7f7f7",stroke:"#cccccc","stroke-width":1,style:{color:"#333333",cursor:"pointer",fontWeight:"normal"}},w);var M=w.style;delete w.style;e=B(w,{fill:"#e6e6e6"},e);var r=e.style;delete e.style;f=B(w,{fill:"#e6ebf5",style:{color:"#000000",fontWeight:"bold"}},f);var q=f.style;delete f.style;c=B(w,{style:{color:"#cccccc"}},c);var O=c.style;delete c.style}p(G.element,k?"mouseover":"mouseenter",function(){3!==J&&G.setState(1)});p(G.element,
	k?"mouseout":"mouseleave",function(){3!==J&&G.setState(J)});G.setState=function(a){1!==a&&(G.state=J=a);G.removeClass(/highcharts-button-(normal|hover|pressed|disabled)/).addClass("highcharts-button-"+["normal","hover","pressed","disabled"][a||0]);K||G.attr([w,e,f,c][a||0]).css([M,r,q,O][a||0])};K||G.attr(w).css(E({cursor:"default"},M));return G.on("click",function(a){3!==J&&l.call(G,a)})},crispLine:function(a,b){a[1]===a[4]&&(a[1]=a[4]=Math.round(a[1])-b%2/2);a[2]===a[5]&&(a[2]=a[5]=Math.round(a[2])+
	b%2/2);return a},path:function(a){var b=this.styledMode?{}:{fill:"none"};z(a)?b.d=a:L(a)&&E(b,a);return this.createElement("path").attr(b)},circle:function(a,b,d){a=L(a)?a:void 0===a?{}:{x:a,y:b,r:d};b=this.createElement("circle");b.xSetter=b.ySetter=function(a,b,d){d.setAttribute("c"+b,a)};return b.attr(a)},arc:function(a,b,d,l,w,e){L(a)?(l=a,b=l.y,d=l.r,a=l.x):l={innerR:l,start:w,end:e};a=this.symbol("arc",a,b,d,d,l);a.r=d;return a},rect:function(a,b,d,l,w,e){w=L(a)?a.r:w;var f=this.createElement("rect");
	a=L(a)?a:void 0===a?{}:{x:a,y:b,width:Math.max(d,0),height:Math.max(l,0)};this.styledMode||(void 0!==e&&(a.strokeWidth=e,a=f.crisp(a)),a.fill="none");w&&(a.r=w);f.rSetter=function(a,b,d){f.r=a;A(d,{rx:a,ry:a})};f.rGetter=function(){return f.r};return f.attr(a)},setSize:function(a,b,d){var l=this.alignedObjects,e=l.length;this.width=a;this.height=b;for(this.boxWrapper.animate({width:a,height:b},{step:function(){this.attr({viewBox:"0 0 "+this.attr("width")+" "+this.attr("height")})},duration:w(d,!0)?
	void 0:0});e--;)l[e].align()},g:function(a){var b=this.createElement("g");return a?b.attr({"class":"highcharts-"+a}):b},image:function(a,b,d,l,w,e){var f={preserveAspectRatio:"none"},k=function(a,b){a.setAttributeNS?a.setAttributeNS("http://www.w3.org/1999/xlink","href",b):a.setAttribute("hc-svg-href",b)},c=function(b){k(t.element,a);e.call(t,b)};1<arguments.length&&E(f,{x:b,y:d,width:l,height:w});var t=this.createElement("image").attr(f);e?(k(t.element,"data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="),
	f=new S.Image,p(f,"load",c),f.src=a,f.complete&&c({})):k(t.element,a);return t},symbol:function(a,l,e,k,c,t){var h=this,B=/^url\((.*?)\)$/,G=B.test(a),J=!G&&(this.symbols[a]?a:"circle"),K=J&&this.symbols[J],M=D(l)&&K&&K.call(this.symbols,Math.round(l),Math.round(e),k,c,t);if(K){var q=this.path(M);h.styledMode||q.attr("fill","none");E(q,{symbolName:J,x:l,y:e,width:k,height:c});t&&E(q,t)}else if(G){var v=a.match(B)[1];q=this.image(v);q.imgwidth=w(R[v]&&R[v].width,t&&t.width);q.imgheight=w(R[v]&&R[v].height,
	t&&t.height);var I=function(){q.attr({width:q.width,height:q.height})};["width","height"].forEach(function(a){q[a+"Setter"]=function(a,b){var d={},l=this["img"+b],w="width"===b?"translateX":"translateY";this[b]=a;D(l)&&(t&&"within"===t.backgroundSize&&this.width&&this.height&&(l=Math.round(l*Math.min(this.width/this.imgwidth,this.height/this.imgheight))),this.element&&this.element.setAttribute(b,l),this.alignByTranslate||(d[w]=((this[b]||0)-l)/2,this.attr(d)))}});D(l)&&q.attr({x:l,y:e});q.isImg=!0;
	D(q.imgwidth)&&D(q.imgheight)?I():(q.attr({width:0,height:0}),f("img",{onload:function(){var a=b[h.chartIndex];0===this.width&&(d(this,{position:"absolute",top:"-999em"}),r.body.appendChild(this));R[v]={width:this.width,height:this.height};q.imgwidth=this.width;q.imgheight=this.height;q.element&&I();this.parentNode&&this.parentNode.removeChild(this);h.imgCount--;if(!h.imgCount&&a&&a.onload)a.onload()},src:v}),this.imgCount++)}return q},symbols:{circle:function(a,b,d,l){return this.arc(a+d/2,b+l/2,
	d/2,l/2,{start:.5*Math.PI,end:2.5*Math.PI,open:!1})},square:function(a,b,d,l){return["M",a,b,"L",a+d,b,a+d,b+l,a,b+l,"Z"]},triangle:function(a,b,d,l){return["M",a+d/2,b,"L",a+d,b+l,a,b+l,"Z"]},"triangle-down":function(a,b,d,l){return["M",a,b,"L",a+d,b,a+d/2,b+l,"Z"]},diamond:function(a,b,d,l){return["M",a+d/2,b,"L",a+d,b+l/2,a+d/2,b+l,a,b+l/2,"Z"]},arc:function(a,b,d,l,e){var f=e.start,k=e.r||d,c=e.r||l||d,t=e.end-.001;d=e.innerR;l=w(e.open,.001>Math.abs(e.end-e.start-2*Math.PI));var h=Math.cos(f),
	B=Math.sin(f),J=Math.cos(t);t=Math.sin(t);f=.001>e.end-f-Math.PI?0:1;e=["M",a+k*h,b+c*B,"A",k,c,0,f,w(e.clockwise,1),a+k*J,b+c*t];D(d)&&e.push(l?"M":"L",a+d*J,b+d*t,"A",d,d,0,f,0,a+d*h,b+d*B);e.push(l?"":"Z");return e},callout:function(a,b,d,l,w){var e=Math.min(w&&w.r||0,d,l),f=e+6,k=w&&w.anchorX;w=w&&w.anchorY;var c=["M",a+e,b,"L",a+d-e,b,"C",a+d,b,a+d,b,a+d,b+e,"L",a+d,b+l-e,"C",a+d,b+l,a+d,b+l,a+d-e,b+l,"L",a+e,b+l,"C",a,b+l,a,b+l,a,b+l-e,"L",a,b+e,"C",a,b,a,b,a+e,b];k&&k>d?w>b+f&&w<b+l-f?c.splice(13,
	3,"L",a+d,w-6,a+d+6,w,a+d,w+6,a+d,b+l-e):c.splice(13,3,"L",a+d,l/2,k,w,a+d,l/2,a+d,b+l-e):k&&0>k?w>b+f&&w<b+l-f?c.splice(33,3,"L",a,w+6,a-6,w,a,w-6,a,b+e):c.splice(33,3,"L",a,l/2,k,w,a,l/2,a,b+e):w&&w>l&&k>a+f&&k<a+d-f?c.splice(23,3,"L",k+6,b+l,k,b+l+6,k-6,b+l,a+e,b+l):w&&0>w&&k>a+f&&k<a+d-f&&c.splice(3,3,"L",k-6,b,k,b-6,k+6,b,d-e,b);return c}},clipRect:function(a,b,d,l){var w=c.uniqueKey()+"-",e=this.createElement("clipPath").attr({id:w}).add(this.defs);a=this.rect(a,b,d,l,0).add(e);a.id=w;a.clipPath=
	e;a.count=0;return a},text:function(a,b,d,l){var w={};if(l&&(this.allowHTML||!this.forExport))return this.html(a,b,d);w.x=Math.round(b||0);d&&(w.y=Math.round(d));D(a)&&(w.text=a);a=this.createElement("text").attr(w);l||(a.xSetter=function(a,b,d){var l=d.getElementsByTagName("tspan"),w=d.getAttribute(b),e;for(e=0;e<l.length;e++){var f=l[e];f.getAttribute(b)===w&&f.setAttribute(b,a)}d.setAttribute(b,a)});return a},fontMetrics:function(a,b){a=!this.styledMode&&/px/.test(a)||!S.getComputedStyle?a||b&&
	b.style&&b.style.fontSize||this.style&&this.style.fontSize:b&&M.prototype.getStyle.call(b,"font-size");a=/px/.test(a)?x(a):12;b=24>a?a+3:Math.round(1.2*a);return{h:b,b:Math.round(.8*b),f:a}},rotCorr:function(a,b,d){var l=a;b&&d&&(l=Math.max(l*Math.cos(b*e),4));return{x:-a/3*Math.sin(b*e),y:l}},label:function(a,b,d,w,e,f,k,c,t){var h=this,J=h.styledMode,K=h.g("button"!==t&&"label"),q=K.text=h.text("",0,0,k).attr({zIndex:1}),r,v,G=0,I=3,m=0,g,p,O,T,x,Q={},R,S,z=/^url\((.*?)\)$/.test(w),y=J||z,n=function(){return J?
	r.strokeWidth()%2/2:(R?parseInt(R,10):0)%2/2};t&&K.addClass("highcharts-"+t);var L=function(){var a=q.element.style,b={};v=(void 0===g||void 0===p||x)&&D(q.textStr)&&q.getBBox();K.width=(g||v.width||0)+2*I+m;K.height=(p||v.height||0)+2*I;S=I+Math.min(h.fontMetrics(a&&a.fontSize,q).b,v?v.height:Infinity);y&&(r||(K.box=r=h.symbols[w]||z?h.symbol(w):h.rect(),r.addClass(("button"===t?"":"highcharts-label-box")+(t?" highcharts-"+t+"-box":"")),r.add(K),a=n(),b.x=a,b.y=(c?-S:0)+a),b.width=Math.round(K.width),
	b.height=Math.round(K.height),r.attr(E(b,Q)),Q={})};var C=function(){var a=m+I;var b=c?0:S;D(g)&&v&&("center"===x||"right"===x)&&(a+={center:.5,right:1}[x]*(g-v.width));if(a!==q.x||b!==q.y)q.attr("x",a),q.hasBoxWidthChanged&&(v=q.getBBox(!0),L()),void 0!==b&&q.attr("y",b);q.x=a;q.y=b};var A=function(a,b){r?r.attr(a,b):Q[a]=b};K.onAdd=function(){q.add(K);K.attr({text:a||0===a?a:"",x:b,y:d});r&&D(e)&&K.attr({anchorX:e,anchorY:f})};K.widthSetter=function(a){g=u(a)?a:null};K.heightSetter=function(a){p=
	a};K["text-alignSetter"]=function(a){x=a};K.paddingSetter=function(a){D(a)&&a!==I&&(I=K.padding=a,C())};K.paddingLeftSetter=function(a){D(a)&&a!==m&&(m=a,C())};K.alignSetter=function(a){a={left:0,center:.5,right:1}[a];a!==G&&(G=a,v&&K.attr({x:O}))};K.textSetter=function(a){void 0!==a&&q.attr({text:a});L();C()};K["stroke-widthSetter"]=function(a,b){a&&(y=!0);R=this["stroke-width"]=a;A(b,a)};J?K.rSetter=function(a,b){A(b,a)}:K.strokeSetter=K.fillSetter=K.rSetter=function(a,b){"r"!==b&&("fill"===b&&
	a&&(y=!0),K[b]=a);A(b,a)};K.anchorXSetter=function(a,b){e=K.anchorX=a;A(b,Math.round(a)-n()-O)};K.anchorYSetter=function(a,b){f=K.anchorY=a;A(b,a-T)};K.xSetter=function(a){K.x=a;G&&(a-=G*((g||v.width)+2*I),K["forceAnimate:x"]=!0);O=Math.round(a);K.attr("translateX",O)};K.ySetter=function(a){T=K.y=Math.round(a);K.attr("translateY",T)};var U=K.css;k={css:function(a){if(a){var b={};a=B(a);K.textProps.forEach(function(d){void 0!==a[d]&&(b[d]=a[d],delete a[d])});q.css(b);"width"in b&&L();"fontSize"in b&&
	(L(),C())}return U.call(K,a)},getBBox:function(){return{width:v.width+2*I,height:v.height+2*I,x:v.x-I,y:v.y-I}},destroy:function(){l(K.element,"mouseenter");l(K.element,"mouseleave");q&&(q=q.destroy());r&&(r=r.destroy());M.prototype.destroy.call(K);K=h=L=C=A=null}};J||(k.shadow=function(a){a&&(L(),r&&r.shadow(a));return K});return E(K,k)}});c.Renderer=n});N(H,"parts/Html.js",[H["parts/Globals.js"],H["parts/Utilities.js"]],function(c,n){var A=n.attr,D=n.defined,F=n.pInt,z=c.createElement,u=c.css,L=
	c.extend,y=c.isFirefox,C=c.isMS,x=c.isWebKit,m=c.pick,p=c.SVGElement;n=c.SVGRenderer;var g=c.win;L(p.prototype,{htmlCss:function(b){var a="SPAN"===this.element.tagName&&b&&"width"in b,d=m(a&&b.width,void 0);if(a){delete b.width;this.textWidth=d;var f=!0}b&&"ellipsis"===b.textOverflow&&(b.whiteSpace="nowrap",b.overflow="hidden");this.styles=L(this.styles,b);u(this.element,b);f&&this.htmlUpdateTransform();return this},htmlGetBBox:function(){var b=this.element;return{x:b.offsetLeft,y:b.offsetTop,width:b.offsetWidth,
	height:b.offsetHeight}},htmlUpdateTransform:function(){if(this.added){var b=this.renderer,a=this.element,d=this.translateX||0,f=this.translateY||0,e=this.x||0,c=this.y||0,r=this.textAlign||"left",m={left:0,center:.5,right:1}[r],q=this.styles,v=q&&q.whiteSpace;u(a,{marginLeft:d,marginTop:f});!b.styledMode&&this.shadows&&this.shadows.forEach(function(a){u(a,{marginLeft:d+1,marginTop:f+1})});this.inverted&&[].forEach.call(a.childNodes,function(d){b.invertChild(d,a)});if("SPAN"===a.tagName){q=this.rotation;
	var k=this.textWidth&&F(this.textWidth),t=[q,r,a.innerHTML,this.textWidth,this.textAlign].join(),B;(B=k!==this.oldTextWidth)&&!(B=k>this.oldTextWidth)&&((B=this.textPxLength)||(u(a,{width:"",whiteSpace:v||"nowrap"}),B=a.offsetWidth),B=B>k);B&&(/[ \-]/.test(a.textContent||a.innerText)||"ellipsis"===a.style.textOverflow)?(u(a,{width:k+"px",display:"block",whiteSpace:v||"normal"}),this.oldTextWidth=k,this.hasBoxWidthChanged=!0):this.hasBoxWidthChanged=!1;t!==this.cTT&&(v=b.fontMetrics(a.style.fontSize,
	a).b,!D(q)||q===(this.oldRotation||0)&&r===this.oldAlign||this.setSpanRotation(q,m,v),this.getSpanCorrection(!D(q)&&this.textPxLength||a.offsetWidth,v,m,q,r));u(a,{left:e+(this.xCorr||0)+"px",top:c+(this.yCorr||0)+"px"});this.cTT=t;this.oldRotation=q;this.oldAlign=r}}else this.alignOnAdd=!0},setSpanRotation:function(b,a,d){var f={},e=this.renderer.getTransformKey();f[e]=f.transform="rotate("+b+"deg)";f[e+(y?"Origin":"-origin")]=f.transformOrigin=100*a+"% "+d+"px";u(this.element,f)},getSpanCorrection:function(b,
	a,d){this.xCorr=-b*d;this.yCorr=-a}});L(n.prototype,{getTransformKey:function(){return C&&!/Edge/.test(g.navigator.userAgent)?"-ms-transform":x?"-webkit-transform":y?"MozTransform":g.opera?"-o-transform":""},html:function(b,a,d){var f=this.createElement("span"),e=f.element,c=f.renderer,r=c.isSVG,g=function(a,b){["opacity","visibility"].forEach(function(d){a[d+"Setter"]=function(e,f,k){var w=a.div?a.div.style:b;p.prototype[d+"Setter"].call(this,e,f,k);w&&(w[f]=e)}});a.addedSetters=!0};f.textSetter=
	function(a){a!==e.innerHTML&&(delete this.bBox,delete this.oldTextWidth);this.textStr=a;e.innerHTML=m(a,"");f.doTransform=!0};r&&g(f,f.element.style);f.xSetter=f.ySetter=f.alignSetter=f.rotationSetter=function(a,b){"align"===b&&(b="textAlign");f[b]=a;f.doTransform=!0};f.afterSetters=function(){this.doTransform&&(this.htmlUpdateTransform(),this.doTransform=!1)};f.attr({text:b,x:Math.round(a),y:Math.round(d)}).css({position:"absolute"});c.styledMode||f.css({fontFamily:this.style.fontFamily,fontSize:this.style.fontSize});
	e.style.whiteSpace="nowrap";f.css=f.htmlCss;r&&(f.add=function(a){var b=c.box.parentNode,d=[];if(this.parentGroup=a){var t=a.div;if(!t){for(;a;)d.push(a),a=a.parentGroup;d.reverse().forEach(function(a){function e(b,d){a[d]=b;"translateX"===d?l.left=b+"px":l.top=b+"px";a.doTransform=!0}var w=A(a.element,"class");t=a.div=a.div||z("div",w?{className:w}:void 0,{position:"absolute",left:(a.translateX||0)+"px",top:(a.translateY||0)+"px",display:a.display,opacity:a.opacity,pointerEvents:a.styles&&a.styles.pointerEvents},
	t||b);var l=t.style;L(a,{classSetter:function(a){return function(b){this.element.setAttribute("class",b);a.className=b}}(t),on:function(){d[0].div&&f.on.apply({element:d[0].div},arguments);return a},translateXSetter:e,translateYSetter:e});a.addedSetters||g(a)})}}else t=b;t.appendChild(e);f.added=!0;f.alignOnAdd&&f.htmlUpdateTransform();return f});return f}})});N(H,"parts/Time.js",[H["parts/Globals.js"],H["parts/Utilities.js"]],function(c,n){var A=n.defined,D=n.isObject,F=n.objectEach,z=n.splat,u=
	c.extend,L=c.merge,y=c.pick,C=c.timeUnits,x=c.win;c.Time=function(c){this.update(c,!1)};c.Time.prototype={defaultOptions:{},update:function(c){var m=y(c&&c.useUTC,!0),g=this;this.options=c=L(!0,this.options||{},c);this.Date=c.Date||x.Date||Date;this.timezoneOffset=(this.useUTC=m)&&c.timezoneOffset;this.getTimezoneOffset=this.timezoneOffsetFunction();(this.variableTimezone=!(m&&!c.getTimezoneOffset&&!c.timezone))||this.timezoneOffset?(this.get=function(b,a){var d=a.getTime(),f=d-g.getTimezoneOffset(a);
	a.setTime(f);b=a["getUTC"+b]();a.setTime(d);return b},this.set=function(b,a,d){if("Milliseconds"===b||"Seconds"===b||"Minutes"===b&&0===a.getTimezoneOffset()%60)a["set"+b](d);else{var f=g.getTimezoneOffset(a);f=a.getTime()-f;a.setTime(f);a["setUTC"+b](d);b=g.getTimezoneOffset(a);f=a.getTime()+b;a.setTime(f)}}):m?(this.get=function(b,a){return a["getUTC"+b]()},this.set=function(b,a,d){return a["setUTC"+b](d)}):(this.get=function(b,a){return a["get"+b]()},this.set=function(b,a,d){return a["set"+b](d)})},
	makeTime:function(m,p,g,b,a,d){if(this.useUTC){var f=this.Date.UTC.apply(0,arguments);var e=this.getTimezoneOffset(f);f+=e;var h=this.getTimezoneOffset(f);e!==h?f+=h-e:e-36E5!==this.getTimezoneOffset(f-36E5)||c.isSafari||(f-=36E5)}else f=(new this.Date(m,p,y(g,1),y(b,0),y(a,0),y(d,0))).getTime();return f},timezoneOffsetFunction:function(){var m=this,p=this.options,g=x.moment;if(!this.useUTC)return function(b){return 6E4*(new Date(b)).getTimezoneOffset()};if(p.timezone){if(g)return function(b){return 6E4*
	-g.tz(b,p.timezone).utcOffset()};c.error(25)}return this.useUTC&&p.getTimezoneOffset?function(b){return 6E4*p.getTimezoneOffset(b)}:function(){return 6E4*(m.timezoneOffset||0)}},dateFormat:function(m,p,g){if(!A(p)||isNaN(p))return c.defaultOptions.lang.invalidDate||"";m=c.pick(m,"%Y-%m-%d %H:%M:%S");var b=this,a=new this.Date(p),d=this.get("Hours",a),f=this.get("Day",a),e=this.get("Date",a),h=this.get("Month",a),r=this.get("FullYear",a),E=c.defaultOptions.lang,q=E.weekdays,v=E.shortWeekdays,k=c.pad;
	a=c.extend({a:v?v[f]:q[f].substr(0,3),A:q[f],d:k(e),e:k(e,2," "),w:f,b:E.shortMonths[h],B:E.months[h],m:k(h+1),o:h+1,y:r.toString().substr(2,2),Y:r,H:k(d),k:d,I:k(d%12||12),l:d%12||12,M:k(b.get("Minutes",a)),p:12>d?"AM":"PM",P:12>d?"am":"pm",S:k(a.getSeconds()),L:k(Math.floor(p%1E3),3)},c.dateFormats);F(a,function(a,d){for(;-1!==m.indexOf("%"+d);)m=m.replace("%"+d,"function"===typeof a?a.call(b,p):a)});return g?m.substr(0,1).toUpperCase()+m.substr(1):m},resolveDTLFormat:function(c){return D(c,!0)?
	c:(c=z(c),{main:c[0],from:c[1],to:c[2]})},getTimeTicks:function(c,p,g,b){var a=this,d=[],f={};var e=new a.Date(p);var h=c.unitRange,r=c.count||1,m;b=y(b,1);if(A(p)){a.set("Milliseconds",e,h>=C.second?0:r*Math.floor(a.get("Milliseconds",e)/r));h>=C.second&&a.set("Seconds",e,h>=C.minute?0:r*Math.floor(a.get("Seconds",e)/r));h>=C.minute&&a.set("Minutes",e,h>=C.hour?0:r*Math.floor(a.get("Minutes",e)/r));h>=C.hour&&a.set("Hours",e,h>=C.day?0:r*Math.floor(a.get("Hours",e)/r));h>=C.day&&a.set("Date",e,h>=
	C.month?1:Math.max(1,r*Math.floor(a.get("Date",e)/r)));if(h>=C.month){a.set("Month",e,h>=C.year?0:r*Math.floor(a.get("Month",e)/r));var q=a.get("FullYear",e)}h>=C.year&&a.set("FullYear",e,q-q%r);h===C.week&&(q=a.get("Day",e),a.set("Date",e,a.get("Date",e)-q+b+(q<b?-7:0)));q=a.get("FullYear",e);b=a.get("Month",e);var v=a.get("Date",e),k=a.get("Hours",e);p=e.getTime();a.variableTimezone&&(m=g-p>4*C.month||a.getTimezoneOffset(p)!==a.getTimezoneOffset(g));p=e.getTime();for(e=1;p<g;)d.push(p),p=h===C.year?
	a.makeTime(q+e*r,0):h===C.month?a.makeTime(q,b+e*r):!m||h!==C.day&&h!==C.week?m&&h===C.hour&&1<r?a.makeTime(q,b,v,k+e*r):p+h*r:a.makeTime(q,b,v+e*r*(h===C.day?1:7)),e++;d.push(p);h<=C.hour&&1E4>d.length&&d.forEach(function(b){0===b%18E5&&"000000000"===a.dateFormat("%H%M%S%L",b)&&(f[b]="day")})}d.info=u(c,{higherRanks:f,totalRange:h*r});return d}}});N(H,"parts/Options.js",[H["parts/Globals.js"]],function(c){var n=c.color,A=c.merge;c.defaultOptions={colors:"#7cb5ec #434348 #90ed7d #f7a35c #8085e9 #f15c80 #e4d354 #2b908f #f45b5b #91e8e1".split(" "),
	symbols:["circle","diamond","square","triangle","triangle-down"],lang:{loading:"Loading...",months:"January February March April May June July August September October November December".split(" "),shortMonths:"Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec".split(" "),weekdays:"Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),decimalPoint:".",numericSymbols:"kMGTPE".split(""),resetZoom:"Reset zoom",resetZoomTitle:"Reset zoom level 1:1",thousandsSep:" "},global:{},time:c.Time.prototype.defaultOptions,
	chart:{styledMode:!1,borderRadius:0,colorCount:10,defaultSeriesType:"line",ignoreHiddenSeries:!0,spacing:[10,10,15,10],resetZoomButton:{theme:{zIndex:6},position:{align:"right",x:-10,y:10}},width:null,height:null,borderColor:"#335cad",backgroundColor:"#ffffff",plotBorderColor:"#cccccc"},title:{text:"Chart title",align:"center",margin:15,widthAdjust:-44},subtitle:{text:"",align:"center",widthAdjust:-44},caption:{margin:15,text:"",align:"left",verticalAlign:"bottom"},plotOptions:{},labels:{style:{position:"absolute",
	color:"#333333"}},legend:{enabled:!0,align:"center",alignColumns:!0,layout:"horizontal",labelFormatter:function(){return this.name},borderColor:"#999999",borderRadius:0,navigation:{activeColor:"#003399",inactiveColor:"#cccccc"},itemStyle:{color:"#333333",cursor:"pointer",fontSize:"12px",fontWeight:"bold",textOverflow:"ellipsis"},itemHoverStyle:{color:"#000000"},itemHiddenStyle:{color:"#cccccc"},shadow:!1,itemCheckboxStyle:{position:"absolute",width:"13px",height:"13px"},squareSymbol:!0,symbolPadding:5,
	verticalAlign:"bottom",x:0,y:0,title:{style:{fontWeight:"bold"}}},loading:{labelStyle:{fontWeight:"bold",position:"relative",top:"45%"},style:{position:"absolute",backgroundColor:"#ffffff",opacity:.5,textAlign:"center"}},tooltip:{enabled:!0,animation:c.svg,borderRadius:3,dateTimeLabelFormats:{millisecond:"%A, %b %e, %H:%M:%S.%L",second:"%A, %b %e, %H:%M:%S",minute:"%A, %b %e, %H:%M",hour:"%A, %b %e, %H:%M",day:"%A, %b %e, %Y",week:"Week from %A, %b %e, %Y",month:"%B %Y",year:"%Y"},footerFormat:"",
	padding:8,snap:c.isTouchDevice?25:10,headerFormat:'<span style="font-size: 10px">{point.key}</span><br/>',pointFormat:'<span style="color:{point.color}">\u25cf</span> {series.name}: <b>{point.y}</b><br/>',backgroundColor:n("#f7f7f7").setOpacity(.85).get(),borderWidth:1,shadow:!0,style:{color:"#333333",cursor:"default",fontSize:"12px",pointerEvents:"none",whiteSpace:"nowrap"}},credits:{enabled:!0,href:"https://www.highcharts.com?credits",position:{align:"right",x:-10,verticalAlign:"bottom",y:-5},style:{cursor:"pointer",
	color:"#999999",fontSize:"9px"},text:"Highcharts.com"}};c.setOptions=function(n){c.defaultOptions=A(!0,c.defaultOptions,n);c.time.update(A(c.defaultOptions.global,c.defaultOptions.time),!1);return c.defaultOptions};c.getOptions=function(){return c.defaultOptions};c.defaultPlotOptions=c.defaultOptions.plotOptions;c.time=new c.Time(A(c.defaultOptions.global,c.defaultOptions.time));c.dateFormat=function(n,A,z){return c.time.dateFormat(n,A,z)};""});N(H,"parts/Tick.js",[H["parts/Globals.js"],H["parts/Utilities.js"]],
	function(c,n){var A=n.defined,D=n.isNumber,F=c.correctFloat,z=c.destroyObjectProperties,u=c.fireEvent,L=c.merge,y=c.pick,C=c.deg2rad;c.Tick=function(c,m,p,g,b){this.axis=c;this.pos=m;this.type=p||"";this.isNewLabel=this.isNew=!0;this.parameters=b||{};this.tickmarkOffset=this.parameters.tickmarkOffset;this.options=this.parameters.options;p||g||this.addLabel()};c.Tick.prototype={addLabel:function(){var x=this,m=x.axis,p=m.options,g=m.chart,b=m.categories,a=m.names,d=x.pos,f=y(x.options&&x.options.labels,
	p.labels),e=m.tickPositions,h=d===e[0],r=d===e[e.length-1];b=this.parameters.category||(b?y(b[d],a[d],d):d);var E=x.label;e=e.info;var q,v;if(m.isDatetimeAxis&&e){var k=g.time.resolveDTLFormat(p.dateTimeLabelFormats[!p.grid&&e.higherRanks[d]||e.unitName]);var t=k.main}x.isFirst=h;x.isLast=r;x.formatCtx={axis:m,chart:g,isFirst:h,isLast:r,dateTimeLabelFormat:t,tickPositionInfo:e,value:m.isLog?F(m.lin2log(b)):b,pos:d};p=m.labelFormatter.call(x.formatCtx,this.formatCtx);if(v=k&&k.list)x.shortenLabel=
	function(){for(q=0;q<v.length;q++)if(E.attr({text:m.labelFormatter.call(c.extend(x.formatCtx,{dateTimeLabelFormat:v[q]}))}),E.getBBox().width<m.getSlotWidth(x)-2*y(f.padding,5))return;E.attr({text:""})};if(A(E))E&&E.textStr!==p&&(!E.textWidth||f.style&&f.style.width||E.styles.width||E.css({width:null}),E.attr({text:p}),E.textPxLength=E.getBBox().width);else{if(x.label=E=A(p)&&f.enabled?g.renderer.text(p,0,0,f.useHTML).add(m.labelGroup):null)g.styledMode||E.css(L(f.style)),E.textPxLength=E.getBBox().width;
	x.rotation=0}},getLabelSize:function(){return this.label?this.label.getBBox()[this.axis.horiz?"height":"width"]:0},handleOverflow:function(c){var m=this.axis,p=m.options.labels,g=c.x,b=m.chart.chartWidth,a=m.chart.spacing,d=y(m.labelLeft,Math.min(m.pos,a[3]));a=y(m.labelRight,Math.max(m.isRadial?0:m.pos+m.len,b-a[1]));var f=this.label,e=this.rotation,h={left:0,center:.5,right:1}[m.labelAlign||f.attr("align")],r=f.getBBox().width,E=m.getSlotWidth(this),q=E,v=1,k,t={};if(e||"justify"!==y(p.overflow,
	"justify"))0>e&&g-h*r<d?k=Math.round(g/Math.cos(e*C)-d):0<e&&g+h*r>a&&(k=Math.round((b-g)/Math.cos(e*C)));else if(b=g+(1-h)*r,g-h*r<d?q=c.x+q*(1-h)-d:b>a&&(q=a-c.x+q*h,v=-1),q=Math.min(E,q),q<E&&"center"===m.labelAlign&&(c.x+=v*(E-q-h*(E-Math.min(r,q)))),r>q||m.autoRotation&&(f.styles||{}).width)k=q;k&&(this.shortenLabel?this.shortenLabel():(t.width=Math.floor(k),(p.style||{}).textOverflow||(t.textOverflow="ellipsis"),f.css(t)))},getPosition:function(x,m,p,g){var b=this.axis,a=b.chart,d=g&&a.oldChartHeight||
	a.chartHeight;x={x:x?c.correctFloat(b.translate(m+p,null,null,g)+b.transB):b.left+b.offset+(b.opposite?(g&&a.oldChartWidth||a.chartWidth)-b.right-b.left:0),y:x?d-b.bottom+b.offset-(b.opposite?b.height:0):c.correctFloat(d-b.translate(m+p,null,null,g)-b.transB)};x.y=Math.max(Math.min(x.y,1E5),-1E5);u(this,"afterGetPosition",{pos:x});return x},getLabelPosition:function(c,m,p,g,b,a,d,f){var e=this.axis,h=e.transA,r=e.isLinked&&e.linkedParent?e.linkedParent.reversed:e.reversed,E=e.staggerLines,q=e.tickRotCorr||
	{x:0,y:0},v=b.y,k=g||e.reserveSpaceDefault?0:-e.labelOffset*("center"===e.labelAlign?.5:1),t={};A(v)||(v=0===e.side?p.rotation?-8:-p.getBBox().height:2===e.side?q.y+8:Math.cos(p.rotation*C)*(q.y-p.getBBox(!1,0).height/2));c=c+b.x+k+q.x-(a&&g?a*h*(r?-1:1):0);m=m+v-(a&&!g?a*h*(r?1:-1):0);E&&(p=d/(f||1)%E,e.opposite&&(p=E-p-1),m+=e.labelOffset/E*p);t.x=c;t.y=Math.round(m);u(this,"afterGetLabelPosition",{pos:t,tickmarkOffset:a,index:d});return t},getMarkPath:function(c,m,p,g,b,a){return a.crispLine(["M",
	c,m,"L",c+(b?0:-p),m+(b?p:0)],g)},renderGridLine:function(c,m,p){var g=this.axis,b=g.options,a=this.gridLine,d={},f=this.pos,e=this.type,h=y(this.tickmarkOffset,g.tickmarkOffset),r=g.chart.renderer,E=e?e+"Grid":"grid",q=b[E+"LineWidth"],v=b[E+"LineColor"];b=b[E+"LineDashStyle"];a||(g.chart.styledMode||(d.stroke=v,d["stroke-width"]=q,b&&(d.dashstyle=b)),e||(d.zIndex=1),c&&(m=0),this.gridLine=a=r.path().attr(d).addClass("highcharts-"+(e?e+"-":"")+"grid-line").add(g.gridGroup));if(a&&(p=g.getPlotLinePath({value:f+
	h,lineWidth:a.strokeWidth()*p,force:"pass",old:c})))a[c||this.isNew?"attr":"animate"]({d:p,opacity:m})},renderMark:function(c,m,p){var g=this.axis,b=g.options,a=g.chart.renderer,d=this.type,f=d?d+"Tick":"tick",e=g.tickSize(f),h=this.mark,r=!h,E=c.x;c=c.y;var q=y(b[f+"Width"],!d&&g.isXAxis?1:0);b=b[f+"Color"];e&&(g.opposite&&(e[0]=-e[0]),r&&(this.mark=h=a.path().addClass("highcharts-"+(d?d+"-":"")+"tick").add(g.axisGroup),g.chart.styledMode||h.attr({stroke:b,"stroke-width":q})),h[r?"attr":"animate"]({d:this.getMarkPath(E,
	c,e[0],h.strokeWidth()*p,g.horiz,a),opacity:m}))},renderLabel:function(c,m,p,g){var b=this.axis,a=b.horiz,d=b.options,f=this.label,e=d.labels,h=e.step;b=y(this.tickmarkOffset,b.tickmarkOffset);var r=!0,E=c.x;c=c.y;f&&D(E)&&(f.xy=c=this.getLabelPosition(E,c,f,a,e,b,g,h),this.isFirst&&!this.isLast&&!y(d.showFirstLabel,1)||this.isLast&&!this.isFirst&&!y(d.showLastLabel,1)?r=!1:!a||e.step||e.rotation||m||0===p||this.handleOverflow(c),h&&g%h&&(r=!1),r&&D(c.y)?(c.opacity=p,f[this.isNewLabel?"attr":"animate"](c),
	this.isNewLabel=!1):(f.attr("y",-9999),this.isNewLabel=!0))},render:function(x,m,p){var g=this.axis,b=g.horiz,a=this.pos,d=y(this.tickmarkOffset,g.tickmarkOffset);a=this.getPosition(b,a,d,m);d=a.x;var f=a.y;g=b&&d===g.pos+g.len||!b&&f===g.pos?-1:1;p=y(p,1);this.isActive=!0;this.renderGridLine(m,p,g);this.renderMark(a,p,g);this.renderLabel(a,m,p,x);this.isNew=!1;c.fireEvent(this,"afterRender")},destroy:function(){z(this,this.axis)}}});N(H,"parts/Axis.js",[H["parts/Globals.js"],H["parts/Utilities.js"]],
	function(c,n){var A=n.defined,D=n.isArray,F=n.isNumber,z=n.isString,u=n.objectEach,L=n.splat,y=c.addEvent,C=c.animObject,x=c.arrayMax,m=c.arrayMin,p=c.color,g=c.correctFloat,b=c.defaultOptions,a=c.deg2rad,d=c.destroyObjectProperties,f=c.extend,e=c.fireEvent,h=c.format,r=c.getMagnitude,E=c.merge,q=c.normalizeTickInterval,v=c.pick,k=c.removeEvent,t=c.seriesTypes,B=c.syncTimeout,I=c.Tick;n=function(){this.init.apply(this,arguments)};c.extend(n.prototype,{defaultOptions:{dateTimeLabelFormats:{millisecond:{main:"%H:%M:%S.%L",
	range:!1},second:{main:"%H:%M:%S",range:!1},minute:{main:"%H:%M",range:!1},hour:{main:"%H:%M",range:!1},day:{main:"%e. %b"},week:{main:"%e. %b"},month:{main:"%b '%y"},year:{main:"%Y"}},endOnTick:!1,labels:{enabled:!0,indentation:10,x:0,style:{color:"#666666",cursor:"default",fontSize:"11px"}},maxPadding:.01,minorTickLength:2,minorTickPosition:"outside",minPadding:.01,showEmpty:!0,startOfWeek:1,startOnTick:!1,tickLength:10,tickPixelInterval:100,tickmarkPlacement:"between",tickPosition:"outside",title:{align:"middle",
	style:{color:"#666666"}},type:"linear",minorGridLineColor:"#f2f2f2",minorGridLineWidth:1,minorTickColor:"#999999",lineColor:"#ccd6eb",lineWidth:1,gridLineColor:"#e6e6e6",tickColor:"#ccd6eb"},defaultYAxisOptions:{endOnTick:!0,maxPadding:.05,minPadding:.05,tickPixelInterval:72,showLastLabel:!0,labels:{x:-8},startOnTick:!0,title:{rotation:270,text:"Values"},stackLabels:{allowOverlap:!1,enabled:!1,crop:!0,overflow:"justify",formatter:function(){return c.numberFormat(this.total,-1)},style:{color:"#000000",
	fontSize:"11px",fontWeight:"bold",textOutline:"1px contrast"}},gridLineWidth:1,lineWidth:0},defaultLeftAxisOptions:{labels:{x:-15},title:{rotation:270}},defaultRightAxisOptions:{labels:{x:15},title:{rotation:90}},defaultBottomAxisOptions:{labels:{autoRotation:[-45],x:0},margin:15,title:{rotation:0}},defaultTopAxisOptions:{labels:{autoRotation:[-45],x:0},margin:15,title:{rotation:0}},init:function(a,b){var d=b.isX,l=this;l.chart=a;l.horiz=a.inverted&&!l.isZAxis?!d:d;l.isXAxis=d;l.coll=l.coll||(d?"xAxis":
	"yAxis");e(this,"init",{userOptions:b});l.opposite=b.opposite;l.side=b.side||(l.horiz?l.opposite?0:2:l.opposite?1:3);l.setOptions(b);var w=this.options,f=w.type;l.labelFormatter=w.labels.formatter||l.defaultLabelFormatter;l.userOptions=b;l.minPixelPadding=0;l.reversed=w.reversed;l.visible=!1!==w.visible;l.zoomEnabled=!1!==w.zoomEnabled;l.hasNames="category"===f||!0===w.categories;l.categories=w.categories||l.hasNames;l.names||(l.names=[],l.names.keys={});l.plotLinesAndBandsGroups={};l.isLog="logarithmic"===
	f;l.isDatetimeAxis="datetime"===f;l.positiveValuesOnly=l.isLog&&!l.allowNegativeLog;l.isLinked=A(w.linkedTo);l.ticks={};l.labelEdge=[];l.minorTicks={};l.plotLinesAndBands=[];l.alternateBands={};l.len=0;l.minRange=l.userMinRange=w.minRange||w.maxZoom;l.range=w.range;l.offset=w.offset||0;l.stacks={};l.oldStacks={};l.stacksTouched=0;l.max=null;l.min=null;l.crosshair=v(w.crosshair,L(a.options.tooltip.crosshairs)[d?0:1],!1);b=l.options.events;-1===a.axes.indexOf(l)&&(d?a.axes.splice(a.xAxis.length,0,l):
	a.axes.push(l),a[l.coll].push(l));l.series=l.series||[];a.inverted&&!l.isZAxis&&d&&void 0===l.reversed&&(l.reversed=!0);u(b,function(a,b){c.isFunction(a)&&y(l,b,a)});l.lin2log=w.linearToLogConverter||l.lin2log;l.isLog&&(l.val2lin=l.log2lin,l.lin2val=l.lin2log);e(this,"afterInit")},setOptions:function(a){this.options=E(this.defaultOptions,"yAxis"===this.coll&&this.defaultYAxisOptions,[this.defaultTopAxisOptions,this.defaultRightAxisOptions,this.defaultBottomAxisOptions,this.defaultLeftAxisOptions][this.side],
	E(b[this.coll],a));e(this,"afterSetOptions",{userOptions:a})},defaultLabelFormatter:function(){var a=this.axis,d=this.value,e=a.chart.time,f=a.categories,k=this.dateTimeLabelFormat,t=b.lang,B=t.numericSymbols;t=t.numericSymbolMagnitude||1E3;var r=B&&B.length,q=a.options.labels.format;a=a.isLog?Math.abs(d):a.tickInterval;if(q)var v=h(q,this,e);else if(f)v=d;else if(k)v=e.dateFormat(k,d);else if(r&&1E3<=a)for(;r--&&void 0===v;)e=Math.pow(t,r+1),a>=e&&0===10*d%e&&null!==B[r]&&0!==d&&(v=c.numberFormat(d/
	e,-1)+B[r]);void 0===v&&(v=1E4<=Math.abs(d)?c.numberFormat(d,-1):c.numberFormat(d,-1,void 0,""));return v},getSeriesExtremes:function(){var a=this,b=a.chart,d;e(this,"getSeriesExtremes",null,function(){a.hasVisibleSeries=!1;a.dataMin=a.dataMax=a.threshold=null;a.softThreshold=!a.isXAxis;a.buildStacks&&a.buildStacks();a.series.forEach(function(l){if(l.visible||!b.options.chart.ignoreHiddenSeries){var e=l.options,w=e.threshold;a.hasVisibleSeries=!0;a.positiveValuesOnly&&0>=w&&(w=null);if(a.isXAxis){if(e=
	l.xData,e.length){d=l.getXExtremes(e);var f=d.min;var c=d.max;F(f)||f instanceof Date||(e=e.filter(F),d=l.getXExtremes(e),f=d.min,c=d.max);e.length&&(a.dataMin=Math.min(v(a.dataMin,f),f),a.dataMax=Math.max(v(a.dataMax,c),c))}}else if(l.getExtremes(),c=l.dataMax,f=l.dataMin,A(f)&&A(c)&&(a.dataMin=Math.min(v(a.dataMin,f),f),a.dataMax=Math.max(v(a.dataMax,c),c)),A(w)&&(a.threshold=w),!e.softThreshold||a.positiveValuesOnly)a.softThreshold=!1}})});e(this,"afterGetSeriesExtremes")},translate:function(a,
	b,d,e,f,c){var l=this.linkedParent||this,w=1,k=0,t=e?l.oldTransA:l.transA;e=e?l.oldMin:l.min;var h=l.minPixelPadding;f=(l.isOrdinal||l.isBroken||l.isLog&&f)&&l.lin2val;t||(t=l.transA);d&&(w*=-1,k=l.len);l.reversed&&(w*=-1,k-=w*(l.sector||l.len));b?(a=(a*w+k-h)/t+e,f&&(a=l.lin2val(a))):(f&&(a=l.val2lin(a)),a=F(e)?w*(a-e)*t+k+w*h+(F(c)?t*c:0):void 0);return a},toPixels:function(a,b){return this.translate(a,!1,!this.horiz,null,!0)+(b?0:this.pos)},toValue:function(a,b){return this.translate(a-(b?0:this.pos),
	!0,!this.horiz,null,!0)},getPlotLinePath:function(a){var b=this,d=b.chart,f=b.left,w=b.top,c=a.old,k=a.value,t=a.translatedValue,h=a.lineWidth,B=a.force,r,q,I,m,g=c&&d.oldChartHeight||d.chartHeight,p=c&&d.oldChartWidth||d.chartWidth,E,x=b.transB,u=function(a,b,d){if("pass"!==B&&a<b||a>d)B?a=Math.min(Math.max(b,a),d):E=!0;return a};a={value:k,lineWidth:h,old:c,force:B,acrossPanes:a.acrossPanes,translatedValue:t};e(this,"getPlotLinePath",a,function(a){t=v(t,b.translate(k,null,null,c));t=Math.min(Math.max(-1E5,
	t),1E5);r=I=Math.round(t+x);q=m=Math.round(g-t-x);F(t)?b.horiz?(q=w,m=g-b.bottom,r=I=u(r,f,f+b.width)):(r=f,I=p-b.right,q=m=u(q,w,w+b.height)):(E=!0,B=!1);a.path=E&&!B?null:d.renderer.crispLine(["M",r,q,"L",I,m],h||1)});return a.path},getLinearTickPositions:function(a,b,d){var l=g(Math.floor(b/a)*a);d=g(Math.ceil(d/a)*a);var e=[],f;g(l+a)===l&&(f=20);if(this.single)return[b];for(b=l;b<=d;){e.push(b);b=g(b+a,f);if(b===w)break;var w=b}return e},getMinorTickInterval:function(){var a=this.options;return!0===
	a.minorTicks?v(a.minorTickInterval,"auto"):!1===a.minorTicks?null:a.minorTickInterval},getMinorTickPositions:function(){var a=this,b=a.options,d=a.tickPositions,e=a.minorTickInterval,f=[],c=a.pointRangePadding||0,k=a.min-c;c=a.max+c;var t=c-k;if(t&&t/e<a.len/3)if(a.isLog)this.paddedTicks.forEach(function(b,d,l){d&&f.push.apply(f,a.getLogTickPositions(e,l[d-1],l[d],!0))});else if(a.isDatetimeAxis&&"auto"===this.getMinorTickInterval())f=f.concat(a.getTimeTicks(a.normalizeTimeTickInterval(e),k,c,b.startOfWeek));
	else for(b=k+(d[0]-k)%e;b<=c&&b!==f[0];b+=e)f.push(b);0!==f.length&&a.trimTicks(f);return f},adjustForMinRange:function(){var a=this.options,b=this.min,d=this.max,e,f,c,k,t;this.isXAxis&&void 0===this.minRange&&!this.isLog&&(A(a.min)||A(a.max)?this.minRange=null:(this.series.forEach(function(a){k=a.xData;for(f=t=a.xIncrement?1:k.length-1;0<f;f--)if(c=k[f]-k[f-1],void 0===e||c<e)e=c}),this.minRange=Math.min(5*e,this.dataMax-this.dataMin)));if(d-b<this.minRange){var h=this.dataMax-this.dataMin>=this.minRange;
	var B=this.minRange;var r=(B-d+b)/2;r=[b-r,v(a.min,b-r)];h&&(r[2]=this.isLog?this.log2lin(this.dataMin):this.dataMin);b=x(r);d=[b+B,v(a.max,b+B)];h&&(d[2]=this.isLog?this.log2lin(this.dataMax):this.dataMax);d=m(d);d-b<B&&(r[0]=d-B,r[1]=v(a.min,d-B),b=x(r))}this.min=b;this.max=d},getClosest:function(){var a;this.categories?a=1:this.series.forEach(function(b){var d=b.closestPointRange,l=b.visible||!b.chart.options.chart.ignoreHiddenSeries;!b.noSharedTooltip&&A(d)&&l&&(a=A(a)?Math.min(a,d):d)});return a},
	nameToX:function(a){var b=D(this.categories),d=b?this.categories:this.names,e=a.options.x;a.series.requireSorting=!1;A(e)||(e=!1===this.options.uniqueNames?a.series.autoIncrement():b?d.indexOf(a.name):v(d.keys[a.name],-1));if(-1===e){if(!b)var f=d.length}else f=e;void 0!==f&&(this.names[f]=a.name,this.names.keys[a.name]=f);return f},updateNames:function(){var a=this,b=this.names;0<b.length&&(Object.keys(b.keys).forEach(function(a){delete b.keys[a]}),b.length=0,this.minRange=this.userMinRange,(this.series||
	[]).forEach(function(b){b.xIncrement=null;if(!b.points||b.isDirtyData)a.max=Math.max(a.max,b.xData.length-1),b.processData(),b.generatePoints();b.data.forEach(function(d,l){if(d&&d.options&&void 0!==d.name){var e=a.nameToX(d);void 0!==e&&e!==d.x&&(d.x=e,b.xData[l]=e)}})}))},setAxisTranslation:function(a){var b=this,d=b.max-b.min,f=b.axisPointRange||0,c=0,w=0,k=b.linkedParent,h=!!b.categories,B=b.transA,r=b.isXAxis;if(r||h||f){var q=b.getClosest();k?(c=k.minPointOffset,w=k.pointRangePadding):b.series.forEach(function(a){var d=
	h?1:r?v(a.options.pointRange,q,0):b.axisPointRange||0,l=a.options.pointPlacement;f=Math.max(f,d);if(!b.single||h)a=t.xrange&&a instanceof t.xrange?!r:r,c=Math.max(c,a&&z(l)?0:d/2),w=Math.max(w,a&&"on"===l?0:d)});k=b.ordinalSlope&&q?b.ordinalSlope/q:1;b.minPointOffset=c*=k;b.pointRangePadding=w*=k;b.pointRange=Math.min(f,d);r&&(b.closestPointRange=q)}a&&(b.oldTransA=B);b.translationSlope=b.transA=B=b.staticScale||b.len/(d+w||1);b.transB=b.horiz?b.left:b.bottom;b.minPixelPadding=B*c;e(this,"afterSetAxisTranslation")},
	minFromRange:function(){return this.max-this.range},setTickInterval:function(a){var b=this,d=b.chart,f=b.options,w=b.isLog,k=b.isDatetimeAxis,t=b.isXAxis,h=b.isLinked,B=f.maxPadding,I=f.minPadding,m=f.tickInterval,p=f.tickPixelInterval,E=b.categories,x=F(b.threshold)?b.threshold:null,u=b.softThreshold;k||E||h||this.getTickAmount();var z=v(b.userMin,f.min);var y=v(b.userMax,f.max);if(h){b.linkedParent=d[b.coll][f.linkedTo];var n=b.linkedParent.getExtremes();b.min=v(n.min,n.dataMin);b.max=v(n.max,n.dataMax);
	f.type!==b.linkedParent.options.type&&c.error(11,1,d)}else{if(!u&&A(x))if(b.dataMin>=x)n=x,I=0;else if(b.dataMax<=x){var L=x;B=0}b.min=v(z,n,b.dataMin);b.max=v(y,L,b.dataMax)}w&&(b.positiveValuesOnly&&!a&&0>=Math.min(b.min,v(b.dataMin,b.min))&&c.error(10,1,d),b.min=g(b.log2lin(b.min),15),b.max=g(b.log2lin(b.max),15));b.range&&A(b.max)&&(b.userMin=b.min=z=Math.max(b.dataMin,b.minFromRange()),b.userMax=y=b.max,b.range=null);e(b,"foundExtremes");b.beforePadding&&b.beforePadding();b.adjustForMinRange();
	!(E||b.axisPointRange||b.usePercentage||h)&&A(b.min)&&A(b.max)&&(d=b.max-b.min)&&(!A(z)&&I&&(b.min-=d*I),!A(y)&&B&&(b.max+=d*B));F(f.softMin)&&!F(b.userMin)&&f.softMin<b.min&&(b.min=z=f.softMin);F(f.softMax)&&!F(b.userMax)&&f.softMax>b.max&&(b.max=y=f.softMax);F(f.floor)&&(b.min=Math.min(Math.max(b.min,f.floor),Number.MAX_VALUE));F(f.ceiling)&&(b.max=Math.max(Math.min(b.max,f.ceiling),v(b.userMax,-Number.MAX_VALUE)));u&&A(b.dataMin)&&(x=x||0,!A(z)&&b.min<x&&b.dataMin>=x?b.min=b.options.minRange?Math.min(x,
	b.max-b.minRange):x:!A(y)&&b.max>x&&b.dataMax<=x&&(b.max=b.options.minRange?Math.max(x,b.min+b.minRange):x));b.tickInterval=b.min===b.max||void 0===b.min||void 0===b.max?1:h&&!m&&p===b.linkedParent.options.tickPixelInterval?m=b.linkedParent.tickInterval:v(m,this.tickAmount?(b.max-b.min)/Math.max(this.tickAmount-1,1):void 0,E?1:(b.max-b.min)*p/Math.max(b.len,p));t&&!a&&b.series.forEach(function(a){a.processData(b.min!==b.oldMin||b.max!==b.oldMax)});b.setAxisTranslation(!0);b.beforeSetTickPositions&&
	b.beforeSetTickPositions();b.postProcessTickInterval&&(b.tickInterval=b.postProcessTickInterval(b.tickInterval));b.pointRange&&!m&&(b.tickInterval=Math.max(b.pointRange,b.tickInterval));a=v(f.minTickInterval,b.isDatetimeAxis&&b.closestPointRange);!m&&b.tickInterval<a&&(b.tickInterval=a);k||w||m||(b.tickInterval=q(b.tickInterval,null,r(b.tickInterval),v(f.allowDecimals,!(.5<b.tickInterval&&5>b.tickInterval&&1E3<b.max&&9999>b.max)),!!this.tickAmount));this.tickAmount||(b.tickInterval=b.unsquish());
	this.setTickPositions()},setTickPositions:function(){var a=this.options,b=a.tickPositions;var d=this.getMinorTickInterval();var f=a.tickPositioner,k=a.startOnTick,t=a.endOnTick;this.tickmarkOffset=this.categories&&"between"===a.tickmarkPlacement&&1===this.tickInterval?.5:0;this.minorTickInterval="auto"===d&&this.tickInterval?this.tickInterval/5:d;this.single=this.min===this.max&&A(this.min)&&!this.tickAmount&&(parseInt(this.min,10)===this.min||!1!==a.allowDecimals);this.tickPositions=d=b&&b.slice();
	!d&&(!this.ordinalPositions&&(this.max-this.min)/this.tickInterval>Math.max(2*this.len,200)?(d=[this.min,this.max],c.error(19,!1,this.chart)):d=this.isDatetimeAxis?this.getTimeTicks(this.normalizeTimeTickInterval(this.tickInterval,a.units),this.min,this.max,a.startOfWeek,this.ordinalPositions,this.closestPointRange,!0):this.isLog?this.getLogTickPositions(this.tickInterval,this.min,this.max):this.getLinearTickPositions(this.tickInterval,this.min,this.max),d.length>this.len&&(d=[d[0],d.pop()],d[0]===
	d[1]&&(d.length=1)),this.tickPositions=d,f&&(f=f.apply(this,[this.min,this.max])))&&(this.tickPositions=d=f);this.paddedTicks=d.slice(0);this.trimTicks(d,k,t);this.isLinked||(this.single&&2>d.length&&!this.categories&&(this.min-=.5,this.max+=.5),b||f||this.adjustTickAmount());e(this,"afterSetTickPositions")},trimTicks:function(a,b,d){var f=a[0],c=a[a.length-1],l=this.minPointOffset||0;e(this,"trimTicks");if(!this.isLinked){if(b&&-Infinity!==f)this.min=f;else for(;this.min-l>a[0];)a.shift();if(d)this.max=
	c;else for(;this.max+l<a[a.length-1];)a.pop();0===a.length&&A(f)&&!this.options.tickPositions&&a.push((c+f)/2)}},alignToOthers:function(){var a={},b,d=this.options;!1===this.chart.options.chart.alignTicks||!1===d.alignTicks||!1===d.startOnTick||!1===d.endOnTick||this.isLog||this.chart[this.coll].forEach(function(d){var f=d.options;f=[d.horiz?f.left:f.top,f.width,f.height,f.pane].join();d.series.length&&(a[f]?b=!0:a[f]=1)});return b},getTickAmount:function(){var a=this.options,b=a.tickAmount,d=a.tickPixelInterval;
	!A(a.tickInterval)&&this.len<d&&!this.isRadial&&!this.isLog&&a.startOnTick&&a.endOnTick&&(b=2);!b&&this.alignToOthers()&&(b=Math.ceil(this.len/d)+1);4>b&&(this.finalTickAmt=b,b=5);this.tickAmount=b},adjustTickAmount:function(){var a=this.options,b=this.tickInterval,d=this.tickPositions,f=this.tickAmount,e=this.finalTickAmt,c=d&&d.length,k=v(this.threshold,this.softThreshold?0:null),t;if(this.hasData()){if(c<f){for(t=this.min;d.length<f;)d.length%2||t===k?d.push(g(d[d.length-1]+b)):d.unshift(g(d[0]-
	b));this.transA*=(c-1)/(f-1);this.min=a.startOnTick?d[0]:Math.min(this.min,d[0]);this.max=a.endOnTick?d[d.length-1]:Math.max(this.max,d[d.length-1])}else c>f&&(this.tickInterval*=2,this.setTickPositions());if(A(e)){for(b=a=d.length;b--;)(3===e&&1===b%2||2>=e&&0<b&&b<a-1)&&d.splice(b,1);this.finalTickAmt=void 0}}},setScale:function(){var a=this.series.some(function(a){return a.isDirtyData||a.isDirty||a.xAxis&&a.xAxis.isDirty}),b;this.oldMin=this.min;this.oldMax=this.max;this.oldAxisLength=this.len;
	this.setAxisSize();(b=this.len!==this.oldAxisLength)||a||this.isLinked||this.forceRedraw||this.userMin!==this.oldUserMin||this.userMax!==this.oldUserMax||this.alignToOthers()?(this.resetStacks&&this.resetStacks(),this.forceRedraw=!1,this.getSeriesExtremes(),this.setTickInterval(),this.oldUserMin=this.userMin,this.oldUserMax=this.userMax,this.isDirty||(this.isDirty=b||this.min!==this.oldMin||this.max!==this.oldMax)):this.cleanStacks&&this.cleanStacks();e(this,"afterSetScale")},setExtremes:function(a,
	b,d,c,k){var l=this,w=l.chart;d=v(d,!0);l.series.forEach(function(a){delete a.kdTree});k=f(k,{min:a,max:b});e(l,"setExtremes",k,function(){l.userMin=a;l.userMax=b;l.eventArgs=k;d&&w.redraw(c)})},zoom:function(a,b){var d=this.dataMin,f=this.dataMax,c=this.options,k=Math.min(d,v(c.min,d)),l=Math.max(f,v(c.max,f));a={newMin:a,newMax:b};e(this,"zoom",a,function(a){var b=a.newMin,e=a.newMax;if(b!==this.min||e!==this.max)this.allowZoomOutside||(A(d)&&(b<k&&(b=k),b>l&&(b=l)),A(f)&&(e<k&&(e=k),e>l&&(e=l))),
	this.displayBtn=void 0!==b||void 0!==e,this.setExtremes(b,e,!1,void 0,{trigger:"zoom"});a.zoomed=!0});return a.zoomed},setAxisSize:function(){var a=this.chart,b=this.options,d=b.offsets||[0,0,0,0],f=this.horiz,e=this.width=Math.round(c.relativeLength(v(b.width,a.plotWidth-d[3]+d[1]),a.plotWidth)),k=this.height=Math.round(c.relativeLength(v(b.height,a.plotHeight-d[0]+d[2]),a.plotHeight)),t=this.top=Math.round(c.relativeLength(v(b.top,a.plotTop+d[0]),a.plotHeight,a.plotTop));b=this.left=Math.round(c.relativeLength(v(b.left,
	a.plotLeft+d[3]),a.plotWidth,a.plotLeft));this.bottom=a.chartHeight-k-t;this.right=a.chartWidth-e-b;this.len=Math.max(f?e:k,0);this.pos=f?b:t},getExtremes:function(){var a=this.isLog;return{min:a?g(this.lin2log(this.min)):this.min,max:a?g(this.lin2log(this.max)):this.max,dataMin:this.dataMin,dataMax:this.dataMax,userMin:this.userMin,userMax:this.userMax}},getThreshold:function(a){var b=this.isLog,d=b?this.lin2log(this.min):this.min;b=b?this.lin2log(this.max):this.max;null===a||-Infinity===a?a=d:Infinity===
	a?a=b:d>a?a=d:b<a&&(a=b);return this.translate(a,0,1,0,1)},autoLabelAlign:function(a){var b=(v(a,0)-90*this.side+720)%360;a={align:"center"};e(this,"autoLabelAlign",a,function(a){15<b&&165>b?a.align="right":195<b&&345>b&&(a.align="left")});return a.align},tickSize:function(a){var b=this.options,d=b[a+"Length"],f=v(b[a+"Width"],"tick"===a&&this.isXAxis&&!this.categories?1:0);if(f&&d){"inside"===b[a+"Position"]&&(d=-d);var c=[d,f]}a={tickSize:c};e(this,"afterTickSize",a);return a.tickSize},labelMetrics:function(){var a=
	this.tickPositions&&this.tickPositions[0]||0;return this.chart.renderer.fontMetrics(this.options.labels.style&&this.options.labels.style.fontSize,this.ticks[a]&&this.ticks[a].label)},unsquish:function(){var b=this.options.labels,d=this.horiz,f=this.tickInterval,e=f,c=this.len/(((this.categories?1:0)+this.max-this.min)/f),k,t=b.rotation,h=this.labelMetrics(),B,r=Number.MAX_VALUE,q,I=this.max-this.min,m=function(a){var b=a/(c||1);b=1<b?Math.ceil(b):1;b*f>I&&Infinity!==a&&Infinity!==c&&I&&(b=Math.ceil(I/
	f));return g(b*f)};d?(q=!b.staggerLines&&!b.step&&(A(t)?[t]:c<v(b.autoRotationLimit,80)&&b.autoRotation))&&q.forEach(function(b){if(b===t||b&&-90<=b&&90>=b){B=m(Math.abs(h.h/Math.sin(a*b)));var d=B+Math.abs(b/360);d<r&&(r=d,k=b,e=B)}}):b.step||(e=m(h.h));this.autoRotation=q;this.labelRotation=v(k,t);return e},getSlotWidth:function(a){var b=this.chart,d=this.horiz,f=this.options.labels,e=Math.max(this.tickPositions.length-(this.categories?0:1),1),c=b.margin[3];return a&&a.slotWidth||d&&2>(f.step||
	0)&&!f.rotation&&(this.staggerLines||1)*this.len/e||!d&&(f.style&&parseInt(f.style.width,10)||c&&c-b.spacing[3]||.33*b.chartWidth)},renderUnsquish:function(){var a=this.chart,b=a.renderer,d=this.tickPositions,f=this.ticks,e=this.options.labels,c=e&&e.style||{},k=this.horiz,t=this.getSlotWidth(),h=Math.max(1,Math.round(t-2*(e.padding||5))),B={},r=this.labelMetrics(),q=e.style&&e.style.textOverflow,v=0;z(e.rotation)||(B.rotation=e.rotation||0);d.forEach(function(a){(a=f[a])&&a.label&&a.label.textPxLength>
	v&&(v=a.label.textPxLength)});this.maxLabelLength=v;if(this.autoRotation)v>h&&v>r.h?B.rotation=this.labelRotation:this.labelRotation=0;else if(t){var I=h;if(!q){var m="clip";for(h=d.length;!k&&h--;){var g=d[h];if(g=f[g].label)g.styles&&"ellipsis"===g.styles.textOverflow?g.css({textOverflow:"clip"}):g.textPxLength>t&&g.css({width:t+"px"}),g.getBBox().height>this.len/d.length-(r.h-r.f)&&(g.specificTextOverflow="ellipsis")}}}B.rotation&&(I=v>.5*a.chartHeight?.33*a.chartHeight:v,q||(m="ellipsis"));if(this.labelAlign=
	e.align||this.autoLabelAlign(this.labelRotation))B.align=this.labelAlign;d.forEach(function(a){var b=(a=f[a])&&a.label,d=c.width,e={};b&&(b.attr(B),a.shortenLabel?a.shortenLabel():I&&!d&&"nowrap"!==c.whiteSpace&&(I<b.textPxLength||"SPAN"===b.element.tagName)?(e.width=I,q||(e.textOverflow=b.specificTextOverflow||m),b.css(e)):b.styles&&b.styles.width&&!e.width&&!d&&b.css({width:null}),delete b.specificTextOverflow,a.rotation=B.rotation)},this);this.tickRotCorr=b.rotCorr(r.b,this.labelRotation||0,0!==
	this.side)},hasData:function(){return this.series.some(function(a){return a.hasData()})||this.options.showEmpty&&A(this.min)&&A(this.max)},addTitle:function(a){var b=this.chart.renderer,d=this.horiz,f=this.opposite,e=this.options.title,c,k=this.chart.styledMode;this.axisTitle||((c=e.textAlign)||(c=(d?{low:"left",middle:"center",high:"right"}:{low:f?"right":"left",middle:"center",high:f?"left":"right"})[e.align]),this.axisTitle=b.text(e.text,0,0,e.useHTML).attr({zIndex:7,rotation:e.rotation||0,align:c}).addClass("highcharts-axis-title"),
	k||this.axisTitle.css(E(e.style)),this.axisTitle.add(this.axisGroup),this.axisTitle.isNew=!0);k||e.style.width||this.isRadial||this.axisTitle.css({width:this.len});this.axisTitle[a?"show":"hide"](a)},generateTick:function(a){var b=this.ticks;b[a]?b[a].addLabel():b[a]=new I(this,a)},getOffset:function(){var a=this,b=a.chart,d=b.renderer,f=a.options,c=a.tickPositions,k=a.ticks,t=a.horiz,h=a.side,B=b.inverted&&!a.isZAxis?[1,0,3,2][h]:h,r,q=0,I=0,m=f.title,g=f.labels,p=0,E=b.axisOffset;b=b.clipOffset;
	var x=[-1,1,1,-1][h],z=f.className,y=a.axisParent;var n=a.hasData();a.showAxis=r=n||v(f.showEmpty,!0);a.staggerLines=a.horiz&&g.staggerLines;a.axisGroup||(a.gridGroup=d.g("grid").attr({zIndex:f.gridZIndex||1}).addClass("highcharts-"+this.coll.toLowerCase()+"-grid "+(z||"")).add(y),a.axisGroup=d.g("axis").attr({zIndex:f.zIndex||2}).addClass("highcharts-"+this.coll.toLowerCase()+" "+(z||"")).add(y),a.labelGroup=d.g("axis-labels").attr({zIndex:g.zIndex||7}).addClass("highcharts-"+a.coll.toLowerCase()+
	"-labels "+(z||"")).add(y));n||a.isLinked?(c.forEach(function(b,d){a.generateTick(b,d)}),a.renderUnsquish(),a.reserveSpaceDefault=0===h||2===h||{1:"left",3:"right"}[h]===a.labelAlign,v(g.reserveSpace,"center"===a.labelAlign?!0:null,a.reserveSpaceDefault)&&c.forEach(function(a){p=Math.max(k[a].getLabelSize(),p)}),a.staggerLines&&(p*=a.staggerLines),a.labelOffset=p*(a.opposite?-1:1)):u(k,function(a,b){a.destroy();delete k[b]});if(m&&m.text&&!1!==m.enabled&&(a.addTitle(r),r&&!1!==m.reserveSpace)){a.titleOffset=
	q=a.axisTitle.getBBox()[t?"height":"width"];var L=m.offset;I=A(L)?0:v(m.margin,t?5:10)}a.renderLine();a.offset=x*v(f.offset,E[h]?E[h]+(f.margin||0):0);a.tickRotCorr=a.tickRotCorr||{x:0,y:0};d=0===h?-a.labelMetrics().h:2===h?a.tickRotCorr.y:0;I=Math.abs(p)+I;p&&(I=I-d+x*(t?v(g.y,a.tickRotCorr.y+8*x):g.x));a.axisTitleMargin=v(L,I);a.getMaxLabelDimensions&&(a.maxLabelDimensions=a.getMaxLabelDimensions(k,c));t=this.tickSize("tick");E[h]=Math.max(E[h],a.axisTitleMargin+q+x*a.offset,I,c&&c.length&&t?t[0]+
	x*a.offset:0);f=f.offset?0:2*Math.floor(a.axisLine.strokeWidth()/2);b[B]=Math.max(b[B],f);e(this,"afterGetOffset")},getLinePath:function(a){var b=this.chart,d=this.opposite,f=this.offset,e=this.horiz,c=this.left+(d?this.width:0)+f;f=b.chartHeight-this.bottom-(d?this.height:0)+f;d&&(a*=-1);return b.renderer.crispLine(["M",e?this.left:c,e?f:this.top,"L",e?b.chartWidth-this.right:c,e?f:b.chartHeight-this.bottom],a)},renderLine:function(){this.axisLine||(this.axisLine=this.chart.renderer.path().addClass("highcharts-axis-line").add(this.axisGroup),
	this.chart.styledMode||this.axisLine.attr({stroke:this.options.lineColor,"stroke-width":this.options.lineWidth,zIndex:7}))},getTitlePosition:function(){var a=this.horiz,b=this.left,d=this.top,f=this.len,c=this.options.title,k=a?b:d,t=this.opposite,h=this.offset,B=c.x||0,r=c.y||0,q=this.axisTitle,v=this.chart.renderer.fontMetrics(c.style&&c.style.fontSize,q);q=Math.max(q.getBBox(null,0).height-v.h-1,0);f={low:k+(a?0:f),middle:k+f/2,high:k+(a?f:0)}[c.align];b=(a?d+this.height:b)+(a?1:-1)*(t?-1:1)*this.axisTitleMargin+
	[-q,q,v.f,-q][this.side];a={x:a?f+B:b+(t?this.width:0)+h+B,y:a?b+r-(t?this.height:0)+h:f+r};e(this,"afterGetTitlePosition",{titlePosition:a});return a},renderMinorTick:function(a){var b=this.chart.hasRendered&&F(this.oldMin),d=this.minorTicks;d[a]||(d[a]=new I(this,a,"minor"));b&&d[a].isNew&&d[a].render(null,!0);d[a].render(null,!1,1)},renderTick:function(a,b){var d=this.isLinked,f=this.ticks,e=this.chart.hasRendered&&F(this.oldMin);if(!d||a>=this.min&&a<=this.max)f[a]||(f[a]=new I(this,a)),e&&f[a].isNew&&
	f[a].render(b,!0,-1),f[a].render(b)},render:function(){var a=this,b=a.chart,d=a.options,f=a.isLog,k=a.isLinked,t=a.tickPositions,h=a.axisTitle,r=a.ticks,q=a.minorTicks,v=a.alternateBands,m=d.stackLabels,g=d.alternateGridColor,p=a.tickmarkOffset,E=a.axisLine,x=a.showAxis,z=C(b.renderer.globalAnimation),y,n;a.labelEdge.length=0;a.overlap=!1;[r,q,v].forEach(function(a){u(a,function(a){a.isActive=!1})});if(a.hasData()||k)a.minorTickInterval&&!a.categories&&a.getMinorTickPositions().forEach(function(b){a.renderMinorTick(b)}),
	t.length&&(t.forEach(function(b,d){a.renderTick(b,d)}),p&&(0===a.min||a.single)&&(r[-1]||(r[-1]=new I(a,-1,null,!0)),r[-1].render(-1))),g&&t.forEach(function(d,e){n=void 0!==t[e+1]?t[e+1]+p:a.max-p;0===e%2&&d<a.max&&n<=a.max+(b.polar?-p:p)&&(v[d]||(v[d]=new c.PlotLineOrBand(a)),y=d+p,v[d].options={from:f?a.lin2log(y):y,to:f?a.lin2log(n):n,color:g},v[d].render(),v[d].isActive=!0)}),a._addedPlotLB||((d.plotLines||[]).concat(d.plotBands||[]).forEach(function(b){a.addPlotBandOrLine(b)}),a._addedPlotLB=
	!0);[r,q,v].forEach(function(a){var d,f=[],e=z.duration;u(a,function(a,b){a.isActive||(a.render(b,!1,0),a.isActive=!1,f.push(b))});B(function(){for(d=f.length;d--;)a[f[d]]&&!a[f[d]].isActive&&(a[f[d]].destroy(),delete a[f[d]])},a!==v&&b.hasRendered&&e?e:0)});E&&(E[E.isPlaced?"animate":"attr"]({d:this.getLinePath(E.strokeWidth())}),E.isPlaced=!0,E[x?"show":"hide"](x));h&&x&&(d=a.getTitlePosition(),F(d.y)?(h[h.isNew?"attr":"animate"](d),h.isNew=!1):(h.attr("y",-9999),h.isNew=!0));m&&m.enabled&&a.renderStackTotals();
	a.isDirty=!1;e(this,"afterRender")},redraw:function(){this.visible&&(this.render(),this.plotLinesAndBands.forEach(function(a){a.render()}));this.series.forEach(function(a){a.isDirty=!0})},keepProps:"extKey hcEvents names series userMax userMin".split(" "),destroy:function(a){var b=this,f=b.stacks,c=b.plotLinesAndBands,t;e(this,"destroy",{keepEvents:a});a||k(b);u(f,function(a,b){d(a);f[b]=null});[b.ticks,b.minorTicks,b.alternateBands].forEach(function(a){d(a)});if(c)for(a=c.length;a--;)c[a].destroy();
	"stackTotalGroup axisLine axisTitle axisGroup gridGroup labelGroup cross scrollbar".split(" ").forEach(function(a){b[a]&&(b[a]=b[a].destroy())});for(t in b.plotLinesAndBandsGroups)b.plotLinesAndBandsGroups[t]=b.plotLinesAndBandsGroups[t].destroy();u(b,function(a,d){-1===b.keepProps.indexOf(d)&&delete b[d]})},drawCrosshair:function(a,b){var d,f=this.crosshair,c=v(f.snap,!0),k,l=this.cross;e(this,"drawCrosshair",{e:a,point:b});a||(a=this.cross&&this.cross.e);if(this.crosshair&&!1!==(A(b)||!c)){c?A(b)&&
	(k=v("colorAxis"!==this.coll?b.crosshairPos:null,this.isXAxis?b.plotX:this.len-b.plotY)):k=a&&(this.horiz?a.chartX-this.pos:this.len-a.chartY+this.pos);A(k)&&(d=this.getPlotLinePath({value:b&&(this.isXAxis?b.x:v(b.stackY,b.y)),translatedValue:k})||null);if(!A(d)){this.hideCrosshair();return}c=this.categories&&!this.isRadial;l||(this.cross=l=this.chart.renderer.path().addClass("highcharts-crosshair highcharts-crosshair-"+(c?"category ":"thin ")+f.className).attr({zIndex:v(f.zIndex,2)}).add(),this.chart.styledMode||
	(l.attr({stroke:f.color||(c?p("#ccd6eb").setOpacity(.25).get():"#cccccc"),"stroke-width":v(f.width,1)}).css({"pointer-events":"none"}),f.dashStyle&&l.attr({dashstyle:f.dashStyle})));l.show().attr({d:d});c&&!f.width&&l.attr({"stroke-width":this.transA});this.cross.e=a}else this.hideCrosshair();e(this,"afterDrawCrosshair",{e:a,point:b})},hideCrosshair:function(){this.cross&&this.cross.hide();e(this,"afterHideCrosshair")}});return c.Axis=n});N(H,"parts/DateTimeAxis.js",[H["parts/Globals.js"]],function(c){var n=
	c.Axis,A=c.getMagnitude,D=c.normalizeTickInterval,F=c.timeUnits;n.prototype.getTimeTicks=function(){return this.chart.time.getTimeTicks.apply(this.chart.time,arguments)};n.prototype.normalizeTimeTickInterval=function(c,u){var z=u||[["millisecond",[1,2,5,10,20,25,50,100,200,500]],["second",[1,2,5,10,15,30]],["minute",[1,2,5,10,15,30]],["hour",[1,2,3,4,6,8,12]],["day",[1,2]],["week",[1,2]],["month",[1,2,3,4,6]],["year",null]];u=z[z.length-1];var y=F[u[0]],n=u[1],x;for(x=0;x<z.length&&!(u=z[x],y=F[u[0]],
	n=u[1],z[x+1]&&c<=(y*n[n.length-1]+F[z[x+1][0]])/2);x++);y===F.year&&c<5*y&&(n=[1,2,5]);c=D(c/y,n,"year"===u[0]?Math.max(A(c/y),1):1);return{unitRange:y,count:c,unitName:u[0]}}});N(H,"parts/LogarithmicAxis.js",[H["parts/Globals.js"]],function(c){var n=c.Axis,A=c.getMagnitude,D=c.normalizeTickInterval,F=c.pick;n.prototype.getLogTickPositions=function(c,u,n,y){var z=this.options,x=this.len,m=[];y||(this._minorAutoInterval=null);if(.5<=c)c=Math.round(c),m=this.getLinearTickPositions(c,u,n);else if(.08<=
	c){x=Math.floor(u);var p,g;for(z=.3<c?[1,2,4]:.15<c?[1,2,4,6,8]:[1,2,3,4,5,6,7,8,9];x<n+1&&!g;x++){var b=z.length;for(p=0;p<b&&!g;p++){var a=this.log2lin(this.lin2log(x)*z[p]);a>u&&(!y||d<=n)&&void 0!==d&&m.push(d);d>n&&(g=!0);var d=a}}}else u=this.lin2log(u),n=this.lin2log(n),c=y?this.getMinorTickInterval():z.tickInterval,c=F("auto"===c?null:c,this._minorAutoInterval,z.tickPixelInterval/(y?5:1)*(n-u)/((y?x/this.tickPositions.length:x)||1)),c=D(c,null,A(c)),m=this.getLinearTickPositions(c,u,n).map(this.log2lin),
	y||(this._minorAutoInterval=c/5);y||(this.tickInterval=c);return m};n.prototype.log2lin=function(c){return Math.log(c)/Math.LN10};n.prototype.lin2log=function(c){return Math.pow(10,c)}});N(H,"parts/PlotLineOrBand.js",[H["parts/Globals.js"],H["parts/Axis.js"],H["parts/Utilities.js"]],function(c,n,A){var D=A.defined,F=A.erase,z=A.objectEach,u=c.arrayMax,L=c.arrayMin,y=c.destroyObjectProperties,C=c.merge,x=c.pick;c.PlotLineOrBand=function(c,p){this.axis=c;p&&(this.options=p,this.id=p.id)};c.PlotLineOrBand.prototype=
	{render:function(){c.fireEvent(this,"render");var m=this,p=m.axis,g=p.horiz,b=m.options,a=b.label,d=m.label,f=b.to,e=b.from,h=b.value,r=D(e)&&D(f),E=D(h),q=m.svgElem,v=!q,k=[],t=b.color,B=x(b.zIndex,0),I=b.events;k={"class":"highcharts-plot-"+(r?"band ":"line ")+(b.className||"")};var w={},l=p.chart.renderer,J=r?"bands":"lines";p.isLog&&(e=p.log2lin(e),f=p.log2lin(f),h=p.log2lin(h));p.chart.styledMode||(E?(k.stroke=t||"#999999",k["stroke-width"]=x(b.width,1),b.dashStyle&&(k.dashstyle=b.dashStyle)):
	r&&(k.fill=t||"#e6ebf5",b.borderWidth&&(k.stroke=b.borderColor,k["stroke-width"]=b.borderWidth)));w.zIndex=B;J+="-"+B;(t=p.plotLinesAndBandsGroups[J])||(p.plotLinesAndBandsGroups[J]=t=l.g("plot-"+J).attr(w).add());v&&(m.svgElem=q=l.path().attr(k).add(t));if(E)k=p.getPlotLinePath({value:h,lineWidth:q.strokeWidth(),acrossPanes:b.acrossPanes});else if(r)k=p.getPlotBandPath(e,f,b);else return;(v||!q.d)&&k&&k.length?(q.attr({d:k}),I&&z(I,function(a,b){q.on(b,function(a){I[b].apply(m,[a])})})):q&&(k?(q.show(!0),
	q.animate({d:k})):q.d&&(q.hide(),d&&(m.label=d=d.destroy())));a&&(D(a.text)||D(a.formatter))&&k&&k.length&&0<p.width&&0<p.height&&!k.isFlat?(a=C({align:g&&r&&"center",x:g?!r&&4:10,verticalAlign:!g&&r&&"middle",y:g?r?16:10:r?6:-4,rotation:g&&!r&&90},a),this.renderLabel(a,k,r,B)):d&&d.hide();return m},renderLabel:function(c,p,g,b){var a=this.label,d=this.axis.chart.renderer;a||(a={align:c.textAlign||c.align,rotation:c.rotation,"class":"highcharts-plot-"+(g?"band":"line")+"-label "+(c.className||"")},
	a.zIndex=b,b=this.getLabelText(c),this.label=a=d.text(b,0,0,c.useHTML).attr(a).add(),this.axis.chart.styledMode||a.css(c.style));d=p.xBounds||[p[1],p[4],g?p[6]:p[1]];p=p.yBounds||[p[2],p[5],g?p[7]:p[2]];g=L(d);b=L(p);a.align(c,!1,{x:g,y:b,width:u(d)-g,height:u(p)-b});a.show(!0)},getLabelText:function(c){return D(c.formatter)?c.formatter.call(this):c.text},destroy:function(){F(this.axis.plotLinesAndBands,this);delete this.axis;y(this)}};c.extend(n.prototype,{getPlotBandPath:function(c,p){var g=this.getPlotLinePath({value:p,
	force:!0,acrossPanes:this.options.acrossPanes}),b=this.getPlotLinePath({value:c,force:!0,acrossPanes:this.options.acrossPanes}),a=[],d=this.horiz,f=1;c=c<this.min&&p<this.min||c>this.max&&p>this.max;if(b&&g){if(c){var e=b.toString()===g.toString();f=0}for(c=0;c<b.length;c+=6)d&&g[c+1]===b[c+1]?(g[c+1]+=f,g[c+4]+=f):d||g[c+2]!==b[c+2]||(g[c+2]+=f,g[c+5]+=f),a.push("M",b[c+1],b[c+2],"L",b[c+4],b[c+5],g[c+4],g[c+5],g[c+1],g[c+2],"z"),a.isFlat=e}return a},addPlotBand:function(c){return this.addPlotBandOrLine(c,
	"plotBands")},addPlotLine:function(c){return this.addPlotBandOrLine(c,"plotLines")},addPlotBandOrLine:function(m,p){var g=(new c.PlotLineOrBand(this,m)).render(),b=this.userOptions;if(g){if(p){var a=b[p]||[];a.push(m);b[p]=a}this.plotLinesAndBands.push(g)}return g},removePlotBandOrLine:function(c){for(var m=this.plotLinesAndBands,g=this.options,b=this.userOptions,a=m.length;a--;)m[a].id===c&&m[a].destroy();[g.plotLines||[],b.plotLines||[],g.plotBands||[],b.plotBands||[]].forEach(function(b){for(a=
	b.length;a--;)b[a].id===c&&F(b,b[a])})},removePlotBand:function(c){this.removePlotBandOrLine(c)},removePlotLine:function(c){this.removePlotBandOrLine(c)}})});N(H,"parts/Tooltip.js",[H["parts/Globals.js"],H["parts/Utilities.js"]],function(c,n){var A=n.defined,D=n.isNumber,F=n.isString,z=n.splat;"";var u=c.doc,L=c.extend,y=c.format,C=c.merge,x=c.pick,m=c.syncTimeout,p=c.timeUnits;c.Tooltip=function(){this.init.apply(this,arguments)};c.Tooltip.prototype={init:function(c,b){this.chart=c;this.options=
	b;this.crosshairs=[];this.now={x:0,y:0};this.isHidden=!0;this.split=b.split&&!c.inverted;this.shared=b.shared||this.split;this.outside=x(b.outside,!(!c.scrollablePixelsX&&!c.scrollablePixelsY))&&!this.split},cleanSplit:function(c){this.chart.series.forEach(function(b){var a=b&&b.tt;a&&(!a.isActive||c?b.tt=a.destroy():a.isActive=!1)})},applyFilter:function(){var c=this.chart;c.renderer.definition({tagName:"filter",id:"drop-shadow-"+c.index,opacity:.5,children:[{tagName:"feGaussianBlur","in":"SourceAlpha",
	stdDeviation:1},{tagName:"feOffset",dx:1,dy:1},{tagName:"feComponentTransfer",children:[{tagName:"feFuncA",type:"linear",slope:.3}]},{tagName:"feMerge",children:[{tagName:"feMergeNode"},{tagName:"feMergeNode","in":"SourceGraphic"}]}]});c.renderer.definition({tagName:"style",textContent:".highcharts-tooltip-"+c.index+"{filter:url(#drop-shadow-"+c.index+")}"})},getLabel:function(){var g=this,b=this.chart.renderer,a=this.chart.styledMode,d=this.options,f="tooltip"+(A(d.className)?" "+d.className:""),
	e;if(!this.label){this.outside&&(this.container=e=c.doc.createElement("div"),e.className="highcharts-tooltip-container",c.css(e,{position:"absolute",top:"1px",pointerEvents:d.style&&d.style.pointerEvents,zIndex:3}),c.doc.body.appendChild(e),this.renderer=b=new c.Renderer(e,0,0,{},void 0,void 0,b.styledMode));this.split?this.label=b.g(f):(this.label=b.label("",0,0,d.shape||"callout",null,null,d.useHTML,null,f).attr({padding:d.padding,r:d.borderRadius}),a||this.label.attr({fill:d.backgroundColor,"stroke-width":d.borderWidth}).css(d.style).shadow(d.shadow));
	a&&(this.applyFilter(),this.label.addClass("highcharts-tooltip-"+this.chart.index));if(this.outside){var h={x:this.label.xSetter,y:this.label.ySetter};this.label.xSetter=function(a,b){h[b].call(this.label,g.distance);e.style.left=a+"px"};this.label.ySetter=function(a,b){h[b].call(this.label,g.distance);e.style.top=a+"px"}}this.label.attr({zIndex:8}).add()}return this.label},update:function(c){this.destroy();C(!0,this.chart.options.tooltip.userOptions,c);this.init(this.chart,C(!0,this.options,c))},
	destroy:function(){this.label&&(this.label=this.label.destroy());this.split&&this.tt&&(this.cleanSplit(this.chart,!0),this.tt=this.tt.destroy());this.renderer&&(this.renderer=this.renderer.destroy(),c.discardElement(this.container));c.clearTimeout(this.hideTimer);c.clearTimeout(this.tooltipTimeout)},move:function(g,b,a,d){var f=this,e=f.now,h=!1!==f.options.animation&&!f.isHidden&&(1<Math.abs(g-e.x)||1<Math.abs(b-e.y)),r=f.followPointer||1<f.len;L(e,{x:h?(2*e.x+g)/3:g,y:h?(e.y+b)/2:b,anchorX:r?void 0:
	h?(2*e.anchorX+a)/3:a,anchorY:r?void 0:h?(e.anchorY+d)/2:d});f.getLabel().attr(e);h&&(c.clearTimeout(this.tooltipTimeout),this.tooltipTimeout=setTimeout(function(){f&&f.move(g,b,a,d)},32))},hide:function(g){var b=this;c.clearTimeout(this.hideTimer);g=x(g,this.options.hideDelay,500);this.isHidden||(this.hideTimer=m(function(){b.getLabel()[g?"fadeOut":"hide"]();b.isHidden=!0},g))},getAnchor:function(c,b){var a=this.chart,d=a.pointer,f=a.inverted,e=a.plotTop,h=a.plotLeft,r=0,g=0,q,v;c=z(c);this.followPointer&&
	b?(void 0===b.chartX&&(b=d.normalize(b)),c=[b.chartX-a.plotLeft,b.chartY-e]):c[0].tooltipPos?c=c[0].tooltipPos:(c.forEach(function(a){q=a.series.yAxis;v=a.series.xAxis;r+=a.plotX+(!f&&v?v.left-h:0);g+=(a.plotLow?(a.plotLow+a.plotHigh)/2:a.plotY)+(!f&&q?q.top-e:0)}),r/=c.length,g/=c.length,c=[f?a.plotWidth-g:r,this.shared&&!f&&1<c.length&&b?b.chartY-e:f?a.plotHeight-r:g]);return c.map(Math.round)},getPosition:function(c,b,a){var d=this.chart,f=this.distance,e={},h=d.inverted&&a.h||0,r,g=this.outside,
	q=g?u.documentElement.clientWidth-2*f:d.chartWidth,v=g?Math.max(u.body.scrollHeight,u.documentElement.scrollHeight,u.body.offsetHeight,u.documentElement.offsetHeight,u.documentElement.clientHeight):d.chartHeight,k=d.pointer.chartPosition,t=d.containerScaling,B=function(a){return t?a*t.scaleX:a},I=function(a){return t?a*t.scaleY:a},w=function(e){var l="x"===e;return[e,l?q:v,l?c:b].concat(g?[l?B(c):I(b),l?k.left-f+B(a.plotX+d.plotLeft):k.top-f+I(a.plotY+d.plotTop),0,l?q:v]:[l?c:b,l?a.plotX+d.plotLeft:
	a.plotY+d.plotTop,l?d.plotLeft:d.plotTop,l?d.plotLeft+d.plotWidth:d.plotTop+d.plotHeight])},l=w("y"),m=w("x"),p=!this.followPointer&&x(a.ttBelow,!d.inverted===!!a.negative),n=function(a,b,d,c,k,l,t){var w="y"===a?I(f):B(f),r=(d-c)/2,q=c<k-f,v=k+f+c<b,g=k-w-d+r;k=k+w-r;if(p&&v)e[a]=k;else if(!p&&q)e[a]=g;else if(q)e[a]=Math.min(t-c,0>g-h?g:g-h);else if(v)e[a]=Math.max(l,k+h+d>b?k:k+h);else return!1},y=function(a,b,d,c,k){var l;k<f||k>b-f?l=!1:e[a]=k<d/2?1:k>b-c/2?b-c-2:k-d/2;return l},z=function(a){var b=
	l;l=m;m=b;r=a},M=function(){!1!==n.apply(0,l)?!1!==y.apply(0,m)||r||(z(!0),M()):r?e.x=e.y=0:(z(!0),M())};(d.inverted||1<this.len)&&z();M();return e},defaultFormatter:function(c){var b=this.points||z(this);var a=[c.tooltipFooterHeaderFormatter(b[0])];a=a.concat(c.bodyFormatter(b));a.push(c.tooltipFooterHeaderFormatter(b[0],!0));return a},refresh:function(g,b){var a=this.chart,d=this.options,f=g,e={},h=[];var r=d.formatter||this.defaultFormatter;e=this.shared;var m=a.styledMode;if(d.enabled){c.clearTimeout(this.hideTimer);
	this.followPointer=z(f)[0].series.tooltipOptions.followPointer;var q=this.getAnchor(f,b);b=q[0];var v=q[1];!e||f.series&&f.series.noSharedTooltip?e=f.getLabelConfig():(a.pointer.applyInactiveState(f),f.forEach(function(a){a.setState("hover");h.push(a.getLabelConfig())}),e={x:f[0].category,y:f[0].y},e.points=h,f=f[0]);this.len=h.length;r=r.call(e,this);e=f.series;this.distance=x(e.tooltipOptions.distance,16);!1===r?this.hide():(a=this.getLabel(),this.isHidden&&a.attr({opacity:1}).show(),this.split?
	this.renderSplit(r,z(g)):(d.style.width&&!m||a.css({width:this.chart.spacingBox.width}),a.attr({text:r&&r.join?r.join(""):r}),a.removeClass(/highcharts-color-[\d]+/g).addClass("highcharts-color-"+x(f.colorIndex,e.colorIndex)),m||a.attr({stroke:d.borderColor||f.color||e.color||"#666666"}),this.updatePosition({plotX:b,plotY:v,negative:f.negative,ttBelow:f.ttBelow,h:q[2]||0})),this.isHidden=!1);c.fireEvent(this,"refresh")}},renderSplit:function(g,b){var a=this,d=[],f=this.chart,e=f.renderer,h=!0,r=this.options,
	m=0,q,v=this.getLabel(),k=f.plotTop;F(g)&&(g=[!1,g]);g.slice(0,b.length+1).forEach(function(c,B){if(!1!==c&&""!==c){B=b[B-1]||{isHeader:!0,plotX:b[0].plotX,plotY:f.plotHeight};var t=B.series||a,w=t.tt,l=B.series||{},g="highcharts-color-"+x(B.colorIndex,l.colorIndex,"none");w||(w={padding:r.padding,r:r.borderRadius},f.styledMode||(w.fill=r.backgroundColor,w["stroke-width"]=r.borderWidth),t.tt=w=e.label(null,null,null,(B.isHeader?r.headerShape:r.shape)||"callout",null,null,r.useHTML).addClass("highcharts-tooltip-box "+
	g).attr(w).add(v));w.isActive=!0;w.attr({text:c});f.styledMode||w.css(r.style).shadow(r.shadow).attr({stroke:r.borderColor||B.color||l.color||"#333333"});c=w.getBBox();g=c.width+w.strokeWidth();B.isHeader?(m=c.height,f.xAxis[0].opposite&&(q=!0,k-=m),c=Math.max(0,Math.min(B.plotX+f.plotLeft-g/2,f.chartWidth+(f.scrollablePixelsX?f.scrollablePixelsX-f.marginRight:0)-g))):c=B.plotX+f.plotLeft-x(r.distance,16)-g;0>c&&(h=!1);B.isHeader?l=q?-m:f.plotHeight+m:(l=l.yAxis,l=l.pos-k+Math.max(0,Math.min(B.plotY||
	0,l.len)));d.push({target:l,rank:B.isHeader?1:0,size:t.tt.getBBox().height+1,point:B,x:c,tt:w})}});this.cleanSplit();r.positioner&&d.forEach(function(b){var d=r.positioner.call(a,b.tt.getBBox().width,b.size,b.point);b.x=d.x;b.align=0;b.target=d.y;b.rank=x(d.rank,b.rank)});c.distribute(d,f.plotHeight+m);d.forEach(function(b){var d=b.point,c=d.series,e=c&&c.yAxis;b.tt.attr({visibility:void 0===b.pos?"hidden":"inherit",x:h||d.isHeader||r.positioner?b.x:d.plotX+f.plotLeft+a.distance,y:b.pos+k,anchorX:d.isHeader?
	d.plotX+f.plotLeft:d.plotX+c.xAxis.pos,anchorY:d.isHeader?f.plotTop+f.plotHeight/2:e.pos+Math.max(0,Math.min(d.plotY,e.len))})})},updatePosition:function(g){var b=this.chart,a=b.pointer,d=this.getLabel(),f=g.plotX+b.plotLeft,e=g.plotY+b.plotTop;a.chartPosition||(a.chartPosition=c.offset(b.container));g=(this.options.positioner||this.getPosition).call(this,d.width,d.height,g);if(this.outside){var h=(this.options.borderWidth||0)+2*this.distance;this.renderer.setSize(d.width+h,d.height+h,!1);if(b=b.containerScaling)c.css(this.container,
	{transform:"scale("+b.scaleX+", "+b.scaleY+")"}),f*=b.scaleX,e*=b.scaleY;f+=a.chartPosition.left-g.x;e+=a.chartPosition.top-g.y}this.move(Math.round(g.x),Math.round(g.y||0),f,e)},getDateFormat:function(c,b,a,d){var f=this.chart.time,e=f.dateFormat("%m-%d %H:%M:%S.%L",b),h={millisecond:15,second:12,minute:9,hour:6,day:3},r="millisecond";for(g in p){if(c===p.week&&+f.dateFormat("%w",b)===a&&"00:00:00.000"===e.substr(6)){var g="week";break}if(p[g]>c){g=r;break}if(h[g]&&e.substr(h[g])!=="01-01 00:00:00.000".substr(h[g]))break;
	"week"!==g&&(r=g)}if(g)var q=f.resolveDTLFormat(d[g]).main;return q},getXDateFormat:function(c,b,a){b=b.dateTimeLabelFormats;var d=a&&a.closestPointRange;return(d?this.getDateFormat(d,c.x,a.options.startOfWeek,b):b.day)||b.year},tooltipFooterHeaderFormatter:function(g,b){var a=b?"footer":"header",d=g.series,f=d.tooltipOptions,e=f.xDateFormat,h=d.xAxis,r=h&&"datetime"===h.options.type&&D(g.key),m=f[a+"Format"];b={isFooter:b,labelConfig:g};c.fireEvent(this,"headerFormatter",b,function(a){r&&!e&&(e=
	this.getXDateFormat(g,f,h));r&&e&&(g.point&&g.point.tooltipDateKeys||["key"]).forEach(function(a){m=m.replace("{point."+a+"}","{point."+a+":"+e+"}")});d.chart.styledMode&&(m=this.styledModeFormat(m));a.text=y(m,{point:g,series:d},this.chart.time)});return b.text},bodyFormatter:function(c){return c.map(function(b){var a=b.series.tooltipOptions;return(a[(b.point.formatPrefix||"point")+"Formatter"]||b.point.tooltipFormatter).call(b.point,a[(b.point.formatPrefix||"point")+"Format"]||"")})},styledModeFormat:function(c){return c.replace('style="font-size: 10px"',
	'class="highcharts-header"').replace(/style="color:{(point|series)\.color}"/g,'class="highcharts-color-{$1.colorIndex}"')}}});N(H,"parts/Pointer.js",[H["parts/Globals.js"],H["parts/Utilities.js"]],function(c,n){var A=n.attr,D=n.defined,F=n.isNumber,z=n.isObject,u=n.objectEach,L=n.splat,y=c.addEvent,C=c.charts,x=c.color,m=c.css,p=c.extend,g=c.find,b=c.fireEvent,a=c.offset,d=c.pick,f=c.Tooltip;c.Pointer=function(a,b){this.init(a,b)};c.Pointer.prototype={init:function(a,b){this.options=b;this.chart=
	a;this.runChartClick=b.chart.events&&!!b.chart.events.click;this.pinchDown=[];this.lastValidTouch={};f&&(a.tooltip=new f(a,b.tooltip),this.followTouchMove=d(b.tooltip.followTouchMove,!0));this.setDOMEvents()},zoomOption:function(a){var b=this.chart,c=b.options.chart,f=c.zoomType||"";b=b.inverted;/touch/.test(a.type)&&(f=d(c.pinchType,f));this.zoomX=a=/x/.test(f);this.zoomY=f=/y/.test(f);this.zoomHor=a&&!b||f&&b;this.zoomVert=f&&!b||a&&b;this.hasZoom=a||f},normalize:function(b,d){var c=b.touches?b.touches.length?
	b.touches.item(0):b.changedTouches[0]:b;d||(this.chartPosition=d=a(this.chart.container));var f=c.pageX-d.left;d=c.pageY-d.top;if(c=this.chart.containerScaling)f/=c.scaleX,d/=c.scaleY;return p(b,{chartX:Math.round(f),chartY:Math.round(d)})},getCoordinates:function(a){var b={xAxis:[],yAxis:[]};this.chart.axes.forEach(function(d){b[d.isXAxis?"xAxis":"yAxis"].push({axis:d,value:d.toValue(a[d.horiz?"chartX":"chartY"])})});return b},findNearestKDPoint:function(a,b,d){var c;a.forEach(function(a){var f=
	!(a.noSharedTooltip&&b)&&0>a.options.findNearestPointBy.indexOf("y");a=a.searchPoint(d,f);if((f=z(a,!0))&&!(f=!z(c,!0))){f=c.distX-a.distX;var e=c.dist-a.dist,t=(a.series.group&&a.series.group.zIndex)-(c.series.group&&c.series.group.zIndex);f=0<(0!==f&&b?f:0!==e?e:0!==t?t:c.series.index>a.series.index?-1:1)}f&&(c=a)});return c},getPointFromEvent:function(a){a=a.target;for(var b;a&&!b;)b=a.point,a=a.parentNode;return b},getChartCoordinatesFromPoint:function(a,b){var c=a.series,f=c.xAxis;c=c.yAxis;
	var e=d(a.clientX,a.plotX),h=a.shapeArgs;if(f&&c)return b?{chartX:f.len+f.pos-e,chartY:c.len+c.pos-a.plotY}:{chartX:e+f.pos,chartY:a.plotY+c.pos};if(h&&h.x&&h.y)return{chartX:h.x,chartY:h.y}},getHoverData:function(a,b,c,f,q,v){var e,t=[];f=!(!f||!a);var h=b&&!b.stickyTracking?[b]:c.filter(function(a){return a.visible&&!(!q&&a.directTouch)&&d(a.options.enableMouseTracking,!0)&&a.stickyTracking});b=(e=f||!v?a:this.findNearestKDPoint(h,q,v))&&e.series;e&&(q&&!b.noSharedTooltip?(h=c.filter(function(a){return a.visible&&
	!(!q&&a.directTouch)&&d(a.options.enableMouseTracking,!0)&&!a.noSharedTooltip}),h.forEach(function(a){var b=g(a.points,function(a){return a.x===e.x&&!a.isNull});z(b)&&(a.chart.isBoosting&&(b=a.getPoint(b)),t.push(b))})):t.push(e));return{hoverPoint:e,hoverSeries:b,hoverPoints:t}},runPointActions:function(a,b){var f=this.chart,e=f.tooltip&&f.tooltip.options.enabled?f.tooltip:void 0,h=e?e.shared:!1,v=b||f.hoverPoint,k=v&&v.series||f.hoverSeries;k=this.getHoverData(v,k,f.series,(!a||"touchmove"!==a.type)&&
	(!!b||k&&k.directTouch&&this.isDirectTouch),h,a);v=k.hoverPoint;var t=k.hoverPoints;b=(k=k.hoverSeries)&&k.tooltipOptions.followPointer;h=h&&k&&!k.noSharedTooltip;if(v&&(v!==f.hoverPoint||e&&e.isHidden)){(f.hoverPoints||[]).forEach(function(a){-1===t.indexOf(a)&&a.setState()});if(f.hoverSeries!==k)k.onMouseOver();this.applyInactiveState(t);(t||[]).forEach(function(a){a.setState("hover")});f.hoverPoint&&f.hoverPoint.firePointEvent("mouseOut");if(!v.series)return;v.firePointEvent("mouseOver");f.hoverPoints=
	t;f.hoverPoint=v;e&&e.refresh(h?t:v,a)}else b&&e&&!e.isHidden&&(v=e.getAnchor([{}],a),e.updatePosition({plotX:v[0],plotY:v[1]}));this.unDocMouseMove||(this.unDocMouseMove=y(f.container.ownerDocument,"mousemove",function(a){var b=C[c.hoverChartIndex];if(b)b.pointer.onDocumentMouseMove(a)}));f.axes.forEach(function(b){var f=d(b.crosshair.snap,!0),e=f?c.find(t,function(a){return a.series[b.coll]===b}):void 0;e||!f?b.drawCrosshair(a,e):b.hideCrosshair()})},applyInactiveState:function(a){var b=[],d;(a||
	[]).forEach(function(a){d=a.series;b.push(d);d.linkedParent&&b.push(d.linkedParent);d.linkedSeries&&(b=b.concat(d.linkedSeries));d.navigatorSeries&&b.push(d.navigatorSeries)});this.chart.series.forEach(function(a){-1===b.indexOf(a)?a.setState("inactive",!0):a.options.inactiveOtherPoints&&a.setAllPointsToState("inactive")})},reset:function(a,b){var d=this.chart,c=d.hoverSeries,f=d.hoverPoint,e=d.hoverPoints,k=d.tooltip,t=k&&k.shared?e:f;a&&t&&L(t).forEach(function(b){b.series.isCartesian&&void 0===
	b.plotX&&(a=!1)});if(a)k&&t&&L(t).length&&(k.refresh(t),k.shared&&e?e.forEach(function(a){a.setState(a.state,!0);a.series.isCartesian&&(a.series.xAxis.crosshair&&a.series.xAxis.drawCrosshair(null,a),a.series.yAxis.crosshair&&a.series.yAxis.drawCrosshair(null,a))}):f&&(f.setState(f.state,!0),d.axes.forEach(function(a){a.crosshair&&a.drawCrosshair(null,f)})));else{if(f)f.onMouseOut();e&&e.forEach(function(a){a.setState()});if(c)c.onMouseOut();k&&k.hide(b);this.unDocMouseMove&&(this.unDocMouseMove=this.unDocMouseMove());
	d.axes.forEach(function(a){a.hideCrosshair()});this.hoverX=d.hoverPoints=d.hoverPoint=null}},scaleGroups:function(a,b){var d=this.chart,c;d.series.forEach(function(f){c=a||f.getPlotBox();f.xAxis&&f.xAxis.zoomEnabled&&f.group&&(f.group.attr(c),f.markerGroup&&(f.markerGroup.attr(c),f.markerGroup.clip(b?d.clipRect:null)),f.dataLabelsGroup&&f.dataLabelsGroup.attr(c))});d.clipRect.attr(b||d.clipBox)},dragStart:function(a){var b=this.chart;b.mouseIsDown=a.type;b.cancelClick=!1;b.mouseDownX=this.mouseDownX=
	a.chartX;b.mouseDownY=this.mouseDownY=a.chartY},drag:function(a){var b=this.chart,d=b.options.chart,c=a.chartX,f=a.chartY,e=this.zoomHor,k=this.zoomVert,t=b.plotLeft,B=b.plotTop,I=b.plotWidth,w=b.plotHeight,l=this.selectionMarker,g=this.mouseDownX,m=this.mouseDownY,p=d.panKey&&a[d.panKey+"Key"];if(!l||!l.touch)if(c<t?c=t:c>t+I&&(c=t+I),f<B?f=B:f>B+w&&(f=B+w),this.hasDragged=Math.sqrt(Math.pow(g-c,2)+Math.pow(m-f,2)),10<this.hasDragged){var u=b.isInsidePlot(g-t,m-B);b.hasCartesianSeries&&(this.zoomX||
	this.zoomY)&&u&&!p&&!l&&(this.selectionMarker=l=b.renderer.rect(t,B,e?1:I,k?1:w,0).attr({"class":"highcharts-selection-marker",zIndex:7}).add(),b.styledMode||l.attr({fill:d.selectionMarkerFill||x("#335cad").setOpacity(.25).get()}));l&&e&&(c-=g,l.attr({width:Math.abs(c),x:(0<c?0:c)+g}));l&&k&&(c=f-m,l.attr({height:Math.abs(c),y:(0<c?0:c)+m}));u&&!l&&d.panning&&b.pan(a,d.panning)}},drop:function(a){var d=this,c=this.chart,f=this.hasPinched;if(this.selectionMarker){var e={originalEvent:a,xAxis:[],yAxis:[]},
	v=this.selectionMarker,k=v.attr?v.attr("x"):v.x,t=v.attr?v.attr("y"):v.y,B=v.attr?v.attr("width"):v.width,I=v.attr?v.attr("height"):v.height,w;if(this.hasDragged||f)c.axes.forEach(function(b){if(b.zoomEnabled&&D(b.min)&&(f||d[{xAxis:"zoomX",yAxis:"zoomY"}[b.coll]])){var c=b.horiz,l="touchend"===a.type?b.minPixelPadding:0,h=b.toValue((c?k:t)+l);c=b.toValue((c?k+B:t+I)-l);e[b.coll].push({axis:b,min:Math.min(h,c),max:Math.max(h,c)});w=!0}}),w&&b(c,"selection",e,function(a){c.zoom(p(a,f?{animation:!1}:
	null))});F(c.index)&&(this.selectionMarker=this.selectionMarker.destroy());f&&this.scaleGroups()}c&&F(c.index)&&(m(c.container,{cursor:c._cursor}),c.cancelClick=10<this.hasDragged,c.mouseIsDown=this.hasDragged=this.hasPinched=!1,this.pinchDown=[])},onContainerMouseDown:function(a){a=this.normalize(a);2!==a.button&&(this.zoomOption(a),a.preventDefault&&a.preventDefault(),this.dragStart(a))},onDocumentMouseUp:function(a){C[c.hoverChartIndex]&&C[c.hoverChartIndex].pointer.drop(a)},onDocumentMouseMove:function(a){var b=
	this.chart,d=this.chartPosition;a=this.normalize(a,d);!d||this.inClass(a.target,"highcharts-tracker")||b.isInsidePlot(a.chartX-b.plotLeft,a.chartY-b.plotTop)||this.reset()},onContainerMouseLeave:function(a){var b=C[c.hoverChartIndex];b&&(a.relatedTarget||a.toElement)&&(b.pointer.reset(),b.pointer.chartPosition=null)},onContainerMouseMove:function(a){var b=this.chart;D(c.hoverChartIndex)&&C[c.hoverChartIndex]&&C[c.hoverChartIndex].mouseIsDown||(c.hoverChartIndex=b.index);a=this.normalize(a);a.preventDefault||
	(a.returnValue=!1);"mousedown"===b.mouseIsDown&&this.drag(a);!this.inClass(a.target,"highcharts-tracker")&&!b.isInsidePlot(a.chartX-b.plotLeft,a.chartY-b.plotTop)||b.openMenu||this.runPointActions(a)},inClass:function(a,b){for(var d;a;){if(d=A(a,"class")){if(-1!==d.indexOf(b))return!0;if(-1!==d.indexOf("highcharts-container"))return!1}a=a.parentNode}},onTrackerMouseOut:function(a){var b=this.chart.hoverSeries;a=a.relatedTarget||a.toElement;this.isDirectTouch=!1;if(!(!b||!a||b.stickyTracking||this.inClass(a,
	"highcharts-tooltip")||this.inClass(a,"highcharts-series-"+b.index)&&this.inClass(a,"highcharts-tracker")))b.onMouseOut()},onContainerClick:function(a){var d=this.chart,c=d.hoverPoint,f=d.plotLeft,e=d.plotTop;a=this.normalize(a);d.cancelClick||(c&&this.inClass(a.target,"highcharts-tracker")?(b(c.series,"click",p(a,{point:c})),d.hoverPoint&&c.firePointEvent("click",a)):(p(a,this.getCoordinates(a)),d.isInsidePlot(a.chartX-f,a.chartY-e)&&b(d,"click",a)))},setDOMEvents:function(){var a=this,b=a.chart.container,
	d=b.ownerDocument;b.onmousedown=function(b){a.onContainerMouseDown(b)};b.onmousemove=function(b){a.onContainerMouseMove(b)};b.onclick=function(b){a.onContainerClick(b)};this.unbindContainerMouseLeave=y(b,"mouseleave",a.onContainerMouseLeave);c.unbindDocumentMouseUp||(c.unbindDocumentMouseUp=y(d,"mouseup",a.onDocumentMouseUp));c.hasTouch&&(y(b,"touchstart",function(b){a.onContainerTouchStart(b)}),y(b,"touchmove",function(b){a.onContainerTouchMove(b)}),c.unbindDocumentTouchEnd||(c.unbindDocumentTouchEnd=
	y(d,"touchend",a.onDocumentTouchEnd)))},destroy:function(){var a=this;a.unDocMouseMove&&a.unDocMouseMove();this.unbindContainerMouseLeave();c.chartCount||(c.unbindDocumentMouseUp&&(c.unbindDocumentMouseUp=c.unbindDocumentMouseUp()),c.unbindDocumentTouchEnd&&(c.unbindDocumentTouchEnd=c.unbindDocumentTouchEnd()));clearInterval(a.tooltipTimeout);u(a,function(b,d){a[d]=null})}}});N(H,"parts/TouchPointer.js",[H["parts/Globals.js"]],function(c){var n=c.charts,A=c.extend,D=c.noop,F=c.pick;A(c.Pointer.prototype,
	{pinchTranslate:function(c,u,n,y,A,x){this.zoomHor&&this.pinchTranslateDirection(!0,c,u,n,y,A,x);this.zoomVert&&this.pinchTranslateDirection(!1,c,u,n,y,A,x)},pinchTranslateDirection:function(c,u,n,y,A,x,m,p){var g=this.chart,b=c?"x":"y",a=c?"X":"Y",d="chart"+a,f=c?"width":"height",e=g["plot"+(c?"Left":"Top")],h,r,E=p||1,q=g.inverted,v=g.bounds[c?"h":"v"],k=1===u.length,t=u[0][d],B=n[0][d],I=!k&&u[1][d],w=!k&&n[1][d];n=function(){!k&&20<Math.abs(t-I)&&(E=p||Math.abs(B-w)/Math.abs(t-I));r=(e-B)/E+t;
	h=g["plot"+(c?"Width":"Height")]/E};n();u=r;if(u<v.min){u=v.min;var l=!0}else u+h>v.max&&(u=v.max-h,l=!0);l?(B-=.8*(B-m[b][0]),k||(w-=.8*(w-m[b][1])),n()):m[b]=[B,w];q||(x[b]=r-e,x[f]=h);x=q?1/E:E;A[f]=h;A[b]=u;y[q?c?"scaleY":"scaleX":"scale"+a]=E;y["translate"+a]=x*e+(B-x*t)},pinch:function(c){var u=this,n=u.chart,y=u.pinchDown,z=c.touches,x=z.length,m=u.lastValidTouch,p=u.hasZoom,g=u.selectionMarker,b={},a=1===x&&(u.inClass(c.target,"highcharts-tracker")&&n.runTrackerClick||u.runChartClick),d={};
	1<x&&(u.initiated=!0);p&&u.initiated&&!a&&c.preventDefault();[].map.call(z,function(a){return u.normalize(a)});"touchstart"===c.type?([].forEach.call(z,function(a,b){y[b]={chartX:a.chartX,chartY:a.chartY}}),m.x=[y[0].chartX,y[1]&&y[1].chartX],m.y=[y[0].chartY,y[1]&&y[1].chartY],n.axes.forEach(function(a){if(a.zoomEnabled){var b=n.bounds[a.horiz?"h":"v"],d=a.minPixelPadding,c=a.toPixels(Math.min(F(a.options.min,a.dataMin),a.dataMin)),f=a.toPixels(Math.max(F(a.options.max,a.dataMax),a.dataMax)),q=Math.max(c,
	f);b.min=Math.min(a.pos,Math.min(c,f)-d);b.max=Math.max(a.pos+a.len,q+d)}}),u.res=!0):u.followTouchMove&&1===x?this.runPointActions(u.normalize(c)):y.length&&(g||(u.selectionMarker=g=A({destroy:D,touch:!0},n.plotBox)),u.pinchTranslate(y,z,b,g,d,m),u.hasPinched=p,u.scaleGroups(b,d),u.res&&(u.res=!1,this.reset(!1,0)))},touch:function(n,u){var z=this.chart,y;if(z.index!==c.hoverChartIndex)this.onContainerMouseLeave({relatedTarget:!0});c.hoverChartIndex=z.index;if(1===n.touches.length)if(n=this.normalize(n),
	(y=z.isInsidePlot(n.chartX-z.plotLeft,n.chartY-z.plotTop))&&!z.openMenu){u&&this.runPointActions(n);if("touchmove"===n.type){u=this.pinchDown;var A=u[0]?4<=Math.sqrt(Math.pow(u[0].chartX-n.chartX,2)+Math.pow(u[0].chartY-n.chartY,2)):!1}F(A,!0)&&this.pinch(n)}else u&&this.reset();else 2===n.touches.length&&this.pinch(n)},onContainerTouchStart:function(c){this.zoomOption(c);this.touch(c,!0)},onContainerTouchMove:function(c){this.touch(c)},onDocumentTouchEnd:function(z){n[c.hoverChartIndex]&&n[c.hoverChartIndex].pointer.drop(z)}})});
	N(H,"parts/MSPointer.js",[H["parts/Globals.js"],H["parts/Utilities.js"]],function(c,n){var A=n.objectEach,D=c.addEvent,F=c.charts,z=c.css,u=c.doc;n=c.extend;var L=c.noop,y=c.Pointer,C=c.removeEvent,x=c.win,m=c.wrap;if(!c.hasTouch&&(x.PointerEvent||x.MSPointerEvent)){var p={},g=!!x.PointerEvent,b=function(){var a=[];a.item=function(a){return this[a]};A(p,function(b){a.push({pageX:b.pageX,pageY:b.pageY,target:b.target})});return a},a=function(a,f,e,h){"touch"!==a.pointerType&&a.pointerType!==a.MSPOINTER_TYPE_TOUCH||
	!F[c.hoverChartIndex]||(h(a),h=F[c.hoverChartIndex].pointer,h[f]({type:e,target:a.currentTarget,preventDefault:L,touches:b()}))};n(y.prototype,{onContainerPointerDown:function(b){a(b,"onContainerTouchStart","touchstart",function(a){p[a.pointerId]={pageX:a.pageX,pageY:a.pageY,target:a.currentTarget}})},onContainerPointerMove:function(b){a(b,"onContainerTouchMove","touchmove",function(a){p[a.pointerId]={pageX:a.pageX,pageY:a.pageY};p[a.pointerId].target||(p[a.pointerId].target=a.currentTarget)})},onDocumentPointerUp:function(b){a(b,
	"onDocumentTouchEnd","touchend",function(a){delete p[a.pointerId]})},batchMSEvents:function(a){a(this.chart.container,g?"pointerdown":"MSPointerDown",this.onContainerPointerDown);a(this.chart.container,g?"pointermove":"MSPointerMove",this.onContainerPointerMove);a(u,g?"pointerup":"MSPointerUp",this.onDocumentPointerUp)}});m(y.prototype,"init",function(a,b,c){a.call(this,b,c);this.hasZoom&&z(b.container,{"-ms-touch-action":"none","touch-action":"none"})});m(y.prototype,"setDOMEvents",function(a){a.apply(this);
	(this.hasZoom||this.followTouchMove)&&this.batchMSEvents(D)});m(y.prototype,"destroy",function(a){this.batchMSEvents(C);a.call(this)})}});N(H,"parts/Legend.js",[H["parts/Globals.js"],H["parts/Utilities.js"]],function(c,n){var A=n.defined,D=n.isNumber,F=c.addEvent,z=c.css,u=c.discardElement,L=c.fireEvent;n=c.isFirefox;var y=c.marginNames,C=c.merge,x=c.pick,m=c.setAnimation,p=c.stableSort,g=c.win,b=c.wrap;c.Legend=function(a,b){this.init(a,b)};c.Legend.prototype={init:function(a,b){this.chart=a;this.setOptions(b);
	b.enabled&&(this.render(),F(this.chart,"endResize",function(){this.legend.positionCheckboxes()}),this.proximate?this.unchartrender=F(this.chart,"render",function(){this.legend.proximatePositions();this.legend.positionItems()}):this.unchartrender&&this.unchartrender())},setOptions:function(a){var b=x(a.padding,8);this.options=a;this.chart.styledMode||(this.itemStyle=a.itemStyle,this.itemHiddenStyle=C(this.itemStyle,a.itemHiddenStyle));this.itemMarginTop=a.itemMarginTop||0;this.padding=b;this.initialItemY=
	b-5;this.symbolWidth=x(a.symbolWidth,16);this.pages=[];this.proximate="proximate"===a.layout&&!this.chart.inverted},update:function(a,b){var d=this.chart;this.setOptions(C(!0,this.options,a));this.destroy();d.isDirtyLegend=d.isDirtyBox=!0;x(b,!0)&&d.redraw();L(this,"afterUpdate")},colorizeItem:function(a,b){a.legendGroup[b?"removeClass":"addClass"]("highcharts-legend-item-hidden");if(!this.chart.styledMode){var d=this.options,c=a.legendItem,h=a.legendLine,r=a.legendSymbol,g=this.itemHiddenStyle.color;
	d=b?d.itemStyle.color:g;var q=b?a.color||g:g,v=a.options&&a.options.marker,k={fill:q};c&&c.css({fill:d,color:d});h&&h.attr({stroke:q});r&&(v&&r.isMarker&&(k=a.pointAttribs(),b||(k.stroke=k.fill=g)),r.attr(k))}L(this,"afterColorizeItem",{item:a,visible:b})},positionItems:function(){this.allItems.forEach(this.positionItem,this);this.chart.isResizing||this.positionCheckboxes()},positionItem:function(a){var b=this.options,c=b.symbolPadding;b=!b.rtl;var e=a._legendItemPos,h=e[0];e=e[1];var r=a.checkbox;
	if((a=a.legendGroup)&&a.element)a[A(a.translateY)?"animate":"attr"]({translateX:b?h:this.legendWidth-h-2*c-4,translateY:e});r&&(r.x=h,r.y=e)},destroyItem:function(a){var b=a.checkbox;["legendItem","legendLine","legendSymbol","legendGroup"].forEach(function(b){a[b]&&(a[b]=a[b].destroy())});b&&u(a.checkbox)},destroy:function(){function a(a){this[a]&&(this[a]=this[a].destroy())}this.getAllItems().forEach(function(b){["legendItem","legendGroup"].forEach(a,b)});"clipRect up down pager nav box title group".split(" ").forEach(a,
	this);this.display=null},positionCheckboxes:function(){var a=this.group&&this.group.alignAttr,b=this.clipHeight||this.legendHeight,c=this.titleHeight;if(a){var e=a.translateY;this.allItems.forEach(function(d){var f=d.checkbox;if(f){var h=e+c+f.y+(this.scrollOffset||0)+3;z(f,{left:a.translateX+d.checkboxOffset+f.x-20+"px",top:h+"px",display:this.proximate||h>e-6&&h<e+b-6?"":"none"})}},this)}},renderTitle:function(){var a=this.options,b=this.padding,c=a.title,e=0;c.text&&(this.title||(this.title=this.chart.renderer.label(c.text,
	b-3,b-4,null,null,null,a.useHTML,null,"legend-title").attr({zIndex:1}),this.chart.styledMode||this.title.css(c.style),this.title.add(this.group)),c.width||this.title.css({width:this.maxLegendWidth+"px"}),a=this.title.getBBox(),e=a.height,this.offsetWidth=a.width,this.contentGroup.attr({translateY:e}));this.titleHeight=e},setText:function(a){var b=this.options;a.legendItem.attr({text:b.labelFormat?c.format(b.labelFormat,a,this.chart.time):b.labelFormatter.call(a)})},renderItem:function(a){var b=this.chart,
	c=b.renderer,e=this.options,h=this.symbolWidth,r=e.symbolPadding,g=this.itemStyle,q=this.itemHiddenStyle,v="horizontal"===e.layout?x(e.itemDistance,20):0,k=!e.rtl,t=a.legendItem,B=!a.series,I=!B&&a.series.drawLegendSymbol?a.series:a,w=I.options;w=this.createCheckboxForItem&&w&&w.showCheckbox;v=h+r+v+(w?20:0);var l=e.useHTML,m=a.options.className;t||(a.legendGroup=c.g("legend-item").addClass("highcharts-"+I.type+"-series highcharts-color-"+a.colorIndex+(m?" "+m:"")+(B?" highcharts-series-"+a.index:
	"")).attr({zIndex:1}).add(this.scrollGroup),a.legendItem=t=c.text("",k?h+r:-r,this.baseline||0,l),b.styledMode||t.css(C(a.visible?g:q)),t.attr({align:k?"left":"right",zIndex:2}).add(a.legendGroup),this.baseline||(this.fontMetrics=c.fontMetrics(b.styledMode?12:g.fontSize,t),this.baseline=this.fontMetrics.f+3+this.itemMarginTop,t.attr("y",this.baseline)),this.symbolHeight=e.symbolHeight||this.fontMetrics.f,I.drawLegendSymbol(this,a),this.setItemEvents&&this.setItemEvents(a,t,l));w&&!a.checkbox&&this.createCheckboxForItem(a);
	this.colorizeItem(a,a.visible);!b.styledMode&&g.width||t.css({width:(e.itemWidth||this.widthOption||b.spacingBox.width)-v});this.setText(a);b=t.getBBox();a.itemWidth=a.checkboxOffset=e.itemWidth||a.legendItemWidth||b.width+v;this.maxItemWidth=Math.max(this.maxItemWidth,a.itemWidth);this.totalItemWidth+=a.itemWidth;this.itemHeight=a.itemHeight=Math.round(a.legendItemHeight||b.height||this.symbolHeight)},layoutItem:function(a){var b=this.options,c=this.padding,e="horizontal"===b.layout,h=a.itemHeight,
	g=b.itemMarginBottom||0,m=this.itemMarginTop,q=e?x(b.itemDistance,20):0,v=this.maxLegendWidth;b=b.alignColumns&&this.totalItemWidth>v?this.maxItemWidth:a.itemWidth;e&&this.itemX-c+b>v&&(this.itemX=c,this.lastLineHeight&&(this.itemY+=m+this.lastLineHeight+g),this.lastLineHeight=0);this.lastItemY=m+this.itemY+g;this.lastLineHeight=Math.max(h,this.lastLineHeight);a._legendItemPos=[this.itemX,this.itemY];e?this.itemX+=b:(this.itemY+=m+h+g,this.lastLineHeight=h);this.offsetWidth=this.widthOption||Math.max((e?
	this.itemX-c-(a.checkbox?0:q):b)+c,this.offsetWidth)},getAllItems:function(){var a=[];this.chart.series.forEach(function(b){var d=b&&b.options;b&&x(d.showInLegend,A(d.linkedTo)?!1:void 0,!0)&&(a=a.concat(b.legendItems||("point"===d.legendType?b.data:b)))});L(this,"afterGetAllItems",{allItems:a});return a},getAlignment:function(){var a=this.options;return this.proximate?a.align.charAt(0)+"tv":a.floating?"":a.align.charAt(0)+a.verticalAlign.charAt(0)+a.layout.charAt(0)},adjustMargins:function(a,b){var d=
	this.chart,c=this.options,h=this.getAlignment();h&&[/(lth|ct|rth)/,/(rtv|rm|rbv)/,/(rbh|cb|lbh)/,/(lbv|lm|ltv)/].forEach(function(f,e){f.test(h)&&!A(a[e])&&(d[y[e]]=Math.max(d[y[e]],d.legend[(e+1)%2?"legendHeight":"legendWidth"]+[1,-1,-1,1][e]*c[e%2?"x":"y"]+x(c.margin,12)+b[e]+(d.titleOffset[e]||0)))})},proximatePositions:function(){var a=this.chart,b=[],f="left"===this.options.align;this.allItems.forEach(function(d){var e=f;if(d.yAxis&&d.points){d.xAxis.options.reversed&&(e=!e);var g=c.find(e?d.points:
	d.points.slice(0).reverse(),function(a){return D(a.plotY)});e=d.legendGroup.getBBox().height;var m=d.yAxis.top-a.plotTop;d.visible?(g=g?g.plotY:d.yAxis.height,g+=m-.3*e):g=m+d.yAxis.height;b.push({target:g,size:e,item:d})}},this);c.distribute(b,a.plotHeight);b.forEach(function(b){b.item._legendItemPos[1]=a.plotTop-a.spacing[0]+b.pos})},render:function(){var a=this.chart,b=a.renderer,f=this.group,e,h=this.box,g=this.options,m=this.padding;this.itemX=m;this.itemY=this.initialItemY;this.lastItemY=this.offsetWidth=
	0;this.widthOption=c.relativeLength(g.width,a.spacingBox.width-m);var q=a.spacingBox.width-2*m-g.x;-1<["rm","lm"].indexOf(this.getAlignment().substring(0,2))&&(q/=2);this.maxLegendWidth=this.widthOption||q;f||(this.group=f=b.g("legend").attr({zIndex:7}).add(),this.contentGroup=b.g().attr({zIndex:1}).add(f),this.scrollGroup=b.g().add(this.contentGroup));this.renderTitle();q=this.getAllItems();p(q,function(a,b){return(a.options&&a.options.legendIndex||0)-(b.options&&b.options.legendIndex||0)});g.reversed&&
	q.reverse();this.allItems=q;this.display=e=!!q.length;this.itemHeight=this.totalItemWidth=this.maxItemWidth=this.lastLineHeight=0;q.forEach(this.renderItem,this);q.forEach(this.layoutItem,this);q=(this.widthOption||this.offsetWidth)+m;var v=this.lastItemY+this.lastLineHeight+this.titleHeight;v=this.handleOverflow(v);v+=m;h||(this.box=h=b.rect().addClass("highcharts-legend-box").attr({r:g.borderRadius}).add(f),h.isNew=!0);a.styledMode||h.attr({stroke:g.borderColor,"stroke-width":g.borderWidth||0,fill:g.backgroundColor||
	"none"}).shadow(g.shadow);0<q&&0<v&&(h[h.isNew?"attr":"animate"](h.crisp.call({},{x:0,y:0,width:q,height:v},h.strokeWidth())),h.isNew=!1);h[e?"show":"hide"]();a.styledMode&&"none"===f.getStyle("display")&&(q=v=0);this.legendWidth=q;this.legendHeight=v;e&&(b=a.spacingBox,h=b.y,/(lth|ct|rth)/.test(this.getAlignment())&&0<a.titleOffset[0]?h+=a.titleOffset[0]:/(lbh|cb|rbh)/.test(this.getAlignment())&&0<a.titleOffset[2]&&(h-=a.titleOffset[2]),h!==b.y&&(b=C(b,{y:h})),f.align(C(g,{width:q,height:v,verticalAlign:this.proximate?
	"top":g.verticalAlign}),!0,b));this.proximate||this.positionItems();L(this,"afterRender")},handleOverflow:function(a){var b=this,c=this.chart,e=c.renderer,h=this.options,g=h.y,m=this.padding;g=c.spacingBox.height+("top"===h.verticalAlign?-g:g)-m;var q=h.maxHeight,v,k=this.clipRect,t=h.navigation,B=x(t.animation,!0),I=t.arrowSize||12,w=this.nav,l=this.pages,p,K=this.allItems,n=function(a){"number"===typeof a?k.attr({height:a}):k&&(b.clipRect=k.destroy(),b.contentGroup.clip());b.contentGroup.div&&(b.contentGroup.div.style.clip=
	a?"rect("+m+"px,9999px,"+(m+a)+"px,0)":"auto")},u=function(a){b[a]=e.circle(0,0,1.3*I).translate(I/2,I/2).add(w);c.styledMode||b[a].attr("fill","rgba(0,0,0,0.0001)");return b[a]};"horizontal"!==h.layout||"middle"===h.verticalAlign||h.floating||(g/=2);q&&(g=Math.min(g,q));l.length=0;a>g&&!1!==t.enabled?(this.clipHeight=v=Math.max(g-20-this.titleHeight-m,0),this.currentPage=x(this.currentPage,1),this.fullHeight=a,K.forEach(function(a,b){var d=a._legendItemPos[1],c=Math.round(a.legendItem.getBBox().height),
	f=l.length;if(!f||d-l[f-1]>v&&(p||d)!==l[f-1])l.push(p||d),f++;a.pageIx=f-1;p&&(K[b-1].pageIx=f-1);b===K.length-1&&d+c-l[f-1]>v&&d!==p&&(l.push(d),a.pageIx=f);d!==p&&(p=d)}),k||(k=b.clipRect=e.clipRect(0,m,9999,0),b.contentGroup.clip(k)),n(v),w||(this.nav=w=e.g().attr({zIndex:1}).add(this.group),this.up=e.symbol("triangle",0,0,I,I).add(w),u("upTracker").on("click",function(){b.scroll(-1,B)}),this.pager=e.text("",15,10).addClass("highcharts-legend-navigation"),c.styledMode||this.pager.css(t.style),
	this.pager.add(w),this.down=e.symbol("triangle-down",0,0,I,I).add(w),u("downTracker").on("click",function(){b.scroll(1,B)})),b.scroll(0),a=g):w&&(n(),this.nav=w.destroy(),this.scrollGroup.attr({translateY:1}),this.clipHeight=0);return a},scroll:function(a,b){var d=this.pages,c=d.length,h=this.currentPage+a;a=this.clipHeight;var g=this.options.navigation,p=this.pager,q=this.padding;h>c&&(h=c);0<h&&(void 0!==b&&m(b,this.chart),this.nav.attr({translateX:q,translateY:a+this.padding+7+this.titleHeight,
	visibility:"visible"}),[this.up,this.upTracker].forEach(function(a){a.attr({"class":1===h?"highcharts-legend-nav-inactive":"highcharts-legend-nav-active"})}),p.attr({text:h+"/"+c}),[this.down,this.downTracker].forEach(function(a){a.attr({x:18+this.pager.getBBox().width,"class":h===c?"highcharts-legend-nav-inactive":"highcharts-legend-nav-active"})},this),this.chart.styledMode||(this.up.attr({fill:1===h?g.inactiveColor:g.activeColor}),this.upTracker.css({cursor:1===h?"default":"pointer"}),this.down.attr({fill:h===
	c?g.inactiveColor:g.activeColor}),this.downTracker.css({cursor:h===c?"default":"pointer"})),this.scrollOffset=-d[h-1]+this.initialItemY,this.scrollGroup.animate({translateY:this.scrollOffset}),this.currentPage=h,this.positionCheckboxes())}};c.LegendSymbolMixin={drawRectangle:function(a,b){var d=a.symbolHeight,c=a.options.squareSymbol;b.legendSymbol=this.chart.renderer.rect(c?(a.symbolWidth-d)/2:0,a.baseline-d+1,c?d:a.symbolWidth,d,x(a.options.symbolRadius,d/2)).addClass("highcharts-point").attr({zIndex:3}).add(b.legendGroup)},
	drawLineMarker:function(a){var b=this.options,c=b.marker,e=a.symbolWidth,h=a.symbolHeight,g=h/2,m=this.chart.renderer,q=this.legendGroup;a=a.baseline-Math.round(.3*a.fontMetrics.b);var v={};this.chart.styledMode||(v={"stroke-width":b.lineWidth||0},b.dashStyle&&(v.dashstyle=b.dashStyle));this.legendLine=m.path(["M",0,a,"L",e,a]).addClass("highcharts-graph").attr(v).add(q);c&&!1!==c.enabled&&e&&(b=Math.min(x(c.radius,g),g),0===this.symbol.indexOf("url")&&(c=C(c,{width:h,height:h}),b=0),this.legendSymbol=
	c=m.symbol(this.symbol,e/2-b,a-b,2*b,2*b,c).addClass("highcharts-point").add(q),c.isMarker=!0)}};(/Trident\/7\.0/.test(g.navigator&&g.navigator.userAgent)||n)&&b(c.Legend.prototype,"positionItem",function(a,b){var d=this,c=function(){b._legendItemPos&&a.call(d,b)};c();d.bubbleLegend||setTimeout(c)})});N(H,"parts/Chart.js",[H["parts/Globals.js"],H["parts/Utilities.js"]],function(c,n){var A=n.attr,D=n.defined,F=n.erase,z=n.isArray,u=n.isNumber,L=n.isObject,y=n.isString,C=n.objectEach,x=n.pInt,m=n.splat,
	p=c.addEvent,g=c.animate,b=c.animObject,a=c.doc,d=c.Axis,f=c.createElement,e=c.defaultOptions,h=c.discardElement,r=c.charts,E=c.css,q=c.extend,v=c.find,k=c.fireEvent,t=c.Legend,B=c.marginNames,I=c.merge,w=c.Pointer,l=c.pick,J=c.removeEvent,K=c.seriesTypes,T=c.syncTimeout,R=c.win,S=c.Chart=function(){this.getArgs.apply(this,arguments)};c.chart=function(a,b,d){return new S(a,b,d)};q(S.prototype,{callbacks:[],getArgs:function(){var a=[].slice.call(arguments);if(y(a[0])||a[0].nodeName)this.renderTo=a.shift();
	this.init(a[0],a[1])},init:function(a,b){var d,f=a.series,l=a.plotOptions||{};k(this,"init",{args:arguments},function(){a.series=null;d=I(e,a);C(d.plotOptions,function(a,b){L(a)&&(a.tooltip=l[b]&&I(l[b].tooltip)||void 0)});d.tooltip.userOptions=a.chart&&a.chart.forExport&&a.tooltip.userOptions||a.tooltip;d.series=a.series=f;this.userOptions=a;var t=d.chart,B=t.events;this.margin=[];this.spacing=[];this.bounds={h:{},v:{}};this.labelCollectors=[];this.callback=b;this.isResizing=0;this.options=d;this.axes=
	[];this.series=[];this.time=a.time&&Object.keys(a.time).length?new c.Time(a.time):c.time;this.styledMode=t.styledMode;this.hasCartesianSeries=t.showAxes;var h=this;h.index=r.length;r.push(h);c.chartCount++;B&&C(B,function(a,b){c.isFunction(a)&&p(h,b,a)});h.xAxis=[];h.yAxis=[];h.pointCount=h.colorCounter=h.symbolCounter=0;k(h,"afterInit");h.firstRender()})},initSeries:function(a){var b=this.options.chart;(b=K[a.type||b.type||b.defaultSeriesType])||c.error(17,!0,this);b=new b;b.init(this,a);return b},
	orderSeries:function(a){var b=this.series;for(a=a||0;a<b.length;a++)b[a]&&(b[a].index=a,b[a].name=b[a].getName())},isInsidePlot:function(a,b,d){var c=d?b:a;a=d?a:b;return 0<=c&&c<=this.plotWidth&&0<=a&&a<=this.plotHeight},redraw:function(a){k(this,"beforeRedraw");var b=this.axes,d=this.series,f=this.pointer,e=this.legend,l=this.userOptions.legend,t=this.isDirtyLegend,h=this.hasCartesianSeries,B=this.isDirtyBox,w=this.renderer,g=w.isHidden(),v=[];this.setResponsive&&this.setResponsive(!1);c.setAnimation(a,
	this);g&&this.temporaryDisplay();this.layOutTitles();for(a=d.length;a--;){var m=d[a];if(m.options.stacking){var I=!0;if(m.isDirty){var p=!0;break}}}if(p)for(a=d.length;a--;)m=d[a],m.options.stacking&&(m.isDirty=!0);d.forEach(function(a){a.isDirty&&("point"===a.options.legendType?(a.updateTotals&&a.updateTotals(),t=!0):l&&(l.labelFormatter||l.labelFormat)&&(t=!0));a.isDirtyData&&k(a,"updatedData")});t&&e&&e.options.enabled&&(e.render(),this.isDirtyLegend=!1);I&&this.getStacks();h&&b.forEach(function(a){a.updateNames();
	a.setScale()});this.getMargins();h&&(b.forEach(function(a){a.isDirty&&(B=!0)}),b.forEach(function(a){var b=a.min+","+a.max;a.extKey!==b&&(a.extKey=b,v.push(function(){k(a,"afterSetExtremes",q(a.eventArgs,a.getExtremes()));delete a.eventArgs}));(B||I)&&a.redraw()}));B&&this.drawChartBox();k(this,"predraw");d.forEach(function(a){(B||a.isDirty)&&a.visible&&a.redraw();a.isDirtyData=!1});f&&f.reset(!0);w.draw();k(this,"redraw");k(this,"render");g&&this.temporaryDisplay(!0);v.forEach(function(a){a.call()})},
	get:function(a){function b(b){return b.id===a||b.options&&b.options.id===a}var d=this.series,c;var f=v(this.axes,b)||v(this.series,b);for(c=0;!f&&c<d.length;c++)f=v(d[c].points||[],b);return f},getAxes:function(){var a=this,b=this.options,c=b.xAxis=m(b.xAxis||{});b=b.yAxis=m(b.yAxis||{});k(this,"getAxes");c.forEach(function(a,b){a.index=b;a.isX=!0});b.forEach(function(a,b){a.index=b});c.concat(b).forEach(function(b){new d(a,b)});k(this,"afterGetAxes")},getSelectedPoints:function(){var a=[];this.series.forEach(function(b){a=
	a.concat((b[b.hasGroupedData?"points":"data"]||[]).filter(function(a){return l(a.selectedStaging,a.selected)}))});return a},getSelectedSeries:function(){return this.series.filter(function(a){return a.selected})},setTitle:function(a,b,d){this.applyDescription("title",a);this.applyDescription("subtitle",b);this.applyDescription("caption",void 0);this.layOutTitles(d)},applyDescription:function(a,b){var d=this,c="title"===a?{color:"#333333",fontSize:this.options.isStock?"16px":"18px"}:{color:"#666666"};
	c=this.options[a]=I(!this.styledMode&&{style:c},this.options[a],b);var f=this[a];f&&b&&(this[a]=f=f.destroy());c&&!f&&(f=this.renderer.text(c.text,0,0,c.useHTML).attr({align:c.align,"class":"highcharts-"+a,zIndex:c.zIndex||4}).add(),f.update=function(b){d[{title:"setTitle",subtitle:"setSubtitle",caption:"setCaption"}[a]](b)},this.styledMode||f.css(c.style),this[a]=f)},layOutTitles:function(a){var b=[0,0,0],d=this.renderer,c=this.spacingBox;["title","subtitle","caption"].forEach(function(a){var f=
	this[a],e=this.options[a],k=e.verticalAlign||"top";a="title"===a?-3:"top"===k?b[0]+2:0;if(f){if(!this.styledMode)var l=e.style.fontSize;l=d.fontMetrics(l,f).b;f.css({width:(e.width||c.width+(e.widthAdjust||0))+"px"});var t=f.getBBox(e.useHTML).height;f.align(q({y:"bottom"===k?l:a+l,height:t},e),!1,"spacingBox");e.floating||("top"===k?b[0]=Math.ceil(b[0]+t):"bottom"===k&&(b[2]=Math.ceil(b[2]+t)))}},this);b[0]&&"top"===(this.options.title.verticalAlign||"top")&&(b[0]+=this.options.title.margin);b[2]&&
	"bottom"===this.options.caption.verticalAlign&&(b[2]+=this.options.caption.margin);var f=!this.titleOffset||this.titleOffset.join(",")!==b.join(",");this.titleOffset=b;!this.isDirtyBox&&f&&(this.isDirtyBox=this.isDirtyLegend=f,this.hasRendered&&l(a,!0)&&this.isDirtyBox&&this.redraw())},getChartSize:function(){var a=this.options.chart,b=a.width;a=a.height;var d=this.renderTo;D(b)||(this.containerWidth=c.getStyle(d,"width"));D(a)||(this.containerHeight=c.getStyle(d,"height"));this.chartWidth=Math.max(0,
	b||this.containerWidth||600);this.chartHeight=Math.max(0,c.relativeLength(a,this.chartWidth)||(1<this.containerHeight?this.containerHeight:400))},temporaryDisplay:function(b){var d=this.renderTo;if(b)for(;d&&d.style;)d.hcOrigStyle&&(c.css(d,d.hcOrigStyle),delete d.hcOrigStyle),d.hcOrigDetached&&(a.body.removeChild(d),d.hcOrigDetached=!1),d=d.parentNode;else for(;d&&d.style;){a.body.contains(d)||d.parentNode||(d.hcOrigDetached=!0,a.body.appendChild(d));if("none"===c.getStyle(d,"display",!1)||d.hcOricDetached)d.hcOrigStyle=
	{display:d.style.display,height:d.style.height,overflow:d.style.overflow},b={display:"block",overflow:"hidden"},d!==this.renderTo&&(b.height=0),c.css(d,b),d.offsetWidth||d.style.setProperty("display","block","important");d=d.parentNode;if(d===a.body)break}},setClassName:function(a){this.container.className="highcharts-container "+(a||"")},getContainer:function(){var b=this.options,d=b.chart;var e=this.renderTo;var l=c.uniqueKey(),t,h;e||(this.renderTo=e=d.renderTo);y(e)&&(this.renderTo=e=a.getElementById(e));
	e||c.error(13,!0,this);var B=x(A(e,"data-highcharts-chart"));u(B)&&r[B]&&r[B].hasRendered&&r[B].destroy();A(e,"data-highcharts-chart",this.index);e.innerHTML="";d.skipClone||e.offsetWidth||this.temporaryDisplay();this.getChartSize();B=this.chartWidth;var w=this.chartHeight;E(e,{overflow:"hidden"});this.styledMode||(t=q({position:"relative",overflow:"hidden",width:B+"px",height:w+"px",textAlign:"left",lineHeight:"normal",zIndex:0,"-webkit-tap-highlight-color":"rgba(0,0,0,0)"},d.style));this.container=
	e=f("div",{id:l},t,e);this._cursor=e.style.cursor;this.renderer=new (c[d.renderer]||c.Renderer)(e,B,w,null,d.forExport,b.exporting&&b.exporting.allowHTML,this.styledMode);this.setClassName(d.className);if(this.styledMode)for(h in b.defs)this.renderer.definition(b.defs[h]);else this.renderer.setStyle(d.style);this.renderer.chartIndex=this.index;k(this,"afterGetContainer")},getMargins:function(a){var b=this.spacing,d=this.margin,c=this.titleOffset;this.resetMargins();c[0]&&!D(d[0])&&(this.plotTop=Math.max(this.plotTop,
	c[0]+b[0]));c[2]&&!D(d[2])&&(this.marginBottom=Math.max(this.marginBottom,c[2]+b[2]));this.legend&&this.legend.display&&this.legend.adjustMargins(d,b);k(this,"getMargins");a||this.getAxisMargins()},getAxisMargins:function(){var a=this,b=a.axisOffset=[0,0,0,0],d=a.colorAxis,c=a.margin,f=function(a){a.forEach(function(a){a.visible&&a.getOffset()})};a.hasCartesianSeries?f(a.axes):d&&d.length&&f(d);B.forEach(function(d,f){D(c[f])||(a[d]+=b[f])});a.setChartSize()},reflow:function(b){var d=this,f=d.options.chart,
	e=d.renderTo,k=D(f.width)&&D(f.height),l=f.width||c.getStyle(e,"width");f=f.height||c.getStyle(e,"height");e=b?b.target:R;if(!k&&!d.isPrinting&&l&&f&&(e===R||e===a)){if(l!==d.containerWidth||f!==d.containerHeight)c.clearTimeout(d.reflowTimeout),d.reflowTimeout=T(function(){d.container&&d.setSize(void 0,void 0,!1)},b?100:0);d.containerWidth=l;d.containerHeight=f}},setReflow:function(a){var b=this;!1===a||this.unbindReflow?!1===a&&this.unbindReflow&&(this.unbindReflow=this.unbindReflow()):(this.unbindReflow=
	p(R,"resize",function(a){b.options&&b.reflow(a)}),p(this,"destroy",this.unbindReflow))},setSize:function(a,d,f){var e=this,l=e.renderer;e.isResizing+=1;c.setAnimation(f,e);e.oldChartHeight=e.chartHeight;e.oldChartWidth=e.chartWidth;void 0!==a&&(e.options.chart.width=a);void 0!==d&&(e.options.chart.height=d);e.getChartSize();if(!e.styledMode){var t=l.globalAnimation;(t?g:E)(e.container,{width:e.chartWidth+"px",height:e.chartHeight+"px"},t)}e.setChartSize(!0);l.setSize(e.chartWidth,e.chartHeight,f);
	e.axes.forEach(function(a){a.isDirty=!0;a.setScale()});e.isDirtyLegend=!0;e.isDirtyBox=!0;e.layOutTitles();e.getMargins();e.redraw(f);e.oldChartHeight=null;k(e,"resize");T(function(){e&&k(e,"endResize",null,function(){--e.isResizing})},b(t).duration)},setChartSize:function(a){var b=this.inverted,d=this.renderer,c=this.chartWidth,f=this.chartHeight,e=this.options.chart,l=this.spacing,t=this.clipOffset,B,h,w,g;this.plotLeft=B=Math.round(this.plotLeft);this.plotTop=h=Math.round(this.plotTop);this.plotWidth=
	w=Math.max(0,Math.round(c-B-this.marginRight));this.plotHeight=g=Math.max(0,Math.round(f-h-this.marginBottom));this.plotSizeX=b?g:w;this.plotSizeY=b?w:g;this.plotBorderWidth=e.plotBorderWidth||0;this.spacingBox=d.spacingBox={x:l[3],y:l[0],width:c-l[3]-l[1],height:f-l[0]-l[2]};this.plotBox=d.plotBox={x:B,y:h,width:w,height:g};c=2*Math.floor(this.plotBorderWidth/2);b=Math.ceil(Math.max(c,t[3])/2);d=Math.ceil(Math.max(c,t[0])/2);this.clipBox={x:b,y:d,width:Math.floor(this.plotSizeX-Math.max(c,t[1])/
	2-b),height:Math.max(0,Math.floor(this.plotSizeY-Math.max(c,t[2])/2-d))};a||this.axes.forEach(function(a){a.setAxisSize();a.setAxisTranslation()});k(this,"afterSetChartSize",{skipAxes:a})},resetMargins:function(){k(this,"resetMargins");var a=this,b=a.options.chart;["margin","spacing"].forEach(function(d){var c=b[d],f=L(c)?c:[c,c,c,c];["Top","Right","Bottom","Left"].forEach(function(c,e){a[d][e]=l(b[d+c],f[e])})});B.forEach(function(b,d){a[b]=l(a.margin[d],a.spacing[d])});a.axisOffset=[0,0,0,0];a.clipOffset=
	[0,0,0,0]},drawChartBox:function(){var a=this.options.chart,b=this.renderer,d=this.chartWidth,c=this.chartHeight,f=this.chartBackground,e=this.plotBackground,l=this.plotBorder,t=this.styledMode,B=this.plotBGImage,h=a.backgroundColor,w=a.plotBackgroundColor,g=a.plotBackgroundImage,q,v=this.plotLeft,m=this.plotTop,I=this.plotWidth,p=this.plotHeight,r=this.plotBox,K=this.clipRect,x=this.clipBox,J="animate";f||(this.chartBackground=f=b.rect().addClass("highcharts-background").add(),J="attr");if(t)var n=
	q=f.strokeWidth();else{n=a.borderWidth||0;q=n+(a.shadow?8:0);h={fill:h||"none"};if(n||f["stroke-width"])h.stroke=a.borderColor,h["stroke-width"]=n;f.attr(h).shadow(a.shadow)}f[J]({x:q/2,y:q/2,width:d-q-n%2,height:c-q-n%2,r:a.borderRadius});J="animate";e||(J="attr",this.plotBackground=e=b.rect().addClass("highcharts-plot-background").add());e[J](r);t||(e.attr({fill:w||"none"}).shadow(a.plotShadow),g&&(B?B.animate(r):this.plotBGImage=b.image(g,v,m,I,p).add()));K?K.animate({width:x.width,height:x.height}):
	this.clipRect=b.clipRect(x);J="animate";l||(J="attr",this.plotBorder=l=b.rect().addClass("highcharts-plot-border").attr({zIndex:1}).add());t||l.attr({stroke:a.plotBorderColor,"stroke-width":a.plotBorderWidth||0,fill:"none"});l[J](l.crisp({x:v,y:m,width:I,height:p},-l.strokeWidth()));this.isDirtyBox=!1;k(this,"afterDrawChartBox")},propFromSeries:function(){var a=this,b=a.options.chart,d,c=a.options.series,f,e;["inverted","angular","polar"].forEach(function(k){d=K[b.type||b.defaultSeriesType];e=b[k]||
	d&&d.prototype[k];for(f=c&&c.length;!e&&f--;)(d=K[c[f].type])&&d.prototype[k]&&(e=!0);a[k]=e})},linkSeries:function(){var a=this,b=a.series;b.forEach(function(a){a.linkedSeries.length=0});b.forEach(function(b){var d=b.options.linkedTo;y(d)&&(d=":previous"===d?a.series[b.index-1]:a.get(d))&&d.linkedParent!==b&&(d.linkedSeries.push(b),b.linkedParent=d,b.visible=l(b.options.visible,d.options.visible,b.visible))});k(this,"afterLinkSeries")},renderSeries:function(){this.series.forEach(function(a){a.translate();
	a.render()})},renderLabels:function(){var a=this,b=a.options.labels;b.items&&b.items.forEach(function(d){var c=q(b.style,d.style),f=x(c.left)+a.plotLeft,e=x(c.top)+a.plotTop+12;delete c.left;delete c.top;a.renderer.text(d.html,f,e).attr({zIndex:2}).css(c).add()})},render:function(){var a=this.axes,b=this.colorAxis,d=this.renderer,c=this.options,f=0,e=function(a){a.forEach(function(a){a.visible&&a.render()})};this.setTitle();this.legend=new t(this,c.legend);this.getStacks&&this.getStacks();this.getMargins(!0);
	this.setChartSize();c=this.plotWidth;a.some(function(a){if(a.horiz&&a.visible&&a.options.labels.enabled&&a.series.length)return f=21,!0});var k=this.plotHeight=Math.max(this.plotHeight-f,0);a.forEach(function(a){a.setScale()});this.getAxisMargins();var l=1.1<c/this.plotWidth;var h=1.05<k/this.plotHeight;if(l||h)a.forEach(function(a){(a.horiz&&l||!a.horiz&&h)&&a.setTickInterval(!0)}),this.getMargins();this.drawChartBox();this.hasCartesianSeries?e(a):b&&b.length&&e(b);this.seriesGroup||(this.seriesGroup=
	d.g("series-group").attr({zIndex:3}).add());this.renderSeries();this.renderLabels();this.addCredits();this.setResponsive&&this.setResponsive();this.updateContainerScaling();this.hasRendered=!0},addCredits:function(a){var b=this;a=I(!0,this.options.credits,a);a.enabled&&!this.credits&&(this.credits=this.renderer.text(a.text+(this.mapCredits||""),0,0).addClass("highcharts-credits").on("click",function(){a.href&&(R.location.href=a.href)}).attr({align:a.position.align,zIndex:8}),b.styledMode||this.credits.css(a.style),
	this.credits.add().align(a.position),this.credits.update=function(a){b.credits=b.credits.destroy();b.addCredits(a)})},updateContainerScaling:function(){var a=this.container;if(a.offsetWidth&&a.offsetHeight&&a.getBoundingClientRect){var b=a.getBoundingClientRect(),d=b.width/a.offsetWidth;a=b.height/a.offsetHeight;1!==d||1!==a?this.containerScaling={scaleX:d,scaleY:a}:delete this.containerScaling}},destroy:function(){var a=this,b=a.axes,d=a.series,f=a.container,e,l=f&&f.parentNode;k(a,"destroy");a.renderer.forExport?
	F(r,a):r[a.index]=void 0;c.chartCount--;a.renderTo.removeAttribute("data-highcharts-chart");J(a);for(e=b.length;e--;)b[e]=b[e].destroy();this.scroller&&this.scroller.destroy&&this.scroller.destroy();for(e=d.length;e--;)d[e]=d[e].destroy();"title subtitle chartBackground plotBackground plotBGImage plotBorder seriesGroup clipRect credits pointer rangeSelector legend resetZoomButton tooltip renderer".split(" ").forEach(function(b){var d=a[b];d&&d.destroy&&(a[b]=d.destroy())});f&&(f.innerHTML="",J(f),
	l&&h(f));C(a,function(b,d){delete a[d]})},firstRender:function(){var a=this,b=a.options;if(!a.isReadyToRender||a.isReadyToRender()){a.getContainer();a.resetMargins();a.setChartSize();a.propFromSeries();a.getAxes();(z(b.series)?b.series:[]).forEach(function(b){a.initSeries(b)});a.linkSeries();k(a,"beforeRender");w&&(a.pointer=new w(a,b));a.render();if(!a.renderer.imgCount&&a.onload)a.onload();a.temporaryDisplay(!0)}},onload:function(){this.callbacks.concat([this.callback]).forEach(function(a){a&&void 0!==
	this.index&&a.apply(this,[this])},this);k(this,"load");k(this,"render");D(this.index)&&this.setReflow(this.options.chart.reflow);this.onload=null}})});N(H,"parts/ScrollablePlotArea.js",[H["parts/Globals.js"]],function(c){var n=c.addEvent,A=c.Chart;"";n(A,"afterSetChartSize",function(n){var A=this.options.chart.scrollablePlotArea,z=A&&A.minWidth;A=A&&A.minHeight;if(!this.renderer.forExport){if(z){if(this.scrollablePixelsX=z=Math.max(0,z-this.chartWidth)){this.plotWidth+=z;this.inverted?(this.clipBox.height+=
	z,this.plotBox.height+=z):(this.clipBox.width+=z,this.plotBox.width+=z);var u={1:{name:"right",value:z}}}}else A&&(this.scrollablePixelsY=z=Math.max(0,A-this.chartHeight))&&(this.plotHeight+=z,this.inverted?(this.clipBox.width+=z,this.plotBox.width+=z):(this.clipBox.height+=z,this.plotBox.height+=z),u={2:{name:"bottom",value:z}});u&&!n.skipAxes&&this.axes.forEach(function(n){u[n.side]?n.getPlotLinePath=function(){var y=u[n.side].name,z=this[y];this[y]=z-u[n.side].value;var x=c.Axis.prototype.getPlotLinePath.apply(this,
	arguments);this[y]=z;return x}:(n.setAxisSize(),n.setAxisTranslation())})}});n(A,"render",function(){this.scrollablePixelsX||this.scrollablePixelsY?(this.setUpScrolling&&this.setUpScrolling(),this.applyFixed()):this.fixedDiv&&this.applyFixed()});A.prototype.setUpScrolling=function(){var n={WebkitOverflowScrolling:"touch",overflowX:"hidden",overflowY:"hidden"};this.scrollablePixelsX&&(n.overflowX="auto");this.scrollablePixelsY&&(n.overflowY="auto");this.scrollingContainer=c.createElement("div",{className:"highcharts-scrolling"},
	n,this.renderTo);this.innerContainer=c.createElement("div",{className:"highcharts-inner-container"},null,this.scrollingContainer);this.innerContainer.appendChild(this.container);this.setUpScrolling=null};A.prototype.moveFixedElements=function(){var c=this.container,n=this.fixedRenderer,z=".highcharts-contextbutton .highcharts-credits .highcharts-legend .highcharts-reset-zoom .highcharts-subtitle .highcharts-title .highcharts-legend-checkbox".split(" "),u;this.scrollablePixelsX&&!this.inverted?u=".highcharts-yaxis":
	this.scrollablePixelsX&&this.inverted?u=".highcharts-xaxis":this.scrollablePixelsY&&!this.inverted?u=".highcharts-xaxis":this.scrollablePixelsY&&this.inverted&&(u=".highcharts-yaxis");z.push(u,u+"-labels");z.forEach(function(u){[].forEach.call(c.querySelectorAll(u),function(c){(c.namespaceURI===n.SVG_NS?n.box:n.box.parentNode).appendChild(c);c.style.pointerEvents="auto"})})};A.prototype.applyFixed=function(){var A,F=!this.fixedDiv,z=this.options.chart.scrollablePlotArea;F?(this.fixedDiv=c.createElement("div",
	{className:"highcharts-fixed"},{position:"absolute",overflow:"hidden",pointerEvents:"none",zIndex:2},null,!0),this.renderTo.insertBefore(this.fixedDiv,this.renderTo.firstChild),this.renderTo.style.overflow="visible",this.fixedRenderer=A=new c.Renderer(this.fixedDiv,this.chartWidth,this.chartHeight),this.scrollableMask=A.path().attr({fill:c.color(this.options.chart.backgroundColor||"#fff").setOpacity(c.pick(z.opacity,.85)).get(),zIndex:-1}).addClass("highcharts-scrollable-mask").add(),this.moveFixedElements(),
	n(this,"afterShowResetZoom",this.moveFixedElements)):this.fixedRenderer.setSize(this.chartWidth,this.chartHeight);A=this.chartWidth+(this.scrollablePixelsX||0);var u=this.chartHeight+(this.scrollablePixelsY||0);c.stop(this.container);this.container.style.width=A+"px";this.container.style.height=u+"px";this.renderer.boxWrapper.attr({width:A,height:u,viewBox:[0,0,A,u].join(" ")});this.chartBackground.attr({width:A,height:u});this.scrollablePixelsY&&(this.scrollingContainer.style.height=this.chartHeight+
	"px");F&&(z.scrollPositionX&&(this.scrollingContainer.scrollLeft=this.scrollablePixelsX*z.scrollPositionX),z.scrollPositionY&&(this.scrollingContainer.scrollTop=this.scrollablePixelsY*z.scrollPositionY));u=this.axisOffset;F=this.plotTop-u[0]-1;z=this.plotLeft-u[3]-1;A=this.plotTop+this.plotHeight+u[2]+1;u=this.plotLeft+this.plotWidth+u[1]+1;var L=this.plotLeft+this.plotWidth-(this.scrollablePixelsX||0),y=this.plotTop+this.plotHeight-(this.scrollablePixelsY||0);F=this.scrollablePixelsX?["M",0,F,"L",
	this.plotLeft-1,F,"L",this.plotLeft-1,A,"L",0,A,"Z","M",L,F,"L",this.chartWidth,F,"L",this.chartWidth,A,"L",L,A,"Z"]:this.scrollablePixelsY?["M",z,0,"L",z,this.plotTop-1,"L",u,this.plotTop-1,"L",u,0,"Z","M",z,y,"L",z,this.chartHeight,"L",u,this.chartHeight,"L",u,y,"Z"]:["M",0,0];"adjustHeight"!==this.redrawTrigger&&this.scrollableMask.attr({d:F})}});N(H,"parts/Point.js",[H["parts/Globals.js"],H["parts/Utilities.js"]],function(c,n){var A=n.defined,D=n.erase,F=n.isArray,z=n.isNumber,u=n.isObject,L,
	y=c.extend,C=c.fireEvent,x=c.format,m=c.pick,p=c.uniqueKey,g=c.removeEvent;c.Point=L=function(){};c.Point.prototype={init:function(b,a,d){this.series=b;this.applyOptions(a,d);this.id=A(this.id)?this.id:p();this.resolveColor();b.chart.pointCount++;C(this,"afterInit");return this},resolveColor:function(){var b=this.series;var a=b.chart.options.chart.colorCount;var d=b.chart.styledMode;d||this.options.color||(this.color=b.color);b.options.colorByPoint?(d||(a=b.options.colors||b.chart.options.colors,
	this.color=this.color||a[b.colorCounter],a=a.length),d=b.colorCounter,b.colorCounter++,b.colorCounter===a&&(b.colorCounter=0)):d=b.colorIndex;this.colorIndex=m(this.colorIndex,d)},applyOptions:function(b,a){var d=this.series,c=d.options.pointValKey||d.pointValKey;b=L.prototype.optionsToObject.call(this,b);y(this,b);this.options=this.options?y(this.options,b):b;b.group&&delete this.group;b.dataLabels&&delete this.dataLabels;c&&(this.y=this[c]);this.formatPrefix=(this.isNull=m(this.isValid&&!this.isValid(),
	null===this.x||!z(this.y)))?"null":"point";this.selected&&(this.state="select");"name"in this&&void 0===a&&d.xAxis&&d.xAxis.hasNames&&(this.x=d.xAxis.nameToX(this));void 0===this.x&&d&&(this.x=void 0===a?d.autoIncrement(this):a);return this},setNestedProperty:function(b,a,d){d.split(".").reduce(function(b,d,c,g){b[d]=g.length-1===c?a:u(b[d],!0)?b[d]:{};return b[d]},b);return b},optionsToObject:function(b){var a={},d=this.series,f=d.options.keys,e=f||d.pointArrayMap||["y"],h=e.length,g=0,m=0;if(z(b)||
	null===b)a[e[0]]=b;else if(F(b))for(!f&&b.length>h&&(d=typeof b[0],"string"===d?a.name=b[0]:"number"===d&&(a.x=b[0]),g++);m<h;)f&&void 0===b[g]||(0<e[m].indexOf(".")?c.Point.prototype.setNestedProperty(a,b[g],e[m]):a[e[m]]=b[g]),g++,m++;else"object"===typeof b&&(a=b,b.dataLabels&&(d._hasPointLabels=!0),b.marker&&(d._hasPointMarkers=!0));return a},getClassName:function(){return"highcharts-point"+(this.selected?" highcharts-point-select":"")+(this.negative?" highcharts-negative":"")+(this.isNull?" highcharts-null-point":
	"")+(void 0!==this.colorIndex?" highcharts-color-"+this.colorIndex:"")+(this.options.className?" "+this.options.className:"")+(this.zone&&this.zone.className?" "+this.zone.className.replace("highcharts-negative",""):"")},getZone:function(){var b=this.series,a=b.zones;b=b.zoneAxis||"y";var d=0,c;for(c=a[d];this[b]>=c.value;)c=a[++d];this.nonZonedColor||(this.nonZonedColor=this.color);this.color=c&&c.color&&!this.options.color?c.color:this.nonZonedColor;return c},destroy:function(){var b=this.series.chart,
	a=b.hoverPoints,d;b.pointCount--;a&&(this.setState(),D(a,this),a.length||(b.hoverPoints=null));if(this===b.hoverPoint)this.onMouseOut();if(this.graphic||this.dataLabel||this.dataLabels)g(this),this.destroyElements();this.legendItem&&b.legend.destroyItem(this);for(d in this)this[d]=null},destroyElements:function(b){var a=this,d=[],c;b=b||{graphic:1,dataLabel:1};b.graphic&&d.push("graphic","shadowGroup");b.dataLabel&&d.push("dataLabel","dataLabelUpper","connector");for(c=d.length;c--;){var e=d[c];a[e]&&
	(a[e]=a[e].destroy())}["dataLabel","connector"].forEach(function(d){var c=d+"s";b[d]&&a[c]&&(a[c].forEach(function(a){a.element&&a.destroy()}),delete a[c])})},getLabelConfig:function(){return{x:this.category,y:this.y,color:this.color,colorIndex:this.colorIndex,key:this.name||this.category,series:this.series,point:this,percentage:this.percentage,total:this.total||this.stackTotal}},tooltipFormatter:function(b){var a=this.series,d=a.tooltipOptions,c=m(d.valueDecimals,""),e=d.valuePrefix||"",h=d.valueSuffix||
	"";a.chart.styledMode&&(b=a.chart.tooltip.styledModeFormat(b));(a.pointArrayMap||["y"]).forEach(function(a){a="{point."+a;if(e||h)b=b.replace(RegExp(a+"}","g"),e+a+"}"+h);b=b.replace(RegExp(a+"}","g"),a+":,."+c+"f}")});return x(b,{point:this,series:this.series},a.chart.time)},firePointEvent:function(b,a,d){var c=this,e=this.series.options;(e.point.events[b]||c.options&&c.options.events&&c.options.events[b])&&this.importEvents();"click"===b&&e.allowPointSelect&&(d=function(a){c.select&&c.select(null,
	a.ctrlKey||a.metaKey||a.shiftKey)});C(this,b,a,d)},visible:!0}});N(H,"parts/Series.js",[H["parts/Globals.js"],H["parts/Utilities.js"]],function(c,n){var A=n.defined,D=n.erase,F=n.isArray,z=n.isNumber,u=n.isString,L=n.objectEach,y=n.splat,C=c.addEvent,x=c.animObject,m=c.arrayMax,p=c.arrayMin,g=c.correctFloat,b=c.defaultOptions,a=c.defaultPlotOptions,d=c.extend,f=c.fireEvent,e=c.merge,h=c.pick,r=c.removeEvent,E=c.SVGElement,q=c.syncTimeout,v=c.win;c.Series=c.seriesType("line",null,{lineWidth:2,allowPointSelect:!1,
	showCheckbox:!1,animation:{duration:1E3},events:{},marker:{lineWidth:0,lineColor:"#ffffff",enabledThreshold:2,radius:4,states:{normal:{animation:!0},hover:{animation:{duration:50},enabled:!0,radiusPlus:2,lineWidthPlus:1},select:{fillColor:"#cccccc",lineColor:"#000000",lineWidth:2}}},point:{events:{}},dataLabels:{align:"center",formatter:function(){return null===this.y?"":c.numberFormat(this.y,-1)},padding:5,style:{fontSize:"11px",fontWeight:"bold",color:"contrast",textOutline:"1px contrast"},verticalAlign:"bottom",
	x:0,y:0},cropThreshold:300,opacity:1,pointRange:0,softThreshold:!0,states:{normal:{animation:!0},hover:{animation:{duration:50},lineWidthPlus:1,marker:{},halo:{size:10,opacity:.25}},select:{animation:{duration:0}},inactive:{animation:{duration:50},opacity:.2}},stickyTracking:!0,turboThreshold:1E3,findNearestPointBy:"x"},{axisTypes:["xAxis","yAxis"],coll:"series",colorCounter:0,cropShoulder:1,directTouch:!1,isCartesian:!0,parallelArrays:["x","y"],pointClass:c.Point,requireSorting:!0,sorted:!0,init:function(a,
	b){f(this,"init",{options:b});var e=this,k=a.series,t;this.eventOptions=this.eventOptions||{};e.chart=a;e.options=b=e.setOptions(b);e.linkedSeries=[];e.bindAxes();d(e,{name:b.name,state:"",visible:!1!==b.visible,selected:!0===b.selected});var l=b.events;L(l,function(a,b){c.isFunction(a)&&e.eventOptions[b]!==a&&(c.isFunction(e.eventOptions[b])&&r(e,b,e.eventOptions[b]),e.eventOptions[b]=a,C(e,b,a))});if(l&&l.click||b.point&&b.point.events&&b.point.events.click||b.allowPointSelect)a.runTrackerClick=
	!0;e.getColor();e.getSymbol();e.parallelArrays.forEach(function(a){e[a+"Data"]||(e[a+"Data"]=[])});e.points||e.data||e.setData(b.data,!1);e.isCartesian&&(a.hasCartesianSeries=!0);k.length&&(t=k[k.length-1]);e._i=h(t&&t._i,-1)+1;a.orderSeries(this.insert(k));f(this,"afterInit")},insert:function(a){var b=this.options.index,d;if(z(b)){for(d=a.length;d--;)if(b>=h(a[d].options.index,a[d]._i)){a.splice(d+1,0,this);break}-1===d&&a.unshift(this);d+=1}else a.push(this);return h(d,a.length-1)},bindAxes:function(){var a=
	this,b=a.options,d=a.chart,e;f(this,"bindAxes",null,function(){(a.axisTypes||[]).forEach(function(f){d[f].forEach(function(d){e=d.options;if(b[f]===e.index||void 0!==b[f]&&b[f]===e.id||void 0===b[f]&&0===e.index)a.insert(d.series),a[f]=d,d.isDirty=!0});a[f]||a.optionalAxis===f||c.error(18,!0,d)})})},updateParallelArrays:function(a,b){var d=a.series,c=arguments,f=z(b)?function(c){var f="y"===c&&d.toYData?d.toYData(a):a[c];d[c+"Data"][b]=f}:function(a){Array.prototype[b].apply(d[a+"Data"],Array.prototype.slice.call(c,
	2))};d.parallelArrays.forEach(f)},hasData:function(){return this.visible&&void 0!==this.dataMax&&void 0!==this.dataMin||this.visible&&this.yData&&0<this.yData.length},autoIncrement:function(){var a=this.options,b=this.xIncrement,d,c=a.pointIntervalUnit,f=this.chart.time;b=h(b,a.pointStart,0);this.pointInterval=d=h(this.pointInterval,a.pointInterval,1);c&&(a=new f.Date(b),"day"===c?f.set("Date",a,f.get("Date",a)+d):"month"===c?f.set("Month",a,f.get("Month",a)+d):"year"===c&&f.set("FullYear",a,f.get("FullYear",
	a)+d),d=a.getTime()-b);this.xIncrement=b+d;return b},setOptions:function(a){var d=this.chart,c=d.options,k=c.plotOptions,w=d.userOptions||{};a=e(a);d=d.styledMode;var l={plotOptions:k,userOptions:a};f(this,"setOptions",l);var g=l.plotOptions[this.type],q=w.plotOptions||{};this.userOptions=l.userOptions;w=e(g,k.series,w.plotOptions&&w.plotOptions[this.type],a);this.tooltipOptions=e(b.tooltip,b.plotOptions.series&&b.plotOptions.series.tooltip,b.plotOptions[this.type].tooltip,c.tooltip.userOptions,k.series&&
	k.series.tooltip,k[this.type].tooltip,a.tooltip);this.stickyTracking=h(a.stickyTracking,q[this.type]&&q[this.type].stickyTracking,q.series&&q.series.stickyTracking,this.tooltipOptions.shared&&!this.noSharedTooltip?!0:w.stickyTracking);null===g.marker&&delete w.marker;this.zoneAxis=w.zoneAxis;c=this.zones=(w.zones||[]).slice();!w.negativeColor&&!w.negativeFillColor||w.zones||(k={value:w[this.zoneAxis+"Threshold"]||w.threshold||0,className:"highcharts-negative"},d||(k.color=w.negativeColor,k.fillColor=
	w.negativeFillColor),c.push(k));c.length&&A(c[c.length-1].value)&&c.push(d?{}:{color:this.color,fillColor:this.fillColor});f(this,"afterSetOptions",{options:w});return w},getName:function(){return h(this.options.name,"Series "+(this.index+1))},getCyclic:function(a,b,d){var c=this.chart,f=this.userOptions,e=a+"Index",k=a+"Counter",t=d?d.length:h(c.options.chart[a+"Count"],c[a+"Count"]);if(!b){var B=h(f[e],f["_"+e]);A(B)||(c.series.length||(c[k]=0),f["_"+e]=B=c[k]%t,c[k]+=1);d&&(b=d[B])}void 0!==B&&
	(this[e]=B);this[a]=b},getColor:function(){this.chart.styledMode?this.getCyclic("color"):this.options.colorByPoint?this.options.color=null:this.getCyclic("color",this.options.color||a[this.type].color,this.chart.options.colors)},getSymbol:function(){this.getCyclic("symbol",this.options.marker.symbol,this.chart.options.symbols)},findPointIndex:function(a,b){var d=a.id;a=a.x;var c=this.points,f;if(d){var e=(d=this.chart.get(d))&&d.index;void 0!==e&&(f=!0)}void 0===e&&z(a)&&(e=this.xData.indexOf(a,b));
	-1!==e&&void 0!==e&&this.cropped&&(e=e>=this.cropStart?e-this.cropStart:e);!f&&c[e]&&c[e].touched&&(e=void 0);return e},drawLegendSymbol:c.LegendSymbolMixin.drawLineMarker,updateData:function(a){var b=this.options,d=this.points,c=[],f,e,k,h=this.requireSorting,g=a.length===d.length,q=!0;this.xIncrement=null;a.forEach(function(a,e){var l=A(a)&&this.pointClass.prototype.optionsToObject.call({series:this},a)||{};var t=l.x;if(l.id||z(t))if(t=this.findPointIndex(l,k),-1===t||void 0===t?c.push(a):d[t]&&
	a!==b.data[t]?(d[t].update(a,!1,null,!1),d[t].touched=!0,h&&(k=t+1)):d[t]&&(d[t].touched=!0),!g||e!==t||this.hasDerivedData)f=!0},this);if(f)for(a=d.length;a--;)(e=d[a])&&!e.touched&&e.remove(!1);else g?a.forEach(function(a,b){d[b].update&&a!==d[b].y&&d[b].update(a,!1,null,!1)}):q=!1;d.forEach(function(a){a&&(a.touched=!1)});if(!q)return!1;c.forEach(function(a){this.addPoint(a,!1,null,null,!1)},this);return!0},setData:function(a,b,d,f){var e=this,k=e.points,t=k&&k.length||0,g,q=e.options,v=e.chart,
	m=null,B=e.xAxis,p=q.turboThreshold,I=this.xData,r=this.yData,x=(g=e.pointArrayMap)&&g.length,n=q.keys,y=0,E=1,A;a=a||[];g=a.length;b=h(b,!0);!1!==f&&g&&t&&!e.cropped&&!e.hasGroupedData&&e.visible&&!e.isSeriesBoosting&&(A=this.updateData(a));if(!A){e.xIncrement=null;e.colorCounter=0;this.parallelArrays.forEach(function(a){e[a+"Data"].length=0});if(p&&g>p){for(d=0;null===m&&d<g;)m=a[d],d++;if(z(m))for(d=0;d<g;d++)I[d]=this.autoIncrement(),r[d]=a[d];else if(F(m))if(x)for(d=0;d<g;d++)m=a[d],I[d]=m[0],
	r[d]=m.slice(1,x+1);else for(n&&(y=n.indexOf("x"),E=n.indexOf("y"),y=0<=y?y:0,E=0<=E?E:1),d=0;d<g;d++)m=a[d],I[d]=m[y],r[d]=m[E];else c.error(12,!1,v)}else for(d=0;d<g;d++)void 0!==a[d]&&(m={series:e},e.pointClass.prototype.applyOptions.apply(m,[a[d]]),e.updateParallelArrays(m,d));r&&u(r[0])&&c.error(14,!0,v);e.data=[];e.options.data=e.userOptions.data=a;for(d=t;d--;)k[d]&&k[d].destroy&&k[d].destroy();B&&(B.minRange=B.userMinRange);e.isDirty=v.isDirtyBox=!0;e.isDirtyData=!!k;d=!1}"point"===q.legendType&&
	(this.processData(),this.generatePoints());b&&v.redraw(d)},processData:function(a){var b=this.xData,d=this.yData,f=b.length;var e=0;var k=this.xAxis,h=this.options;var g=h.cropThreshold;var q=this.getExtremesFromAll||h.getExtremesFromAll,m=this.isCartesian;h=k&&k.val2lin;var v=k&&k.isLog,p=this.requireSorting;if(m&&!this.isDirty&&!k.isDirty&&!this.yAxis.isDirty&&!a)return!1;if(k){a=k.getExtremes();var r=a.min;var x=a.max}if(m&&this.sorted&&!q&&(!g||f>g||this.forceCrop))if(b[f-1]<r||b[0]>x)b=[],d=
	[];else if(this.yData&&(b[0]<r||b[f-1]>x)){e=this.cropData(this.xData,this.yData,r,x);b=e.xData;d=e.yData;e=e.start;var n=!0}for(g=b.length||1;--g;)if(f=v?h(b[g])-h(b[g-1]):b[g]-b[g-1],0<f&&(void 0===u||f<u))var u=f;else 0>f&&p&&(c.error(15,!1,this.chart),p=!1);this.cropped=n;this.cropStart=e;this.processedXData=b;this.processedYData=d;this.closestPointRange=this.basePointRange=u},cropData:function(a,b,d,c,f){var e=a.length,k=0,t=e,g;f=h(f,this.cropShoulder);for(g=0;g<e;g++)if(a[g]>=d){k=Math.max(0,
	g-f);break}for(d=g;d<e;d++)if(a[d]>c){t=d+f;break}return{xData:a.slice(k,t),yData:b.slice(k,t),start:k,end:t}},generatePoints:function(){var a=this.options,b=a.data,c=this.data,e,h=this.processedXData,l=this.processedYData,g=this.pointClass,q=h.length,m=this.cropStart||0,v=this.hasGroupedData;a=a.keys;var p=[],r;c||v||(c=[],c.length=b.length,c=this.data=c);a&&v&&(this.options.keys=!1);for(r=0;r<q;r++){var x=m+r;if(v){var n=(new g).init(this,[h[r]].concat(y(l[r])));n.dataGroup=this.groupMap[r];n.dataGroup.options&&
	(n.options=n.dataGroup.options,d(n,n.dataGroup.options),delete n.dataLabels)}else(n=c[x])||void 0===b[x]||(c[x]=n=(new g).init(this,b[x],h[r]));n&&(n.index=x,p[r]=n)}this.options.keys=a;if(c&&(q!==(e=c.length)||v))for(r=0;r<e;r++)r!==m||v||(r+=q),c[r]&&(c[r].destroyElements(),c[r].plotX=void 0);this.data=c;this.points=p;f(this,"afterGeneratePoints")},getXExtremes:function(a){return{min:p(a),max:m(a)}},getExtremes:function(a){var b=this.xAxis,d=this.yAxis,c=this.processedXData||this.xData,e=[],k=0,
	h=0;var g=0;var q=this.requireSorting?this.cropShoulder:0,v=d?d.positiveValuesOnly:!1,r;a=a||this.stackedYData||this.processedYData||[];d=a.length;b&&(g=b.getExtremes(),h=g.min,g=g.max);for(r=0;r<d;r++){var x=c[r];var n=a[r];var u=(z(n)||F(n))&&(n.length||0<n||!v);x=this.getExtremesFromAll||this.options.getExtremesFromAll||this.cropped||!b||(c[r+q]||x)>=h&&(c[r-q]||x)<=g;if(u&&x)if(u=n.length)for(;u--;)z(n[u])&&(e[k++]=n[u]);else e[k++]=n}this.dataMin=p(e);this.dataMax=m(e);f(this,"afterGetExtremes")},
	translate:function(){this.processedXData||this.processData();this.generatePoints();var a=this.options,b=a.stacking,d=this.xAxis,c=d.categories,e=this.yAxis,l=this.points,q=l.length,m=!!this.modifyValue,v,p=this.pointPlacementToXValue(),r=z(p),n=a.threshold,x=a.startFromThreshold?n:0,u,y=this.zoneAxis||"y",E=Number.MAX_VALUE;for(v=0;v<q;v++){var C=l[v],L=C.x;var D=C.y;var H=C.low,N=b&&e.stacks[(this.negStacks&&D<(x?0:n)?"-":"")+this.stackKey];e.positiveValuesOnly&&null!==D&&0>=D&&(C.isNull=!0);C.plotX=
	u=g(Math.min(Math.max(-1E5,d.translate(L,0,0,0,1,p,"flags"===this.type)),1E5));if(b&&this.visible&&N&&N[L]){var W=this.getStackIndicator(W,L,this.index);if(!C.isNull){var P=N[L];var X=P.points[W.key]}}F(X)&&(H=X[0],D=X[1],H===x&&W.key===N[L].base&&(H=h(z(n)&&n,e.min)),e.positiveValuesOnly&&0>=H&&(H=null),C.total=C.stackTotal=P.total,C.percentage=P.total&&C.y/P.total*100,C.stackY=D,this.irregularWidths||P.setOffset(this.pointXOffset||0,this.barW||0));C.yBottom=A(H)?Math.min(Math.max(-1E5,e.translate(H,
	0,1,0,1)),1E5):null;m&&(D=this.modifyValue(D,C));C.plotY=D="number"===typeof D&&Infinity!==D?Math.min(Math.max(-1E5,e.translate(D,0,1,0,1)),1E5):void 0;C.isInside=void 0!==D&&0<=D&&D<=e.len&&0<=u&&u<=d.len;C.clientX=r?g(d.translate(L,0,0,0,1,p)):u;C.negative=C[y]<(a[y+"Threshold"]||n||0);C.category=c&&void 0!==c[C.x]?c[C.x]:C.x;if(!C.isNull){void 0!==Y&&(E=Math.min(E,Math.abs(u-Y)));var Y=u}C.zone=this.zones.length&&C.getZone()}this.closestPointRangePx=E;f(this,"afterTranslate")},getValidPoints:function(a,
	b,d){var c=this.chart;return(a||this.points||[]).filter(function(a){return b&&!c.isInsidePlot(a.plotX,a.plotY,c.inverted)?!1:d||!a.isNull})},getClipBox:function(a,b){var d=this.options,c=this.chart,f=c.inverted,e=this.xAxis,k=e&&this.yAxis;a&&!1===d.clip&&k?a=f?{y:-c.chartWidth+k.len+k.pos,height:c.chartWidth,width:c.chartHeight,x:-c.chartHeight+e.len+e.pos}:{y:-k.pos,height:c.chartHeight,width:c.chartWidth,x:-e.pos}:(a=this.clipBox||c.clipBox,b&&(a.width=c.plotSizeX,a.x=0));return b?{width:a.width,
	x:a.x}:a},setClip:function(a){var b=this.chart,d=this.options,c=b.renderer,f=b.inverted,e=this.clipBox,k=this.getClipBox(a),h=this.sharedClipKey||["_sharedClip",a&&a.duration,a&&a.easing,k.height,d.xAxis,d.yAxis].join(),g=b[h],q=b[h+"m"];g||(a&&(k.width=0,f&&(k.x=b.plotSizeX+(!1!==d.clip?0:b.plotTop)),b[h+"m"]=q=c.clipRect(f?b.plotSizeX+99:-99,f?-b.plotLeft:-b.plotTop,99,f?b.chartWidth:b.chartHeight)),b[h]=g=c.clipRect(k),g.count={length:0});a&&!g.count[this.index]&&(g.count[this.index]=!0,g.count.length+=
	1);if(!1!==d.clip||a)this.group.clip(a||e?g:b.clipRect),this.markerGroup.clip(q),this.sharedClipKey=h;a||(g.count[this.index]&&(delete g.count[this.index],--g.count.length),0===g.count.length&&h&&b[h]&&(e||(b[h]=b[h].destroy()),b[h+"m"]&&(b[h+"m"]=b[h+"m"].destroy())))},animate:function(a){var b=this.chart,d=x(this.options.animation);if(a)this.setClip(d);else{var c=this.sharedClipKey;a=b[c];var f=this.getClipBox(d,!0);a&&a.animate(f,d);b[c+"m"]&&b[c+"m"].animate({width:f.width+99,x:f.x-(b.inverted?
	0:99)},d);this.animate=null}},afterAnimate:function(){this.setClip();f(this,"afterAnimate");this.finishedAnimating=!0},drawPoints:function(){var a=this.points,b=this.chart,d,c=this.options.marker,f=this[this.specialGroup]||this.markerGroup;var e=this.xAxis;var g=h(c.enabled,!e||e.isRadial?!0:null,this.closestPointRangePx>=c.enabledThreshold*c.radius);if(!1!==c.enabled||this._hasPointMarkers)for(e=0;e<a.length;e++){var q=a[e];var m=(d=q.graphic)?"animate":"attr";var v=q.marker||{};var p=!!q.marker;
	var r=g&&void 0===v.enabled||v.enabled;var n=!1!==q.isInside;if(r&&!q.isNull){r=h(v.symbol,this.symbol);var x=this.markerAttribs(q,q.selected&&"select");d?d[n?"show":"hide"](n).animate(x):n&&(0<x.width||q.hasImage)&&(q.graphic=d=b.renderer.symbol(r,x.x,x.y,x.width,x.height,p?v:c).add(f));if(d&&!b.styledMode)d[m](this.pointAttribs(q,q.selected&&"select"));d&&d.addClass(q.getClassName(),!0)}else d&&(q.graphic=d.destroy())}},markerAttribs:function(a,b){var d=this.options.marker,c=a.marker||{},f=c.symbol||
	d.symbol,e=h(c.radius,d.radius);b&&(d=d.states[b],b=c.states&&c.states[b],e=h(b&&b.radius,d&&d.radius,e+(d&&d.radiusPlus||0)));a.hasImage=f&&0===f.indexOf("url");a.hasImage&&(e=0);a={x:Math.floor(a.plotX)-e,y:a.plotY-e};e&&(a.width=a.height=2*e);return a},pointAttribs:function(a,b){var d=this.options.marker,c=a&&a.options,f=c&&c.marker||{},e=this.color,k=c&&c.color,t=a&&a.color;c=h(f.lineWidth,d.lineWidth);var g=a&&a.zone&&a.zone.color;a=1;e=k||g||t||e;k=f.fillColor||d.fillColor||e;e=f.lineColor||
	d.lineColor||e;b=b||"normal";d=d.states[b];b=f.states&&f.states[b]||{};c=h(b.lineWidth,d.lineWidth,c+h(b.lineWidthPlus,d.lineWidthPlus,0));k=b.fillColor||d.fillColor||k;e=b.lineColor||d.lineColor||e;a=h(b.opacity,d.opacity,a);return{stroke:e,"stroke-width":c,fill:k,opacity:a}},destroy:function(a){var b=this,d=b.chart,e=/AppleWebKit\/533/.test(v.navigator.userAgent),k,l,h=b.data||[],g,q;f(b,"destroy");a||r(b);(b.axisTypes||[]).forEach(function(a){(q=b[a])&&q.series&&(D(q.series,b),q.isDirty=q.forceRedraw=
	!0)});b.legendItem&&b.chart.legend.destroyItem(b);for(l=h.length;l--;)(g=h[l])&&g.destroy&&g.destroy();b.points=null;c.clearTimeout(b.animationTimeout);L(b,function(a,b){a instanceof E&&!a.survive&&(k=e&&"group"===b?"hide":"destroy",a[k]())});d.hoverSeries===b&&(d.hoverSeries=null);D(d.series,b);d.orderSeries();L(b,function(d,c){a&&"hcEvents"===c||delete b[c]})},getGraphPath:function(a,b,d){var c=this,f=c.options,e=f.step,k,h=[],t=[],g;a=a||c.points;(k=a.reversed)&&a.reverse();(e={right:1,center:2}[e]||
	e&&3)&&k&&(e=4-e);!f.connectNulls||b||d||(a=this.getValidPoints(a));a.forEach(function(k,l){var q=k.plotX,v=k.plotY,m=a[l-1];(k.leftCliff||m&&m.rightCliff)&&!d&&(g=!0);k.isNull&&!A(b)&&0<l?g=!f.connectNulls:k.isNull&&!b?g=!0:(0===l||g?l=["M",k.plotX,k.plotY]:c.getPointSpline?l=c.getPointSpline(a,k,l):e?(l=1===e?["L",m.plotX,v]:2===e?["L",(m.plotX+q)/2,m.plotY,"L",(m.plotX+q)/2,v]:["L",q,m.plotY],l.push("L",q,v)):l=["L",q,v],t.push(k.x),e&&(t.push(k.x),2===e&&t.push(k.x)),h.push.apply(h,l),g=!1)});
	h.xMap=t;return c.graphPath=h},drawGraph:function(){var a=this,b=this.options,d=(this.gappedPath||this.getGraphPath).call(this),c=this.chart.styledMode,f=[["graph","highcharts-graph"]];c||f[0].push(b.lineColor||this.color||"#cccccc",b.dashStyle);f=a.getZonesGraphs(f);f.forEach(function(f,e){var k=f[0],l=a[k],h=l?"animate":"attr";l?(l.endX=a.preventGraphAnimation?null:d.xMap,l.animate({d:d})):d.length&&(a[k]=l=a.chart.renderer.path(d).addClass(f[1]).attr({zIndex:1}).add(a.group));l&&!c&&(k={stroke:f[2],
	"stroke-width":b.lineWidth,fill:a.fillGraph&&a.color||"none"},f[3]?k.dashstyle=f[3]:"square"!==b.linecap&&(k["stroke-linecap"]=k["stroke-linejoin"]="round"),l[h](k).shadow(2>e&&b.shadow));l&&(l.startX=d.xMap,l.isArea=d.isArea)})},getZonesGraphs:function(a){this.zones.forEach(function(b,d){d=["zone-graph-"+d,"highcharts-graph highcharts-zone-graph-"+d+" "+(b.className||"")];this.chart.styledMode||d.push(b.color||this.color,b.dashStyle||this.options.dashStyle);a.push(d)},this);return a},applyZones:function(){var a=
	this,b=this.chart,d=b.renderer,c=this.zones,f,e,g=this.clips||[],q,m=this.graph,v=this.area,p=Math.max(b.chartWidth,b.chartHeight),r=this[(this.zoneAxis||"y")+"Axis"],n=b.inverted,x,u,y,E=!1;if(c.length&&(m||v)&&r&&void 0!==r.min){var z=r.reversed;var A=r.horiz;m&&!this.showLine&&m.hide();v&&v.hide();var C=r.getExtremes();c.forEach(function(c,k){f=z?A?b.plotWidth:0:A?0:r.toPixels(C.min)||0;f=Math.min(Math.max(h(e,f),0),p);e=Math.min(Math.max(Math.round(r.toPixels(h(c.value,C.max),!0)||0),0),p);E&&
	(f=e=r.toPixels(C.max));x=Math.abs(f-e);u=Math.min(f,e);y=Math.max(f,e);r.isXAxis?(q={x:n?y:u,y:0,width:x,height:p},A||(q.x=b.plotHeight-q.x)):(q={x:0,y:n?y:u,width:p,height:x},A&&(q.y=b.plotWidth-q.y));n&&d.isVML&&(q=r.isXAxis?{x:0,y:z?u:y,height:q.width,width:b.chartWidth}:{x:q.y-b.plotLeft-b.spacingBox.x,y:0,width:q.height,height:b.chartHeight});g[k]?g[k].animate(q):g[k]=d.clipRect(q);m&&a["zone-graph-"+k].clip(g[k]);v&&a["zone-area-"+k].clip(g[k]);E=c.value>C.max;a.resetZones&&0===e&&(e=void 0)});
	this.clips=g}else a.visible&&(m&&m.show(!0),v&&v.show(!0))},invertGroups:function(a){function b(){["group","markerGroup"].forEach(function(b){d[b]&&(c.renderer.isVML&&d[b].attr({width:d.yAxis.len,height:d.xAxis.len}),d[b].width=d.yAxis.len,d[b].height=d.xAxis.len,d[b].invert(a))})}var d=this,c=d.chart;if(d.xAxis){var f=C(c,"resize",b);C(d,"destroy",f);b(a);d.invertGroups=b}},plotGroup:function(a,b,d,c,f){var e=this[a],k=!e;k&&(this[a]=e=this.chart.renderer.g().attr({zIndex:c||.1}).add(f));e.addClass("highcharts-"+
	b+" highcharts-series-"+this.index+" highcharts-"+this.type+"-series "+(A(this.colorIndex)?"highcharts-color-"+this.colorIndex+" ":"")+(this.options.className||"")+(e.hasClass("highcharts-tracker")?" highcharts-tracker":""),!0);e.attr({visibility:d})[k?"attr":"animate"](this.getPlotBox());return e},getPlotBox:function(){var a=this.chart,b=this.xAxis,d=this.yAxis;a.inverted&&(b=d,d=this.xAxis);return{translateX:b?b.left:a.plotLeft,translateY:d?d.top:a.plotTop,scaleX:1,scaleY:1}},render:function(){var a=
	this,b=a.chart,d=a.options,c=!!a.animate&&b.renderer.isSVG&&x(d.animation).duration,e=a.visible?"inherit":"hidden",l=d.zIndex,h=a.hasRendered,g=b.seriesGroup,m=b.inverted;f(this,"render");var v=a.plotGroup("group","series",e,l,g);a.markerGroup=a.plotGroup("markerGroup","markers",e,l,g);c&&a.animate(!0);v.inverted=a.isCartesian||a.invertable?m:!1;a.drawGraph&&(a.drawGraph(),a.applyZones());a.visible&&a.drawPoints();a.drawDataLabels&&a.drawDataLabels();a.redrawPoints&&a.redrawPoints();a.drawTracker&&
	!1!==a.options.enableMouseTracking&&a.drawTracker();a.invertGroups(m);!1===d.clip||a.sharedClipKey||h||v.clip(b.clipRect);c&&a.animate();h||(a.animationTimeout=q(function(){a.afterAnimate()},c));a.isDirty=!1;a.hasRendered=!0;f(a,"afterRender")},redraw:function(){var a=this.chart,b=this.isDirty||this.isDirtyData,d=this.group,c=this.xAxis,f=this.yAxis;d&&(a.inverted&&d.attr({width:a.plotWidth,height:a.plotHeight}),d.animate({translateX:h(c&&c.left,a.plotLeft),translateY:h(f&&f.top,a.plotTop)}));this.translate();
	this.render();b&&delete this.kdTree},kdAxisArray:["clientX","plotY"],searchPoint:function(a,b){var d=this.xAxis,c=this.yAxis,f=this.chart.inverted;return this.searchKDTree({clientX:f?d.len-a.chartY+d.pos:a.chartX-d.pos,plotY:f?c.len-a.chartX+c.pos:a.chartY-c.pos},b,a)},buildKDTree:function(a){function b(a,c,f){var e;if(e=a&&a.length){var k=d.kdAxisArray[c%f];a.sort(function(a,b){return a[k]-b[k]});e=Math.floor(e/2);return{point:a[e],left:b(a.slice(0,e),c+1,f),right:b(a.slice(e+1),c+1,f)}}}this.buildingKdTree=
	!0;var d=this,c=-1<d.options.findNearestPointBy.indexOf("y")?2:1;delete d.kdTree;q(function(){d.kdTree=b(d.getValidPoints(null,!d.directTouch),c,c);d.buildingKdTree=!1},d.options.kdNow||a&&"touchstart"===a.type?0:1)},searchKDTree:function(a,b,d){function c(a,b,d,l){var g=b.point,q=f.kdAxisArray[d%l],t=g;var m=A(a[e])&&A(g[e])?Math.pow(a[e]-g[e],2):null;var v=A(a[k])&&A(g[k])?Math.pow(a[k]-g[k],2):null;v=(m||0)+(v||0);g.dist=A(v)?Math.sqrt(v):Number.MAX_VALUE;g.distX=A(m)?Math.sqrt(m):Number.MAX_VALUE;
	q=a[q]-g[q];v=0>q?"left":"right";m=0>q?"right":"left";b[v]&&(v=c(a,b[v],d+1,l),t=v[h]<t[h]?v:g);b[m]&&Math.sqrt(q*q)<t[h]&&(a=c(a,b[m],d+1,l),t=a[h]<t[h]?a:t);return t}var f=this,e=this.kdAxisArray[0],k=this.kdAxisArray[1],h=b?"distX":"dist";b=-1<f.options.findNearestPointBy.indexOf("y")?2:1;this.kdTree||this.buildingKdTree||this.buildKDTree(d);if(this.kdTree)return c(a,this.kdTree,b,b)},pointPlacementToXValue:function(){var a=this.options.pointPlacement;"between"===a&&(a=.5);z(a)&&(a*=h(this.options.pointRange||
	this.xAxis.pointRange));return a}});""});N(H,"parts/Stacking.js",[H["parts/Globals.js"],H["parts/Utilities.js"]],function(c,n){var A=n.defined,D=n.objectEach;n=c.Axis;var F=c.Chart,z=c.correctFloat,u=c.destroyObjectProperties,L=c.format,y=c.pick,C=c.Series;c.StackItem=function(c,m,p,g,b){var a=c.chart.inverted;this.axis=c;this.isNegative=p;this.options=m=m||{};this.x=g;this.total=null;this.points={};this.stack=b;this.rightCliff=this.leftCliff=0;this.alignOptions={align:m.align||(a?p?"left":"right":
	"center"),verticalAlign:m.verticalAlign||(a?"middle":p?"bottom":"top"),y:m.y,x:m.x};this.textAlign=m.textAlign||(a?p?"right":"left":"center")};c.StackItem.prototype={destroy:function(){u(this,this.axis)},render:function(c){var m=this.axis.chart,p=this.options,g=p.format;g=g?L(g,this,m.time):p.formatter.call(this);this.label?this.label.attr({text:g,visibility:"hidden"}):(this.label=m.renderer.label(g,null,null,p.shape,null,null,p.useHTML,!1,"stack-labels"),g={text:g,align:this.textAlign,rotation:p.rotation,
	padding:y(p.padding,0),visibility:"hidden"},this.label.attr(g),m.styledMode||this.label.css(p.style),this.label.added||this.label.add(c));this.label.labelrank=m.plotHeight},setOffset:function(c,m,p,g,b){var a=this.axis,d=a.chart;g=a.translate(a.usePercentage?100:g?g:this.total,0,0,0,1);p=a.translate(p?p:0);p=A(g)&&Math.abs(g-p);c=y(b,d.xAxis[0].translate(this.x))+c;a=A(g)&&this.getStackBox(d,this,c,g,m,p,a);m=this.label;c=this.isNegative;b="justify"===y(this.options.overflow,"justify");if(m&&a){p=
	m.getBBox();var f=d.inverted?c?p.width:0:p.width/2,e=d.inverted?p.height/2:c?-4:p.height+4;this.alignOptions.x=y(this.options.x,0);m.align(this.alignOptions,null,a);g=m.alignAttr;m.show();g.y-=e;b&&(g.x-=f,C.prototype.justifyDataLabel.call(this.axis,m,this.alignOptions,g,p,a),g.x+=f);g.x=m.alignAttr.x;m.attr({x:g.x,y:g.y});y(!b&&this.options.crop,!0)&&((d=d.isInsidePlot(m.x+(d.inverted?0:-p.width/2),m.y)&&d.isInsidePlot(m.x+(d.inverted?c?-p.width:p.width:p.width/2),m.y+p.height))||m.hide())}},getStackBox:function(c,
	m,p,g,b,a,d){var f=m.axis.reversed,e=c.inverted;c=d.height+d.pos-(e?c.plotLeft:c.plotTop);m=m.isNegative&&!f||!m.isNegative&&f;return{x:e?m?g:g-a:p,y:e?c-p-b:m?c-g-a:c-g,width:e?a:b,height:e?b:a}}};F.prototype.getStacks=function(){var c=this,m=c.inverted;c.yAxis.forEach(function(c){c.stacks&&c.hasVisibleSeries&&(c.oldStacks=c.stacks)});c.series.forEach(function(p){var g=p.xAxis&&p.xAxis.options||{};!p.options.stacking||!0!==p.visible&&!1!==c.options.chart.ignoreHiddenSeries||(p.stackKey=[p.type,y(p.options.stack,
	""),m?g.top:g.left,m?g.height:g.width].join())})};n.prototype.buildStacks=function(){var c=this.series,m=y(this.options.reversedStacks,!0),p=c.length,g;if(!this.isXAxis){this.usePercentage=!1;for(g=p;g--;)c[m?g:p-g-1].setStackedPoints();for(g=0;g<p;g++)c[g].modifyStacks()}};n.prototype.renderStackTotals=function(){var c=this.chart,m=c.renderer,p=this.stacks,g=this.stackTotalGroup;g||(this.stackTotalGroup=g=m.g("stack-labels").attr({visibility:"visible",zIndex:6}).add());g.translate(c.plotLeft,c.plotTop);
	D(p,function(b){D(b,function(a){a.render(g)})})};n.prototype.resetStacks=function(){var c=this,m=c.stacks;c.isXAxis||D(m,function(m){D(m,function(g,b){g.touched<c.stacksTouched?(g.destroy(),delete m[b]):(g.total=null,g.cumulative=null)})})};n.prototype.cleanStacks=function(){if(!this.isXAxis){if(this.oldStacks)var c=this.stacks=this.oldStacks;D(c,function(c){D(c,function(c){c.cumulative=c.total})})}};C.prototype.setStackedPoints=function(){if(this.options.stacking&&(!0===this.visible||!1===this.chart.options.chart.ignoreHiddenSeries)){var n=
	this.processedXData,m=this.processedYData,p=[],g=m.length,b=this.options,a=b.threshold,d=y(b.startFromThreshold&&a,0),f=b.stack;b=b.stacking;var e=this.stackKey,h="-"+e,r=this.negStacks,u=this.yAxis,q=u.stacks,v=u.oldStacks,k,t;u.stacksTouched+=1;for(t=0;t<g;t++){var B=n[t];var I=m[t];var w=this.getStackIndicator(w,B,this.index);var l=w.key;var J=(k=r&&I<(d?0:a))?h:e;q[J]||(q[J]={});q[J][B]||(v[J]&&v[J][B]?(q[J][B]=v[J][B],q[J][B].total=null):q[J][B]=new c.StackItem(u,u.options.stackLabels,k,B,f));
	J=q[J][B];null!==I?(J.points[l]=J.points[this.index]=[y(J.cumulative,d)],A(J.cumulative)||(J.base=l),J.touched=u.stacksTouched,0<w.index&&!1===this.singleStacks&&(J.points[l][0]=J.points[this.index+","+B+",0"][0])):J.points[l]=J.points[this.index]=null;"percent"===b?(k=k?e:h,r&&q[k]&&q[k][B]?(k=q[k][B],J.total=k.total=Math.max(k.total,J.total)+Math.abs(I)||0):J.total=z(J.total+(Math.abs(I)||0))):J.total=z(J.total+(I||0));J.cumulative=y(J.cumulative,d)+(I||0);null!==I&&(J.points[l].push(J.cumulative),
	p[t]=J.cumulative)}"percent"===b&&(u.usePercentage=!0);this.stackedYData=p;u.oldStacks={}}};C.prototype.modifyStacks=function(){var c=this,m=c.stackKey,p=c.yAxis.stacks,g=c.processedXData,b,a=c.options.stacking;c[a+"Stacker"]&&[m,"-"+m].forEach(function(d){for(var f=g.length,e,h;f--;)if(e=g[f],b=c.getStackIndicator(b,e,c.index,d),h=(e=p[d]&&p[d][e])&&e.points[b.key])c[a+"Stacker"](h,e,f)})};C.prototype.percentStacker=function(c,m,p){m=m.total?100/m.total:0;c[0]=z(c[0]*m);c[1]=z(c[1]*m);this.stackedYData[p]=
	c[1]};C.prototype.getStackIndicator=function(c,m,p,g){!A(c)||c.x!==m||g&&c.key!==g?c={x:m,index:0,key:g}:c.index++;c.key=[p,m,c.index].join();return c}});N(H,"parts/Dynamics.js",[H["parts/Globals.js"],H["parts/Utilities.js"]],function(c,n){var A=n.defined,D=n.erase,F=n.isArray,z=n.isNumber,u=n.isObject,L=n.isString,y=n.objectEach,C=n.splat,x=c.addEvent,m=c.animate,p=c.Axis;n=c.Chart;var g=c.createElement,b=c.css,a=c.extend,d=c.fireEvent,f=c.merge,e=c.pick,h=c.Point,r=c.Series,E=c.seriesTypes,q=c.setAnimation;
	c.cleanRecursively=function(a,b){var d={};y(a,function(f,e){if(u(a[e],!0)&&!a.nodeType&&b[e])f=c.cleanRecursively(a[e],b[e]),Object.keys(f).length&&(d[e]=f);else if(u(a[e])||a[e]!==b[e])d[e]=a[e]});return d};a(n.prototype,{addSeries:function(a,b,c){var f,k=this;a&&(b=e(b,!0),d(k,"addSeries",{options:a},function(){f=k.initSeries(a);k.isDirtyLegend=!0;k.linkSeries();d(k,"afterAddSeries",{series:f});b&&k.redraw(c)}));return f},addAxis:function(a,b,d,c){return this.createAxis(b?"xAxis":"yAxis",{axis:a,
	redraw:d,animation:c})},addColorAxis:function(a,b,d){return this.createAxis("colorAxis",{axis:a,redraw:b,animation:d})},createAxis:function(a,b){var d=this.options,k="colorAxis"===a,h=b.redraw,g=b.animation;b=f(b.axis,{index:this[a].length,isX:"xAxis"===a});var l=k?new c.ColorAxis(this,b):new p(this,b);d[a]=C(d[a]||{});d[a].push(b);k&&(this.isDirtyLegend=!0);e(h,!0)&&this.redraw(g);return l},showLoading:function(d){var c=this,f=c.options,h=c.loadingDiv,q=f.loading,v=function(){h&&b(h,{left:c.plotLeft+
	"px",top:c.plotTop+"px",width:c.plotWidth+"px",height:c.plotHeight+"px"})};h||(c.loadingDiv=h=g("div",{className:"highcharts-loading highcharts-loading-hidden"},null,c.container),c.loadingSpan=g("span",{className:"highcharts-loading-inner"},null,h),x(c,"redraw",v));h.className="highcharts-loading";c.loadingSpan.innerHTML=e(d,f.lang.loading,"");c.styledMode||(b(h,a(q.style,{zIndex:10})),b(c.loadingSpan,q.labelStyle),c.loadingShown||(b(h,{opacity:0,display:""}),m(h,{opacity:q.style.opacity||.5},{duration:q.showDuration||
	0})));c.loadingShown=!0;v()},hideLoading:function(){var a=this.options,d=this.loadingDiv;d&&(d.className="highcharts-loading highcharts-loading-hidden",this.styledMode||m(d,{opacity:0},{duration:a.loading.hideDuration||100,complete:function(){b(d,{display:"none"})}}));this.loadingShown=!1},propsRequireDirtyBox:"backgroundColor borderColor borderWidth borderRadius plotBackgroundColor plotBackgroundImage plotBorderColor plotBorderWidth plotShadow shadow".split(" "),propsRequireReflow:"margin marginTop marginRight marginBottom marginLeft spacing spacingTop spacingRight spacingBottom spacingLeft".split(" "),
	propsRequireUpdateSeries:"chart.inverted chart.polar chart.ignoreHiddenSeries chart.type colors plotOptions time tooltip".split(" "),collectionsWithUpdate:"xAxis yAxis zAxis series colorAxis pane".split(" "),update:function(a,b,h,g){var k=this,q={credits:"addCredits",title:"setTitle",subtitle:"setSubtitle",caption:"setCaption"},l,m,t,v=a.isResponsiveOptions,r=[];d(k,"update",{options:a});v||k.setResponsive(!1,!0);a=c.cleanRecursively(a,k.options);f(!0,k.userOptions,a);if(l=a.chart){f(!0,k.options.chart,
	l);"className"in l&&k.setClassName(l.className);"reflow"in l&&k.setReflow(l.reflow);if("inverted"in l||"polar"in l||"type"in l){k.propFromSeries();var p=!0}"alignTicks"in l&&(p=!0);y(l,function(a,b){-1!==k.propsRequireUpdateSeries.indexOf("chart."+b)&&(m=!0);-1!==k.propsRequireDirtyBox.indexOf(b)&&(k.isDirtyBox=!0);v||-1===k.propsRequireReflow.indexOf(b)||(t=!0)});!k.styledMode&&"style"in l&&k.renderer.setStyle(l.style)}!k.styledMode&&a.colors&&(this.options.colors=a.colors);a.plotOptions&&f(!0,this.options.plotOptions,
	a.plotOptions);a.time&&this.time===c.time&&(this.time=new c.Time(a.time));y(a,function(a,b){if(k[b]&&"function"===typeof k[b].update)k[b].update(a,!1);else if("function"===typeof k[q[b]])k[q[b]](a);"chart"!==b&&-1!==k.propsRequireUpdateSeries.indexOf(b)&&(m=!0)});this.collectionsWithUpdate.forEach(function(b){if(a[b]){if("series"===b){var d=[];k[b].forEach(function(a,b){a.options.isInternal||d.push(e(a.options.index,b))})}C(a[b]).forEach(function(a,c){(c=A(a.id)&&k.get(a.id)||k[b][d?d[c]:c])&&c.coll===
	b&&(c.update(a,!1),h&&(c.touched=!0));!c&&h&&k.collectionsWithInit[b]&&(k.collectionsWithInit[b][0].apply(k,[a].concat(k.collectionsWithInit[b][1]||[]).concat([!1])).touched=!0)});h&&k[b].forEach(function(a){a.touched||a.options.isInternal?delete a.touched:r.push(a)})}});r.forEach(function(a){a.remove&&a.remove(!1)});p&&k.axes.forEach(function(a){a.update({},!1)});m&&k.series.forEach(function(a){a.update({},!1)});a.loading&&f(!0,k.options.loading,a.loading);p=l&&l.width;l=l&&l.height;L(l)&&(l=c.relativeLength(l,
	p||k.chartWidth));t||z(p)&&p!==k.chartWidth||z(l)&&l!==k.chartHeight?k.setSize(p,l,g):e(b,!0)&&k.redraw(g);d(k,"afterUpdate",{options:a,redraw:b,animation:g})},setSubtitle:function(a,b){this.applyDescription("subtitle",a);this.layOutTitles(b)},setCaption:function(a,b){this.applyDescription("caption",a);this.layOutTitles(b)}});n.prototype.collectionsWithInit={xAxis:[n.prototype.addAxis,[!0]],yAxis:[n.prototype.addAxis,[!1]],colorAxis:[n.prototype.addColorAxis,[!1]],series:[n.prototype.addSeries]};
	a(h.prototype,{update:function(a,b,d,c){function f(){k.applyOptions(a);null===k.y&&h&&(k.graphic=h.destroy());u(a,!0)&&(h&&h.element&&a&&a.marker&&void 0!==a.marker.symbol&&(k.graphic=h.destroy()),a&&a.dataLabels&&k.dataLabel&&(k.dataLabel=k.dataLabel.destroy()),k.connector&&(k.connector=k.connector.destroy()));g=k.index;l.updateParallelArrays(k,g);m.data[g]=u(m.data[g],!0)||u(a,!0)?k.options:e(a,m.data[g]);l.isDirty=l.isDirtyData=!0;!l.fixedBox&&l.hasCartesianSeries&&(q.isDirtyBox=!0);"point"===
	m.legendType&&(q.isDirtyLegend=!0);b&&q.redraw(d)}var k=this,l=k.series,h=k.graphic,g,q=l.chart,m=l.options;b=e(b,!0);!1===c?f():k.firePointEvent("update",{options:a},f)},remove:function(a,b){this.series.removePoint(this.series.data.indexOf(this),a,b)}});a(r.prototype,{addPoint:function(a,b,c,f,h){var k=this.options,l=this.data,g=this.chart,q=this.xAxis;q=q&&q.hasNames&&q.names;var m=k.data,t=this.xData,v;b=e(b,!0);var r={series:this};this.pointClass.prototype.applyOptions.apply(r,[a]);var p=r.x;
	var n=t.length;if(this.requireSorting&&p<t[n-1])for(v=!0;n&&t[n-1]>p;)n--;this.updateParallelArrays(r,"splice",n,0,0);this.updateParallelArrays(r,n);q&&r.name&&(q[p]=r.name);m.splice(n,0,a);v&&(this.data.splice(n,0,null),this.processData());"point"===k.legendType&&this.generatePoints();c&&(l[0]&&l[0].remove?l[0].remove(!1):(l.shift(),this.updateParallelArrays(r,"shift"),m.shift()));!1!==h&&d(this,"addPoint",{point:r});this.isDirtyData=this.isDirty=!0;b&&g.redraw(f)},removePoint:function(a,b,d){var c=
	this,f=c.data,k=f[a],l=c.points,h=c.chart,g=function(){l&&l.length===f.length&&l.splice(a,1);f.splice(a,1);c.options.data.splice(a,1);c.updateParallelArrays(k||{series:c},"splice",a,1);k&&k.destroy();c.isDirty=!0;c.isDirtyData=!0;b&&h.redraw()};q(d,h);b=e(b,!0);k?k.firePointEvent("remove",null,g):g()},remove:function(a,b,c,f){function k(){h.destroy(f);h.remove=null;l.isDirtyLegend=l.isDirtyBox=!0;l.linkSeries();e(a,!0)&&l.redraw(b)}var h=this,l=h.chart;!1!==c?d(h,"remove",null,k):k()},update:function(b,
	k){b=c.cleanRecursively(b,this.userOptions);d(this,"update",{options:b});var h=this,g=h.chart,q=h.userOptions,m=h.initialType||h.type,l=b.type||q.type||g.options.chart.type,r=!(this.hasDerivedData||b.dataGrouping||l&&l!==this.type||void 0!==b.pointStart||b.pointInterval||b.pointIntervalUnit||b.keys),p=E[m].prototype,v,n=["group","markerGroup","dataLabelsGroup","transformGroup"],u=["eventOptions","navigatorSeries","baseSeries"],x=h.finishedAnimating&&{animation:!1},y={};r&&(u.push("data","isDirtyData",
	"points","processedXData","processedYData","xIncrement","_hasPointMarkers","_hasPointLabels","mapMap","mapData","minY","maxY","minX","maxX"),!1!==b.visible&&u.push("area","graph"),h.parallelArrays.forEach(function(a){u.push(a+"Data")}),b.data&&this.setData(b.data,!1));b=f(q,x,{index:void 0===q.index?h.index:q.index,pointStart:e(q.pointStart,h.xData[0])},!r&&{data:h.options.data},b);r&&b.data&&(b.data=h.options.data);u=n.concat(u);u.forEach(function(a){u[a]=h[a];delete h[a]});h.remove(!1,null,!1,!0);
	for(v in p)h[v]=void 0;E[l||m]?a(h,E[l||m].prototype):c.error(17,!0,g);u.forEach(function(a){h[a]=u[a]});h.init(g,b);if(r&&this.points){var z=h.options;!1===z.visible?(y.graphic=1,y.dataLabel=1):h._hasPointLabels||(l=z.marker,p=z.dataLabels,l&&(!1===l.enabled||"symbol"in l)&&(y.graphic=1),p&&!1===p.enabled&&(y.dataLabel=1));this.points.forEach(function(a){a&&a.series&&(a.resolveColor(),Object.keys(y).length&&a.destroyElements(y),!1===z.showInLegend&&a.legendItem&&g.legend.destroyItem(a))},this)}b.zIndex!==
	q.zIndex&&n.forEach(function(a){h[a]&&h[a].attr({zIndex:b.zIndex})});h.initialType=m;g.linkSeries();d(this,"afterUpdate");e(k,!0)&&g.redraw(r?void 0:!1)},setName:function(a){this.name=this.options.name=this.userOptions.name=a;this.chart.isDirtyLegend=!0}});a(p.prototype,{update:function(b,d){var c=this.chart,k=b&&b.events||{};b=f(this.userOptions,b);c.options[this.coll].indexOf&&(c.options[this.coll][c.options[this.coll].indexOf(this.userOptions)]=b);y(c.options[this.coll].events,function(a,b){"undefined"===
	typeof k[b]&&(k[b]=void 0)});this.destroy(!0);this.init(c,a(b,{events:k}));c.isDirtyBox=!0;e(d,!0)&&c.redraw()},remove:function(a){for(var b=this.chart,d=this.coll,c=this.series,f=c.length;f--;)c[f]&&c[f].remove(!1);D(b.axes,this);D(b[d],this);F(b.options[d])?b.options[d].splice(this.options.index,1):delete b.options[d];b[d].forEach(function(a,b){a.options.index=a.userOptions.index=b});this.destroy();b.isDirtyBox=!0;e(a,!0)&&b.redraw()},setTitle:function(a,b){this.update({title:a},b)},setCategories:function(a,
	b){this.update({categories:a},b)}})});N(H,"parts/AreaSeries.js",[H["parts/Globals.js"],H["parts/Utilities.js"]],function(c,n){var A=n.objectEach,D=c.color,F=c.pick,z=c.Series;n=c.seriesType;n("area","line",{softThreshold:!1,threshold:0},{singleStacks:!1,getStackPoints:function(c){var n=[],u=[],z=this.xAxis,x=this.yAxis,m=x.stacks[this.stackKey],p={},g=this.index,b=x.series,a=b.length,d=F(x.options.reversedStacks,!0)?1:-1,f;c=c||this.points;if(this.options.stacking){for(f=0;f<c.length;f++)c[f].leftNull=
	c[f].rightNull=null,p[c[f].x]=c[f];A(m,function(a,b){null!==a.total&&u.push(b)});u.sort(function(a,b){return a-b});var e=b.map(function(a){return a.visible});u.forEach(function(b,c){var h=0,q,r;if(p[b]&&!p[b].isNull)n.push(p[b]),[-1,1].forEach(function(k){var h=1===k?"rightNull":"leftNull",v=0,n=m[u[c+k]];if(n)for(f=g;0<=f&&f<a;)q=n.points[f],q||(f===g?p[b][h]=!0:e[f]&&(r=m[b].points[f])&&(v-=r[1]-r[0])),f+=d;p[b][1===k?"rightCliff":"leftCliff"]=v});else{for(f=g;0<=f&&f<a;){if(q=m[b].points[f]){h=
	q[1];break}f+=d}h=x.translate(h,0,1,0,1);n.push({isNull:!0,plotX:z.translate(b,0,0,0,1),x:b,plotY:h,yBottom:h})}})}return n},getGraphPath:function(n){var u=z.prototype.getGraphPath,y=this.options,A=y.stacking,x=this.yAxis,m,p=[],g=[],b=this.index,a=x.stacks[this.stackKey],d=y.threshold,f=Math.round(x.getThreshold(y.threshold));y=c.pick(y.connectNulls,"percent"===A);var e=function(c,e,k){var h=n[c];c=A&&a[h.x].points[b];var q=h[k+"Null"]||0;k=h[k+"Cliff"]||0;h=!0;if(k||q){var m=(q?c[0]:c[1])+k;var v=
	c[0]+k;h=!!q}else!A&&n[e]&&n[e].isNull&&(m=v=d);void 0!==m&&(g.push({plotX:r,plotY:null===m?f:x.getThreshold(m),isNull:h,isCliff:!0}),p.push({plotX:r,plotY:null===v?f:x.getThreshold(v),doCurve:!1}))};n=n||this.points;A&&(n=this.getStackPoints(n));for(m=0;m<n.length;m++){var h=n[m].isNull;var r=F(n[m].rectPlotX,n[m].plotX);var E=F(n[m].yBottom,f);if(!h||y)y||e(m,m-1,"left"),h&&!A&&y||(g.push(n[m]),p.push({x:m,plotX:r,plotY:E})),y||e(m,m+1,"right")}m=u.call(this,g,!0,!0);p.reversed=!0;h=u.call(this,
	p,!0,!0);h.length&&(h[0]="L");h=m.concat(h);u=u.call(this,g,!1,y);h.xMap=m.xMap;this.areaPath=h;return u},drawGraph:function(){this.areaPath=[];z.prototype.drawGraph.apply(this);var c=this,n=this.areaPath,y=this.options,A=[["area","highcharts-area",this.color,y.fillColor]];this.zones.forEach(function(n,m){A.push(["zone-area-"+m,"highcharts-area highcharts-zone-area-"+m+" "+n.className,n.color||c.color,n.fillColor||y.fillColor])});A.forEach(function(u){var m=u[0],p=c[m],g=p?"animate":"attr",b={};p?
	(p.endX=c.preventGraphAnimation?null:n.xMap,p.animate({d:n})):(b.zIndex=0,p=c[m]=c.chart.renderer.path(n).addClass(u[1]).add(c.group),p.isArea=!0);c.chart.styledMode||(b.fill=F(u[3],D(u[2]).setOpacity(F(y.fillOpacity,.75)).get()));p[g](b);p.startX=n.xMap;p.shiftUnit=y.step?2:1})},drawLegendSymbol:c.LegendSymbolMixin.drawRectangle});""});N(H,"parts/SplineSeries.js",[H["parts/Globals.js"]],function(c){var n=c.pick;c=c.seriesType;c("spline","line",{},{getPointSpline:function(c,D,F){var z=D.plotX,u=D.plotY,
	A=c[F-1];F=c[F+1];if(A&&!A.isNull&&!1!==A.doCurve&&!D.isCliff&&F&&!F.isNull&&!1!==F.doCurve&&!D.isCliff){c=A.plotY;var y=F.plotX;F=F.plotY;var C=0;var x=(1.5*z+A.plotX)/2.5;var m=(1.5*u+c)/2.5;y=(1.5*z+y)/2.5;var p=(1.5*u+F)/2.5;y!==x&&(C=(p-m)*(y-z)/(y-x)+u-p);m+=C;p+=C;m>c&&m>u?(m=Math.max(c,u),p=2*u-m):m<c&&m<u&&(m=Math.min(c,u),p=2*u-m);p>F&&p>u?(p=Math.max(F,u),m=2*u-p):p<F&&p<u&&(p=Math.min(F,u),m=2*u-p);D.rightContX=y;D.rightContY=p}D=["C",n(A.rightContX,A.plotX),n(A.rightContY,A.plotY),n(x,
	z),n(m,u),z,u];A.rightContX=A.rightContY=null;return D}});""});N(H,"parts/AreaSplineSeries.js",[H["parts/Globals.js"]],function(c){var n=c.seriesTypes.area.prototype,A=c.seriesType;A("areaspline","spline",c.defaultPlotOptions.area,{getStackPoints:n.getStackPoints,getGraphPath:n.getGraphPath,drawGraph:n.drawGraph,drawLegendSymbol:c.LegendSymbolMixin.drawRectangle});""});N(H,"parts/ColumnSeries.js",[H["parts/Globals.js"],H["parts/Utilities.js"]],function(c,n){var A=n.defined,D=n.isNumber,F=c.animObject,
	z=c.color,u=c.extend,L=c.merge,y=c.pick,C=c.Series;n=c.seriesType;var x=c.svg;n("column","line",{borderRadius:0,crisp:!0,groupPadding:.2,marker:null,pointPadding:.1,minPointLength:0,cropThreshold:50,pointRange:null,states:{hover:{halo:!1,brightness:.1},select:{color:"#cccccc",borderColor:"#000000"}},dataLabels:{align:null,verticalAlign:null,y:null},softThreshold:!1,startFromThreshold:!0,stickyTracking:!1,tooltip:{distance:6},threshold:0,borderColor:"#ffffff"},{cropShoulder:0,directTouch:!0,trackerGroups:["group",
	"dataLabelsGroup"],negStacks:!0,init:function(){C.prototype.init.apply(this,arguments);var c=this,p=c.chart;p.hasRendered&&p.series.forEach(function(g){g.type===c.type&&(g.isDirty=!0)})},getColumnMetrics:function(){var c=this,p=c.options,g=c.xAxis,b=c.yAxis,a=g.options.reversedStacks;a=g.reversed&&!a||!g.reversed&&a;var d,f={},e=0;!1===p.grouping?e=1:c.chart.series.forEach(function(a){var h=a.yAxis,k=a.options;if(a.type===c.type&&(a.visible||!c.chart.options.chart.ignoreHiddenSeries)&&b.len===h.len&&
	b.pos===h.pos){if(k.stacking){d=a.stackKey;void 0===f[d]&&(f[d]=e++);var g=f[d]}else!1!==k.grouping&&(g=e++);a.columnIndex=g}});var h=Math.min(Math.abs(g.transA)*(g.ordinalSlope||p.pointRange||g.closestPointRange||g.tickInterval||1),g.len),r=h*p.groupPadding,n=(h-2*r)/(e||1);p=Math.min(p.maxPointWidth||g.len,y(p.pointWidth,n*(1-2*p.pointPadding)));c.columnMetrics={width:p,offset:(n-p)/2+(r+((c.columnIndex||0)+(a?1:0))*n-h/2)*(a?-1:1)};return c.columnMetrics},crispCol:function(c,p,g,b){var a=this.chart,
	d=this.borderWidth,f=-(d%2?.5:0);d=d%2?.5:1;a.inverted&&a.renderer.isVML&&(d+=1);this.options.crisp&&(g=Math.round(c+g)+f,c=Math.round(c)+f,g-=c);b=Math.round(p+b)+d;f=.5>=Math.abs(p)&&.5<b;p=Math.round(p)+d;b-=p;f&&b&&(--p,b+=1);return{x:c,y:p,width:g,height:b}},translate:function(){var c=this,p=c.chart,g=c.options,b=c.dense=2>c.closestPointRange*c.xAxis.transA;b=c.borderWidth=y(g.borderWidth,b?0:1);var a=c.yAxis,d=g.threshold,f=c.translatedThreshold=a.getThreshold(d),e=y(g.minPointLength,5),h=c.getColumnMetrics(),
	r=h.width,n=c.barW=Math.max(r,1+2*b),q=c.pointXOffset=h.offset,v=c.dataMin,k=c.dataMax;p.inverted&&(f-=.5);g.pointPadding&&(n=Math.ceil(n));C.prototype.translate.apply(c);c.points.forEach(function(b){var h=y(b.yBottom,f),g=999+Math.abs(h),m=r;g=Math.min(Math.max(-g,b.plotY),a.len+g);var l=b.plotX+q,t=n,u=Math.min(g,h),x=Math.max(g,h)-u;if(e&&Math.abs(x)<e){x=e;var z=!a.reversed&&!b.negative||a.reversed&&b.negative;b.y===d&&c.dataMax<=d&&a.min<d&&v!==k&&(z=!z);u=Math.abs(u-f)>e?h-e:f-(z?e:0)}A(b.options.pointWidth)&&
	(m=t=Math.ceil(b.options.pointWidth),l-=Math.round((m-r)/2));b.barX=l;b.pointWidth=m;b.tooltipPos=p.inverted?[a.len+a.pos-p.plotLeft-g,c.xAxis.len-l-t/2,x]:[l+t/2,g+a.pos-p.plotTop,x];b.shapeType=c.pointClass.prototype.shapeType||"rect";b.shapeArgs=c.crispCol.apply(c,b.isNull?[l,f,t,0]:[l,u,t,x])})},getSymbol:c.noop,drawLegendSymbol:c.LegendSymbolMixin.drawRectangle,drawGraph:function(){this.group[this.dense?"addClass":"removeClass"]("highcharts-dense-data")},pointAttribs:function(c,p){var g=this.options,
	b=this.pointAttrToOptions||{};var a=b.stroke||"borderColor";var d=b["stroke-width"]||"borderWidth",f=c&&c.color||this.color,e=c&&c[a]||g[a]||this.color||f,h=c&&c[d]||g[d]||this[d]||0;b=c&&c.options.dashStyle||g.dashStyle;var m=y(g.opacity,1);if(c&&this.zones.length){var n=c.getZone();f=c.options.color||n&&(n.color||c.nonZonedColor)||this.color;n&&(e=n.borderColor||e,b=n.dashStyle||b,h=n.borderWidth||h)}p&&(c=L(g.states[p],c.options.states&&c.options.states[p]||{}),p=c.brightness,f=c.color||void 0!==
	p&&z(f).brighten(c.brightness).get()||f,e=c[a]||e,h=c[d]||h,b=c.dashStyle||b,m=y(c.opacity,m));a={fill:f,stroke:e,"stroke-width":h,opacity:m};b&&(a.dashstyle=b);return a},drawPoints:function(){var c=this,p=this.chart,g=c.options,b=p.renderer,a=g.animationLimit||250,d;c.points.forEach(function(f){var e=f.graphic,h=e&&p.pointCount<a?"animate":"attr";if(D(f.plotY)&&null!==f.y){d=f.shapeArgs;e&&e.element.nodeName!==f.shapeType&&(e=e.destroy());if(e)e[h](L(d));else f.graphic=e=b[f.shapeType](d).add(f.group||
	c.group);if(g.borderRadius)e[h]({r:g.borderRadius});p.styledMode||e[h](c.pointAttribs(f,f.selected&&"select")).shadow(!1!==f.allowShadow&&g.shadow,null,g.stacking&&!g.borderRadius);e.addClass(f.getClassName(),!0)}else e&&(f.graphic=e.destroy())})},animate:function(c){var m=this,g=this.yAxis,b=m.options,a=this.chart.inverted,d={},f=a?"translateX":"translateY";if(x)if(c)d.scaleY=.001,c=Math.min(g.pos+g.len,Math.max(g.pos,g.toPixels(b.threshold))),a?d.translateX=c-g.len:d.translateY=c,m.clipBox&&m.setClip(),
	m.group.attr(d);else{var e=m.group.attr(f);m.group.animate({scaleY:1},u(F(m.options.animation),{step:function(a,b){d[f]=e+b.pos*(g.pos-e);m.group.attr(d)}}));m.animate=null}},remove:function(){var c=this,p=c.chart;p.hasRendered&&p.series.forEach(function(g){g.type===c.type&&(g.isDirty=!0)});C.prototype.remove.apply(c,arguments)}});""});N(H,"parts/BarSeries.js",[H["parts/Globals.js"]],function(c){c=c.seriesType;c("bar","column",null,{inverted:!0});""});N(H,"parts/ScatterSeries.js",[H["parts/Globals.js"]],
	function(c){var n=c.Series,A=c.seriesType;A("scatter","line",{lineWidth:0,findNearestPointBy:"xy",jitter:{x:0,y:0},marker:{enabled:!0},tooltip:{headerFormat:'<span style="color:{point.color}">\u25cf</span> <span style="font-size: 10px"> {series.name}</span><br/>',pointFormat:"x: <b>{point.x}</b><br/>y: <b>{point.y}</b><br/>"}},{sorted:!1,requireSorting:!1,noSharedTooltip:!0,trackerGroups:["group","markerGroup","dataLabelsGroup"],takeOrdinalPosition:!1,drawGraph:function(){this.options.lineWidth&&
	n.prototype.drawGraph.call(this)},applyJitter:function(){var c=this,n=this.options.jitter,z=this.points.length;n&&this.points.forEach(function(u,A){["x","y"].forEach(function(y,C){var x="plot"+y.toUpperCase();if(n[y]&&!u.isNull){var m=c[y+"Axis"];var p=n[y]*m.transA;if(m&&!m.isLog){var g=Math.max(0,u[x]-p);m=Math.min(m.len,u[x]+p);C=1E4*Math.sin(A+C*z);u[x]=g+(m-g)*(C-Math.floor(C));"x"===y&&(u.clientX=u.plotX)}}})})}});c.addEvent(n,"afterTranslate",function(){this.applyJitter&&this.applyJitter()});
	""});N(H,"mixins/centered-series.js",[H["parts/Globals.js"],H["parts/Utilities.js"]],function(c,n){var A=n.isNumber,D=c.deg2rad,F=c.pick,z=c.relativeLength;c.CenteredSeriesMixin={getCenter:function(){var c=this.options,n=this.chart,y=2*(c.slicedOffset||0),A=n.plotWidth-2*y;n=n.plotHeight-2*y;var x=c.center;x=[F(x[0],"50%"),F(x[1],"50%"),c.size||"100%",c.innerSize||0];var m=Math.min(A,n),p;for(p=0;4>p;++p){var g=x[p];c=2>p||2===p&&/%$/.test(g);x[p]=z(g,[A,n,m,x[2]][p])+(c?y:0)}x[3]>x[2]&&(x[3]=x[2]);
	return x},getStartAndEndRadians:function(c,n){c=A(c)?c:0;n=A(n)&&n>c&&360>n-c?n:c+360;return{start:D*(c+-90),end:D*(n+-90)}}}});N(H,"parts/PieSeries.js",[H["parts/Globals.js"],H["parts/Utilities.js"]],function(c,n){var A=n.defined,D=n.isNumber,F=c.addEvent;n=c.CenteredSeriesMixin;var z=n.getStartAndEndRadians,u=c.merge,H=c.noop,y=c.pick,C=c.Point,x=c.Series,m=c.seriesType,p=c.fireEvent,g=c.setAnimation;m("pie","line",{center:[null,null],clip:!1,colorByPoint:!0,dataLabels:{allowOverlap:!0,connectorPadding:5,
	distance:30,enabled:!0,formatter:function(){return this.point.isNull?void 0:this.point.name},softConnector:!0,x:0,connectorShape:"fixedOffset",crookDistance:"70%"},fillColor:void 0,ignoreHiddenPoint:!0,inactiveOtherPoints:!0,legendType:"point",marker:null,size:null,showInLegend:!1,slicedOffset:10,stickyTracking:!1,tooltip:{followPointer:!0},borderColor:"#ffffff",borderWidth:1,states:{hover:{brightness:.1}}},{isCartesian:!1,requireSorting:!1,directTouch:!0,noSharedTooltip:!0,trackerGroups:["group",
	"dataLabelsGroup"],axisTypes:[],pointAttribs:c.seriesTypes.column.prototype.pointAttribs,animate:function(b){var a=this,d=a.points,c=a.startAngleRad;b||(d.forEach(function(b){var d=b.graphic,f=b.shapeArgs;d&&(d.attr({r:b.startR||a.center[3]/2,start:c,end:c}),d.animate({r:f.r,start:f.start,end:f.end},a.options.animation))}),a.animate=null)},hasData:function(){return!!this.processedXData.length},updateTotals:function(){var b,a=0,d=this.points,c=d.length,e=this.options.ignoreHiddenPoint;for(b=0;b<c;b++){var h=
	d[b];a+=e&&!h.visible?0:h.isNull?0:h.y}this.total=a;for(b=0;b<c;b++)h=d[b],h.percentage=0<a&&(h.visible||!e)?h.y/a*100:0,h.total=a},generatePoints:function(){x.prototype.generatePoints.call(this);this.updateTotals()},getX:function(b,a,d){var c=this.center,e=this.radii?this.radii[d.index]:c[2]/2;return c[0]+(a?-1:1)*Math.cos(Math.asin(Math.max(Math.min((b-c[1])/(e+d.labelDistance),1),-1)))*(e+d.labelDistance)+(0<d.labelDistance?(a?-1:1)*this.options.dataLabels.padding:0)},translate:function(b){this.generatePoints();
	var a=0,d=this.options,f=d.slicedOffset,e=f+(d.borderWidth||0),h=z(d.startAngle,d.endAngle),g=this.startAngleRad=h.start;h=(this.endAngleRad=h.end)-g;var m=this.points,q=d.dataLabels.distance;d=d.ignoreHiddenPoint;var v,k=m.length;b||(this.center=b=this.getCenter());for(v=0;v<k;v++){var t=m[v];var n=g+a*h;if(!d||t.visible)a+=t.percentage/100;var u=g+a*h;t.shapeType="arc";t.shapeArgs={x:b[0],y:b[1],r:b[2]/2,innerR:b[3]/2,start:Math.round(1E3*n)/1E3,end:Math.round(1E3*u)/1E3};t.labelDistance=y(t.options.dataLabels&&
	t.options.dataLabels.distance,q);t.labelDistance=c.relativeLength(t.labelDistance,t.shapeArgs.r);this.maxLabelDistance=Math.max(this.maxLabelDistance||0,t.labelDistance);u=(u+n)/2;u>1.5*Math.PI?u-=2*Math.PI:u<-Math.PI/2&&(u+=2*Math.PI);t.slicedTranslation={translateX:Math.round(Math.cos(u)*f),translateY:Math.round(Math.sin(u)*f)};var w=Math.cos(u)*b[2]/2;var l=Math.sin(u)*b[2]/2;t.tooltipPos=[b[0]+.7*w,b[1]+.7*l];t.half=u<-Math.PI/2||u>Math.PI/2?1:0;t.angle=u;n=Math.min(e,t.labelDistance/5);t.labelPosition=
	{natural:{x:b[0]+w+Math.cos(u)*t.labelDistance,y:b[1]+l+Math.sin(u)*t.labelDistance},"final":{},alignment:0>t.labelDistance?"center":t.half?"right":"left",connectorPosition:{breakAt:{x:b[0]+w+Math.cos(u)*n,y:b[1]+l+Math.sin(u)*n},touchingSliceAt:{x:b[0]+w,y:b[1]+l}}}}p(this,"afterTranslate")},drawEmpty:function(){var b=this.options;if(0===this.total){var a=this.center[0];var d=this.center[1];this.graph||(this.graph=this.chart.renderer.circle(a,d,0).addClass("highcharts-graph").add(this.group));this.graph.animate({"stroke-width":b.borderWidth,
	cx:a,cy:d,r:this.center[2]/2,fill:b.fillColor||"none",stroke:b.color||"#cccccc"})}else this.graph&&(this.graph=this.graph.destroy())},redrawPoints:function(){var b=this,a=b.chart,d=a.renderer,c,e,h,g,m=b.options.shadow;this.drawEmpty();!m||b.shadowGroup||a.styledMode||(b.shadowGroup=d.g("shadow").attr({zIndex:-1}).add(b.group));b.points.forEach(function(f){var q={};e=f.graphic;if(!f.isNull&&e){g=f.shapeArgs;c=f.getTranslate();if(!a.styledMode){var k=f.shadowGroup;m&&!k&&(k=f.shadowGroup=d.g("shadow").add(b.shadowGroup));
	k&&k.attr(c);h=b.pointAttribs(f,f.selected&&"select")}f.delayedRendering?(e.setRadialReference(b.center).attr(g).attr(c),a.styledMode||e.attr(h).attr({"stroke-linejoin":"round"}).shadow(m,k),f.delayedRendering=!1):(e.setRadialReference(b.center),a.styledMode||u(!0,q,h),u(!0,q,g,c),e.animate(q));e.attr({visibility:f.visible?"inherit":"hidden"});e.addClass(f.getClassName())}else e&&(f.graphic=e.destroy())})},drawPoints:function(){var b=this.chart.renderer;this.points.forEach(function(a){a.graphic||
	(a.graphic=b[a.shapeType](a.shapeArgs).add(a.series.group),a.delayedRendering=!0)})},searchPoint:H,sortByAngle:function(b,a){b.sort(function(b,c){return void 0!==b.angle&&(c.angle-b.angle)*a})},drawLegendSymbol:c.LegendSymbolMixin.drawRectangle,getCenter:n.getCenter,getSymbol:H,drawGraph:null},{init:function(){C.prototype.init.apply(this,arguments);var b=this;b.name=y(b.name,"Slice");var a=function(a){b.slice("select"===a.type)};F(b,"select",a);F(b,"unselect",a);return b},isValid:function(){return D(this.y)&&
	0<=this.y},setVisible:function(b,a){var c=this,f=c.series,e=f.chart,h=f.options.ignoreHiddenPoint;a=y(a,h);b!==c.visible&&(c.visible=c.options.visible=b=void 0===b?!c.visible:b,f.options.data[f.data.indexOf(c)]=c.options,["graphic","dataLabel","connector","shadowGroup"].forEach(function(a){if(c[a])c[a][b?"show":"hide"](!0)}),c.legendItem&&e.legend.colorizeItem(c,b),b||"hover"!==c.state||c.setState(""),h&&(f.isDirty=!0),a&&e.redraw())},slice:function(b,a,c){var d=this.series;g(c,d.chart);y(a,!0);this.sliced=
	this.options.sliced=A(b)?b:!this.sliced;d.options.data[d.data.indexOf(this)]=this.options;this.graphic.animate(this.getTranslate());this.shadowGroup&&this.shadowGroup.animate(this.getTranslate())},getTranslate:function(){return this.sliced?this.slicedTranslation:{translateX:0,translateY:0}},haloPath:function(b){var a=this.shapeArgs;return this.sliced||!this.visible?[]:this.series.chart.renderer.symbols.arc(a.x,a.y,a.r+b,a.r+b,{innerR:a.r-1,start:a.start,end:a.end})},connectorShapes:{fixedOffset:function(b,
	a,c){var d=a.breakAt;a=a.touchingSliceAt;return["M",b.x,b.y].concat(c.softConnector?["C",b.x+("left"===b.alignment?-5:5),b.y,2*d.x-a.x,2*d.y-a.y,d.x,d.y]:["L",d.x,d.y]).concat(["L",a.x,a.y])},straight:function(b,a){a=a.touchingSliceAt;return["M",b.x,b.y,"L",a.x,a.y]},crookedLine:function(b,a,d){a=a.touchingSliceAt;var f=this.series,e=f.center[0],h=f.chart.plotWidth,g=f.chart.plotLeft;f=b.alignment;var m=this.shapeArgs.r;d=c.relativeLength(d.crookDistance,1);d="left"===f?e+m+(h+g-e-m)*(1-d):g+(e-m)*
	d;e=["L",d,b.y];if("left"===f?d>b.x||d<a.x:d<b.x||d>a.x)e=[];return["M",b.x,b.y].concat(e).concat(["L",a.x,a.y])}},getConnectorPath:function(){var b=this.labelPosition,a=this.series.options.dataLabels,c=a.connectorShape,f=this.connectorShapes;f[c]&&(c=f[c]);return c.call(this,{x:b.final.x,y:b.final.y,alignment:b.alignment},b.connectorPosition,a)}});""});N(H,"parts/DataLabels.js",[H["parts/Globals.js"],H["parts/Utilities.js"]],function(c,n){var A=n.defined,D=n.isArray,F=n.objectEach,z=n.splat,u=c.arrayMax,
	H=c.extend,y=c.format,C=c.merge;n=c.noop;var x=c.pick,m=c.relativeLength,p=c.Series,g=c.seriesTypes,b=c.stableSort;c.distribute=function(a,d,f){function e(a,b){return a.target-b.target}var h,g=!0,m=a,q=[];var p=0;var k=m.reducedLen||d;for(h=a.length;h--;)p+=a[h].size;if(p>k){b(a,function(a,b){return(b.rank||0)-(a.rank||0)});for(p=h=0;p<=k;)p+=a[h].size,h++;q=a.splice(h-1,a.length)}b(a,e);for(a=a.map(function(a){return{size:a.size,targets:[a.target],align:x(a.align,.5)}});g;){for(h=a.length;h--;)g=
	a[h],p=(Math.min.apply(0,g.targets)+Math.max.apply(0,g.targets))/2,g.pos=Math.min(Math.max(0,p-g.size*g.align),d-g.size);h=a.length;for(g=!1;h--;)0<h&&a[h-1].pos+a[h-1].size>a[h].pos&&(a[h-1].size+=a[h].size,a[h-1].targets=a[h-1].targets.concat(a[h].targets),a[h-1].align=.5,a[h-1].pos+a[h-1].size>d&&(a[h-1].pos=d-a[h-1].size),a.splice(h,1),g=!0)}m.push.apply(m,q);h=0;a.some(function(a){var b=0;if(a.targets.some(function(){m[h].pos=a.pos+b;if(Math.abs(m[h].pos-m[h].target)>f)return m.slice(0,h+1).forEach(function(a){delete a.pos}),
	m.reducedLen=(m.reducedLen||d)-.1*d,m.reducedLen>.1*d&&c.distribute(m,d,f),!0;b+=m[h].size;h++}))return!0});b(m,e)};p.prototype.drawDataLabels=function(){function a(a,b){var c=b.filter;return c?(b=c.operator,a=a[c.property],c=c.value,">"===b&&a>c||"<"===b&&a<c||">="===b&&a>=c||"<="===b&&a<=c||"=="===b&&a==c||"==="===b&&a===c?!0:!1):!0}function b(a,b){var c=[],d;if(D(a)&&!D(b))c=a.map(function(a){return C(a,b)});else if(D(b)&&!D(a))c=b.map(function(b){return C(a,b)});else if(D(a)||D(b))for(d=Math.max(a.length,
	b.length);d--;)c[d]=C(a[d],b[d]);else c=C(a,b);return c}var f=this,e=f.chart,h=f.options,g=h.dataLabels,m=f.points,q,p=f.hasRendered||0,k=c.animObject(h.animation).duration,t=Math.min(k,200),n=!e.renderer.forExport&&x(g.defer,0<t),u=e.renderer;g=b(b(e.options.plotOptions&&e.options.plotOptions.series&&e.options.plotOptions.series.dataLabels,e.options.plotOptions&&e.options.plotOptions[f.type]&&e.options.plotOptions[f.type].dataLabels),g);c.fireEvent(this,"drawDataLabels");if(D(g)||g.enabled||f._hasPointLabels){var w=
	f.plotGroup("dataLabelsGroup","data-labels",n&&!p?"hidden":"inherit",g.zIndex||6);n&&(w.attr({opacity:+p}),p||setTimeout(function(){var a=f.dataLabelsGroup;a&&(f.visible&&w.show(!0),a[h.animation?"animate":"attr"]({opacity:1},{duration:t}))},k-t));m.forEach(function(c){q=z(b(g,c.dlOptions||c.options&&c.options.dataLabels));q.forEach(function(b,d){var k=b.enabled&&(!c.isNull||c.dataLabelOnNull)&&a(c,b),g=c.dataLabels?c.dataLabels[d]:c.dataLabel,l=c.connectors?c.connectors[d]:c.connector,q=x(b.distance,
	c.labelDistance),m=!g;if(k){var t=c.getLabelConfig();var p=x(b[c.formatPrefix+"Format"],b.format);t=A(p)?y(p,t,e.time):(b[c.formatPrefix+"Formatter"]||b.formatter).call(t,b);p=b.style;var n=b.rotation;e.styledMode||(p.color=x(b.color,p.color,f.color,"#000000"),"contrast"===p.color&&(c.contrastColor=u.getContrast(c.color||f.color),p.color=!A(q)&&b.inside||0>q||h.stacking?c.contrastColor:"#000000"),h.cursor&&(p.cursor=h.cursor));var r={r:b.borderRadius||0,rotation:n,padding:b.padding,zIndex:1};e.styledMode||
	(r.fill=b.backgroundColor,r.stroke=b.borderColor,r["stroke-width"]=b.borderWidth);F(r,function(a,b){void 0===a&&delete r[b]})}!g||k&&A(t)?k&&A(t)&&(g?r.text=t:(c.dataLabels=c.dataLabels||[],g=c.dataLabels[d]=n?u.text(t,0,-9999).addClass("highcharts-data-label"):u.label(t,0,-9999,b.shape,null,null,b.useHTML,null,"data-label"),d||(c.dataLabel=g),g.addClass(" highcharts-data-label-color-"+c.colorIndex+" "+(b.className||"")+(b.useHTML?" highcharts-tracker":""))),g.options=b,g.attr(r),e.styledMode||g.css(p).shadow(b.shadow),
	g.added||g.add(w),b.textPath&&!b.useHTML&&g.setTextPath(c.getDataLabelPath&&c.getDataLabelPath(g)||c.graphic,b.textPath),f.alignDataLabel(c,g,b,null,m)):(c.dataLabel=c.dataLabel&&c.dataLabel.destroy(),c.dataLabels&&(1===c.dataLabels.length?delete c.dataLabels:delete c.dataLabels[d]),d||delete c.dataLabel,l&&(c.connector=c.connector.destroy(),c.connectors&&(1===c.connectors.length?delete c.connectors:delete c.connectors[d])))})})}c.fireEvent(this,"afterDrawDataLabels")};p.prototype.alignDataLabel=
	function(a,b,c,e,h){var d=this.chart,f=this.isCartesian&&d.inverted,g=x(a.dlBox&&a.dlBox.centerX,a.plotX,-9999),m=x(a.plotY,-9999),k=b.getBBox(),p=c.rotation,n=c.align,u=this.visible&&(a.series.forceDL||d.isInsidePlot(g,Math.round(m),f)||e&&d.isInsidePlot(g,f?e.x+1:e.y+e.height-1,f)),w="justify"===x(c.overflow,"justify");if(u){var l=d.renderer.fontMetrics(d.styledMode?void 0:c.style.fontSize,b).b;e=H({x:f?this.yAxis.len-m:g,y:Math.round(f?this.xAxis.len-g:m),width:0,height:0},e);H(c,{width:k.width,
	height:k.height});p?(w=!1,g=d.renderer.rotCorr(l,p),g={x:e.x+c.x+e.width/2+g.x,y:e.y+c.y+{top:0,middle:.5,bottom:1}[c.verticalAlign]*e.height},b[h?"attr":"animate"](g).attr({align:n}),m=(p+720)%360,m=180<m&&360>m,"left"===n?g.y-=m?k.height:0:"center"===n?(g.x-=k.width/2,g.y-=k.height/2):"right"===n&&(g.x-=k.width,g.y-=m?0:k.height),b.placed=!0,b.alignAttr=g):(b.align(c,null,e),g=b.alignAttr);w&&0<=e.height?this.justifyDataLabel(b,c,g,k,e,h):x(c.crop,!0)&&(u=d.isInsidePlot(g.x,g.y)&&d.isInsidePlot(g.x+
	k.width,g.y+k.height));if(c.shape&&!p)b[h?"attr":"animate"]({anchorX:f?d.plotWidth-a.plotY:a.plotX,anchorY:f?d.plotHeight-a.plotX:a.plotY})}u||(b.hide(!0),b.placed=!1)};p.prototype.justifyDataLabel=function(a,b,c,e,g,m){var d=this.chart,f=b.align,h=b.verticalAlign,k=a.box?0:a.padding||0;var p=c.x+k;if(0>p){"right"===f?(b.align="left",b.inside=!0):b.x=-p;var n=!0}p=c.x+e.width-k;p>d.plotWidth&&("left"===f?(b.align="right",b.inside=!0):b.x=d.plotWidth-p,n=!0);p=c.y+k;0>p&&("bottom"===h?(b.verticalAlign=
	"top",b.inside=!0):b.y=-p,n=!0);p=c.y+e.height-k;p>d.plotHeight&&("top"===h?(b.verticalAlign="bottom",b.inside=!0):b.y=d.plotHeight-p,n=!0);n&&(a.placed=!m,a.align(b,null,g));return n};g.pie&&(g.pie.prototype.dataLabelPositioners={radialDistributionY:function(a){return a.top+a.distributeBox.pos},radialDistributionX:function(a,b,c,e){return a.getX(c<b.top+2||c>b.bottom-2?e:c,b.half,b)},justify:function(a,b,c){return c[0]+(a.half?-1:1)*(b+a.labelDistance)},alignToPlotEdges:function(a,b,c,e){a=a.getBBox().width;
	return b?a+e:c-a-e},alignToConnectors:function(a,b,c,e){var d=0,f;a.forEach(function(a){f=a.dataLabel.getBBox().width;f>d&&(d=f)});return b?d+e:c-d-e}},g.pie.prototype.drawDataLabels=function(){var a=this,b=a.data,f,e=a.chart,g=a.options.dataLabels,m=g.connectorPadding,n,q=e.plotWidth,v=e.plotHeight,k=e.plotLeft,t=Math.round(e.chartWidth/3),y,z=a.center,w=z[2]/2,l=z[1],J,D,F,H,L=[[],[]],M,G,N,Q,P=[0,0,0,0],U=a.dataLabelPositioners,V;a.visible&&(g.enabled||a._hasPointLabels)&&(b.forEach(function(a){a.dataLabel&&
	a.visible&&a.dataLabel.shortened&&(a.dataLabel.attr({width:"auto"}).css({width:"auto",textOverflow:"clip"}),a.dataLabel.shortened=!1)}),p.prototype.drawDataLabels.apply(a),b.forEach(function(a){a.dataLabel&&(a.visible?(L[a.half].push(a),a.dataLabel._pos=null,!A(g.style.width)&&!A(a.options.dataLabels&&a.options.dataLabels.style&&a.options.dataLabels.style.width)&&a.dataLabel.getBBox().width>t&&(a.dataLabel.css({width:.7*t}),a.dataLabel.shortened=!0)):(a.dataLabel=a.dataLabel.destroy(),a.dataLabels&&
	1===a.dataLabels.length&&delete a.dataLabels))}),L.forEach(function(b,d){var h=b.length,p=[],n;if(h){a.sortByAngle(b,d-.5);if(0<a.maxLabelDistance){var t=Math.max(0,l-w-a.maxLabelDistance);var r=Math.min(l+w+a.maxLabelDistance,e.plotHeight);b.forEach(function(a){0<a.labelDistance&&a.dataLabel&&(a.top=Math.max(0,l-w-a.labelDistance),a.bottom=Math.min(l+w+a.labelDistance,e.plotHeight),n=a.dataLabel.getBBox().height||21,a.distributeBox={target:a.labelPosition.natural.y-a.top+n/2,size:n,rank:a.y},p.push(a.distributeBox))});
	t=r+n-t;c.distribute(p,t,t/5)}for(Q=0;Q<h;Q++){f=b[Q];F=f.labelPosition;J=f.dataLabel;N=!1===f.visible?"hidden":"inherit";G=t=F.natural.y;p&&A(f.distributeBox)&&(void 0===f.distributeBox.pos?N="hidden":(H=f.distributeBox.size,G=U.radialDistributionY(f)));delete f.positionIndex;if(g.justify)M=U.justify(f,w,z);else switch(g.alignTo){case "connectors":M=U.alignToConnectors(b,d,q,k);break;case "plotEdges":M=U.alignToPlotEdges(J,d,q,k);break;default:M=U.radialDistributionX(a,f,G,t)}J._attr={visibility:N,
	align:F.alignment};J._pos={x:M+g.x+({left:m,right:-m}[F.alignment]||0),y:G+g.y-10};F.final.x=M;F.final.y=G;x(g.crop,!0)&&(D=J.getBBox().width,t=null,M-D<m&&1===d?(t=Math.round(D-M+m),P[3]=Math.max(t,P[3])):M+D>q-m&&0===d&&(t=Math.round(M+D-q+m),P[1]=Math.max(t,P[1])),0>G-H/2?P[0]=Math.max(Math.round(-G+H/2),P[0]):G+H/2>v&&(P[2]=Math.max(Math.round(G+H/2-v),P[2])),J.sideOverflow=t)}}}),0===u(P)||this.verifyDataLabelOverflow(P))&&(this.placeDataLabels(),this.points.forEach(function(b){V=C(g,b.options.dataLabels);
	if(n=x(V.connectorWidth,1)){var c;y=b.connector;if((J=b.dataLabel)&&J._pos&&b.visible&&0<b.labelDistance){N=J._attr.visibility;if(c=!y)b.connector=y=e.renderer.path().addClass("highcharts-data-label-connector  highcharts-color-"+b.colorIndex+(b.className?" "+b.className:"")).add(a.dataLabelsGroup),e.styledMode||y.attr({"stroke-width":n,stroke:V.connectorColor||b.color||"#666666"});y[c?"attr":"animate"]({d:b.getConnectorPath()});y.attr("visibility",N)}else y&&(b.connector=y.destroy())}}))},g.pie.prototype.placeDataLabels=
	function(){this.points.forEach(function(a){var b=a.dataLabel,c;b&&a.visible&&((c=b._pos)?(b.sideOverflow&&(b._attr.width=Math.max(b.getBBox().width-b.sideOverflow,0),b.css({width:b._attr.width+"px",textOverflow:(this.options.dataLabels.style||{}).textOverflow||"ellipsis"}),b.shortened=!0),b.attr(b._attr),b[b.moved?"animate":"attr"](c),b.moved=!0):b&&b.attr({y:-9999}));delete a.distributeBox},this)},g.pie.prototype.alignDataLabel=n,g.pie.prototype.verifyDataLabelOverflow=function(a){var b=this.center,
	c=this.options,e=c.center,g=c.minSize||80,p=null!==c.size;if(!p){if(null!==e[0])var n=Math.max(b[2]-Math.max(a[1],a[3]),g);else n=Math.max(b[2]-a[1]-a[3],g),b[0]+=(a[3]-a[1])/2;null!==e[1]?n=Math.max(Math.min(n,b[2]-Math.max(a[0],a[2])),g):(n=Math.max(Math.min(n,b[2]-a[0]-a[2]),g),b[1]+=(a[0]-a[2])/2);n<b[2]?(b[2]=n,b[3]=Math.min(m(c.innerSize||0,n),n),this.translate(b),this.drawDataLabels&&this.drawDataLabels()):p=!0}return p});g.column&&(g.column.prototype.alignDataLabel=function(a,b,c,e,g){var d=
	this.chart.inverted,f=a.series,h=a.dlBox||a.shapeArgs,m=x(a.below,a.plotY>x(this.translatedThreshold,f.yAxis.len)),k=x(c.inside,!!this.options.stacking);h&&(e=C(h),0>e.y&&(e.height+=e.y,e.y=0),h=e.y+e.height-f.yAxis.len,0<h&&(e.height-=h),d&&(e={x:f.yAxis.len-e.y-e.height,y:f.xAxis.len-e.x-e.width,width:e.height,height:e.width}),k||(d?(e.x+=m?0:e.width,e.width=0):(e.y+=m?e.height:0,e.height=0)));c.align=x(c.align,!d||k?"center":m?"right":"left");c.verticalAlign=x(c.verticalAlign,d||k?"middle":m?"top":
	"bottom");p.prototype.alignDataLabel.call(this,a,b,c,e,g);c.inside&&a.contrastColor&&b.css({color:a.contrastColor})})});N(H,"modules/overlapping-datalabels.src.js",[H["parts/Globals.js"],H["parts/Utilities.js"]],function(c,n){var A=n.isArray,D=n.objectEach;n=c.Chart;var F=c.pick,z=c.addEvent,u=c.fireEvent;z(n,"render",function(){var c=[];(this.labelCollectors||[]).forEach(function(n){c=c.concat(n())});(this.yAxis||[]).forEach(function(n){n.options.stackLabels&&!n.options.stackLabels.allowOverlap&&
	D(n.stacks,function(n){D(n,function(n){c.push(n.label)})})});(this.series||[]).forEach(function(n){var u=n.options.dataLabels;n.visible&&(!1!==u.enabled||n._hasPointLabels)&&n.points.forEach(function(n){n.visible&&(A(n.dataLabels)?n.dataLabels:n.dataLabel?[n.dataLabel]:[]).forEach(function(m){var p=m.options;m.labelrank=F(p.labelrank,n.labelrank,n.shapeArgs&&n.shapeArgs.height);p.allowOverlap||c.push(m)})})});this.hideOverlappingLabels(c)});n.prototype.hideOverlappingLabels=function(c){var n=this,
	z=c.length,x=n.renderer,m,p,g;var b=function(a){var b=a.box?0:a.padding||0;var c=0;if(a&&(!a.alignAttr||a.placed)){var d=a.alignAttr||{x:a.attr("x"),y:a.attr("y")};var f=a.parentGroup;a.width||(c=a.getBBox(),a.width=c.width,a.height=c.height,c=x.fontMetrics(null,a.element).h);return{x:d.x+(f.translateX||0)+b,y:d.y+(f.translateY||0)+b-c,width:a.width-2*b,height:a.height-2*b}}};for(p=0;p<z;p++)if(m=c[p])m.oldOpacity=m.opacity,m.newOpacity=1,m.absoluteBox=b(m);c.sort(function(a,b){return(b.labelrank||
	0)-(a.labelrank||0)});for(p=0;p<z;p++){var a=(b=c[p])&&b.absoluteBox;for(m=p+1;m<z;++m){var d=(g=c[m])&&g.absoluteBox;!a||!d||b===g||0===b.newOpacity||0===g.newOpacity||d.x>a.x+a.width||d.x+d.width<a.x||d.y>a.y+a.height||d.y+d.height<a.y||((b.labelrank<g.labelrank?b:g).newOpacity=0)}}c.forEach(function(a){var b;if(a){var c=a.newOpacity;a.oldOpacity!==c&&(a.alignAttr&&a.placed?(c?a.show(!0):b=function(){a.hide(!0);a.placed=!1},a.alignAttr.opacity=c,a[a.isOld?"animate":"attr"](a.alignAttr,null,b),u(n,
	"afterHideOverlappingLabels")):a.attr({opacity:c}));a.isOld=!0}})}});N(H,"parts/Interaction.js",[H["parts/Globals.js"],H["parts/Utilities.js"]],function(c,n){var A=n.defined,D=n.isArray,F=n.isObject,z=n.objectEach,u=c.addEvent;n=c.Chart;var H=c.createElement,y=c.css,C=c.defaultOptions,x=c.defaultPlotOptions,m=c.extend,p=c.fireEvent,g=c.hasTouch,b=c.Legend,a=c.merge,d=c.pick,f=c.Point,e=c.Series,h=c.seriesTypes,r=c.svg;var E=c.TrackerMixin={drawTrackerPoint:function(){var a=this,b=a.chart,c=b.pointer,
	d=function(a){var b=c.getPointFromEvent(a);void 0!==b&&(c.isDirectTouch=!0,b.onMouseOver(a))},e;a.points.forEach(function(a){e=D(a.dataLabels)?a.dataLabels:a.dataLabel?[a.dataLabel]:[];a.graphic&&(a.graphic.element.point=a);e.forEach(function(b){b.div?b.div.point=a:b.element.point=a})});a._hasTracking||(a.trackerGroups.forEach(function(e){if(a[e]){a[e].addClass("highcharts-tracker").on("mouseover",d).on("mouseout",function(a){c.onTrackerMouseOut(a)});if(g)a[e].on("touchstart",d);!b.styledMode&&a.options.cursor&&
	a[e].css(y).css({cursor:a.options.cursor})}}),a._hasTracking=!0);p(this,"afterDrawTracker")},drawTrackerGraph:function(){var a=this,b=a.options,c=b.trackByArea,d=[].concat(c?a.areaPath:a.graphPath),e=d.length,f=a.chart,h=f.pointer,l=f.renderer,m=f.options.tooltip.snap,n=a.tracker,u,x=function(){if(f.hoverSeries!==a)a.onMouseOver()},y="rgba(192,192,192,"+(r?.0001:.002)+")";if(e&&!c)for(u=e+1;u--;)"M"===d[u]&&d.splice(u+1,0,d[u+1]-m,d[u+2],"L"),(u&&"M"===d[u]||u===e)&&d.splice(u,0,"L",d[u-2]+m,d[u-
	1]);n?n.attr({d:d}):a.graph&&(a.tracker=l.path(d).attr({visibility:a.visible?"visible":"hidden",zIndex:2}).addClass(c?"highcharts-tracker-area":"highcharts-tracker-line").add(a.group),f.styledMode||a.tracker.attr({"stroke-linejoin":"round",stroke:y,fill:c?y:"none","stroke-width":a.graph.strokeWidth()+(c?0:2*m)}),[a.tracker,a.markerGroup].forEach(function(a){a.addClass("highcharts-tracker").on("mouseover",x).on("mouseout",function(a){h.onTrackerMouseOut(a)});b.cursor&&!f.styledMode&&a.css({cursor:b.cursor});
	if(g)a.on("touchstart",x)}));p(this,"afterDrawTracker")}};h.column&&(h.column.prototype.drawTracker=E.drawTrackerPoint);h.pie&&(h.pie.prototype.drawTracker=E.drawTrackerPoint);h.scatter&&(h.scatter.prototype.drawTracker=E.drawTrackerPoint);m(b.prototype,{setItemEvents:function(b,c,d){var e=this,g=e.chart.renderer.boxWrapper,k=b instanceof f,h="highcharts-legend-"+(k?"point":"series")+"-active",l=e.chart.styledMode;(d?c:b.legendGroup).on("mouseover",function(){b.visible&&e.allItems.forEach(function(a){b!==
	a&&a.setState("inactive",!k)});b.setState("hover");b.visible&&g.addClass(h);l||c.css(e.options.itemHoverStyle)}).on("mouseout",function(){e.chart.styledMode||c.css(a(b.visible?e.itemStyle:e.itemHiddenStyle));e.allItems.forEach(function(a){b!==a&&a.setState("",!k)});g.removeClass(h);b.setState()}).on("click",function(a){var c=function(){b.setVisible&&b.setVisible();e.allItems.forEach(function(a){b!==a&&a.setState(b.visible?"inactive":"",!k)})};g.removeClass(h);a={browserEvent:a};b.firePointEvent?b.firePointEvent("legendItemClick",
	a,c):p(b,"legendItemClick",a,c)})},createCheckboxForItem:function(a){a.checkbox=H("input",{type:"checkbox",className:"highcharts-legend-checkbox",checked:a.selected,defaultChecked:a.selected},this.options.itemCheckboxStyle,this.chart.container);u(a.checkbox,"click",function(b){p(a.series||a,"checkboxClick",{checked:b.target.checked,item:a},function(){a.select()})})}});m(n.prototype,{showResetZoom:function(){function a(){b.zoomOut()}var b=this,c=C.lang,d=b.options.chart.resetZoomButton,e=d.theme,f=
	e.states,g="chart"===d.relativeTo||"spaceBox"===d.relativeTo?null:"plotBox";p(this,"beforeShowResetZoom",null,function(){b.resetZoomButton=b.renderer.button(c.resetZoom,null,null,a,e,f&&f.hover).attr({align:d.position.align,title:c.resetZoomTitle}).addClass("highcharts-reset-zoom").add().align(d.position,!1,g)});p(this,"afterShowResetZoom")},zoomOut:function(){p(this,"selection",{resetSelection:!0},this.zoom)},zoom:function(a){var b=this,c,e=b.pointer,f=!1,g=b.inverted?e.mouseDownX:e.mouseDownY;!a||
	a.resetSelection?(b.axes.forEach(function(a){c=a.zoom()}),e.initiated=!1):a.xAxis.concat(a.yAxis).forEach(function(a){var d=a.axis,k=b.inverted?d.left:d.top,h=b.inverted?k+d.width:k+d.height,l=d.isXAxis,m=!1;if(!l&&g>=k&&g<=h||l||!A(g))m=!0;e[l?"zoomX":"zoomY"]&&m&&(c=d.zoom(a.min,a.max),d.displayBtn&&(f=!0))});var h=b.resetZoomButton;f&&!h?b.showResetZoom():!f&&F(h)&&(b.resetZoomButton=h.destroy());c&&b.redraw(d(b.options.chart.animation,a&&a.animation,100>b.pointCount))},pan:function(a,b){var c=
	this,d=c.hoverPoints,e;p(this,"pan",{originalEvent:a},function(){d&&d.forEach(function(a){a.setState()});("xy"===b?[1,0]:[1]).forEach(function(b){b=c[b?"xAxis":"yAxis"][0];var d=b.horiz,f=a[d?"chartX":"chartY"];d=d?"mouseDownX":"mouseDownY";var g=c[d],k=(b.pointRange||0)/2,h=b.reversed&&!c.inverted||!b.reversed&&c.inverted?-1:1,m=b.getExtremes(),n=b.toValue(g-f,!0)+k*h;h=b.toValue(g+b.len-f,!0)-k*h;var p=h<n;g=p?h:n;n=p?n:h;h=Math.min(m.dataMin,k?m.min:b.toValue(b.toPixels(m.min)-b.minPixelPadding));
	k=Math.max(m.dataMax,k?m.max:b.toValue(b.toPixels(m.max)+b.minPixelPadding));p=h-g;0<p&&(n+=p,g=h);p=n-k;0<p&&(n=k,g-=p);b.series.length&&g!==m.min&&n!==m.max&&(b.setExtremes(g,n,!1,!1,{trigger:"pan"}),e=!0);c[d]=f});e&&c.redraw(!1);y(c.container,{cursor:"move"})})}});m(f.prototype,{select:function(a,b){var c=this,e=c.series,f=e.chart;this.selectedStaging=a=d(a,!c.selected);c.firePointEvent(a?"select":"unselect",{accumulate:b},function(){c.selected=c.options.selected=a;e.options.data[e.data.indexOf(c)]=
	c.options;c.setState(a&&"select");b||f.getSelectedPoints().forEach(function(a){var b=a.series;a.selected&&a!==c&&(a.selected=a.options.selected=!1,b.options.data[b.data.indexOf(a)]=a.options,a.setState(f.hoverPoints&&b.options.inactiveOtherPoints?"inactive":""),a.firePointEvent("unselect"))})});delete this.selectedStaging},onMouseOver:function(a){var b=this.series.chart,c=b.pointer;a=a?c.normalize(a):c.getChartCoordinatesFromPoint(this,b.inverted);c.runPointActions(a,this)},onMouseOut:function(){var a=
	this.series.chart;this.firePointEvent("mouseOut");this.series.options.inactiveOtherPoints||(a.hoverPoints||[]).forEach(function(a){a.setState()});a.hoverPoints=a.hoverPoint=null},importEvents:function(){if(!this.hasImportedEvents){var b=this,d=a(b.series.options.point,b.options).events;b.events=d;z(d,function(a,d){c.isFunction(a)&&u(b,d,a)});this.hasImportedEvents=!0}},setState:function(a,b){var c=this.series,e=this.state,f=c.options.states[a||"normal"]||{},g=x[c.type].marker&&c.options.marker,h=
	g&&!1===g.enabled,l=g&&g.states&&g.states[a||"normal"]||{},n=!1===l.enabled,q=c.stateMarkerGraphic,r=this.marker||{},v=c.chart,u=c.halo,y,z=g&&c.markerAttribs;a=a||"";if(!(a===this.state&&!b||this.selected&&"select"!==a||!1===f.enabled||a&&(n||h&&!1===l.enabled)||a&&r.states&&r.states[a]&&!1===r.states[a].enabled)){this.state=a;z&&(y=c.markerAttribs(this,a));if(this.graphic){e&&this.graphic.removeClass("highcharts-point-"+e);a&&this.graphic.addClass("highcharts-point-"+a);if(!v.styledMode){var A=
	c.pointAttribs(this,a);var C=d(v.options.chart.animation,f.animation);c.options.inactiveOtherPoints&&((this.dataLabels||[]).forEach(function(a){a&&a.animate({opacity:A.opacity},C)}),this.connector&&this.connector.animate({opacity:A.opacity},C));this.graphic.animate(A,C)}y&&this.graphic.animate(y,d(v.options.chart.animation,l.animation,g.animation));q&&q.hide()}else{if(a&&l){e=r.symbol||c.symbol;q&&q.currentSymbol!==e&&(q=q.destroy());if(y)if(q)q[b?"animate":"attr"]({x:y.x,y:y.y});else e&&(c.stateMarkerGraphic=
	q=v.renderer.symbol(e,y.x,y.y,y.width,y.height).add(c.markerGroup),q.currentSymbol=e);!v.styledMode&&q&&q.attr(c.pointAttribs(this,a))}q&&(q[a&&this.isInside?"show":"hide"](),q.element.point=this)}a=f.halo;f=(q=this.graphic||q)&&q.visibility||"inherit";a&&a.size&&q&&"hidden"!==f?(u||(c.halo=u=v.renderer.path().add(q.parentGroup)),u.show()[b?"animate":"attr"]({d:this.haloPath(a.size)}),u.attr({"class":"highcharts-halo highcharts-color-"+d(this.colorIndex,c.colorIndex)+(this.className?" "+this.className:
	""),visibility:f,zIndex:-1}),u.point=this,v.styledMode||u.attr(m({fill:this.color||c.color,"fill-opacity":a.opacity},a.attributes))):u&&u.point&&u.point.haloPath&&u.animate({d:u.point.haloPath(0)},null,u.hide);p(this,"afterSetState")}},haloPath:function(a){return this.series.chart.renderer.symbols.circle(Math.floor(this.plotX)-a,this.plotY-a,2*a,2*a)}});m(e.prototype,{onMouseOver:function(){var a=this.chart,b=a.hoverSeries;if(b&&b!==this)b.onMouseOut();this.options.events.mouseOver&&p(this,"mouseOver");
	this.setState("hover");a.hoverSeries=this},onMouseOut:function(){var a=this.options,b=this.chart,c=b.tooltip,d=b.hoverPoint;b.hoverSeries=null;if(d)d.onMouseOut();this&&a.events.mouseOut&&p(this,"mouseOut");!c||this.stickyTracking||c.shared&&!this.noSharedTooltip||c.hide();b.series.forEach(function(a){a.setState("",!0)})},setState:function(a,b){var c=this,e=c.options,f=c.graph,g=e.inactiveOtherPoints,h=e.states,l=e.lineWidth,m=e.opacity,n=d(h[a||"normal"]&&h[a||"normal"].animation,c.chart.options.chart.animation);
	e=0;a=a||"";if(c.state!==a&&([c.group,c.markerGroup,c.dataLabelsGroup].forEach(function(b){b&&(c.state&&b.removeClass("highcharts-series-"+c.state),a&&b.addClass("highcharts-series-"+a))}),c.state=a,!c.chart.styledMode)){if(h[a]&&!1===h[a].enabled)return;a&&(l=h[a].lineWidth||l+(h[a].lineWidthPlus||0),m=d(h[a].opacity,m));if(f&&!f.dashstyle)for(h={"stroke-width":l},f.animate(h,n);c["zone-graph-"+e];)c["zone-graph-"+e].attr(h),e+=1;g||[c.group,c.markerGroup,c.dataLabelsGroup,c.labelBySeries].forEach(function(a){a&&
	a.animate({opacity:m},n)})}b&&g&&c.points&&c.setAllPointsToState(a)},setAllPointsToState:function(a){this.points.forEach(function(b){b.setState&&b.setState(a)})},setVisible:function(a,b){var c=this,d=c.chart,e=c.legendItem,f=d.options.chart.ignoreHiddenSeries,g=c.visible;var h=(c.visible=a=c.options.visible=c.userOptions.visible=void 0===a?!g:a)?"show":"hide";["group","dataLabelsGroup","markerGroup","tracker","tt"].forEach(function(a){if(c[a])c[a][h]()});if(d.hoverSeries===c||(d.hoverPoint&&d.hoverPoint.series)===
	c)c.onMouseOut();e&&d.legend.colorizeItem(c,a);c.isDirty=!0;c.options.stacking&&d.series.forEach(function(a){a.options.stacking&&a.visible&&(a.isDirty=!0)});c.linkedSeries.forEach(function(b){b.setVisible(a,!1)});f&&(d.isDirtyBox=!0);p(c,h);!1!==b&&d.redraw()},show:function(){this.setVisible(!0)},hide:function(){this.setVisible(!1)},select:function(a){this.selected=a=this.options.selected=void 0===a?!this.selected:a;this.checkbox&&(this.checkbox.checked=a);p(this,a?"select":"unselect")},drawTracker:E.drawTrackerGraph})});
	N(H,"parts/Responsive.js",[H["parts/Globals.js"],H["parts/Utilities.js"]],function(c,n){var A=n.isArray,D=n.isObject,F=n.objectEach,z=n.splat;n=c.Chart;var u=c.pick;n.prototype.setResponsive=function(n,u){var y=this.options.responsive,x=[],m=this.currentResponsive;!u&&y&&y.rules&&y.rules.forEach(function(m){void 0===m._id&&(m._id=c.uniqueKey());this.matchResponsiveRule(m,x)},this);u=c.merge.apply(0,x.map(function(m){return c.find(y.rules,function(c){return c._id===m}).chartOptions}));u.isResponsiveOptions=
	!0;x=x.toString()||void 0;x!==(m&&m.ruleIds)&&(m&&this.update(m.undoOptions,n,!0),x?(m=this.currentOptions(u),m.isResponsiveOptions=!0,this.currentResponsive={ruleIds:x,mergedOptions:u,undoOptions:m},this.update(u,n,!0)):this.currentResponsive=void 0)};n.prototype.matchResponsiveRule=function(c,n){var y=c.condition;(y.callback||function(){return this.chartWidth<=u(y.maxWidth,Number.MAX_VALUE)&&this.chartHeight<=u(y.maxHeight,Number.MAX_VALUE)&&this.chartWidth>=u(y.minWidth,0)&&this.chartHeight>=u(y.minHeight,
	0)}).call(this)&&n.push(c._id)};n.prototype.currentOptions=function(c){function n(c,p,g,b){var a;F(c,function(c,f){if(!b&&-1<u.collectionsWithUpdate.indexOf(f))for(c=z(c),g[f]=[],a=0;a<c.length;a++)p[f][a]&&(g[f][a]={},n(c[a],p[f][a],g[f][a],b+1));else D(c)?(g[f]=A(c)?[]:{},n(c,p[f]||{},g[f],b+1)):g[f]=void 0===p[f]?null:p[f]})}var u=this,x={};n(c,this.options,x,0);return x}});N(H,"masters/highcharts.src.js",[H["parts/Globals.js"],H["parts/Utilities.js"]],function(c,n){var A=c.extend;A(c,{attr:n.attr,
	defined:n.defined,erase:n.erase,isArray:n.isArray,isClass:n.isClass,isDOMElement:n.isDOMElement,isNumber:n.isNumber,isObject:n.isObject,isString:n.isString,objectEach:n.objectEach,pInt:n.pInt,splat:n.splat});return c});H["masters/highcharts.src.js"]._modules=H;return H["masters/highcharts.src.js"]});
	//# sourceMappingURL=highcharts.js.map

/***/ }),
/* 48 */
/***/ (function(module, exports) {

	/*
	 Highcharts JS v6.0.1 (2017-10-05)
	 Exporting module

	 (c) 2010-2017 Torstein Honsi

	 License: www.highcharts.com/license
	*/
	(function(k){"object"===typeof module&&module.exports?module.exports=k:k(Highcharts)})(function(k){(function(f){var k=f.defaultOptions,z=f.doc,B=f.Chart,w=f.addEvent,I=f.removeEvent,F=f.fireEvent,p=f.createElement,C=f.discardElement,u=f.css,n=f.merge,D=f.pick,h=f.each,G=f.objectEach,r=f.extend,J=f.isTouchDevice,E=f.win,H=E.navigator.userAgent,K=f.Renderer.prototype.symbols;/Edge\/|Trident\/|MSIE /.test(H);/firefox/i.test(H);r(k.lang,{printChart:"Print chart",downloadPNG:"Download PNG image",downloadJPEG:"Download JPEG image",
	downloadPDF:"Download PDF document",downloadSVG:"Download SVG vector image",contextButtonTitle:"Chart context menu"});k.navigation={buttonOptions:{theme:{},symbolSize:14,symbolX:12.5,symbolY:10.5,align:"right",buttonSpacing:3,height:32,verticalAlign:"top",width:32}};n(!0,k.navigation,{menuStyle:{border:"1px solid #999999",background:"#ffffff",padding:"5px 0"},menuItemStyle:{padding:"0.5em 1em",background:"none",color:"#333333",fontSize:J?"14px":"11px",transition:"background 250ms, color 250ms"},menuItemHoverStyle:{background:"#335cad",
	color:"#ffffff"},buttonOptions:{symbolFill:"#666666",symbolStroke:"#666666",symbolStrokeWidth:1,theme:{fill:"#ffffff",stroke:"none",padding:5}}});k.exporting={type:"image/png",url:"https://export.highcharts.com/",printMaxWidth:780,scale:2,buttons:{contextButton:{className:"highcharts-contextbutton",menuClassName:"highcharts-contextmenu",symbol:"menu",_titleKey:"contextButtonTitle",menuItems:"printChart separator downloadPNG downloadJPEG downloadPDF downloadSVG".split(" ")}},menuItemDefinitions:{printChart:{textKey:"printChart",
	onclick:function(){this.print()}},separator:{separator:!0},downloadPNG:{textKey:"downloadPNG",onclick:function(){this.exportChart()}},downloadJPEG:{textKey:"downloadJPEG",onclick:function(){this.exportChart({type:"image/jpeg"})}},downloadPDF:{textKey:"downloadPDF",onclick:function(){this.exportChart({type:"application/pdf"})}},downloadSVG:{textKey:"downloadSVG",onclick:function(){this.exportChart({type:"image/svg+xml"})}}}};f.post=function(a,b,e){var c=p("form",n({method:"post",action:a,enctype:"multipart/form-data"},
	e),{display:"none"},z.body);G(b,function(a,b){p("input",{type:"hidden",name:b,value:a},null,c)});c.submit();C(c)};r(B.prototype,{sanitizeSVG:function(a,b){if(b&&b.exporting&&b.exporting.allowHTML){var e=a.match(/<\/svg>(.*?$)/);e&&e[1]&&(e='\x3cforeignObject x\x3d"0" y\x3d"0" width\x3d"'+b.chart.width+'" height\x3d"'+b.chart.height+'"\x3e\x3cbody xmlns\x3d"http://www.w3.org/1999/xhtml"\x3e'+e[1]+"\x3c/body\x3e\x3c/foreignObject\x3e",a=a.replace("\x3c/svg\x3e",e+"\x3c/svg\x3e"))}a=a.replace(/zIndex="[^"]+"/g,
	"").replace(/isShadow="[^"]+"/g,"").replace(/symbolName="[^"]+"/g,"").replace(/jQuery[0-9]+="[^"]+"/g,"").replace(/url\(("|&quot;)(\S+)("|&quot;)\)/g,"url($2)").replace(/url\([^#]+#/g,"url(#").replace(/<svg /,'\x3csvg xmlns:xlink\x3d"http://www.w3.org/1999/xlink" ').replace(/ (NS[0-9]+\:)?href=/g," xlink:href\x3d").replace(/\n/," ").replace(/<\/svg>.*?$/,"\x3c/svg\x3e").replace(/(fill|stroke)="rgba\(([ 0-9]+,[ 0-9]+,[ 0-9]+),([ 0-9\.]+)\)"/g,'$1\x3d"rgb($2)" $1-opacity\x3d"$3"').replace(/&nbsp;/g,
	"\u00a0").replace(/&shy;/g,"\u00ad");this.ieSanitizeSVG&&(a=this.ieSanitizeSVG(a));return a},getChartHTML:function(){return this.container.innerHTML},getSVG:function(a){var b,e,c,v,m,g=n(this.options,a);e=p("div",null,{position:"absolute",top:"-9999em",width:this.chartWidth+"px",height:this.chartHeight+"px"},z.body);c=this.renderTo.style.width;m=this.renderTo.style.height;c=g.exporting.sourceWidth||g.chart.width||/px$/.test(c)&&parseInt(c,10)||600;m=g.exporting.sourceHeight||g.chart.height||/px$/.test(m)&&
	parseInt(m,10)||400;r(g.chart,{animation:!1,renderTo:e,forExport:!0,renderer:"SVGRenderer",width:c,height:m});g.exporting.enabled=!1;delete g.data;g.series=[];h(this.series,function(a){v=n(a.userOptions,{animation:!1,enableMouseTracking:!1,showCheckbox:!1,visible:a.visible});v.isInternal||g.series.push(v)});h(this.axes,function(a){a.userOptions.internalKey||(a.userOptions.internalKey=f.uniqueKey())});b=new f.Chart(g,this.callback);a&&h(["xAxis","yAxis","series"],function(c){var d={};a[c]&&(d[c]=a[c],
	b.update(d))});h(this.axes,function(a){var c=f.find(b.axes,function(b){return b.options.internalKey===a.userOptions.internalKey}),d=a.getExtremes(),e=d.userMin,d=d.userMax;!c||void 0===e&&void 0===d||c.setExtremes(e,d,!0,!1)});c=b.getChartHTML();c=this.sanitizeSVG(c,g);g=null;b.destroy();C(e);return c},getSVGForExport:function(a,b){var e=this.options.exporting;return this.getSVG(n({chart:{borderRadius:0}},e.chartOptions,b,{exporting:{sourceWidth:a&&a.sourceWidth||e.sourceWidth,sourceHeight:a&&a.sourceHeight||
	e.sourceHeight}}))},exportChart:function(a,b){b=this.getSVGForExport(a,b);a=n(this.options.exporting,a);f.post(a.url,{filename:a.filename||"chart",type:a.type,width:a.width||0,scale:a.scale,svg:b},a.formAttributes)},print:function(){var a=this,b=a.container,e=[],c=b.parentNode,f=z.body,m=f.childNodes,g=a.options.exporting.printMaxWidth,d,t;if(!a.isPrinting){a.isPrinting=!0;a.pointer.reset(null,0);F(a,"beforePrint");if(t=g&&a.chartWidth>g)d=[a.options.chart.width,void 0,!1],a.setSize(g,void 0,!1);
	h(m,function(a,b){1===a.nodeType&&(e[b]=a.style.display,a.style.display="none")});f.appendChild(b);E.focus();E.print();setTimeout(function(){c.appendChild(b);h(m,function(a,b){1===a.nodeType&&(a.style.display=e[b])});a.isPrinting=!1;t&&a.setSize.apply(a,d);F(a,"afterPrint")},1E3)}},contextMenu:function(a,b,e,c,v,m,g){var d=this,t=d.options.navigation,k=d.chartWidth,q=d.chartHeight,n="cache-"+a,l=d[n],x=Math.max(v,m),y,A;l||(d[n]=l=p("div",{className:a},{position:"absolute",zIndex:1E3,padding:x+"px"},
	d.container),y=p("div",{className:"highcharts-menu"},null,l),u(y,r({MozBoxShadow:"3px 3px 10px #888",WebkitBoxShadow:"3px 3px 10px #888",boxShadow:"3px 3px 10px #888"},t.menuStyle)),A=function(){u(l,{display:"none"});g&&g.setState(0);d.openMenu=!1},d.exportEvents.push(w(l,"mouseleave",function(){l.hideTimer=setTimeout(A,500)}),w(l,"mouseenter",function(){clearTimeout(l.hideTimer)}),w(z,"mouseup",function(b){d.pointer.inClass(b.target,a)||A()})),h(b,function(a){"string"===typeof a&&(a=d.options.exporting.menuItemDefinitions[a]);
	if(f.isObject(a,!0)){var b;a.separator?b=p("hr",null,null,y):(b=p("div",{className:"highcharts-menu-item",onclick:function(b){b&&b.stopPropagation();A();a.onclick&&a.onclick.apply(d,arguments)},innerHTML:a.text||d.options.lang[a.textKey]},null,y),b.onmouseover=function(){u(this,t.menuItemHoverStyle)},b.onmouseout=function(){u(this,t.menuItemStyle)},u(b,r({cursor:"pointer"},t.menuItemStyle)));d.exportDivElements.push(b)}}),d.exportDivElements.push(y,l),d.exportMenuWidth=l.offsetWidth,d.exportMenuHeight=
	l.offsetHeight);b={display:"block"};e+d.exportMenuWidth>k?b.right=k-e-v-x+"px":b.left=e-x+"px";c+m+d.exportMenuHeight>q&&"top"!==g.alignOptions.verticalAlign?b.bottom=q-c-x+"px":b.top=c+m-x+"px";u(l,b);d.openMenu=!0},addButton:function(a){var b=this,e=b.renderer,c=n(b.options.navigation.buttonOptions,a),f=c.onclick,m=c.menuItems,g,d,k=c.symbolSize||12;b.btnCount||(b.btnCount=0);b.exportDivElements||(b.exportDivElements=[],b.exportSVGElements=[]);if(!1!==c.enabled){var h=c.theme,q=h.states,p=q&&q.hover,
	q=q&&q.select,l;delete h.states;f?l=function(a){a.stopPropagation();f.call(b,a)}:m&&(l=function(){b.contextMenu(d.menuClassName,m,d.translateX,d.translateY,d.width,d.height,d);d.setState(2)});c.text&&c.symbol?h.paddingLeft=D(h.paddingLeft,25):c.text||r(h,{width:c.width,height:c.height,padding:0});d=e.button(c.text,0,0,l,h,p,q).addClass(a.className).attr({"stroke-linecap":"round",title:b.options.lang[c._titleKey],zIndex:3});d.menuClassName=a.menuClassName||"highcharts-menu-"+b.btnCount++;c.symbol&&
	(g=e.symbol(c.symbol,c.symbolX-k/2,c.symbolY-k/2,k,k).addClass("highcharts-button-symbol").attr({zIndex:1}).add(d),g.attr({stroke:c.symbolStroke,fill:c.symbolFill,"stroke-width":c.symbolStrokeWidth||1}));d.add().align(r(c,{width:d.width,x:D(c.x,b.buttonOffset)}),!0,"spacingBox");b.buttonOffset+=(d.width+c.buttonSpacing)*("right"===c.align?-1:1);b.exportSVGElements.push(d,g)}},destroyExport:function(a){var b=a?a.target:this;a=b.exportSVGElements;var e=b.exportDivElements,c=b.exportEvents,f;a&&(h(a,
	function(a,c){a&&(a.onclick=a.ontouchstart=null,f="cache-"+a.menuClassName,b[f]&&delete b[f],b.exportSVGElements[c]=a.destroy())}),a.length=0);e&&(h(e,function(a,c){clearTimeout(a.hideTimer);I(a,"mouseleave");b.exportDivElements[c]=a.onmouseout=a.onmouseover=a.ontouchstart=a.onclick=null;C(a)}),e.length=0);c&&(h(c,function(a){a()}),c.length=0)}});K.menu=function(a,b,e,c){return["M",a,b+2.5,"L",a+e,b+2.5,"M",a,b+c/2+.5,"L",a+e,b+c/2+.5,"M",a,b+c-1.5,"L",a+e,b+c-1.5]};B.prototype.renderExporting=function(){var a=
	this,b=a.options.exporting,e=b.buttons,c=a.isDirtyExporting||!a.exportSVGElements;a.buttonOffset=0;a.isDirtyExporting&&a.destroyExport();c&&!1!==b.enabled&&(a.exportEvents=[],G(e,function(b){a.addButton(b)}),a.isDirtyExporting=!1);w(a,"destroy",a.destroyExport)};B.prototype.callbacks.push(function(a){a.renderExporting();w(a,"redraw",a.renderExporting);h(["exporting","navigation"],function(b){a[b]={update:function(e,c){a.isDirtyExporting=!0;n(!0,a.options[b],e);D(c,!0)&&a.redraw()}}})})})(k)});

/***/ }),
/* 49 */
/***/ (function(module, exports) {

	/*! jQuery Searchable v1.1.0 by Stidges (http://twitter.com/stidges) | MIT */
	!function(a){function b(a){return"function"==typeof a}function c(b,c){this.$element=a(b),this.settings=a.extend({},e,c),this.init()}var d="searchable",e={selector:"tbody tr",childSelector:"td",searchField:"#search",striped:!1,oddRow:{},evenRow:{},hide:function(a){a.hide()},show:function(a){a.show()},searchType:"default",onSearchActive:!1,onSearchEmpty:!1,onSearchFocus:!1,onSearchBlur:!1,clearOnLoad:!1},f=!1,g=!1,h=!1,i=!1;c.prototype={init:function(){this.$searchElems=a(this.settings.selector,this.$element),this.$search=a(this.settings.searchField),this.matcherFunc=this.getMatcherFunction(this.settings.searchType),this.determineCallbacks(),this.bindEvents(),this.updateStriping()},determineCallbacks:function(){f=b(this.settings.onSearchActive),g=b(this.settings.onSearchEmpty),h=b(this.settings.onSearchFocus),i=b(this.settings.onSearchBlur)},bindEvents:function(){var b=this;this.$search.on("change keyup",function(){b.search(a(this).val()),b.updateStriping()}),h&&this.$search.on("focus",this.settings.onSearchFocus),i&&this.$search.on("blur",this.settings.onSearchBlur),this.settings.clearOnLoad===!0&&(this.$search.val(""),this.$search.trigger("change")),""!==this.$search.val()&&this.$search.trigger("change")},updateStriping:function(){var b=this,c=["oddRow","evenRow"],d=this.settings.selector+":visible";this.settings.striped&&a(d,this.$element).each(function(d,e){a(e).css(b.settings[c[d%2]])})},search:function(b){var c,d,e,h,i,j,k,l;if(0===a.trim(b).length)return this.$searchElems.css("display",""),this.updateStriping(),void(g&&this.settings.onSearchEmpty(this.$element));for(f&&this.settings.onSearchActive(this.$element,b),d=this.$searchElems.length,c=this.matcherFunc(b),k=0;d>k;k++){for(j=a(this.$searchElems[k]),e=j.find(this.settings.childSelector),h=e.length,i=!0,l=0;h>l;l++)if(c(a(e[l]).text())){i=!1;break}i===!0?this.settings.hide(j):this.settings.show(j)}},getMatcherFunction:function(a){return"fuzzy"===a?this.getFuzzyMatcher:"strict"===a?this.getStrictMatcher:this.getDefaultMatcher},getFuzzyMatcher:function(a){var b,c=a.split("").reduce(function(a,b){return a+"[^"+b+"]*"+b});return b=new RegExp(c,"gi"),function(a){return b.test(a)}},getStrictMatcher:function(b){return b=a.trim(b),function(a){return-1!==a.indexOf(b)}},getDefaultMatcher:function(b){return b=a.trim(b).toLowerCase(),function(a){return-1!==a.toLowerCase().indexOf(b)}}},a.fn[d]=function(b){return this.each(function(){a.data(this,"plugin_"+d)||a.data(this,"plugin_"+d,new c(this,b))})}}(jQuery,window,document);

/***/ }),
/* 50 */
/***/ (function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ }),
/* 51 */
/***/ (function(module, exports) {

	/**
	 * Owl Carousel v2.3.4
	 * Copyright 2013-2018 David Deutsch
	 * Licensed under: SEE LICENSE IN https://github.com/OwlCarousel2/OwlCarousel2/blob/master/LICENSE
	 */
	!function(a,b,c,d){function e(b,c){this.settings=null,this.options=a.extend({},e.Defaults,c),this.$element=a(b),this._handlers={},this._plugins={},this._supress={},this._current=null,this._speed=null,this._coordinates=[],this._breakpoint=null,this._width=null,this._items=[],this._clones=[],this._mergers=[],this._widths=[],this._invalidated={},this._pipe=[],this._drag={time:null,target:null,pointer:null,stage:{start:null,current:null},direction:null},this._states={current:{},tags:{initializing:["busy"],animating:["busy"],dragging:["interacting"]}},a.each(["onResize","onThrottledResize"],a.proxy(function(b,c){this._handlers[c]=a.proxy(this[c],this)},this)),a.each(e.Plugins,a.proxy(function(a,b){this._plugins[a.charAt(0).toLowerCase()+a.slice(1)]=new b(this)},this)),a.each(e.Workers,a.proxy(function(b,c){this._pipe.push({filter:c.filter,run:a.proxy(c.run,this)})},this)),this.setup(),this.initialize()}e.Defaults={items:3,loop:!1,center:!1,rewind:!1,checkVisibility:!0,mouseDrag:!0,touchDrag:!0,pullDrag:!0,freeDrag:!1,margin:0,stagePadding:0,merge:!1,mergeFit:!0,autoWidth:!1,startPosition:0,rtl:!1,smartSpeed:250,fluidSpeed:!1,dragEndSpeed:!1,responsive:{},responsiveRefreshRate:200,responsiveBaseElement:b,fallbackEasing:"swing",slideTransition:"",info:!1,nestedItemSelector:!1,itemElement:"div",stageElement:"div",refreshClass:"owl-refresh",loadedClass:"owl-loaded",loadingClass:"owl-loading",rtlClass:"owl-rtl",responsiveClass:"owl-responsive",dragClass:"owl-drag",itemClass:"owl-item",stageClass:"owl-stage",stageOuterClass:"owl-stage-outer",grabClass:"owl-grab"},e.Width={Default:"default",Inner:"inner",Outer:"outer"},e.Type={Event:"event",State:"state"},e.Plugins={},e.Workers=[{filter:["width","settings"],run:function(){this._width=this.$element.width()}},{filter:["width","items","settings"],run:function(a){a.current=this._items&&this._items[this.relative(this._current)]}},{filter:["items","settings"],run:function(){this.$stage.children(".cloned").remove()}},{filter:["width","items","settings"],run:function(a){var b=this.settings.margin||"",c=!this.settings.autoWidth,d=this.settings.rtl,e={width:"auto","margin-left":d?b:"","margin-right":d?"":b};!c&&this.$stage.children().css(e),a.css=e}},{filter:["width","items","settings"],run:function(a){var b=(this.width()/this.settings.items).toFixed(3)-this.settings.margin,c=null,d=this._items.length,e=!this.settings.autoWidth,f=[];for(a.items={merge:!1,width:b};d--;)c=this._mergers[d],c=this.settings.mergeFit&&Math.min(c,this.settings.items)||c,a.items.merge=c>1||a.items.merge,f[d]=e?b*c:this._items[d].width();this._widths=f}},{filter:["items","settings"],run:function(){var b=[],c=this._items,d=this.settings,e=Math.max(2*d.items,4),f=2*Math.ceil(c.length/2),g=d.loop&&c.length?d.rewind?e:Math.max(e,f):0,h="",i="";for(g/=2;g>0;)b.push(this.normalize(b.length/2,!0)),h+=c[b[b.length-1]][0].outerHTML,b.push(this.normalize(c.length-1-(b.length-1)/2,!0)),i=c[b[b.length-1]][0].outerHTML+i,g-=1;this._clones=b,a(h).addClass("cloned").appendTo(this.$stage),a(i).addClass("cloned").prependTo(this.$stage)}},{filter:["width","items","settings"],run:function(){for(var a=this.settings.rtl?1:-1,b=this._clones.length+this._items.length,c=-1,d=0,e=0,f=[];++c<b;)d=f[c-1]||0,e=this._widths[this.relative(c)]+this.settings.margin,f.push(d+e*a);this._coordinates=f}},{filter:["width","items","settings"],run:function(){var a=this.settings.stagePadding,b=this._coordinates,c={width:Math.ceil(Math.abs(b[b.length-1]))+2*a,"padding-left":a||"","padding-right":a||""};this.$stage.css(c)}},{filter:["width","items","settings"],run:function(a){var b=this._coordinates.length,c=!this.settings.autoWidth,d=this.$stage.children();if(c&&a.items.merge)for(;b--;)a.css.width=this._widths[this.relative(b)],d.eq(b).css(a.css);else c&&(a.css.width=a.items.width,d.css(a.css))}},{filter:["items"],run:function(){this._coordinates.length<1&&this.$stage.removeAttr("style")}},{filter:["width","items","settings"],run:function(a){a.current=a.current?this.$stage.children().index(a.current):0,a.current=Math.max(this.minimum(),Math.min(this.maximum(),a.current)),this.reset(a.current)}},{filter:["position"],run:function(){this.animate(this.coordinates(this._current))}},{filter:["width","position","items","settings"],run:function(){var a,b,c,d,e=this.settings.rtl?1:-1,f=2*this.settings.stagePadding,g=this.coordinates(this.current())+f,h=g+this.width()*e,i=[];for(c=0,d=this._coordinates.length;c<d;c++)a=this._coordinates[c-1]||0,b=Math.abs(this._coordinates[c])+f*e,(this.op(a,"<=",g)&&this.op(a,">",h)||this.op(b,"<",g)&&this.op(b,">",h))&&i.push(c);this.$stage.children(".active").removeClass("active"),this.$stage.children(":eq("+i.join("), :eq(")+")").addClass("active"),this.$stage.children(".center").removeClass("center"),this.settings.center&&this.$stage.children().eq(this.current()).addClass("center")}}],e.prototype.initializeStage=function(){this.$stage=this.$element.find("."+this.settings.stageClass),this.$stage.length||(this.$element.addClass(this.options.loadingClass),this.$stage=a("<"+this.settings.stageElement+">",{class:this.settings.stageClass}).wrap(a("<div/>",{class:this.settings.stageOuterClass})),this.$element.append(this.$stage.parent()))},e.prototype.initializeItems=function(){var b=this.$element.find(".owl-item");if(b.length)return this._items=b.get().map(function(b){return a(b)}),this._mergers=this._items.map(function(){return 1}),void this.refresh();this.replace(this.$element.children().not(this.$stage.parent())),this.isVisible()?this.refresh():this.invalidate("width"),this.$element.removeClass(this.options.loadingClass).addClass(this.options.loadedClass)},e.prototype.initialize=function(){if(this.enter("initializing"),this.trigger("initialize"),this.$element.toggleClass(this.settings.rtlClass,this.settings.rtl),this.settings.autoWidth&&!this.is("pre-loading")){var a,b,c;a=this.$element.find("img"),b=this.settings.nestedItemSelector?"."+this.settings.nestedItemSelector:d,c=this.$element.children(b).width(),a.length&&c<=0&&this.preloadAutoWidthImages(a)}this.initializeStage(),this.initializeItems(),this.registerEventHandlers(),this.leave("initializing"),this.trigger("initialized")},e.prototype.isVisible=function(){return!this.settings.checkVisibility||this.$element.is(":visible")},e.prototype.setup=function(){var b=this.viewport(),c=this.options.responsive,d=-1,e=null;c?(a.each(c,function(a){a<=b&&a>d&&(d=Number(a))}),e=a.extend({},this.options,c[d]),"function"==typeof e.stagePadding&&(e.stagePadding=e.stagePadding()),delete e.responsive,e.responsiveClass&&this.$element.attr("class",this.$element.attr("class").replace(new RegExp("("+this.options.responsiveClass+"-)\\S+\\s","g"),"$1"+d))):e=a.extend({},this.options),this.trigger("change",{property:{name:"settings",value:e}}),this._breakpoint=d,this.settings=e,this.invalidate("settings"),this.trigger("changed",{property:{name:"settings",value:this.settings}})},e.prototype.optionsLogic=function(){this.settings.autoWidth&&(this.settings.stagePadding=!1,this.settings.merge=!1)},e.prototype.prepare=function(b){var c=this.trigger("prepare",{content:b});return c.data||(c.data=a("<"+this.settings.itemElement+"/>").addClass(this.options.itemClass).append(b)),this.trigger("prepared",{content:c.data}),c.data},e.prototype.update=function(){for(var b=0,c=this._pipe.length,d=a.proxy(function(a){return this[a]},this._invalidated),e={};b<c;)(this._invalidated.all||a.grep(this._pipe[b].filter,d).length>0)&&this._pipe[b].run(e),b++;this._invalidated={},!this.is("valid")&&this.enter("valid")},e.prototype.width=function(a){switch(a=a||e.Width.Default){case e.Width.Inner:case e.Width.Outer:return this._width;default:return this._width-2*this.settings.stagePadding+this.settings.margin}},e.prototype.refresh=function(){this.enter("refreshing"),this.trigger("refresh"),this.setup(),this.optionsLogic(),this.$element.addClass(this.options.refreshClass),this.update(),this.$element.removeClass(this.options.refreshClass),this.leave("refreshing"),this.trigger("refreshed")},e.prototype.onThrottledResize=function(){b.clearTimeout(this.resizeTimer),this.resizeTimer=b.setTimeout(this._handlers.onResize,this.settings.responsiveRefreshRate)},e.prototype.onResize=function(){return!!this._items.length&&(this._width!==this.$element.width()&&(!!this.isVisible()&&(this.enter("resizing"),this.trigger("resize").isDefaultPrevented()?(this.leave("resizing"),!1):(this.invalidate("width"),this.refresh(),this.leave("resizing"),void this.trigger("resized")))))},e.prototype.registerEventHandlers=function(){a.support.transition&&this.$stage.on(a.support.transition.end+".owl.core",a.proxy(this.onTransitionEnd,this)),!1!==this.settings.responsive&&this.on(b,"resize",this._handlers.onThrottledResize),this.settings.mouseDrag&&(this.$element.addClass(this.options.dragClass),this.$stage.on("mousedown.owl.core",a.proxy(this.onDragStart,this)),this.$stage.on("dragstart.owl.core selectstart.owl.core",function(){return!1})),this.settings.touchDrag&&(this.$stage.on("touchstart.owl.core",a.proxy(this.onDragStart,this)),this.$stage.on("touchcancel.owl.core",a.proxy(this.onDragEnd,this)))},e.prototype.onDragStart=function(b){var d=null;3!==b.which&&(a.support.transform?(d=this.$stage.css("transform").replace(/.*\(|\)| /g,"").split(","),d={x:d[16===d.length?12:4],y:d[16===d.length?13:5]}):(d=this.$stage.position(),d={x:this.settings.rtl?d.left+this.$stage.width()-this.width()+this.settings.margin:d.left,y:d.top}),this.is("animating")&&(a.support.transform?this.animate(d.x):this.$stage.stop(),this.invalidate("position")),this.$element.toggleClass(this.options.grabClass,"mousedown"===b.type),this.speed(0),this._drag.time=(new Date).getTime(),this._drag.target=a(b.target),this._drag.stage.start=d,this._drag.stage.current=d,this._drag.pointer=this.pointer(b),a(c).on("mouseup.owl.core touchend.owl.core",a.proxy(this.onDragEnd,this)),a(c).one("mousemove.owl.core touchmove.owl.core",a.proxy(function(b){var d=this.difference(this._drag.pointer,this.pointer(b));a(c).on("mousemove.owl.core touchmove.owl.core",a.proxy(this.onDragMove,this)),Math.abs(d.x)<Math.abs(d.y)&&this.is("valid")||(b.preventDefault(),this.enter("dragging"),this.trigger("drag"))},this)))},e.prototype.onDragMove=function(a){var b=null,c=null,d=null,e=this.difference(this._drag.pointer,this.pointer(a)),f=this.difference(this._drag.stage.start,e);this.is("dragging")&&(a.preventDefault(),this.settings.loop?(b=this.coordinates(this.minimum()),c=this.coordinates(this.maximum()+1)-b,f.x=((f.x-b)%c+c)%c+b):(b=this.settings.rtl?this.coordinates(this.maximum()):this.coordinates(this.minimum()),c=this.settings.rtl?this.coordinates(this.minimum()):this.coordinates(this.maximum()),d=this.settings.pullDrag?-1*e.x/5:0,f.x=Math.max(Math.min(f.x,b+d),c+d)),this._drag.stage.current=f,this.animate(f.x))},e.prototype.onDragEnd=function(b){var d=this.difference(this._drag.pointer,this.pointer(b)),e=this._drag.stage.current,f=d.x>0^this.settings.rtl?"left":"right";a(c).off(".owl.core"),this.$element.removeClass(this.options.grabClass),(0!==d.x&&this.is("dragging")||!this.is("valid"))&&(this.speed(this.settings.dragEndSpeed||this.settings.smartSpeed),this.current(this.closest(e.x,0!==d.x?f:this._drag.direction)),this.invalidate("position"),this.update(),this._drag.direction=f,(Math.abs(d.x)>3||(new Date).getTime()-this._drag.time>300)&&this._drag.target.one("click.owl.core",function(){return!1})),this.is("dragging")&&(this.leave("dragging"),this.trigger("dragged"))},e.prototype.closest=function(b,c){var e=-1,f=30,g=this.width(),h=this.coordinates();return this.settings.freeDrag||a.each(h,a.proxy(function(a,i){return"left"===c&&b>i-f&&b<i+f?e=a:"right"===c&&b>i-g-f&&b<i-g+f?e=a+1:this.op(b,"<",i)&&this.op(b,">",h[a+1]!==d?h[a+1]:i-g)&&(e="left"===c?a+1:a),-1===e},this)),this.settings.loop||(this.op(b,">",h[this.minimum()])?e=b=this.minimum():this.op(b,"<",h[this.maximum()])&&(e=b=this.maximum())),e},e.prototype.animate=function(b){var c=this.speed()>0;this.is("animating")&&this.onTransitionEnd(),c&&(this.enter("animating"),this.trigger("translate")),a.support.transform3d&&a.support.transition?this.$stage.css({transform:"translate3d("+b+"px,0px,0px)",transition:this.speed()/1e3+"s"+(this.settings.slideTransition?" "+this.settings.slideTransition:"")}):c?this.$stage.animate({left:b+"px"},this.speed(),this.settings.fallbackEasing,a.proxy(this.onTransitionEnd,this)):this.$stage.css({left:b+"px"})},e.prototype.is=function(a){return this._states.current[a]&&this._states.current[a]>0},e.prototype.current=function(a){if(a===d)return this._current;if(0===this._items.length)return d;if(a=this.normalize(a),this._current!==a){var b=this.trigger("change",{property:{name:"position",value:a}});b.data!==d&&(a=this.normalize(b.data)),this._current=a,this.invalidate("position"),this.trigger("changed",{property:{name:"position",value:this._current}})}return this._current},e.prototype.invalidate=function(b){return"string"===a.type(b)&&(this._invalidated[b]=!0,this.is("valid")&&this.leave("valid")),a.map(this._invalidated,function(a,b){return b})},e.prototype.reset=function(a){(a=this.normalize(a))!==d&&(this._speed=0,this._current=a,this.suppress(["translate","translated"]),this.animate(this.coordinates(a)),this.release(["translate","translated"]))},e.prototype.normalize=function(a,b){var c=this._items.length,e=b?0:this._clones.length;return!this.isNumeric(a)||c<1?a=d:(a<0||a>=c+e)&&(a=((a-e/2)%c+c)%c+e/2),a},e.prototype.relative=function(a){return a-=this._clones.length/2,this.normalize(a,!0)},e.prototype.maximum=function(a){var b,c,d,e=this.settings,f=this._coordinates.length;if(e.loop)f=this._clones.length/2+this._items.length-1;else if(e.autoWidth||e.merge){if(b=this._items.length)for(c=this._items[--b].width(),d=this.$element.width();b--&&!((c+=this._items[b].width()+this.settings.margin)>d););f=b+1}else f=e.center?this._items.length-1:this._items.length-e.items;return a&&(f-=this._clones.length/2),Math.max(f,0)},e.prototype.minimum=function(a){return a?0:this._clones.length/2},e.prototype.items=function(a){return a===d?this._items.slice():(a=this.normalize(a,!0),this._items[a])},e.prototype.mergers=function(a){return a===d?this._mergers.slice():(a=this.normalize(a,!0),this._mergers[a])},e.prototype.clones=function(b){var c=this._clones.length/2,e=c+this._items.length,f=function(a){return a%2==0?e+a/2:c-(a+1)/2};return b===d?a.map(this._clones,function(a,b){return f(b)}):a.map(this._clones,function(a,c){return a===b?f(c):null})},e.prototype.speed=function(a){return a!==d&&(this._speed=a),this._speed},e.prototype.coordinates=function(b){var c,e=1,f=b-1;return b===d?a.map(this._coordinates,a.proxy(function(a,b){return this.coordinates(b)},this)):(this.settings.center?(this.settings.rtl&&(e=-1,f=b+1),c=this._coordinates[b],c+=(this.width()-c+(this._coordinates[f]||0))/2*e):c=this._coordinates[f]||0,c=Math.ceil(c))},e.prototype.duration=function(a,b,c){return 0===c?0:Math.min(Math.max(Math.abs(b-a),1),6)*Math.abs(c||this.settings.smartSpeed)},e.prototype.to=function(a,b){var c=this.current(),d=null,e=a-this.relative(c),f=(e>0)-(e<0),g=this._items.length,h=this.minimum(),i=this.maximum();this.settings.loop?(!this.settings.rewind&&Math.abs(e)>g/2&&(e+=-1*f*g),a=c+e,(d=((a-h)%g+g)%g+h)!==a&&d-e<=i&&d-e>0&&(c=d-e,a=d,this.reset(c))):this.settings.rewind?(i+=1,a=(a%i+i)%i):a=Math.max(h,Math.min(i,a)),this.speed(this.duration(c,a,b)),this.current(a),this.isVisible()&&this.update()},e.prototype.next=function(a){a=a||!1,this.to(this.relative(this.current())+1,a)},e.prototype.prev=function(a){a=a||!1,this.to(this.relative(this.current())-1,a)},e.prototype.onTransitionEnd=function(a){if(a!==d&&(a.stopPropagation(),(a.target||a.srcElement||a.originalTarget)!==this.$stage.get(0)))return!1;this.leave("animating"),this.trigger("translated")},e.prototype.viewport=function(){var d;return this.options.responsiveBaseElement!==b?d=a(this.options.responsiveBaseElement).width():b.innerWidth?d=b.innerWidth:c.documentElement&&c.documentElement.clientWidth?d=c.documentElement.clientWidth:console.warn("Can not detect viewport width."),d},e.prototype.replace=function(b){this.$stage.empty(),this._items=[],b&&(b=b instanceof jQuery?b:a(b)),this.settings.nestedItemSelector&&(b=b.find("."+this.settings.nestedItemSelector)),b.filter(function(){return 1===this.nodeType}).each(a.proxy(function(a,b){b=this.prepare(b),this.$stage.append(b),this._items.push(b),this._mergers.push(1*b.find("[data-merge]").addBack("[data-merge]").attr("data-merge")||1)},this)),this.reset(this.isNumeric(this.settings.startPosition)?this.settings.startPosition:0),this.invalidate("items")},e.prototype.add=function(b,c){var e=this.relative(this._current);c=c===d?this._items.length:this.normalize(c,!0),b=b instanceof jQuery?b:a(b),this.trigger("add",{content:b,position:c}),b=this.prepare(b),0===this._items.length||c===this._items.length?(0===this._items.length&&this.$stage.append(b),0!==this._items.length&&this._items[c-1].after(b),this._items.push(b),this._mergers.push(1*b.find("[data-merge]").addBack("[data-merge]").attr("data-merge")||1)):(this._items[c].before(b),this._items.splice(c,0,b),this._mergers.splice(c,0,1*b.find("[data-merge]").addBack("[data-merge]").attr("data-merge")||1)),this._items[e]&&this.reset(this._items[e].index()),this.invalidate("items"),this.trigger("added",{content:b,position:c})},e.prototype.remove=function(a){(a=this.normalize(a,!0))!==d&&(this.trigger("remove",{content:this._items[a],position:a}),this._items[a].remove(),this._items.splice(a,1),this._mergers.splice(a,1),this.invalidate("items"),this.trigger("removed",{content:null,position:a}))},e.prototype.preloadAutoWidthImages=function(b){b.each(a.proxy(function(b,c){this.enter("pre-loading"),c=a(c),a(new Image).one("load",a.proxy(function(a){c.attr("src",a.target.src),c.css("opacity",1),this.leave("pre-loading"),!this.is("pre-loading")&&!this.is("initializing")&&this.refresh()},this)).attr("src",c.attr("src")||c.attr("data-src")||c.attr("data-src-retina"))},this))},e.prototype.destroy=function(){this.$element.off(".owl.core"),this.$stage.off(".owl.core"),a(c).off(".owl.core"),!1!==this.settings.responsive&&(b.clearTimeout(this.resizeTimer),this.off(b,"resize",this._handlers.onThrottledResize));for(var d in this._plugins)this._plugins[d].destroy();this.$stage.children(".cloned").remove(),this.$stage.unwrap(),this.$stage.children().contents().unwrap(),this.$stage.children().unwrap(),this.$stage.remove(),this.$element.removeClass(this.options.refreshClass).removeClass(this.options.loadingClass).removeClass(this.options.loadedClass).removeClass(this.options.rtlClass).removeClass(this.options.dragClass).removeClass(this.options.grabClass).attr("class",this.$element.attr("class").replace(new RegExp(this.options.responsiveClass+"-\\S+\\s","g"),"")).removeData("owl.carousel")},e.prototype.op=function(a,b,c){var d=this.settings.rtl;switch(b){case"<":return d?a>c:a<c;case">":return d?a<c:a>c;case">=":return d?a<=c:a>=c;case"<=":return d?a>=c:a<=c}},e.prototype.on=function(a,b,c,d){a.addEventListener?a.addEventListener(b,c,d):a.attachEvent&&a.attachEvent("on"+b,c)},e.prototype.off=function(a,b,c,d){a.removeEventListener?a.removeEventListener(b,c,d):a.detachEvent&&a.detachEvent("on"+b,c)},e.prototype.trigger=function(b,c,d,f,g){var h={item:{count:this._items.length,index:this.current()}},i=a.camelCase(a.grep(["on",b,d],function(a){return a}).join("-").toLowerCase()),j=a.Event([b,"owl",d||"carousel"].join(".").toLowerCase(),a.extend({relatedTarget:this},h,c));return this._supress[b]||(a.each(this._plugins,function(a,b){b.onTrigger&&b.onTrigger(j)}),this.register({type:e.Type.Event,name:b}),this.$element.trigger(j),this.settings&&"function"==typeof this.settings[i]&&this.settings[i].call(this,j)),j},e.prototype.enter=function(b){a.each([b].concat(this._states.tags[b]||[]),a.proxy(function(a,b){this._states.current[b]===d&&(this._states.current[b]=0),this._states.current[b]++},this))},e.prototype.leave=function(b){a.each([b].concat(this._states.tags[b]||[]),a.proxy(function(a,b){this._states.current[b]--},this))},e.prototype.register=function(b){if(b.type===e.Type.Event){if(a.event.special[b.name]||(a.event.special[b.name]={}),!a.event.special[b.name].owl){var c=a.event.special[b.name]._default;a.event.special[b.name]._default=function(a){return!c||!c.apply||a.namespace&&-1!==a.namespace.indexOf("owl")?a.namespace&&a.namespace.indexOf("owl")>-1:c.apply(this,arguments)},a.event.special[b.name].owl=!0}}else b.type===e.Type.State&&(this._states.tags[b.name]?this._states.tags[b.name]=this._states.tags[b.name].concat(b.tags):this._states.tags[b.name]=b.tags,this._states.tags[b.name]=a.grep(this._states.tags[b.name],a.proxy(function(c,d){return a.inArray(c,this._states.tags[b.name])===d},this)))},e.prototype.suppress=function(b){a.each(b,a.proxy(function(a,b){this._supress[b]=!0},this))},e.prototype.release=function(b){a.each(b,a.proxy(function(a,b){delete this._supress[b]},this))},e.prototype.pointer=function(a){var c={x:null,y:null};return a=a.originalEvent||a||b.event,a=a.touches&&a.touches.length?a.touches[0]:a.changedTouches&&a.changedTouches.length?a.changedTouches[0]:a,a.pageX?(c.x=a.pageX,c.y=a.pageY):(c.x=a.clientX,c.y=a.clientY),c},e.prototype.isNumeric=function(a){return!isNaN(parseFloat(a))},e.prototype.difference=function(a,b){return{x:a.x-b.x,y:a.y-b.y}},a.fn.owlCarousel=function(b){var c=Array.prototype.slice.call(arguments,1);return this.each(function(){var d=a(this),f=d.data("owl.carousel");f||(f=new e(this,"object"==typeof b&&b),d.data("owl.carousel",f),a.each(["next","prev","to","destroy","refresh","replace","add","remove"],function(b,c){f.register({type:e.Type.Event,name:c}),f.$element.on(c+".owl.carousel.core",a.proxy(function(a){a.namespace&&a.relatedTarget!==this&&(this.suppress([c]),f[c].apply(this,[].slice.call(arguments,1)),this.release([c]))},f))})),"string"==typeof b&&"_"!==b.charAt(0)&&f[b].apply(f,c)})},a.fn.owlCarousel.Constructor=e}(window.Zepto||window.jQuery,window,document),function(a,b,c,d){var e=function(b){this._core=b,this._interval=null,this._visible=null,this._handlers={"initialized.owl.carousel":a.proxy(function(a){a.namespace&&this._core.settings.autoRefresh&&this.watch()},this)},this._core.options=a.extend({},e.Defaults,this._core.options),this._core.$element.on(this._handlers)};e.Defaults={autoRefresh:!0,autoRefreshInterval:500},e.prototype.watch=function(){this._interval||(this._visible=this._core.isVisible(),this._interval=b.setInterval(a.proxy(this.refresh,this),this._core.settings.autoRefreshInterval))},e.prototype.refresh=function(){this._core.isVisible()!==this._visible&&(this._visible=!this._visible,this._core.$element.toggleClass("owl-hidden",!this._visible),this._visible&&this._core.invalidate("width")&&this._core.refresh())},e.prototype.destroy=function(){var a,c;b.clearInterval(this._interval);for(a in this._handlers)this._core.$element.off(a,this._handlers[a]);for(c in Object.getOwnPropertyNames(this))"function"!=typeof this[c]&&(this[c]=null)},a.fn.owlCarousel.Constructor.Plugins.AutoRefresh=e}(window.Zepto||window.jQuery,window,document),function(a,b,c,d){var e=function(b){this._core=b,this._loaded=[],this._handlers={"initialized.owl.carousel change.owl.carousel resized.owl.carousel":a.proxy(function(b){if(b.namespace&&this._core.settings&&this._core.settings.lazyLoad&&(b.property&&"position"==b.property.name||"initialized"==b.type)){var c=this._core.settings,e=c.center&&Math.ceil(c.items/2)||c.items,f=c.center&&-1*e||0,g=(b.property&&b.property.value!==d?b.property.value:this._core.current())+f,h=this._core.clones().length,i=a.proxy(function(a,b){this.load(b)},this);for(c.lazyLoadEager>0&&(e+=c.lazyLoadEager,c.loop&&(g-=c.lazyLoadEager,e++));f++<e;)this.load(h/2+this._core.relative(g)),h&&a.each(this._core.clones(this._core.relative(g)),i),g++}},this)},this._core.options=a.extend({},e.Defaults,this._core.options),this._core.$element.on(this._handlers)};e.Defaults={lazyLoad:!1,lazyLoadEager:0},e.prototype.load=function(c){var d=this._core.$stage.children().eq(c),e=d&&d.find(".owl-lazy");!e||a.inArray(d.get(0),this._loaded)>-1||(e.each(a.proxy(function(c,d){var e,f=a(d),g=b.devicePixelRatio>1&&f.attr("data-src-retina")||f.attr("data-src")||f.attr("data-srcset");this._core.trigger("load",{element:f,url:g},"lazy"),f.is("img")?f.one("load.owl.lazy",a.proxy(function(){f.css("opacity",1),this._core.trigger("loaded",{element:f,url:g},"lazy")},this)).attr("src",g):f.is("source")?f.one("load.owl.lazy",a.proxy(function(){this._core.trigger("loaded",{element:f,url:g},"lazy")},this)).attr("srcset",g):(e=new Image,e.onload=a.proxy(function(){f.css({"background-image":'url("'+g+'")',opacity:"1"}),this._core.trigger("loaded",{element:f,url:g},"lazy")},this),e.src=g)},this)),this._loaded.push(d.get(0)))},e.prototype.destroy=function(){var a,b;for(a in this.handlers)this._core.$element.off(a,this.handlers[a]);for(b in Object.getOwnPropertyNames(this))"function"!=typeof this[b]&&(this[b]=null)},a.fn.owlCarousel.Constructor.Plugins.Lazy=e}(window.Zepto||window.jQuery,window,document),function(a,b,c,d){var e=function(c){this._core=c,this._previousHeight=null,this._handlers={"initialized.owl.carousel refreshed.owl.carousel":a.proxy(function(a){a.namespace&&this._core.settings.autoHeight&&this.update()},this),"changed.owl.carousel":a.proxy(function(a){a.namespace&&this._core.settings.autoHeight&&"position"===a.property.name&&this.update()},this),"loaded.owl.lazy":a.proxy(function(a){a.namespace&&this._core.settings.autoHeight&&a.element.closest("."+this._core.settings.itemClass).index()===this._core.current()&&this.update()},this)},this._core.options=a.extend({},e.Defaults,this._core.options),this._core.$element.on(this._handlers),this._intervalId=null;var d=this;a(b).on("load",function(){d._core.settings.autoHeight&&d.update()}),a(b).resize(function(){d._core.settings.autoHeight&&(null!=d._intervalId&&clearTimeout(d._intervalId),d._intervalId=setTimeout(function(){d.update()},250))})};e.Defaults={autoHeight:!1,autoHeightClass:"owl-height"},e.prototype.update=function(){var b=this._core._current,c=b+this._core.settings.items,d=this._core.settings.lazyLoad,e=this._core.$stage.children().toArray().slice(b,c),f=[],g=0;a.each(e,function(b,c){f.push(a(c).height())}),g=Math.max.apply(null,f),g<=1&&d&&this._previousHeight&&(g=this._previousHeight),this._previousHeight=g,this._core.$stage.parent().height(g).addClass(this._core.settings.autoHeightClass)},e.prototype.destroy=function(){var a,b;for(a in this._handlers)this._core.$element.off(a,this._handlers[a]);for(b in Object.getOwnPropertyNames(this))"function"!=typeof this[b]&&(this[b]=null)},a.fn.owlCarousel.Constructor.Plugins.AutoHeight=e}(window.Zepto||window.jQuery,window,document),function(a,b,c,d){var e=function(b){this._core=b,this._videos={},this._playing=null,this._handlers={"initialized.owl.carousel":a.proxy(function(a){a.namespace&&this._core.register({type:"state",name:"playing",tags:["interacting"]})},this),"resize.owl.carousel":a.proxy(function(a){a.namespace&&this._core.settings.video&&this.isInFullScreen()&&a.preventDefault()},this),"refreshed.owl.carousel":a.proxy(function(a){a.namespace&&this._core.is("resizing")&&this._core.$stage.find(".cloned .owl-video-frame").remove()},this),"changed.owl.carousel":a.proxy(function(a){a.namespace&&"position"===a.property.name&&this._playing&&this.stop()},this),"prepared.owl.carousel":a.proxy(function(b){if(b.namespace){var c=a(b.content).find(".owl-video");c.length&&(c.css("display","none"),this.fetch(c,a(b.content)))}},this)},this._core.options=a.extend({},e.Defaults,this._core.options),this._core.$element.on(this._handlers),this._core.$element.on("click.owl.video",".owl-video-play-icon",a.proxy(function(a){this.play(a)},this))};e.Defaults={video:!1,videoHeight:!1,videoWidth:!1},e.prototype.fetch=function(a,b){var c=function(){return a.attr("data-vimeo-id")?"vimeo":a.attr("data-vzaar-id")?"vzaar":"youtube"}(),d=a.attr("data-vimeo-id")||a.attr("data-youtube-id")||a.attr("data-vzaar-id"),e=a.attr("data-width")||this._core.settings.videoWidth,f=a.attr("data-height")||this._core.settings.videoHeight,g=a.attr("href");if(!g)throw new Error("Missing video URL.");if(d=g.match(/(http:|https:|)\/\/(player.|www.|app.)?(vimeo\.com|youtu(be\.com|\.be|be\.googleapis\.com|be\-nocookie\.com)|vzaar\.com)\/(video\/|videos\/|embed\/|channels\/.+\/|groups\/.+\/|watch\?v=|v\/)?([A-Za-z0-9._%-]*)(\&\S+)?/),d[3].indexOf("youtu")>-1)c="youtube";else if(d[3].indexOf("vimeo")>-1)c="vimeo";else{if(!(d[3].indexOf("vzaar")>-1))throw new Error("Video URL not supported.");c="vzaar"}d=d[6],this._videos[g]={type:c,id:d,width:e,height:f},b.attr("data-video",g),this.thumbnail(a,this._videos[g])},e.prototype.thumbnail=function(b,c){var d,e,f,g=c.width&&c.height?"width:"+c.width+"px;height:"+c.height+"px;":"",h=b.find("img"),i="src",j="",k=this._core.settings,l=function(c){e='<div class="owl-video-play-icon"></div>',d=k.lazyLoad?a("<div/>",{class:"owl-video-tn "+j,srcType:c}):a("<div/>",{class:"owl-video-tn",style:"opacity:1;background-image:url("+c+")"}),b.after(d),b.after(e)};if(b.wrap(a("<div/>",{class:"owl-video-wrapper",style:g})),this._core.settings.lazyLoad&&(i="data-src",j="owl-lazy"),h.length)return l(h.attr(i)),h.remove(),!1;"youtube"===c.type?(f="//img.youtube.com/vi/"+c.id+"/hqdefault.jpg",l(f)):"vimeo"===c.type?a.ajax({type:"GET",url:"//vimeo.com/api/v2/video/"+c.id+".json",jsonp:"callback",dataType:"jsonp",success:function(a){f=a[0].thumbnail_large,l(f)}}):"vzaar"===c.type&&a.ajax({type:"GET",url:"//vzaar.com/api/videos/"+c.id+".json",jsonp:"callback",dataType:"jsonp",success:function(a){f=a.framegrab_url,l(f)}})},e.prototype.stop=function(){this._core.trigger("stop",null,"video"),this._playing.find(".owl-video-frame").remove(),this._playing.removeClass("owl-video-playing"),this._playing=null,this._core.leave("playing"),this._core.trigger("stopped",null,"video")},e.prototype.play=function(b){var c,d=a(b.target),e=d.closest("."+this._core.settings.itemClass),f=this._videos[e.attr("data-video")],g=f.width||"100%",h=f.height||this._core.$stage.height();this._playing||(this._core.enter("playing"),this._core.trigger("play",null,"video"),e=this._core.items(this._core.relative(e.index())),this._core.reset(e.index()),c=a('<iframe frameborder="0" allowfullscreen mozallowfullscreen webkitAllowFullScreen ></iframe>'),c.attr("height",h),c.attr("width",g),"youtube"===f.type?c.attr("src","//www.youtube.com/embed/"+f.id+"?autoplay=1&rel=0&v="+f.id):"vimeo"===f.type?c.attr("src","//player.vimeo.com/video/"+f.id+"?autoplay=1"):"vzaar"===f.type&&c.attr("src","//view.vzaar.com/"+f.id+"/player?autoplay=true"),a(c).wrap('<div class="owl-video-frame" />').insertAfter(e.find(".owl-video")),this._playing=e.addClass("owl-video-playing"))},e.prototype.isInFullScreen=function(){var b=c.fullscreenElement||c.mozFullScreenElement||c.webkitFullscreenElement;return b&&a(b).parent().hasClass("owl-video-frame")},e.prototype.destroy=function(){var a,b;this._core.$element.off("click.owl.video");for(a in this._handlers)this._core.$element.off(a,this._handlers[a]);for(b in Object.getOwnPropertyNames(this))"function"!=typeof this[b]&&(this[b]=null)},a.fn.owlCarousel.Constructor.Plugins.Video=e}(window.Zepto||window.jQuery,window,document),function(a,b,c,d){var e=function(b){this.core=b,this.core.options=a.extend({},e.Defaults,this.core.options),this.swapping=!0,this.previous=d,this.next=d,this.handlers={"change.owl.carousel":a.proxy(function(a){a.namespace&&"position"==a.property.name&&(this.previous=this.core.current(),this.next=a.property.value)},this),"drag.owl.carousel dragged.owl.carousel translated.owl.carousel":a.proxy(function(a){a.namespace&&(this.swapping="translated"==a.type)},this),"translate.owl.carousel":a.proxy(function(a){a.namespace&&this.swapping&&(this.core.options.animateOut||this.core.options.animateIn)&&this.swap()},this)},this.core.$element.on(this.handlers)};e.Defaults={animateOut:!1,
	animateIn:!1},e.prototype.swap=function(){if(1===this.core.settings.items&&a.support.animation&&a.support.transition){this.core.speed(0);var b,c=a.proxy(this.clear,this),d=this.core.$stage.children().eq(this.previous),e=this.core.$stage.children().eq(this.next),f=this.core.settings.animateIn,g=this.core.settings.animateOut;this.core.current()!==this.previous&&(g&&(b=this.core.coordinates(this.previous)-this.core.coordinates(this.next),d.one(a.support.animation.end,c).css({left:b+"px"}).addClass("animated owl-animated-out").addClass(g)),f&&e.one(a.support.animation.end,c).addClass("animated owl-animated-in").addClass(f))}},e.prototype.clear=function(b){a(b.target).css({left:""}).removeClass("animated owl-animated-out owl-animated-in").removeClass(this.core.settings.animateIn).removeClass(this.core.settings.animateOut),this.core.onTransitionEnd()},e.prototype.destroy=function(){var a,b;for(a in this.handlers)this.core.$element.off(a,this.handlers[a]);for(b in Object.getOwnPropertyNames(this))"function"!=typeof this[b]&&(this[b]=null)},a.fn.owlCarousel.Constructor.Plugins.Animate=e}(window.Zepto||window.jQuery,window,document),function(a,b,c,d){var e=function(b){this._core=b,this._call=null,this._time=0,this._timeout=0,this._paused=!0,this._handlers={"changed.owl.carousel":a.proxy(function(a){a.namespace&&"settings"===a.property.name?this._core.settings.autoplay?this.play():this.stop():a.namespace&&"position"===a.property.name&&this._paused&&(this._time=0)},this),"initialized.owl.carousel":a.proxy(function(a){a.namespace&&this._core.settings.autoplay&&this.play()},this),"play.owl.autoplay":a.proxy(function(a,b,c){a.namespace&&this.play(b,c)},this),"stop.owl.autoplay":a.proxy(function(a){a.namespace&&this.stop()},this),"mouseover.owl.autoplay":a.proxy(function(){this._core.settings.autoplayHoverPause&&this._core.is("rotating")&&this.pause()},this),"mouseleave.owl.autoplay":a.proxy(function(){this._core.settings.autoplayHoverPause&&this._core.is("rotating")&&this.play()},this),"touchstart.owl.core":a.proxy(function(){this._core.settings.autoplayHoverPause&&this._core.is("rotating")&&this.pause()},this),"touchend.owl.core":a.proxy(function(){this._core.settings.autoplayHoverPause&&this.play()},this)},this._core.$element.on(this._handlers),this._core.options=a.extend({},e.Defaults,this._core.options)};e.Defaults={autoplay:!1,autoplayTimeout:5e3,autoplayHoverPause:!1,autoplaySpeed:!1},e.prototype._next=function(d){this._call=b.setTimeout(a.proxy(this._next,this,d),this._timeout*(Math.round(this.read()/this._timeout)+1)-this.read()),this._core.is("interacting")||c.hidden||this._core.next(d||this._core.settings.autoplaySpeed)},e.prototype.read=function(){return(new Date).getTime()-this._time},e.prototype.play=function(c,d){var e;this._core.is("rotating")||this._core.enter("rotating"),c=c||this._core.settings.autoplayTimeout,e=Math.min(this._time%(this._timeout||c),c),this._paused?(this._time=this.read(),this._paused=!1):b.clearTimeout(this._call),this._time+=this.read()%c-e,this._timeout=c,this._call=b.setTimeout(a.proxy(this._next,this,d),c-e)},e.prototype.stop=function(){this._core.is("rotating")&&(this._time=0,this._paused=!0,b.clearTimeout(this._call),this._core.leave("rotating"))},e.prototype.pause=function(){this._core.is("rotating")&&!this._paused&&(this._time=this.read(),this._paused=!0,b.clearTimeout(this._call))},e.prototype.destroy=function(){var a,b;this.stop();for(a in this._handlers)this._core.$element.off(a,this._handlers[a]);for(b in Object.getOwnPropertyNames(this))"function"!=typeof this[b]&&(this[b]=null)},a.fn.owlCarousel.Constructor.Plugins.autoplay=e}(window.Zepto||window.jQuery,window,document),function(a,b,c,d){"use strict";var e=function(b){this._core=b,this._initialized=!1,this._pages=[],this._controls={},this._templates=[],this.$element=this._core.$element,this._overrides={next:this._core.next,prev:this._core.prev,to:this._core.to},this._handlers={"prepared.owl.carousel":a.proxy(function(b){b.namespace&&this._core.settings.dotsData&&this._templates.push('<div class="'+this._core.settings.dotClass+'">'+a(b.content).find("[data-dot]").addBack("[data-dot]").attr("data-dot")+"</div>")},this),"added.owl.carousel":a.proxy(function(a){a.namespace&&this._core.settings.dotsData&&this._templates.splice(a.position,0,this._templates.pop())},this),"remove.owl.carousel":a.proxy(function(a){a.namespace&&this._core.settings.dotsData&&this._templates.splice(a.position,1)},this),"changed.owl.carousel":a.proxy(function(a){a.namespace&&"position"==a.property.name&&this.draw()},this),"initialized.owl.carousel":a.proxy(function(a){a.namespace&&!this._initialized&&(this._core.trigger("initialize",null,"navigation"),this.initialize(),this.update(),this.draw(),this._initialized=!0,this._core.trigger("initialized",null,"navigation"))},this),"refreshed.owl.carousel":a.proxy(function(a){a.namespace&&this._initialized&&(this._core.trigger("refresh",null,"navigation"),this.update(),this.draw(),this._core.trigger("refreshed",null,"navigation"))},this)},this._core.options=a.extend({},e.Defaults,this._core.options),this.$element.on(this._handlers)};e.Defaults={nav:!1,navText:['<span aria-label="Previous">&#x2039;</span>','<span aria-label="Next">&#x203a;</span>'],navSpeed:!1,navElement:'button type="button" role="presentation"',navContainer:!1,navContainerClass:"owl-nav",navClass:["owl-prev","owl-next"],slideBy:1,dotClass:"owl-dot",dotsClass:"owl-dots",dots:!0,dotsEach:!1,dotsData:!1,dotsSpeed:!1,dotsContainer:!1},e.prototype.initialize=function(){var b,c=this._core.settings;this._controls.$relative=(c.navContainer?a(c.navContainer):a("<div>").addClass(c.navContainerClass).appendTo(this.$element)).addClass("disabled"),this._controls.$previous=a("<"+c.navElement+">").addClass(c.navClass[0]).html(c.navText[0]).prependTo(this._controls.$relative).on("click",a.proxy(function(a){this.prev(c.navSpeed)},this)),this._controls.$next=a("<"+c.navElement+">").addClass(c.navClass[1]).html(c.navText[1]).appendTo(this._controls.$relative).on("click",a.proxy(function(a){this.next(c.navSpeed)},this)),c.dotsData||(this._templates=[a('<button role="button">').addClass(c.dotClass).append(a("<span>")).prop("outerHTML")]),this._controls.$absolute=(c.dotsContainer?a(c.dotsContainer):a("<div>").addClass(c.dotsClass).appendTo(this.$element)).addClass("disabled"),this._controls.$absolute.on("click","button",a.proxy(function(b){var d=a(b.target).parent().is(this._controls.$absolute)?a(b.target).index():a(b.target).parent().index();b.preventDefault(),this.to(d,c.dotsSpeed)},this));for(b in this._overrides)this._core[b]=a.proxy(this[b],this)},e.prototype.destroy=function(){var a,b,c,d,e;e=this._core.settings;for(a in this._handlers)this.$element.off(a,this._handlers[a]);for(b in this._controls)"$relative"===b&&e.navContainer?this._controls[b].html(""):this._controls[b].remove();for(d in this.overides)this._core[d]=this._overrides[d];for(c in Object.getOwnPropertyNames(this))"function"!=typeof this[c]&&(this[c]=null)},e.prototype.update=function(){var a,b,c,d=this._core.clones().length/2,e=d+this._core.items().length,f=this._core.maximum(!0),g=this._core.settings,h=g.center||g.autoWidth||g.dotsData?1:g.dotsEach||g.items;if("page"!==g.slideBy&&(g.slideBy=Math.min(g.slideBy,g.items)),g.dots||"page"==g.slideBy)for(this._pages=[],a=d,b=0,c=0;a<e;a++){if(b>=h||0===b){if(this._pages.push({start:Math.min(f,a-d),end:a-d+h-1}),Math.min(f,a-d)===f)break;b=0,++c}b+=this._core.mergers(this._core.relative(a))}},e.prototype.draw=function(){var b,c=this._core.settings,d=this._core.items().length<=c.items,e=this._core.relative(this._core.current()),f=c.loop||c.rewind;this._controls.$relative.toggleClass("disabled",!c.nav||d),c.nav&&(this._controls.$previous.toggleClass("disabled",!f&&e<=this._core.minimum(!0)),this._controls.$next.toggleClass("disabled",!f&&e>=this._core.maximum(!0))),this._controls.$absolute.toggleClass("disabled",!c.dots||d),c.dots&&(b=this._pages.length-this._controls.$absolute.children().length,c.dotsData&&0!==b?this._controls.$absolute.html(this._templates.join("")):b>0?this._controls.$absolute.append(new Array(b+1).join(this._templates[0])):b<0&&this._controls.$absolute.children().slice(b).remove(),this._controls.$absolute.find(".active").removeClass("active"),this._controls.$absolute.children().eq(a.inArray(this.current(),this._pages)).addClass("active"))},e.prototype.onTrigger=function(b){var c=this._core.settings;b.page={index:a.inArray(this.current(),this._pages),count:this._pages.length,size:c&&(c.center||c.autoWidth||c.dotsData?1:c.dotsEach||c.items)}},e.prototype.current=function(){var b=this._core.relative(this._core.current());return a.grep(this._pages,a.proxy(function(a,c){return a.start<=b&&a.end>=b},this)).pop()},e.prototype.getPosition=function(b){var c,d,e=this._core.settings;return"page"==e.slideBy?(c=a.inArray(this.current(),this._pages),d=this._pages.length,b?++c:--c,c=this._pages[(c%d+d)%d].start):(c=this._core.relative(this._core.current()),d=this._core.items().length,b?c+=e.slideBy:c-=e.slideBy),c},e.prototype.next=function(b){a.proxy(this._overrides.to,this._core)(this.getPosition(!0),b)},e.prototype.prev=function(b){a.proxy(this._overrides.to,this._core)(this.getPosition(!1),b)},e.prototype.to=function(b,c,d){var e;!d&&this._pages.length?(e=this._pages.length,a.proxy(this._overrides.to,this._core)(this._pages[(b%e+e)%e].start,c)):a.proxy(this._overrides.to,this._core)(b,c)},a.fn.owlCarousel.Constructor.Plugins.Navigation=e}(window.Zepto||window.jQuery,window,document),function(a,b,c,d){"use strict";var e=function(c){this._core=c,this._hashes={},this.$element=this._core.$element,this._handlers={"initialized.owl.carousel":a.proxy(function(c){c.namespace&&"URLHash"===this._core.settings.startPosition&&a(b).trigger("hashchange.owl.navigation")},this),"prepared.owl.carousel":a.proxy(function(b){if(b.namespace){var c=a(b.content).find("[data-hash]").addBack("[data-hash]").attr("data-hash");if(!c)return;this._hashes[c]=b.content}},this),"changed.owl.carousel":a.proxy(function(c){if(c.namespace&&"position"===c.property.name){var d=this._core.items(this._core.relative(this._core.current())),e=a.map(this._hashes,function(a,b){return a===d?b:null}).join();if(!e||b.location.hash.slice(1)===e)return;b.location.hash=e}},this)},this._core.options=a.extend({},e.Defaults,this._core.options),this.$element.on(this._handlers),a(b).on("hashchange.owl.navigation",a.proxy(function(a){var c=b.location.hash.substring(1),e=this._core.$stage.children(),f=this._hashes[c]&&e.index(this._hashes[c]);f!==d&&f!==this._core.current()&&this._core.to(this._core.relative(f),!1,!0)},this))};e.Defaults={URLhashListener:!1},e.prototype.destroy=function(){var c,d;a(b).off("hashchange.owl.navigation");for(c in this._handlers)this._core.$element.off(c,this._handlers[c]);for(d in Object.getOwnPropertyNames(this))"function"!=typeof this[d]&&(this[d]=null)},a.fn.owlCarousel.Constructor.Plugins.Hash=e}(window.Zepto||window.jQuery,window,document),function(a,b,c,d){function e(b,c){var e=!1,f=b.charAt(0).toUpperCase()+b.slice(1);return a.each((b+" "+h.join(f+" ")+f).split(" "),function(a,b){if(g[b]!==d)return e=!c||b,!1}),e}function f(a){return e(a,!0)}var g=a("<support>").get(0).style,h="Webkit Moz O ms".split(" "),i={transition:{end:{WebkitTransition:"webkitTransitionEnd",MozTransition:"transitionend",OTransition:"oTransitionEnd",transition:"transitionend"}},animation:{end:{WebkitAnimation:"webkitAnimationEnd",MozAnimation:"animationend",OAnimation:"oAnimationEnd",animation:"animationend"}}},j={csstransforms:function(){return!!e("transform")},csstransforms3d:function(){return!!e("perspective")},csstransitions:function(){return!!e("transition")},cssanimations:function(){return!!e("animation")}};j.csstransitions()&&(a.support.transition=new String(f("transition")),a.support.transition.end=i.transition.end[a.support.transition]),j.cssanimations()&&(a.support.animation=new String(f("animation")),a.support.animation.end=i.animation.end[a.support.animation]),j.csstransforms()&&(a.support.transform=new String(f("transform")),a.support.transform3d=j.csstransforms3d())}(window.Zepto||window.jQuery,window,document);

/***/ }),
/* 52 */
/***/ (function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ }),
/* 53 */
/***/ (function(module, exports) {

	/*
	 * bootstrap-tagsinput v0.6.1 by Tim Schlechter
	 * 
	 */

	!function(a){"use strict";function b(b,c){this.itemsArray=[],this.$element=a(b),this.$element.hide(),this.isSelect="SELECT"===b.tagName,this.multiple=this.isSelect&&b.hasAttribute("multiple"),this.objectItems=c&&c.itemValue,this.placeholderText=b.hasAttribute("placeholder")?this.$element.attr("placeholder"):"",this.inputSize=Math.max(1,this.placeholderText.length),this.$container=a('<div class="bootstrap-tagsinput"></div>'),this.$input=a('<input type="text" placeholder="'+this.placeholderText+'"/>').appendTo(this.$container),this.$element.before(this.$container),this.build(c)}function c(a,b){if("function"!=typeof a[b]){var c=a[b];a[b]=function(a){return a[c]}}}function d(a,b){if("function"!=typeof a[b]){var c=a[b];a[b]=function(){return c}}}function e(a){return a?i.text(a).html():""}function f(a){var b=0;if(document.selection){a.focus();var c=document.selection.createRange();c.moveStart("character",-a.value.length),b=c.text.length}else(a.selectionStart||"0"==a.selectionStart)&&(b=a.selectionStart);return b}function g(b,c){var d=!1;return a.each(c,function(a,c){if("number"==typeof c&&b.which===c)return d=!0,!1;if(b.which===c.which){var e=!c.hasOwnProperty("altKey")||b.altKey===c.altKey,f=!c.hasOwnProperty("shiftKey")||b.shiftKey===c.shiftKey,g=!c.hasOwnProperty("ctrlKey")||b.ctrlKey===c.ctrlKey;if(e&&f&&g)return d=!0,!1}}),d}var h={tagClass:function(a){return"label label-info"},itemValue:function(a){return a?a.toString():a},itemText:function(a){return this.itemValue(a)},itemTitle:function(a){return null},freeInput:!0,addOnBlur:!0,maxTags:void 0,maxChars:void 0,confirmKeys:[13,44],delimiter:",",delimiterRegex:null,cancelConfirmKeysOnEmpty:!0,onTagExists:function(a,b){b.hide().fadeIn()},trimValue:!1,allowDuplicates:!1};b.prototype={constructor:b,add:function(b,c,d){var f=this;if(!(f.options.maxTags&&f.itemsArray.length>=f.options.maxTags)&&(b===!1||b)){if("string"==typeof b&&f.options.trimValue&&(b=a.trim(b)),"object"==typeof b&&!f.objectItems)throw"Can't add objects when itemValue option is not set";if(!b.toString().match(/^\s*$/)){if(f.isSelect&&!f.multiple&&f.itemsArray.length>0&&f.remove(f.itemsArray[0]),"string"==typeof b&&"INPUT"===this.$element[0].tagName){var g=f.options.delimiterRegex?f.options.delimiterRegex:f.options.delimiter,h=b.split(g);if(h.length>1){for(var i=0;i<h.length;i++)this.add(h[i],!0);return void(c||f.pushVal())}}var j=f.options.itemValue(b),k=f.options.itemText(b),l=f.options.tagClass(b),m=f.options.itemTitle(b),n=a.grep(f.itemsArray,function(a){return f.options.itemValue(a)===j})[0];if(!n||f.options.allowDuplicates){if(!(f.items().toString().length+b.length+1>f.options.maxInputLength)){var o=a.Event("beforeItemAdd",{item:b,cancel:!1,options:d});if(f.$element.trigger(o),!o.cancel){f.itemsArray.push(b);var p=a('<span class="tag '+e(l)+(null!==m?'" title="'+m:"")+'">'+e(k)+'<span data-role="remove"></span></span>');if(p.data("item",b),f.findInputWrapper().before(p),p.after(" "),f.isSelect&&!a('option[value="'+encodeURIComponent(j)+'"]',f.$element)[0]){var q=a("<option selected>"+e(k)+"</option>");q.data("item",b),q.attr("value",j),f.$element.append(q)}c||f.pushVal(),(f.options.maxTags===f.itemsArray.length||f.items().toString().length===f.options.maxInputLength)&&f.$container.addClass("bootstrap-tagsinput-max"),f.$element.trigger(a.Event("itemAdded",{item:b,options:d}))}}}else if(f.options.onTagExists){var r=a(".tag",f.$container).filter(function(){return a(this).data("item")===n});f.options.onTagExists(b,r)}}}},remove:function(b,c,d){var e=this;if(e.objectItems&&(b="object"==typeof b?a.grep(e.itemsArray,function(a){return e.options.itemValue(a)==e.options.itemValue(b)}):a.grep(e.itemsArray,function(a){return e.options.itemValue(a)==b}),b=b[b.length-1]),b){var f=a.Event("beforeItemRemove",{item:b,cancel:!1,options:d});if(e.$element.trigger(f),f.cancel)return;a(".tag",e.$container).filter(function(){return a(this).data("item")===b}).remove(),a("option",e.$element).filter(function(){return a(this).data("item")===b}).remove(),-1!==a.inArray(b,e.itemsArray)&&e.itemsArray.splice(a.inArray(b,e.itemsArray),1)}c||e.pushVal(),e.options.maxTags>e.itemsArray.length&&e.$container.removeClass("bootstrap-tagsinput-max"),e.$element.trigger(a.Event("itemRemoved",{item:b,options:d}))},removeAll:function(){var b=this;for(a(".tag",b.$container).remove(),a("option",b.$element).remove();b.itemsArray.length>0;)b.itemsArray.pop();b.pushVal()},refresh:function(){var b=this;a(".tag",b.$container).each(function(){var c=a(this),d=c.data("item"),f=b.options.itemValue(d),g=b.options.itemText(d),h=b.options.tagClass(d);if(c.attr("class",null),c.addClass("tag "+e(h)),c.contents().filter(function(){return 3==this.nodeType})[0].nodeValue=e(g),b.isSelect){var i=a("option",b.$element).filter(function(){return a(this).data("item")===d});i.attr("value",f)}})},items:function(){return this.itemsArray},pushVal:function(){var b=this,c=a.map(b.items(),function(a){return b.options.itemValue(a).toString()});b.$element.val(c,!0).trigger("change")},build:function(b){var e=this;if(e.options=a.extend({},h,b),e.objectItems&&(e.options.freeInput=!1),c(e.options,"itemValue"),c(e.options,"itemText"),d(e.options,"tagClass"),e.options.typeahead){var i=e.options.typeahead||{};d(i,"source"),e.$input.typeahead(a.extend({},i,{source:function(b,c){function d(a){for(var b=[],d=0;d<a.length;d++){var g=e.options.itemText(a[d]);f[g]=a[d],b.push(g)}c(b)}this.map={};var f=this.map,g=i.source(b);a.isFunction(g.success)?g.success(d):a.isFunction(g.then)?g.then(d):a.when(g).then(d)},updater:function(a){return e.add(this.map[a]),this.map[a]},matcher:function(a){return-1!==a.toLowerCase().indexOf(this.query.trim().toLowerCase())},sorter:function(a){return a.sort()},highlighter:function(a){var b=new RegExp("("+this.query+")","gi");return a.replace(b,"<strong>$1</strong>")}}))}if(e.options.typeaheadjs){var j=null,k={},l=e.options.typeaheadjs;a.isArray(l)?(j=l[0],k=l[1]):k=l,e.$input.typeahead(j,k).on("typeahead:selected",a.proxy(function(a,b){k.valueKey?e.add(b[k.valueKey]):e.add(b),e.$input.typeahead("val","")},e))}e.$container.on("click",a.proxy(function(a){e.$element.attr("disabled")||e.$input.removeAttr("disabled"),e.$input.focus()},e)),e.options.addOnBlur&&e.options.freeInput&&e.$input.on("focusout",a.proxy(function(b){0===a(".typeahead, .twitter-typeahead",e.$container).length&&(e.add(e.$input.val()),e.$input.val(""))},e)),e.$container.on("keydown","input",a.proxy(function(b){var c=a(b.target),d=e.findInputWrapper();if(e.$element.attr("disabled"))return void e.$input.attr("disabled","disabled");switch(b.which){case 8:if(0===f(c[0])){var g=d.prev();g.length&&e.remove(g.data("item"))}break;case 46:if(0===f(c[0])){var h=d.next();h.length&&e.remove(h.data("item"))}break;case 37:var i=d.prev();0===c.val().length&&i[0]&&(i.before(d),c.focus());break;case 39:var j=d.next();0===c.val().length&&j[0]&&(j.after(d),c.focus())}var k=c.val().length;Math.ceil(k/5);c.attr("size",Math.max(this.inputSize,c.val().length))},e)),e.$container.on("keypress","input",a.proxy(function(b){var c=a(b.target);if(e.$element.attr("disabled"))return void e.$input.attr("disabled","disabled");var d=c.val(),f=e.options.maxChars&&d.length>=e.options.maxChars;e.options.freeInput&&(g(b,e.options.confirmKeys)||f)&&(0!==d.length&&(e.add(f?d.substr(0,e.options.maxChars):d),c.val("")),e.options.cancelConfirmKeysOnEmpty===!1&&b.preventDefault());var h=c.val().length;Math.ceil(h/5);c.attr("size",Math.max(this.inputSize,c.val().length))},e)),e.$container.on("click","[data-role=remove]",a.proxy(function(b){e.$element.attr("disabled")||e.remove(a(b.target).closest(".tag").data("item"))},e)),e.options.itemValue===h.itemValue&&("INPUT"===e.$element[0].tagName?e.add(e.$element.val()):a("option",e.$element).each(function(){e.add(a(this).attr("value"),!0)}))},destroy:function(){var a=this;a.$container.off("keypress","input"),a.$container.off("click","[role=remove]"),a.$container.remove(),a.$element.removeData("tagsinput"),a.$element.show()},focus:function(){this.$input.focus()},input:function(){return this.$input},findInputWrapper:function(){for(var b=this.$input[0],c=this.$container[0];b&&b.parentNode!==c;)b=b.parentNode;return a(b)}},a.fn.tagsinput=function(c,d,e){var f=[];return this.each(function(){var g=a(this).data("tagsinput");if(g)if(c||d){if(void 0!==g[c]){if(3===g[c].length&&void 0!==e)var h=g[c](d,null,e);else var h=g[c](d);void 0!==h&&f.push(h)}}else f.push(g);else g=new b(this,c),a(this).data("tagsinput",g),f.push(g),"SELECT"===this.tagName&&a("option",a(this)).attr("selected","selected"),a(this).val(a(this).val())}),"string"==typeof c?f.length>1?f:f[0]:f},a.fn.tagsinput.Constructor=b;var i=a("<div />");a(function(){a("input[data-role=tagsinput], select[multiple][data-role=tagsinput]").tagsinput()})}(window.jQuery);
	//# sourceMappingURL=bootstrap-tagsinput.min.js.map

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/*! Sortable 1.8.4 - MIT | git://github.com/SortableJS/Sortable.git */

	!function(t){"use strict"; true?!(__WEBPACK_AMD_DEFINE_FACTORY__ = (t), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)):"undefined"!=typeof module&&void 0!==module.exports?module.exports=t():window.Sortable=t()}(function(){"use strict";if("undefined"==typeof window||!window.document)return function(){throw new Error("Sortable.js requires a window with a document")};var U,V,f,u,q,G,h,X,Y,A,K,n,Z,Q,l,s,c,p,k,J,$,tt,et,ot,g,nt,I=[],B=!1,v=!1,it=!1,d=[],rt=!1,at=!1,m=[],i=/\s+/g,lt="Sortable"+(new Date).getTime(),b=window,st=b.document,w=b.parseInt,ct=b.setTimeout,e=b.jQuery||b.Zepto,o=b.Polymer,r={capture:!1,passive:!1},dt=!!navigator.userAgent.match(/(?:Trident.*rv[ :]?11\.|msie|iemobile)/i),_=!!navigator.userAgent.match(/Edge/i),y=!!navigator.userAgent.match(/firefox/i),D=!(!navigator.userAgent.match(/safari/i)||navigator.userAgent.match(/chrome/i)||navigator.userAgent.match(/android/i)),S=!!navigator.userAgent.match(/iP(ad|od|hone)/i),T=_||dt?"cssFloat":"float",a="draggable"in st.createElement("div"),C=function(){if(dt)return!1;var t=st.createElement("x");return t.style.cssText="pointer-events:auto","auto"===t.style.pointerEvents}(),ht=!1,E=!1,ut=Math.abs,x=Math.min,N=Math.max,M=[],P=function(t,e){var o=Dt(t),n=w(o.width)-w(o.paddingLeft)-w(o.paddingRight)-w(o.borderLeftWidth)-w(o.borderRightWidth),i=Mt(t,0,e),r=Mt(t,1,e),a=i&&Dt(i),l=r&&Dt(r),s=a&&w(a.marginLeft)+w(a.marginRight)+Lt(i).width,c=l&&w(l.marginLeft)+w(l.marginRight)+Lt(r).width;if("flex"===o.display)return"column"===o.flexDirection||"column-reverse"===o.flexDirection?"vertical":"horizontal";if("grid"===o.display)return o.gridTemplateColumns.split(" ").length<=1?"vertical":"horizontal";if(i&&"none"!==a.float){var d="left"===a.float?"left":"right";return!r||"both"!==l.clear&&l.clear!==d?"horizontal":"vertical"}return i&&("block"===a.display||"flex"===a.display||"table"===a.display||"grid"===a.display||n<=s&&"none"===o[T]||r&&"none"===o[T]&&n<s+c)?"vertical":"horizontal"},O=function(t,e){if(!t||!t.getBoundingClientRect)return H();var o=t,n=!1;do{if(o.clientWidth<o.scrollWidth||o.clientHeight<o.scrollHeight){var i=Dt(o);if(o.clientWidth<o.scrollWidth&&("auto"==i.overflowX||"scroll"==i.overflowX)||o.clientHeight<o.scrollHeight&&("auto"==i.overflowY||"scroll"==i.overflowY)){if(!o||!o.getBoundingClientRect||o===st.body)return H();if(n||e)return o;n=!0}}}while(o=o.parentNode);return H()},H=function(){return dt?st.documentElement:st.scrollingElement},ft=function(t,e,o){t.scrollLeft+=e,t.scrollTop+=o},R=It(function(o,t,e,n){if(t.scroll){var i=e?e[lt]:window,r=t.scrollSensitivity,a=t.scrollSpeed,l=o.clientX,s=o.clientY,c=H(),d=!1;Y!==e&&(L(),X=t.scroll,A=t.scrollFn,!0===X&&(X=O(e,!0),Y=X));var h=0,u=X;do{var f,p,g,v,m,b,w,_,y,D=u,S=Lt(D),T=S.top,C=S.bottom,E=S.left,x=S.right,N=S.width,M=S.height;if(f=D.scrollWidth,p=D.scrollHeight,g=Dt(D),_=D.scrollLeft,y=D.scrollTop,w=D===c?(b=N<f&&("auto"===g.overflowX||"scroll"===g.overflowX||"visible"===g.overflowX),M<p&&("auto"===g.overflowY||"scroll"===g.overflowY||"visible"===g.overflowY)):(b=N<f&&("auto"===g.overflowX||"scroll"===g.overflowX),M<p&&("auto"===g.overflowY||"scroll"===g.overflowY)),v=b&&(ut(x-l)<=r&&_+N<f)-(ut(E-l)<=r&&!!_),m=w&&(ut(C-s)<=r&&y+M<p)-(ut(T-s)<=r&&!!y),!I[h])for(var P=0;P<=h;P++)I[P]||(I[P]={});I[h].vx==v&&I[h].vy==m&&I[h].el===D||(I[h].el=D,I[h].vx=v,I[h].vy=m,clearInterval(I[h].pid),!D||0==v&&0==m||(d=!0,I[h].pid=setInterval(function(){n&&0===this.layer&&(mt.active._emulateDragOver(!0),mt.active._onTouchMove(k,!0));var t=I[this.layer].vy?I[this.layer].vy*a:0,e=I[this.layer].vx?I[this.layer].vx*a:0;"function"==typeof A&&"continue"!==A.call(i,e,t,o,k,I[this.layer].el)||ft(I[this.layer].el,e,t)}.bind({layer:h}),24))),h++}while(t.bubbleScroll&&u!==c&&(u=O(u,!1)));B=d}},30),L=function(){I.forEach(function(t){clearInterval(t.pid)}),I=[]},W=function(t){function s(a,l){return function(t,e,o,n){var i=t.options.group.name&&e.options.group.name&&t.options.group.name===e.options.group.name;if(null==a&&(l||i))return!0;if(null==a||!1===a)return!1;if(l&&"clone"===a)return a;if("function"==typeof a)return s(a(t,e,o,n),l)(t,e,o,n);var r=(l?t:e).options.group.name;return!0===a||"string"==typeof a&&a===r||a.join&&-1<a.indexOf(r)}}var e={},o=t.group;o&&"object"==typeof o||(o={name:o}),e.name=o.name,e.checkPull=s(o.pull,!0),e.checkPut=s(o.put),e.revertClone=o.revertClone,t.group=e},F=function(t){U&&U.parentNode&&U.parentNode[lt]&&U.parentNode[lt]._computeIsAligned(t)},pt=function(t,e){for(var o=e;!o[lt];)o=o.parentNode;return t===o},gt=function(t,e,o){for(var n=t.parentNode;n&&!n[lt];)n=n.parentNode;n&&n[lt][o](Bt(e,{artificialBubble:!0}))},z=function(){!C&&f&&Dt(f,"display","none")},j=function(){!C&&f&&Dt(f,"display","")};st.addEventListener("click",function(t){if(it)return t.preventDefault(),t.stopPropagation&&t.stopPropagation(),t.stopImmediatePropagation&&t.stopImmediatePropagation(),it=!1},!0);var vt,t=function(t){if(t=t.touches?t.touches[0]:t,U){var e=function(t,e){for(var o=0;o<d.length;o++)if(!Pt(d[o])){var n=Lt(d[o]),i=d[o][lt].options.emptyInsertThreshold,r=t>=n.left-i&&t<=n.right+i,a=e>=n.top-i&&e<=n.bottom+i;if(r&&a)return d[o]}}(t.clientX,t.clientY);e&&e[lt]._onDragOver({clientX:t.clientX,clientY:t.clientY,target:e,rootEl:e})}};function mt(t,e){if(!t||!t.nodeType||1!==t.nodeType)throw"Sortable: `el` must be HTMLElement, not "+{}.toString.call(t);this.el=t,this.options=e=Bt({},e),t[lt]=this;var o={group:null,sort:!0,disabled:!1,store:null,handle:null,scroll:!0,scrollSensitivity:30,scrollSpeed:10,bubbleScroll:!0,draggable:/[uo]l/i.test(t.nodeName)?">li":">*",swapThreshold:1,invertSwap:!1,invertedSwapThreshold:null,removeCloneOnHide:!0,direction:function(){return P(t,this.options)},ghostClass:"sortable-ghost",chosenClass:"sortable-chosen",dragClass:"sortable-drag",ignore:"a, img",filter:null,preventOnFilter:!0,animation:0,easing:null,setData:function(t,e){t.setData("Text",e.textContent)},dropBubble:!1,dragoverBubble:!1,dataIdAttr:"data-id",delay:0,touchStartThreshold:w(window.devicePixelRatio,10)||1,forceFallback:!1,fallbackClass:"sortable-fallback",fallbackOnBody:!1,fallbackTolerance:0,fallbackOffset:{x:0,y:0},supportPointer:!1!==mt.supportPointer&&("PointerEvent"in window||window.navigator&&"msPointerEnabled"in window.navigator),emptyInsertThreshold:5};for(var n in o)!(n in e)&&(e[n]=o[n]);for(var i in W(e),this)"_"===i.charAt(0)&&"function"==typeof this[i]&&(this[i]=this[i].bind(this));this.nativeDraggable=!e.forceFallback&&a,this.nativeDraggable&&(this.options.touchStartThreshold=1),e.supportPointer?wt(t,"pointerdown",this._onTapStart):(wt(t,"mousedown",this._onTapStart),wt(t,"touchstart",this._onTapStart)),this.nativeDraggable&&(wt(t,"dragover",this),wt(t,"dragenter",this)),d.push(this.el),e.store&&e.store.get&&this.sort(e.store.get(this)||[])}function bt(t,e,o,n){if(t){o=o||st;do{if(null!=e&&(">"===e[0]&&t.parentNode===o&&kt(t,e.substring(1))||kt(t,e))||n&&t===o)return t;if(t===o)break}while(t=(i=t).host&&i!==st&&i.host.nodeType?i.host:i.parentNode)}var i;return null}function wt(t,e,o){t.addEventListener(e,o,r)}function _t(t,e,o){t.removeEventListener(e,o,r)}function yt(t,e,o){if(t&&e)if(t.classList)t.classList[o?"add":"remove"](e);else{var n=(" "+t.className+" ").replace(i," ").replace(" "+e+" "," ");t.className=(n+(o?" "+e:"")).replace(i," ")}}function Dt(t,e,o){var n=t&&t.style;if(n){if(void 0===o)return st.defaultView&&st.defaultView.getComputedStyle?o=st.defaultView.getComputedStyle(t,""):t.currentStyle&&(o=t.currentStyle),void 0===e?o:o[e];e in n||-1!==e.indexOf("webkit")||(e="-webkit-"+e),n[e]=o+("string"==typeof o?"":"px")}}function St(t){var e="";do{var o=Dt(t,"transform");o&&"none"!==o&&(e=o+" "+e)}while(t=t.parentNode);return window.DOMMatrix?new DOMMatrix(e):window.WebKitCSSMatrix?new WebKitCSSMatrix(e):window.CSSMatrix?new CSSMatrix(e):void 0}function Tt(t,e,o){if(t){var n=t.getElementsByTagName(e),i=0,r=n.length;if(o)for(;i<r;i++)o(n[i],i);return n}return[]}function Ct(t,e,o,n,i,r,a,l,s){var c,d=(t=t||e[lt]).options,h="on"+o.charAt(0).toUpperCase()+o.substr(1);!window.CustomEvent||dt||_?(c=st.createEvent("Event")).initEvent(o,!0,!0):c=new CustomEvent(o,{bubbles:!0,cancelable:!0}),c.to=i||e,c.from=r||e,c.item=n||e,c.clone=u,c.oldIndex=a,c.newIndex=l,c.originalEvent=s,c.pullMode=Q?Q.lastPutMode:void 0,e&&e.dispatchEvent(c),d[h]&&d[h].call(t,c)}function Et(t,e,o,n,i,r,a,l){var s,c,d=t[lt],h=d.options.onMove;return!window.CustomEvent||dt||_?(s=st.createEvent("Event")).initEvent("move",!0,!0):s=new CustomEvent("move",{bubbles:!0,cancelable:!0}),s.to=e,s.from=t,s.dragged=o,s.draggedRect=n,s.related=i||e,s.relatedRect=r||Lt(e),s.willInsertAfter=l,s.originalEvent=a,t.dispatchEvent(s),h&&(c=h.call(d,s,a)),c}function xt(t){t.draggable=!1}function Nt(){ht=!1}function Mt(t,e,o){for(var n=0,i=0,r=t.children;i<r.length;){if("none"!==r[i].style.display&&r[i]!==f&&r[i]!==U&&bt(r[i],o.draggable,t,!1)){if(n===e)return r[i];n++}i++}return null}function Pt(t){for(var e=t.lastElementChild;e&&(e===f||"none"===e.style.display);)e=e.previousElementSibling;return e||null}function Xt(t){return At(U)<At(t)?1:-1}function Yt(t){for(var e=t.tagName+t.className+t.src+t.href+t.textContent,o=e.length,n=0;o--;)n+=e.charCodeAt(o);return n.toString(36)}function At(t,e){var o=0;if(!t||!t.parentNode)return-1;for(;t&&(t=t.previousElementSibling);)"TEMPLATE"!==t.nodeName.toUpperCase()&&t!==u&&o++;return o}function kt(t,e){if(t)try{if(t.matches)return t.matches(e);if(t.msMatchesSelector)return t.msMatchesSelector(e);if(t.webkitMatchesSelector)return t.webkitMatchesSelector(e)}catch(t){return!1}return!1}function It(o,n){return function(){if(!vt){var t=arguments,e=this;vt=ct(function(){1===t.length?o.call(e,t[0]):o.apply(e,t),vt=void 0},n)}}}function Bt(t,e){if(t&&e)for(var o in e)e.hasOwnProperty(o)&&(t[o]=e[o]);return t}function Ot(t){return o&&o.dom?o.dom(t).cloneNode(!0):e?e(t).clone(!0)[0]:t.cloneNode(!0)}function Ht(t){return ct(t,0)}function Rt(t){return clearTimeout(t)}function Lt(t,e,o,n){if(t.getBoundingClientRect||t===b){var i,r,a,l,s,c,d;if(d=t!==b&&t!==H()?(r=(i=t.getBoundingClientRect()).top,a=i.left,l=i.bottom,s=i.right,c=i.height,i.width):(a=r=0,l=window.innerHeight,s=window.innerWidth,c=window.innerHeight,window.innerWidth),n&&t!==b&&(o=o||t.parentNode,!dt))do{if(o&&o.getBoundingClientRect&&"none"!==Dt(o,"transform")){var h=o.getBoundingClientRect();r-=h.top+w(Dt(o,"border-top-width")),a-=h.left+w(Dt(o,"border-left-width")),l=r+i.height,s=a+i.width;break}}while(o=o.parentNode);if(e&&t!==b){var u=St(o||t),f=u&&u.a,p=u&&u.d;u&&(l=(r/=p)+(c/=p),s=(a/=f)+(d/=f))}return{top:r,left:a,bottom:l,right:s,width:d,height:c}}}function Wt(t,e){for(var o=O(t,!0),n=Lt(t)[e];o;){var i=Lt(o)[e];if(!("top"===e||"left"===e?i<=n:n<=i))return o;if(o===H())break;o=O(o,!1)}return!1}function Ft(t){var e=0,o=0,n=H();if(t)do{var i=St(t),r=i.a,a=i.d;e+=t.scrollLeft*r,o+=t.scrollTop*a}while(t!==n&&(t=t.parentNode));return[e,o]}return wt(st,"dragover",t),wt(st,"mousemove",t),wt(st,"touchmove",t),mt.prototype={constructor:mt,_computeIsAligned:function(t){var e;if(f&&!C?(z(),e=st.elementFromPoint(t.clientX,t.clientY),j()):e=t.target,e=bt(e,this.options.draggable,this.el,!1),!E&&U&&U.parentNode===this.el){for(var o,n,i,r,a,l,s,c,d=this.el.children,h=0;h<d.length;h++)bt(d[h],this.options.draggable,this.el,!1)&&d[h]!==e&&(d[h].sortableMouseAligned=(o=t.clientX,n=t.clientY,i=d[h],r=this._getDirection(t,null),this.options,void 0,a=Lt(i),l="vertical"===r?a.left:a.top,s="vertical"===r?a.right:a.bottom,l<(c="vertical"===r?o:n)&&c<s));bt(e,this.options.draggable,this.el,!0)||($=null),E=!0,ct(function(){E=!1},30)}},_getDirection:function(t,e){return"function"==typeof this.options.direction?this.options.direction.call(this,t,e,U):this.options.direction},_onTapStart:function(t){if(t.cancelable){var e,o=this,n=this.el,i=this.options,r=i.preventOnFilter,a=t.type,l=t.touches&&t.touches[0],s=(l||t).target,c=t.target.shadowRoot&&(t.path&&t.path[0]||t.composedPath&&t.composedPath()[0])||s,d=i.filter;if(function(t){M.length=0;var e=t.getElementsByTagName("input"),o=e.length;for(;o--;){var n=e[o];n.checked&&M.push(n)}}(n),(!dt||t.artificialBubble||pt(n,s))&&!U&&!(/mousedown|pointerdown/.test(a)&&0!==t.button||i.disabled||c.isContentEditable))if(s=bt(s,i.draggable,n,!1)){if(h!==s){if(e=At(s,i.draggable),"function"==typeof d){if(d.call(this,t,s,this))return Ct(o,c,"filter",s,n,n,e),void(r&&t.cancelable&&t.preventDefault())}else if(d&&(d=d.split(",").some(function(t){if(t=bt(c,t.trim(),n,!1))return Ct(o,t,"filter",s,n,n,e),!0})))return void(r&&t.cancelable&&t.preventDefault());i.handle&&!bt(c,i.handle,n,!1)||this._prepareDragStart(t,l,s,e)}}else dt&&gt(n,t,"_onTapStart")}},_handleAutoScroll:function(e,o){if(U&&this.options.scroll){var n=e.clientX,i=e.clientY,t=st.elementFromPoint(n,i),r=this;if(o||_||dt||D){R(e,r.options,t,o);var a=O(t,!0);!B||l&&n===s&&i===c||(l&&clearInterval(l),l=setInterval(function(){if(U){var t=O(st.elementFromPoint(n,i),!0);t!==a&&(a=t,L(),R(e,r.options,a,o))}},10),s=n,c=i)}else{if(!r.options.bubbleScroll||O(t,!0)===H())return void L();R(e,r.options,O(t,!1),!1)}}},_prepareDragStart:function(t,e,o,n){var i,r=this,a=r.el,l=r.options,s=a.ownerDocument;o&&!U&&o.parentNode===a&&(q=a,V=(U=o).parentNode,G=U.nextSibling,h=o,Z=l.group,K=n,p={target:U,clientX:(e||t).clientX,clientY:(e||t).clientY},this._lastX=(e||t).clientX,this._lastY=(e||t).clientY,U.style["will-change"]="all",U.style.transition="",U.style.transform="",i=function(){r._disableDelayedDragEvents(),!y&&r.nativeDraggable&&(U.draggable=!0),r._triggerDragStart(t,e),Ct(r,q,"choose",U,q,q,K),yt(U,l.chosenClass,!0)},l.ignore.split(",").forEach(function(t){Tt(U,t.trim(),xt)}),l.supportPointer?wt(s,"pointerup",r._onDrop):(wt(s,"mouseup",r._onDrop),wt(s,"touchend",r._onDrop),wt(s,"touchcancel",r._onDrop)),y&&this.nativeDraggable&&(this.options.touchStartThreshold=4,U.draggable=!0),!l.delay||this.nativeDraggable&&(_||dt)?i():(wt(s,"mouseup",r._disableDelayedDrag),wt(s,"touchend",r._disableDelayedDrag),wt(s,"touchcancel",r._disableDelayedDrag),wt(s,"mousemove",r._delayedDragTouchMoveHandler),wt(s,"touchmove",r._delayedDragTouchMoveHandler),l.supportPointer&&wt(s,"pointermove",r._delayedDragTouchMoveHandler),r._dragStartTimer=ct(i,l.delay)))},_delayedDragTouchMoveHandler:function(t){var e=t.touches?t.touches[0]:t;N(ut(e.clientX-this._lastX),ut(e.clientY-this._lastY))>=Math.floor(this.options.touchStartThreshold/(this.nativeDraggable&&window.devicePixelRatio||1))&&this._disableDelayedDrag()},_disableDelayedDrag:function(){U&&xt(U),clearTimeout(this._dragStartTimer),this._disableDelayedDragEvents()},_disableDelayedDragEvents:function(){var t=this.el.ownerDocument;_t(t,"mouseup",this._disableDelayedDrag),_t(t,"touchend",this._disableDelayedDrag),_t(t,"touchcancel",this._disableDelayedDrag),_t(t,"mousemove",this._delayedDragTouchMoveHandler),_t(t,"touchmove",this._delayedDragTouchMoveHandler),_t(t,"pointermove",this._delayedDragTouchMoveHandler)},_triggerDragStart:function(t,e){e=e||("touch"==t.pointerType?t:null),!this.nativeDraggable||e?this.options.supportPointer?wt(st,"pointermove",this._onTouchMove):wt(st,e?"touchmove":"mousemove",this._onTouchMove):(wt(U,"dragend",this),wt(q,"dragstart",this._onDragStart));try{st.selection?Ht(function(){st.selection.empty()}):window.getSelection().removeAllRanges()}catch(t){}},_dragStarted:function(t,e){if(v=!1,q&&U){this.nativeDraggable&&(wt(st,"dragover",this._handleAutoScroll),wt(st,"dragover",F));var o=this.options;!t&&yt(U,o.dragClass,!1),yt(U,o.ghostClass,!0),Dt(U,"transform",""),mt.active=this,t&&this._appendGhost(),Ct(this,q,"start",U,q,q,K,void 0,e)}else this._nulling()},_emulateDragOver:function(t){if(k){if(this._lastX===k.clientX&&this._lastY===k.clientY&&!t)return;this._lastX=k.clientX,this._lastY=k.clientY,z();for(var e=st.elementFromPoint(k.clientX,k.clientY),o=e;e&&e.shadowRoot;)o=e=e.shadowRoot.elementFromPoint(k.clientX,k.clientY);if(o)do{if(o[lt])if(o[lt]._onDragOver({clientX:k.clientX,clientY:k.clientY,target:e,rootEl:o})&&!this.options.dragoverBubble)break;e=o}while(o=o.parentNode);U.parentNode[lt]._computeIsAligned(k),j()}},_onTouchMove:function(t,e){if(p){var o=this.options,n=o.fallbackTolerance,i=o.fallbackOffset,r=t.touches?t.touches[0]:t,a=f&&St(f),l=f&&a&&a.a,s=f&&a&&a.d,c=S&&g&&Ft(g),d=(r.clientX-p.clientX+i.x)/(l||1)+(c?c[0]-m[0]:0)/(l||1),h=(r.clientY-p.clientY+i.y)/(s||1)+(c?c[1]-m[1]:0)/(s||1),u=t.touches?"translate3d("+d+"px,"+h+"px,0)":"translate("+d+"px,"+h+"px)";if(!mt.active&&!v){if(n&&x(ut(r.clientX-this._lastX),ut(r.clientY-this._lastY))<n)return;this._onDragStart(t,!0)}!e&&this._handleAutoScroll(r,!0),J=!0,k=r,Dt(f,"webkitTransform",u),Dt(f,"mozTransform",u),Dt(f,"msTransform",u),Dt(f,"transform",u),t.cancelable&&t.preventDefault()}},_appendGhost:function(){if(!f){var t=this.options.fallbackOnBody?st.body:q,e=Lt(U,!0,t,!S),o=(Dt(U),this.options);if(S){for(g=t;"static"===Dt(g,"position")&&"none"===Dt(g,"transform")&&g!==st;)g=g.parentNode;if(g!==st){var n=Lt(g,!0);e.top-=n.top,e.left-=n.left}g!==st.body&&g!==st.documentElement?(g===st&&(g=H()),e.top+=g.scrollTop,e.left+=g.scrollLeft):g=H(),m=Ft(g)}yt(f=U.cloneNode(!0),o.ghostClass,!1),yt(f,o.fallbackClass,!0),yt(f,o.dragClass,!0),Dt(f,"box-sizing","border-box"),Dt(f,"margin",0),Dt(f,"top",e.top),Dt(f,"left",e.left),Dt(f,"width",e.width),Dt(f,"height",e.height),Dt(f,"opacity","0.8"),Dt(f,"position",S?"absolute":"fixed"),Dt(f,"zIndex","100000"),Dt(f,"pointerEvents","none"),t.appendChild(f)}},_onDragStart:function(t,e){var o=this,n=t.dataTransfer,i=o.options;(u=Ot(U)).draggable=!1,u.style["will-change"]="",this._hideClone(),yt(u,o.options.chosenClass,!1),o._cloneId=Ht(function(){o.options.removeCloneOnHide||q.insertBefore(u,U),Ct(o,q,"clone",U)}),!e&&yt(U,i.dragClass,!0),e?(it=!0,o._loopId=setInterval(o._emulateDragOver,50)):(_t(st,"mouseup",o._onDrop),_t(st,"touchend",o._onDrop),_t(st,"touchcancel",o._onDrop),n&&(n.effectAllowed="move",i.setData&&i.setData.call(o,n,U)),wt(st,"drop",o),Dt(U,"transform","translateZ(0)")),v=!0,o._dragStartId=Ht(o._dragStarted.bind(o,e,t)),wt(st,"selectstart",o),D&&Dt(st.body,"user-select","none")},_onDragOver:function(e){var o,n,t,i=this.el,r=e.target,a=this.options,l=a.group,s=mt.active,c=Z===l,d=a.sort,h=this;if(!ht&&(!dt||e.rootEl||e.artificialBubble||pt(i,r))){if(void 0!==e.preventDefault&&e.cancelable&&e.preventDefault(),J=!0,r=bt(r,a.draggable,i,!0),bt(e.target,null,U,!0)||r.animated)return z(!1);if(r!==U&&(it=!1),s&&!a.disabled&&(c?d||(t=!q.contains(U)):Q===this||(this.lastPutMode=Z.checkPull(this,s,U,e))&&l.checkPut(this,s,U,e))){var u=this._getDirection(e,r);if(o=Lt(U),t)return this._hideClone(),V=q,G?q.insertBefore(U,G):q.appendChild(U),z(!0);var f=Pt(i);if(f&&(I=e,B=u,O=Lt(Pt(i)),H="vertical"===B?I.clientY:I.clientX,R="vertical"===B?I.clientX:I.clientY,L="vertical"===B?O.bottom:O.right,W="vertical"===B?O.left:O.top,F="vertical"===B?O.right:O.bottom,!("vertical"===B?F+10<R||R<=F&&L<H&&W<=R:L<H&&W<R||H<=L&&F+10<R)||f.animated)){if(r&&r!==U&&r.parentNode===i){var p,g=0,v=r.sortableMouseAligned,m=U.parentNode!==i,b="vertical"===u?"top":"left",w=Wt(r,"top")||Wt(U,"top"),_=w?w.scrollTop:void 0;if($!==r&&(et=null,p=Lt(r)[b],rt=!1),C=r,E=u,x=(T=U)===U&&nt||Lt(T),N=C===U&&nt||Lt(C),M="vertical"===E?x.left:x.top,P="vertical"===E?x.right:x.bottom,X="vertical"===E?x.width:x.height,Y="vertical"===E?N.left:N.top,A="vertical"===E?N.right:N.bottom,k="vertical"===E?N.width:N.height,et=(M===Y||P===A||M+X/2===Y+k/2)&&v||m||w||a.invertSwap||"insert"===et||"swap"===et?("swap"!==et&&(at=a.invertSwap||m),g=function(t,e,o,n,i,r,a){var l=Lt(e),s="vertical"===o?t.clientY:t.clientX,c="vertical"===o?l.height:l.width,d="vertical"===o?l.top:l.left,h="vertical"===o?l.bottom:l.right,u=Lt(U),f=!1;if(!r)if(a&&ot<c*n)if(!rt&&(1===tt?d+c*i/2<s:s<h-c*i/2)&&(rt=!0),rt)f=!0;else{"vertical"===o?u.top:u.left,"vertical"===o?u.bottom:u.right;if(1===tt?s<d+ot:h-ot<s)return-1*tt}else if(d+c*(1-n)/2<s&&s<h-c*(1-n)/2)return Xt(e);if((f=f||r)&&(s<d+c*i/2||h-c*i/2<s))return d+c/2<s?1:-1;return 0}(e,r,u,a.swapThreshold,null==a.invertedSwapThreshold?a.swapThreshold:a.invertedSwapThreshold,at,$===r),"swap"):(g=Xt(r),"insert"),0===g)return z(!1);nt=null,tt=g,n=Lt($=r);var y=r.nextElementSibling,D=!1,S=Et(q,i,U,o,r,n,e,D=1===g);if(!1!==S)return 1!==S&&-1!==S||(D=1===S),ht=!0,ct(Nt,30),c?s._hideClone():s._showClone(this),D&&!y?i.appendChild(U):r.parentNode.insertBefore(U,D?y:r),w&&ft(w,0,_-w.scrollTop),V=U.parentNode,void 0===p||at||(ot=ut(p-Lt(r)[b])),j(),z(!0)}}else if(f&&i===e.target&&(r=f),r&&(n=Lt(r)),c?s._hideClone():s._showClone(this),!1!==Et(q,i,U,o,r,n,e,!!r))return i.appendChild(U),V=i,nt=null,j(),z(!0);if(i.contains(U))return z(!1)}var T,C,E,x,N,M,P,X,Y,A,k,I,B,O,H,R,L,W,F;return dt&&!e.rootEl&&gt(i,e,"_onDragOver"),!1}function z(t){return t&&(c?s._hideClone():s._showClone(h),s&&(yt(U,Q?Q.options.ghostClass:s.options.ghostClass,!1),yt(U,a.ghostClass,!0)),Q!==h&&h!==mt.active?Q=h:h===mt.active&&(Q=null),o&&h._animate(o,U),r&&n&&h._animate(n,r)),(r===U&&!U.animated||r===i&&!r.animated)&&($=null),a.dragoverBubble||e.rootEl||r===st||(h._handleAutoScroll(e),U.parentNode[lt]._computeIsAligned(e)),!a.dragoverBubble&&e.stopPropagation&&e.stopPropagation(),!0}function j(){Ct(h,q,"change",r,i,q,K,At(U,a.draggable),e)}},_animate:function(t,e){var o=this.options.animation;if(o){var n=Lt(e);if(e===U&&(nt=n),1===t.nodeType&&(t=Lt(t)),t.left+t.width/2!==n.left+n.width/2||t.top+t.height/2!==n.top+n.height/2){var i=St(this.el),r=i&&i.a,a=i&&i.d;Dt(e,"transition","none"),Dt(e,"transform","translate3d("+(t.left-n.left)/(r||1)+"px,"+(t.top-n.top)/(a||1)+"px,0)"),e.offsetWidth,Dt(e,"transition","transform "+o+"ms"+(this.options.easing?" "+this.options.easing:"")),Dt(e,"transform","translate3d(0,0,0)")}"number"==typeof e.animated&&clearTimeout(e.animated),e.animated=ct(function(){Dt(e,"transition",""),Dt(e,"transform",""),e.animated=!1},o)}},_offUpEvents:function(){var t=this.el.ownerDocument;_t(st,"touchmove",this._onTouchMove),_t(st,"pointermove",this._onTouchMove),_t(t,"mouseup",this._onDrop),_t(t,"touchend",this._onDrop),_t(t,"pointerup",this._onDrop),_t(t,"touchcancel",this._onDrop),_t(st,"selectstart",this)},_onDrop:function(t){var e=this.el,o=this.options;rt=at=B=v=!1,clearInterval(this._loopId),clearInterval(l),L(),clearTimeout(vt),vt=void 0,clearTimeout(this._dragStartTimer),Rt(this._cloneId),Rt(this._dragStartId),_t(st,"mousemove",this._onTouchMove),this.nativeDraggable&&(_t(st,"drop",this),_t(e,"dragstart",this._onDragStart),_t(st,"dragover",this._handleAutoScroll),_t(st,"dragover",F)),D&&Dt(st.body,"user-select",""),this._offUpEvents(),t&&(J&&(t.cancelable&&t.preventDefault(),!o.dropBubble&&t.stopPropagation()),f&&f.parentNode&&f.parentNode.removeChild(f),(q===V||Q&&"clone"!==Q.lastPutMode)&&u&&u.parentNode&&u.parentNode.removeChild(u),U&&(this.nativeDraggable&&_t(U,"dragend",this),xt(U),U.style["will-change"]="",yt(U,Q?Q.options.ghostClass:this.options.ghostClass,!1),yt(U,this.options.chosenClass,!1),Ct(this,q,"unchoose",U,V,q,K,null,t),q!==V?(0<=(n=At(U,o.draggable))&&(Ct(null,V,"add",U,V,q,K,n,t),Ct(this,q,"remove",U,V,q,K,n,t),Ct(null,V,"sort",U,V,q,K,n,t),Ct(this,q,"sort",U,V,q,K,n,t)),Q&&Q.save()):U.nextSibling!==G&&0<=(n=At(U,o.draggable))&&(Ct(this,q,"update",U,V,q,K,n,t),Ct(this,q,"sort",U,V,q,K,n,t)),mt.active&&(null!=n&&-1!==n||(n=K),Ct(this,q,"end",U,V,q,K,n,t),this.save()))),this._nulling()},_nulling:function(){q=U=V=f=G=u=h=X=Y=I.length=l=s=c=p=k=J=n=K=$=tt=nt=Q=Z=mt.active=null,M.forEach(function(t){t.checked=!0}),M.length=0},handleEvent:function(t){switch(t.type){case"drop":case"dragend":this._onDrop(t);break;case"dragenter":case"dragover":U&&(this._onDragOver(t),function(t){t.dataTransfer&&(t.dataTransfer.dropEffect="move");t.cancelable&&t.preventDefault()}(t));break;case"selectstart":t.preventDefault()}},toArray:function(){for(var t,e=[],o=this.el.children,n=0,i=o.length,r=this.options;n<i;n++)bt(t=o[n],r.draggable,this.el,!1)&&e.push(t.getAttribute(r.dataIdAttr)||Yt(t));return e},sort:function(t){var n={},i=this.el;this.toArray().forEach(function(t,e){var o=i.children[e];bt(o,this.options.draggable,i,!1)&&(n[t]=o)},this),t.forEach(function(t){n[t]&&(i.removeChild(n[t]),i.appendChild(n[t]))})},save:function(){var t=this.options.store;t&&t.set&&t.set(this)},closest:function(t,e){return bt(t,e||this.options.draggable,this.el,!1)},option:function(t,e){var o=this.options;if(void 0===e)return o[t];o[t]=e,"group"===t&&W(o)},destroy:function(){var t=this.el;t[lt]=null,_t(t,"mousedown",this._onTapStart),_t(t,"touchstart",this._onTapStart),_t(t,"pointerdown",this._onTapStart),this.nativeDraggable&&(_t(t,"dragover",this),_t(t,"dragenter",this)),Array.prototype.forEach.call(t.querySelectorAll("[draggable]"),function(t){t.removeAttribute("draggable")}),this._onDrop(),d.splice(d.indexOf(this.el),1),this.el=t=null},_hideClone:function(){u.cloneHidden||(Dt(u,"display","none"),u.cloneHidden=!0,u.parentNode&&this.options.removeCloneOnHide&&u.parentNode.removeChild(u))},_showClone:function(t){"clone"===t.lastPutMode?u.cloneHidden&&(q.contains(U)&&!this.options.group.revertClone?q.insertBefore(u,U):G?q.insertBefore(u,G):q.appendChild(u),this.options.group.revertClone&&this._animate(U,u),Dt(u,"display",""),u.cloneHidden=!1):this._hideClone()}},wt(st,"touchmove",function(t){(mt.active||v)&&t.cancelable&&t.preventDefault()}),mt.utils={on:wt,off:_t,css:Dt,find:Tt,is:function(t,e){return!!bt(t,e,t,!1)},extend:Bt,throttle:It,closest:bt,toggleClass:yt,clone:Ot,index:At,nextTick:Ht,cancelNextTick:Rt,detectDirection:P,getChild:Mt},mt.create=function(t,e){return new mt(t,e)},mt.version="1.8.4",mt});

/***/ }),
/* 55 */
/***/ (function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ }),
/* 56 */
/***/ (function(module, exports) {

	// Cross-broswer implementation of text ranges and selections
	// documentation: http://bililite.com/blog/2011/01/17/cross-browser-text-ranges-and-selections/
	// Version: 2.6
	// Copyright (c) 2013 Daniel Wachsstock
	// MIT license:
	// Permission is hereby granted, free of charge, to any person
	// obtaining a copy of this software and associated documentation
	// files (the "Software"), to deal in the Software without
	// restriction, including without limitation the rights to use,
	// copy, modify, merge, publish, distribute, sublicense, and/or sell
	// copies of the Software, and to permit persons to whom the
	// Software is furnished to do so, subject to the following
	// conditions:

	// The above copyright notice and this permission notice shall be
	// included in all copies or substantial portions of the Software.

	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
	// OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
	// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
	// WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
	// OTHER DEALINGS IN THE SOFTWARE.

	(function(){

	// a bit of weirdness with IE11: using 'focus' is flaky, even if I'm not bubbling, as far as I can tell.
	var focusEvent = 'onfocusin' in document.createElement('input') ? 'focusin' : 'focus';

	// IE11 normalize is buggy (http://connect.microsoft.com/IE/feedback/details/809424/node-normalize-removes-text-if-dashes-are-present)
	var n = document.createElement('div');
	n.appendChild(document.createTextNode('x-'));
	n.appendChild(document.createTextNode('x'));
	n.normalize();
	var canNormalize = n.firstChild.length == 3;


	bililiteRange = function(el, debug){
		var ret;
		if (debug){
			ret = new NothingRange(); // Easier to force it to use the no-selection type than to try to find an old browser
		}else if (window.getSelection && el.setSelectionRange){
			// Standards. Element is an input or textarea 
			// note that some input elements do not allow selections
			try{
				el.selectionStart; // even getting the selection in such an element will throw
				ret = new InputRange();
			}catch(e){
				ret = new NothingRange();
			}
		}else if (window.getSelection){
			// Standards, with any other kind of element
			ret = new W3CRange();
		}else if (document.selection){
			// Internet Explorer
			ret = new IERange();
		}else{
			// doesn't support selection
			ret = new NothingRange();
		}
		ret._el = el;
		// determine parent document, as implemented by John McLear <john@mclear.co.uk>
		ret._doc = el.ownerDocument;
		ret._win = 'defaultView' in ret._doc ? ret._doc.defaultView : ret._doc.parentWindow;
		ret._textProp = textProp(el);
		ret._bounds = [0, ret.length()];
		//  There's no way to detect whether a focus event happened as a result of a click (which should change the selection)
		// or as a result of a keyboard event (a tab in) or a script  action (el.focus()). So we track it globally, which is a hack, and is likely to fail
		// in edge cases (right-clicks, drag-n-drop), and is vulnerable to a lower-down handler preventing bubbling.
		// I just don't know a better way.
		// I'll hack my event-listening code below, rather than create an entire new bilililiteRange, potentially before the DOM has loaded
		if (!('bililiteRangeMouseDown' in ret._doc)){
			var _doc = {_el: ret._doc};
			ret._doc.bililiteRangeMouseDown = false;
			bililiteRange.fn.listen.call(_doc, 'mousedown', function() {
				ret._doc.bililiteRangeMouseDown = true;
			});
			bililiteRange.fn.listen.call(_doc, 'mouseup', function() {
				ret._doc.bililiteRangeMouseDown = false;
			});
		}
		// note that bililiteRangeSelection is an array, which means that copying it only copies the address, which points to the original.
		// make sure that we never let it (always do return [bililiteRangeSelection[0], bililiteRangeSelection[1]]), which means never returning
		// this._bounds directly
		if (!('bililiteRangeSelection' in el)){
			// start tracking the selection
			function trackSelection(evt){
				if (evt && evt.which == 9){
					// do tabs my way, by restoring the selection
					// there's a flash of the browser's selection, but I don't see a way of avoiding that
					ret._nativeSelect(ret._nativeRange(el.bililiteRangeSelection));
				}else{
					el.bililiteRangeSelection = ret._nativeSelection();
				}
			}
			trackSelection();
			// only IE does this right and allows us to grab the selection before blurring
			if ('onbeforedeactivate' in el){
				ret.listen('beforedeactivate', trackSelection);
			}else{
				// with standards-based browsers, have to listen for every user interaction
				ret.listen('mouseup', trackSelection).listen('keyup', trackSelection);
			}
			ret.listen(focusEvent, function(){
				// restore the correct selection when the element comes into focus (mouse clicks change the position of the selection)
				// Note that Firefox will not fire the focus event until the window/tab is active even if el.focus() is called
				// https://bugzilla.mozilla.org/show_bug.cgi?id=566671
				if (!ret._doc.bililiteRangeMouseDown){
					ret._nativeSelect(ret._nativeRange(el.bililiteRangeSelection));
				}
			});
		}
		if (!('oninput' in el)){
			// give IE8 a chance. Note that this still fails in IE11, which has has oninput on contenteditable elements but does not 
			// dispatch input events. See http://connect.microsoft.com/IE/feedback/details/794285/ie10-11-input-event-does-not-fire-on-div-with-contenteditable-set
			// TODO: revisit this when I have IE11 running on my development machine
			var inputhack = function() {ret.dispatch({type: 'input'}) };
			ret.listen('keyup', inputhack);
			ret.listen('cut', inputhack);
			ret.listen('paste', inputhack);
			ret.listen('drop', inputhack);
			el.oninput = 'patched';
		}
		return ret;
	}

	function textProp(el){
		// returns the property that contains the text of the element
		// note that for <body> elements the text attribute represents the obsolete text color, not the textContent.
		// we document that these routines do not work for <body> elements so that should not be relevant
		if (typeof el.value != 'undefined') return 'value';
		if (typeof el.text != 'undefined') return 'text';
		if (typeof el.textContent != 'undefined') return 'textContent';
		return 'innerText';
	}

	// base class
	function Range(){}
	Range.prototype = {
		length: function() {
			return this._el[this._textProp].replace(/\r/g, '').length; // need to correct for IE's CrLf weirdness
		},
		bounds: function(s){
			if (bililiteRange.bounds[s]){
				this._bounds = bililiteRange.bounds[s].apply(this);
			}else if (s){
				this._bounds = s; // don't do error checking now; things may change at a moment's notice
			}else{
				var b = [
					Math.max(0, Math.min (this.length(), this._bounds[0])),
					Math.max(0, Math.min (this.length(), this._bounds[1]))
				];
				b[1] = Math.max(b[0], b[1]);
				return b; // need to constrain it to fit
			}
			return this; // allow for chaining
		},
		select: function(){
			var b = this._el.bililiteRangeSelection = this.bounds();
			if (this._el == document.activeElement){
				// only actually select if this element is active!
				this._nativeSelect(this._nativeRange(b));
			}
			this.dispatch({type: 'select'});
			return this; // allow for chaining
		},
		text: function(text, select){
			if (arguments.length){
				var bounds = this.bounds(), el = this._el;
				// signal the input per DOM 3 input events, http://www.w3.org/TR/DOM-Level-3-Events/#h4_events-inputevents
				// we add another field, bounds, which are the bounds of the original text before being changed.
				this.dispatch({type: 'beforeinput', data: text, bounds: bounds});
				this._nativeSetText(text, this._nativeRange(bounds));
				if (select == 'start'){
					this.bounds ([bounds[0], bounds[0]]);
				}else if (select == 'end'){
					this.bounds ([bounds[0]+text.length, bounds[0]+text.length]);
				}else if (select == 'all'){
					this.bounds ([bounds[0], bounds[0]+text.length]);
				}
				this.dispatch({type: 'input', data: text, bounds: bounds});
				return this; // allow for chaining
			}else{
				return this._nativeGetText(this._nativeRange(this.bounds())).replace(/\r/g, ''); // need to correct for IE's CrLf weirdness
			}
		},
		insertEOL: function (){
			this._nativeEOL();
			this._bounds = [this._bounds[0]+1, this._bounds[0]+1]; // move past the EOL marker
			return this;
		},
		sendkeys: function (text){
			var self = this;
			this.data().sendkeysOriginalText = this.text();
			this.data().sendkeysBounds = undefined;
			function simplechar (rng, c){
				if (/^{[^}]*}$/.test(c)) c = c.slice(1,-1);	// deal with unknown {key}s
				for (var i =0; i < c.length; ++i){
					var x = c.charCodeAt(i);
					rng.dispatch({type: 'keypress', keyCode: x, which: x, charCode: x});
				}
				rng.text(c, 'end');
			}
			text.replace(/{[^}]*}|[^{]+|{/g, function(part){
				(bililiteRange.sendkeys[part] || simplechar)(self, part, simplechar);
			});
			this.bounds(this.data().sendkeysBounds);
			this.dispatch({type: 'sendkeys', which: text});
			return this;
		},
		top: function(){
			return this._nativeTop(this._nativeRange(this.bounds()));
		},
		scrollIntoView: function(scroller){
			var top = this.top();
			// scroll into position if necessary
			if (this._el.scrollTop > top || this._el.scrollTop+this._el.clientHeight < top){
				if (scroller){
					scroller.call(this._el, top);
				}else{
					this._el.scrollTop = top;
				}
			}
			return this;
		},
		wrap: function (n){
			this._nativeWrap(n, this._nativeRange(this.bounds()));
			return this;
		},
		selection: function(text){
			if (arguments.length){
				return this.bounds('selection').text(text, 'end').select();
			}else{
				return this.bounds('selection').text();
			}
		},
		clone: function(){
			return bililiteRange(this._el).bounds(this.bounds());
		},
		all: function(text){
			if (arguments.length){
				this.dispatch ({type: 'beforeinput', data: text});
				this._el[this._textProp] = text;
				this.dispatch ({type: 'input', data: text});
				return this;
			}else{
				return this._el[this._textProp].replace(/\r/g, ''); // need to correct for IE's CrLf weirdness
			}
		},
		element: function() { return this._el },
		// includes a quickie polyfill for CustomEvent for IE that isn't perfect but works for me
		// IE10 allows custom events but not "new CustomEvent"; have to do it the old-fashioned way
		dispatch: function(opts){
			opts = opts || {};
			var event = document.createEvent ? document.createEvent('CustomEvent') : this._doc.createEventObject();
			event.initCustomEvent && event.initCustomEvent(opts.type, !!opts.bubbles, !!opts.cancelable, opts.detail);
			for (var key in opts) event[key] = opts[key];
			// dispatch event asynchronously (in the sense of on the next turn of the event loop; still should be fired in order of dispatch
			var el = this._el;
			setTimeout(function(){
				try {
					el.dispatchEvent ? el.dispatchEvent(event) : el.fireEvent("on" + opts.type, document.createEventObject());
					}catch(e){
					// IE8 will not let me fire custom events at all. Call them directly
						var listeners = el['listen'+opts.type];
						if (listeners) for (var i = 0; i < listeners.length; ++i){
							listeners[i].call(el, event);
						}
					}
			}, 0);
			return this;
		},
		listen: function (type, func){
			var el = this._el;
			if (el.addEventListener){
				el.addEventListener(type, func);
			}else{
				el.attachEvent("on" + type, func);
				// IE8 can't even handle custom events created with createEventObject  (though it permits attachEvent), so we have to make our own
				var listeners = el['listen'+type] = el['listen'+type] || [];
				listeners.push(func);
			}
			return this;
		},
		dontlisten: function (type, func){
			var el = this._el;
			if (el.removeEventListener){
				el.removeEventListener(type, func);
			}else try{
				el.detachEvent("on" + type, func);
			}catch(e){
				var listeners = el['listen'+type];
				if (listeners) for (var i = 0; i < listeners.length; ++i){
					if (listeners[i] === func) listeners[i] = function(){}; // replace with a noop
				}
			}
			return this;
		}
	};

	// allow extensions ala jQuery
	bililiteRange.fn = Range.prototype; // to allow monkey patching
	bililiteRange.extend = function(fns){
		for (fn in fns) Range.prototype[fn] = fns[fn];
	};

	//bounds functions
	bililiteRange.bounds = {
		all: function() { return [0, this.length()] },
		start: function () { return [0,0] },
		end: function () { return [this.length(), this.length()] },
		selection: function(){
			if (this._el == document.activeElement){
				this.bounds ('all'); // first select the whole thing for constraining
				return this._nativeSelection();
			}else{
				return this._el.bililiteRangeSelection;
			}
		}
	};

	// sendkeys functions
	bililiteRange.sendkeys = {
		'{enter}': function (rng){
			simplechar(rng, '\n');
			rng.insertEOL();
		},
		'{tab}': function (rng, c, simplechar){
			simplechar(rng, '\t'); // useful for inserting what would be whitespace
		},
		'{newline}': function (rng, c, simplechar){
			simplechar(rng, '\n'); // useful for inserting what would be whitespace (and if I don't want to use insertEOL, which does some fancy things)
		},
		'{backspace}': function (rng){
			var b = rng.bounds();
			if (b[0] == b[1]) rng.bounds([b[0]-1, b[0]]); // no characters selected; it's just an insertion point. Remove the previous character
			rng.text('', 'end'); // delete the characters and update the selection
		},
		'{del}': function (rng){
			var b = rng.bounds();
			if (b[0] == b[1]) rng.bounds([b[0], b[0]+1]); // no characters selected; it's just an insertion point. Remove the next character
			rng.text('', 'end'); // delete the characters and update the selection
		},
		'{rightarrow}':  function (rng){
			var b = rng.bounds();
			if (b[0] == b[1]) ++b[1]; // no characters selected; it's just an insertion point. Move to the right
			rng.bounds([b[1], b[1]]);
		},
		'{leftarrow}': function (rng){
			var b = rng.bounds();
			if (b[0] == b[1]) --b[0]; // no characters selected; it's just an insertion point. Move to the left
			rng.bounds([b[0], b[0]]);
		},
		'{selectall}' : function (rng){
			rng.bounds('all');
		},
		'{selection}': function (rng){
			// insert the characters without the sendkeys processing
			var s = rng.data().sendkeysOriginalText;
			for (var i =0; i < s.length; ++i){
				var x = s.charCodeAt(i);
				rng.dispatch({type: 'keypress', keyCode: x, which: x, charCode: x});
			}
			rng.text(s, 'end');
		},
		'{mark}' : function (rng){
			rng.data().sendkeysBounds = rng.bounds();
		}
	};
	// Synonyms from the proposed DOM standard (http://www.w3.org/TR/DOM-Level-3-Events-key/)
	bililiteRange.sendkeys['{Enter}'] = bililiteRange.sendkeys['{enter}'];
	bililiteRange.sendkeys['{Backspace}'] = bililiteRange.sendkeys['{backspace}'];
	bililiteRange.sendkeys['{Delete}'] = bililiteRange.sendkeys['{del}'];
	bililiteRange.sendkeys['{ArrowRight}'] = bililiteRange.sendkeys['{rightarrow}'];
	bililiteRange.sendkeys['{ArrowLeft}'] = bililiteRange.sendkeys['{leftarrow}'];

	function IERange(){}
	IERange.prototype = new Range();
	IERange.prototype._nativeRange = function (bounds){
		var rng;
		if (this._el.tagName == 'INPUT'){
			// IE 8 is very inconsistent; textareas have createTextRange but it doesn't work
			rng = this._el.createTextRange();
		}else{
			rng = this._doc.body.createTextRange ();
			rng.moveToElementText(this._el);
		}
		if (bounds){
			if (bounds[1] < 0) bounds[1] = 0; // IE tends to run elements out of bounds
			if (bounds[0] > this.length()) bounds[0] = this.length();
			if (bounds[1] < rng.text.replace(/\r/g, '').length){ // correct for IE's CrLf weirdness
				// block-display elements have an invisible, uncounted end of element marker, so we move an extra one and use the current length of the range
				rng.moveEnd ('character', -1);
				rng.moveEnd ('character', bounds[1]-rng.text.replace(/\r/g, '').length);
			}
			if (bounds[0] > 0) rng.moveStart('character', bounds[0]);
		}
		return rng;					
	};
	IERange.prototype._nativeSelect = function (rng){
		rng.select();
	};
	IERange.prototype._nativeSelection = function (){
		// returns [start, end] for the selection constrained to be in element
		var rng = this._nativeRange(); // range of the element to constrain to
		var len = this.length();
		var sel = this._doc.selection.createRange();
		try{
			return [
				iestart(sel, rng),
				ieend (sel, rng)
			];
		}catch (e){
			// TODO: determine if this is still necessary, since we only call _nativeSelection if _el is active
			// IE gets upset sometimes about comparing text to input elements, but the selections cannot overlap, so make a best guess
			return (sel.parentElement().sourceIndex < this._el.sourceIndex) ? [0,0] : [len, len];
		}
	};
	IERange.prototype._nativeGetText = function (rng){
		return rng.text;
	};
	IERange.prototype._nativeSetText = function (text, rng){
		rng.text = text;
	};
	IERange.prototype._nativeEOL = function(){
		if ('value' in this._el){
			this.text('\n'); // for input and textarea, insert it straight
		}else{
			this._nativeRange(this.bounds()).pasteHTML('\n<br/>');
		}
	};
	IERange.prototype._nativeTop = function(rng){
		var startrng = this._nativeRange([0,0]);
		return rng.boundingTop - startrng.boundingTop;
	}
	IERange.prototype._nativeWrap = function(n, rng) {
		// hacky to use string manipulation but I don't see another way to do it.
		var div = document.createElement('div');
		div.appendChild(n);
		// insert the existing range HTML after the first tag
		var html = div.innerHTML.replace('><', '>'+rng.htmlText+'<');
		rng.pasteHTML(html);
	};

	// IE internals
	function iestart(rng, constraint){
		// returns the position (in character) of the start of rng within constraint. If it's not in constraint, returns 0 if it's before, length if it's after
		var len = constraint.text.replace(/\r/g, '').length; // correct for IE's CrLf weirdness
		if (rng.compareEndPoints ('StartToStart', constraint) <= 0) return 0; // at or before the beginning
		if (rng.compareEndPoints ('StartToEnd', constraint) >= 0) return len;
		for (var i = 0; rng.compareEndPoints ('StartToStart', constraint) > 0; ++i, rng.moveStart('character', -1));
		return i;
	}
	function ieend (rng, constraint){
		// returns the position (in character) of the end of rng within constraint. If it's not in constraint, returns 0 if it's before, length if it's after
		var len = constraint.text.replace(/\r/g, '').length; // correct for IE's CrLf weirdness
		if (rng.compareEndPoints ('EndToEnd', constraint) >= 0) return len; // at or after the end
		if (rng.compareEndPoints ('EndToStart', constraint) <= 0) return 0;
		for (var i = 0; rng.compareEndPoints ('EndToStart', constraint) > 0; ++i, rng.moveEnd('character', -1));
		return i;
	}

	// an input element in a standards document. "Native Range" is just the bounds array
	function InputRange(){}
	InputRange.prototype = new Range();
	InputRange.prototype._nativeRange = function(bounds) {
		return bounds || [0, this.length()];
	};
	InputRange.prototype._nativeSelect = function (rng){
		this._el.setSelectionRange(rng[0], rng[1]);
	};
	InputRange.prototype._nativeSelection = function(){
		return [this._el.selectionStart, this._el.selectionEnd];
	};
	InputRange.prototype._nativeGetText = function(rng){
		return this._el.value.substring(rng[0], rng[1]);
	};
	InputRange.prototype._nativeSetText = function(text, rng){
		var val = this._el.value;
		this._el.value = val.substring(0, rng[0]) + text + val.substring(rng[1]);
	};
	InputRange.prototype._nativeEOL = function(){
		this.text('\n');
	};
	InputRange.prototype._nativeTop = function(rng){
		// I can't remember where I found this clever hack to find the location of text in a text area
		var clone = this._el.cloneNode(true);
		clone.style.visibility = 'hidden';
		clone.style.position = 'absolute';
		this._el.parentNode.insertBefore(clone, this._el);
		clone.style.height = '1px';
		clone.value = this._el.value.slice(0, rng[0]);
		var top = clone.scrollHeight;
		// this gives the bottom of the text, so we have to subtract the height of a single line
		clone.value = 'X';
		top -= clone.scrollHeight;
		clone.parentNode.removeChild(clone);
		return top;
	}
	InputRange.prototype._nativeWrap = function() {throw new Error("Cannot wrap in a text element")};

	function W3CRange(){}
	W3CRange.prototype = new Range();
	W3CRange.prototype._nativeRange = function (bounds){
		var rng = this._doc.createRange();
		rng.selectNodeContents(this._el);
		if (bounds){
			w3cmoveBoundary (rng, bounds[0], true, this._el);
			rng.collapse (true);
			w3cmoveBoundary (rng, bounds[1]-bounds[0], false, this._el);
		}
		return rng;					
	};
	W3CRange.prototype._nativeSelect = function (rng){
		this._win.getSelection().removeAllRanges();
		this._win.getSelection().addRange (rng);
	};
	W3CRange.prototype._nativeSelection = function (){
		// returns [start, end] for the selection constrained to be in element
		var rng = this._nativeRange(); // range of the element to constrain to
		if (this._win.getSelection().rangeCount == 0) return [this.length(), this.length()]; // append to the end
		var sel = this._win.getSelection().getRangeAt(0);
		return [
			w3cstart(sel, rng),
			w3cend (sel, rng)
		];
		}
	W3CRange.prototype._nativeGetText = function (rng){
		return String.prototype.slice.apply(this._el.textContent, this.bounds());
		// return rng.toString(); // this fails in IE11 since it insists on inserting \r's before \n's in Ranges. node.textContent works as expected
	};
	W3CRange.prototype._nativeSetText = function (text, rng){
		rng.deleteContents();
		rng.insertNode (this._doc.createTextNode(text));
		if (canNormalize) this._el.normalize(); // merge the text with the surrounding text
	};
	W3CRange.prototype._nativeEOL = function(){
		var rng = this._nativeRange(this.bounds());
		rng.deleteContents();
		var br = this._doc.createElement('br');
		br.setAttribute ('_moz_dirty', ''); // for Firefox
		rng.insertNode (br);
		rng.insertNode (this._doc.createTextNode('\n'));
		rng.collapse (false);
	};
	W3CRange.prototype._nativeTop = function(rng){
		if (this.length == 0) return 0; // no text, no scrolling
		if (rng.toString() == ''){
			var textnode = this._doc.createTextNode('X');
			rng.insertNode (textnode);
		}
		var startrng = this._nativeRange([0,1]);
		var top = rng.getBoundingClientRect().top - startrng.getBoundingClientRect().top;
		if (textnode) textnode.parentNode.removeChild(textnode);
		return top;
	}
	W3CRange.prototype._nativeWrap = function(n, rng) {
		rng.surroundContents(n);
	};

	// W3C internals
	function nextnode (node, root){
		//  in-order traversal
		// we've already visited node, so get kids then siblings
		if (node.firstChild) return node.firstChild;
		if (node.nextSibling) return node.nextSibling;
		if (node===root) return null;
		while (node.parentNode){
			// get uncles
			node = node.parentNode;
			if (node == root) return null;
			if (node.nextSibling) return node.nextSibling;
		}
		return null;
	}
	function w3cmoveBoundary (rng, n, bStart, el){
		// move the boundary (bStart == true ? start : end) n characters forward, up to the end of element el. Forward only!
		// if the start is moved after the end, then an exception is raised
		if (n <= 0) return;
		var node = rng[bStart ? 'startContainer' : 'endContainer'];
		if (node.nodeType == 3){
		  // we may be starting somewhere into the text
		  n += rng[bStart ? 'startOffset' : 'endOffset'];
		}
		while (node){
			if (node.nodeType == 3){
				var length = node.nodeValue.length;
				if (n <= length){
					rng[bStart ? 'setStart' : 'setEnd'](node, n);
					// special case: if we end next to a <br>, include that node.
					if (n == length){
						// skip past zero-length text nodes
						for (var next = nextnode (node, el); next && next.nodeType==3 && next.nodeValue.length == 0; next = nextnode(next, el)){
							rng[bStart ? 'setStartAfter' : 'setEndAfter'](next);
						}
						if (next && next.nodeType == 1 && next.nodeName == "BR") rng[bStart ? 'setStartAfter' : 'setEndAfter'](next);
					}
					return;
				}else{
					rng[bStart ? 'setStartAfter' : 'setEndAfter'](node); // skip past this one
					n -= length; // and eat these characters
				}
			}
			node = nextnode (node, el);
		}
	}
	var     START_TO_START                 = 0; // from the w3c definitions
	var     START_TO_END                   = 1;
	var     END_TO_END                     = 2;
	var     END_TO_START                   = 3;
	// from the Mozilla documentation, for range.compareBoundaryPoints(how, sourceRange)
	// -1, 0, or 1, indicating whether the corresponding boundary-point of range is respectively before, equal to, or after the corresponding boundary-point of sourceRange. 
	    // * Range.END_TO_END compares the end boundary-point of sourceRange to the end boundary-point of range.
	    // * Range.END_TO_START compares the end boundary-point of sourceRange to the start boundary-point of range.
	    // * Range.START_TO_END compares the start boundary-point of sourceRange to the end boundary-point of range.
	    // * Range.START_TO_START compares the start boundary-point of sourceRange to the start boundary-point of range. 
	function w3cstart(rng, constraint){
		if (rng.compareBoundaryPoints (START_TO_START, constraint) <= 0) return 0; // at or before the beginning
		if (rng.compareBoundaryPoints (END_TO_START, constraint) >= 0) return constraint.toString().length;
		rng = rng.cloneRange(); // don't change the original
		rng.setEnd (constraint.endContainer, constraint.endOffset); // they now end at the same place
		return constraint.toString().replace(/\r/g, '').length - rng.toString().replace(/\r/g, '').length;
	}
	function w3cend (rng, constraint){
		if (rng.compareBoundaryPoints (END_TO_END, constraint) >= 0) return constraint.toString().length; // at or after the end
		if (rng.compareBoundaryPoints (START_TO_END, constraint) <= 0) return 0;
		rng = rng.cloneRange(); // don't change the original
		rng.setStart (constraint.startContainer, constraint.startOffset); // they now start at the same place
		return rng.toString().replace(/\r/g, '').length;
	}

	function NothingRange(){}
	NothingRange.prototype = new Range();
	NothingRange.prototype._nativeRange = function(bounds) {
		return bounds || [0,this.length()];
	};
	NothingRange.prototype._nativeSelect = function (rng){ // do nothing
	};
	NothingRange.prototype._nativeSelection = function(){
		return [0,0];
	};
	NothingRange.prototype._nativeGetText = function (rng){
		return this._el[this._textProp].substring(rng[0], rng[1]);
	};
	NothingRange.prototype._nativeSetText = function (text, rng){
		var val = this._el[this._textProp];
		this._el[this._textProp] = val.substring(0, rng[0]) + text + val.substring(rng[1]);
	};
	NothingRange.prototype._nativeEOL = function(){
		this.text('\n');
	};
	NothingRange.prototype._nativeTop = function(){
		return 0;
	};
	NothingRange.prototype._nativeWrap = function() {throw new Error("Wrapping not implemented")};


	// data for elements, similar to jQuery data, but allows for monitoring with custom events
	var data = []; // to avoid attaching javascript objects to DOM elements, to avoid memory leaks
	bililiteRange.fn.data = function(){
		var index = this.element().bililiteRangeData;
		if (index == undefined){
			index = this.element().bililiteRangeData = data.length;
			data[index] = new Data(this);
		}
		return data[index];
	}
	try {
		Object.defineProperty({},'foo',{}); // IE8 will throw an error
		var Data = function(rng) {
			// we use JSON.stringify to display the data values. To make some of those non-enumerable, we have to use properties
			Object.defineProperty(this, 'values', {
				value: {}
			});
			Object.defineProperty(this, 'sourceRange', {
				value: rng
			});
			Object.defineProperty(this, 'toJSON', {
				value: function(){
					var ret = {};
					for (var i in Data.prototype) if (i in this.values) ret[i] = this.values[i];
					return ret;
				}
			});
			// to display all the properties (not just those changed), use JSON.stringify(state.all)
			Object.defineProperty(this, 'all', {
				get: function(){
					var ret = {};
					for (var i in Data.prototype) ret[i] = this[i];
					return ret;
				}
			});
		}

		Data.prototype = {};
		Object.defineProperty(Data.prototype, 'values', {
			value: {}
		});
		Object.defineProperty(Data.prototype, 'monitored', {
			value: {}
		});
		
		bililiteRange.data = function (name, newdesc){
			newdesc = newdesc || {};
			var desc = Object.getOwnPropertyDescriptor(Data.prototype, name) || {};
			if ('enumerable' in newdesc) desc.enumerable = !!newdesc.enumerable;
			if (!('enumerable' in desc)) desc.enumerable = true; // default
			if ('value' in newdesc) Data.prototype.values[name] = newdesc.value;
			if ('monitored' in newdesc) Data.prototype.monitored[name] = newdesc.monitored;
			desc.configurable = true;
			desc.get = function (){
				if (name in this.values) return this.values[name];
				return Data.prototype.values[name];
			};
			desc.set = function (value){
				this.values[name] = value;
				if (Data.prototype.monitored[name]) this.sourceRange.dispatch({
					type: 'bililiteRangeData',
					bubbles: true,
					detail: {name: name, value: value}
				});
			}
			Object.defineProperty(Data.prototype, name, desc);
		}
	}catch(err){
		// if we can't set object property properties, just use old-fashioned properties
	  Data = function(rng){ this.sourceRange = rng };
		Data.prototype = {};
		bililiteRange.data = function(name, newdesc){
			if ('value' in newdesc) Data.prototype[name] = newdesc.value;
		}
	}

	})();

	// Polyfill for forEach, per Mozilla documentation. https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach#Polyfill
	if (!Array.prototype.forEach)
	{
	  Array.prototype.forEach = function(fun /*, thisArg */)
	  {
	    "use strict";

	    if (this === void 0 || this === null)
	      throw new TypeError();

	    var t = Object(this);
	    var len = t.length >>> 0;
	    if (typeof fun !== "function")
	      throw new TypeError();

	    var thisArg = arguments.length >= 2 ? arguments[1] : void 0;
	    for (var i = 0; i < len; i++)
	    {
	      if (i in t)
	        fun.call(thisArg, t[i], i, t);
	    }
	  };
	}


/***/ }),
/* 57 */
/***/ (function(module, exports) {

	// insert characters in a textarea or text input field
	// special characters are enclosed in {}; use {{} for the { character itself
	// documentation: http://bililite.com/blog/2008/08/20/the-fnsendkeys-plugin/
	// Version: 4
	// Copyright (c) 2013 Daniel Wachsstock
	// MIT license:
	// Permission is hereby granted, free of charge, to any person
	// obtaining a copy of this software and associated documentation
	// files (the "Software"), to deal in the Software without
	// restriction, including without limitation the rights to use,
	// copy, modify, merge, publish, distribute, sublicense, and/or sell
	// copies of the Software, and to permit persons to whom the
	// Software is furnished to do so, subject to the following
	// conditions:

	// The above copyright notice and this permission notice shall be
	// included in all copies or substantial portions of the Software.

	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
	// OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
	// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
	// WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
	// OTHER DEALINGS IN THE SOFTWARE.

	(function($){

	$.fn.sendkeys = function (x){
		x = x.replace(/([^{])\n/g, '$1{enter}'); // turn line feeds into explicit break insertions, but not if escaped
		return this.each( function(){
			bililiteRange(this).bounds('selection').sendkeys(x).select();
			this.focus();
		});
	}; // sendkeys

	// add a default handler for keydowns so that we can send keystrokes, even though code-generated events 
	// are untrusted (http://www.w3.org/TR/DOM-Level-3-Events/#trusted-events)
	// documentation of special event handlers is at http://learn.jquery.com/events/event-extensions/
	$.event.special.keydown = $.event.special.keydown || {};
	$.event.special.keydown._default = function (evt){
		if (evt.isTrusted) return false;
		if (evt.ctrlKey || evt.altKey || evt.metaKey) return false; // only deal with printable characters. This may be a false assumption
		if (evt.key == null) return false; // nothing to print. Use the keymap plugin to set this 
		var target = evt.target;
		if (target.isContentEditable || target.nodeName == 'INPUT' || target.nodeName == 'TEXTAREA') {
			// only insert into editable elements
			var key = evt.key;
			if (key.length > 1 && key.charAt(0) != '{') key = '{'+key+'}'; // sendkeys notation
			$(target).sendkeys(key);
			return true;
		}
		return false;
	}
	})(jQuery)

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

	(function webpackUniversalModuleDefinition(root, factory) {
		if(true)
			module.exports = factory();
		else if(typeof define === 'function' && define.amd)
			define([], factory);
		else if(typeof exports === 'object')
			exports["Cleave"] = factory();
		else
			root["Cleave"] = factory();
	})(this, function() {
	return /******/ (function(modules) { // webpackBootstrap
	/******/ 	// The module cache
	/******/ 	var installedModules = {};

	/******/ 	// The require function
	/******/ 	function __webpack_require__(moduleId) {

	/******/ 		// Check if module is in cache
	/******/ 		if(installedModules[moduleId])
	/******/ 			return installedModules[moduleId].exports;

	/******/ 		// Create a new module (and put it into the cache)
	/******/ 		var module = installedModules[moduleId] = {
	/******/ 			exports: {},
	/******/ 			id: moduleId,
	/******/ 			loaded: false
	/******/ 		};

	/******/ 		// Execute the module function
	/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

	/******/ 		// Flag the module as loaded
	/******/ 		module.loaded = true;

	/******/ 		// Return the exports of the module
	/******/ 		return module.exports;
	/******/ 	}


	/******/ 	// expose the modules object (__webpack_modules__)
	/******/ 	__webpack_require__.m = modules;

	/******/ 	// expose the module cache
	/******/ 	__webpack_require__.c = installedModules;

	/******/ 	// __webpack_public_path__
	/******/ 	__webpack_require__.p = "";

	/******/ 	// Load entry module and return exports
	/******/ 	return __webpack_require__(0);
	/******/ })
	/************************************************************************/
	/******/ ([
	/* 0 */
	/***/ (function(module, exports, __webpack_require__) {

		/* WEBPACK VAR INJECTION */(function(global) {'use strict';

		/**
		 * Construct a new Cleave instance by passing the configuration object
		 *
		 * @param {String | HTMLElement} element
		 * @param {Object} opts
		 */
		var Cleave = function (element, opts) {
		    var owner = this;
		    var hasMultipleElements = false;

		    if (typeof element === 'string') {
		        owner.element = document.querySelector(element);
		        hasMultipleElements = document.querySelectorAll(element).length > 1;
		    } else {
		      if (typeof element.length !== 'undefined' && element.length > 0) {
		        owner.element = element[0];
		        hasMultipleElements = element.length > 1;
		      } else {
		        owner.element = element;
		      }
		    }

		    if (!owner.element) {
		        throw new Error('[cleave.js] Please check the element');
		    }

		    if (hasMultipleElements) {
		      try {
		        // eslint-disable-next-line
		        console.warn('[cleave.js] Multiple input fields matched, cleave.js will only take the first one.');
		      } catch (e) {
		        // Old IE
		      }
		    }

		    opts.initValue = owner.element.value;

		    owner.properties = Cleave.DefaultProperties.assign({}, opts);

		    owner.init();
		};

		Cleave.prototype = {
		    init: function () {
		        var owner = this, pps = owner.properties;

		        // no need to use this lib
		        if (!pps.numeral && !pps.phone && !pps.creditCard && !pps.time && !pps.date && (pps.blocksLength === 0 && !pps.prefix)) {
		            owner.onInput(pps.initValue);

		            return;
		        }

		        pps.maxLength = Cleave.Util.getMaxLength(pps.blocks);

		        owner.isAndroid = Cleave.Util.isAndroid();
		        owner.lastInputValue = '';

		        owner.onChangeListener = owner.onChange.bind(owner);
		        owner.onKeyDownListener = owner.onKeyDown.bind(owner);
		        owner.onFocusListener = owner.onFocus.bind(owner);
		        owner.onCutListener = owner.onCut.bind(owner);
		        owner.onCopyListener = owner.onCopy.bind(owner);

		        owner.element.addEventListener('input', owner.onChangeListener);
		        owner.element.addEventListener('keydown', owner.onKeyDownListener);
		        owner.element.addEventListener('focus', owner.onFocusListener);
		        owner.element.addEventListener('cut', owner.onCutListener);
		        owner.element.addEventListener('copy', owner.onCopyListener);


		        owner.initPhoneFormatter();
		        owner.initDateFormatter();
		        owner.initTimeFormatter();
		        owner.initNumeralFormatter();

		        // avoid touch input field if value is null
		        // otherwise Firefox will add red box-shadow for <input required />
		        if (pps.initValue || (pps.prefix && !pps.noImmediatePrefix)) {
		            owner.onInput(pps.initValue);
		        }
		    },

		    initNumeralFormatter: function () {
		        var owner = this, pps = owner.properties;

		        if (!pps.numeral) {
		            return;
		        }

		        pps.numeralFormatter = new Cleave.NumeralFormatter(
		            pps.numeralDecimalMark,
		            pps.numeralIntegerScale,
		            pps.numeralDecimalScale,
		            pps.numeralThousandsGroupStyle,
		            pps.numeralPositiveOnly,
		            pps.stripLeadingZeroes,
		            pps.prefix,
		            pps.signBeforePrefix,
		            pps.delimiter
		        );
		    },

		    initTimeFormatter: function() {
		        var owner = this, pps = owner.properties;

		        if (!pps.time) {
		            return;
		        }

		        pps.timeFormatter = new Cleave.TimeFormatter(pps.timePattern, pps.timeFormat);
		        pps.blocks = pps.timeFormatter.getBlocks();
		        pps.blocksLength = pps.blocks.length;
		        pps.maxLength = Cleave.Util.getMaxLength(pps.blocks);
		    },

		    initDateFormatter: function () {
		        var owner = this, pps = owner.properties;

		        if (!pps.date) {
		            return;
		        }

		        pps.dateFormatter = new Cleave.DateFormatter(pps.datePattern, pps.dateMin, pps.dateMax);
		        pps.blocks = pps.dateFormatter.getBlocks();
		        pps.blocksLength = pps.blocks.length;
		        pps.maxLength = Cleave.Util.getMaxLength(pps.blocks);
		    },

		    initPhoneFormatter: function () {
		        var owner = this, pps = owner.properties;

		        if (!pps.phone) {
		            return;
		        }

		        // Cleave.AsYouTypeFormatter should be provided by
		        // external google closure lib
		        try {
		            pps.phoneFormatter = new Cleave.PhoneFormatter(
		                new pps.root.Cleave.AsYouTypeFormatter(pps.phoneRegionCode),
		                pps.delimiter
		            );
		        } catch (ex) {
		            throw new Error('[cleave.js] Please include phone-type-formatter.{country}.js lib');
		        }
		    },

		    onKeyDown: function (event) {
		        var owner = this, pps = owner.properties,
		            charCode = event.which || event.keyCode,
		            Util = Cleave.Util,
		            currentValue = owner.element.value;

		        // if we got any charCode === 8, this means, that this device correctly
		        // sends backspace keys in event, so we do not need to apply any hacks
		        owner.hasBackspaceSupport = owner.hasBackspaceSupport || charCode === 8;
		        if (!owner.hasBackspaceSupport
		          && Util.isAndroidBackspaceKeydown(owner.lastInputValue, currentValue)
		        ) {
		            charCode = 8;
		        }

		        owner.lastInputValue = currentValue;

		        // hit backspace when last character is delimiter
		        var postDelimiter = Util.getPostDelimiter(currentValue, pps.delimiter, pps.delimiters);
		        if (charCode === 8 && postDelimiter) {
		            pps.postDelimiterBackspace = postDelimiter;
		        } else {
		            pps.postDelimiterBackspace = false;
		        }
		    },

		    onChange: function () {
		        this.onInput(this.element.value);
		    },

		    onFocus: function () {
		        var owner = this,
		            pps = owner.properties;

		        Cleave.Util.fixPrefixCursor(owner.element, pps.prefix, pps.delimiter, pps.delimiters);
		    },

		    onCut: function (e) {
		        if (!Cleave.Util.checkFullSelection(this.element.value)) return;
		        this.copyClipboardData(e);
		        this.onInput('');
		    },

		    onCopy: function (e) {
		        if (!Cleave.Util.checkFullSelection(this.element.value)) return;
		        this.copyClipboardData(e);
		    },

		    copyClipboardData: function (e) {
		        var owner = this,
		            pps = owner.properties,
		            Util = Cleave.Util,
		            inputValue = owner.element.value,
		            textToCopy = '';

		        if (!pps.copyDelimiter) {
		            textToCopy = Util.stripDelimiters(inputValue, pps.delimiter, pps.delimiters);
		        } else {
		            textToCopy = inputValue;
		        }

		        try {
		            if (e.clipboardData) {
		                e.clipboardData.setData('Text', textToCopy);
		            } else {
		                window.clipboardData.setData('Text', textToCopy);
		            }

		            e.preventDefault();
		        } catch (ex) {
		            //  empty
		        }
		    },

		    onInput: function (value) {
		        var owner = this, pps = owner.properties,
		            Util = Cleave.Util;

		        // case 1: delete one more character "4"
		        // 1234*| -> hit backspace -> 123|
		        // case 2: last character is not delimiter which is:
		        // 12|34* -> hit backspace -> 1|34*
		        // note: no need to apply this for numeral mode
		        var postDelimiterAfter = Util.getPostDelimiter(value, pps.delimiter, pps.delimiters);
		        if (!pps.numeral && pps.postDelimiterBackspace && !postDelimiterAfter) {
		            value = Util.headStr(value, value.length - pps.postDelimiterBackspace.length);
		        }

		        // phone formatter
		        if (pps.phone) {
		            if (pps.prefix && (!pps.noImmediatePrefix || value.length)) {
		                pps.result = pps.prefix + pps.phoneFormatter.format(value).slice(pps.prefix.length);
		            } else {
		                pps.result = pps.phoneFormatter.format(value);
		            }
		            owner.updateValueState();

		            return;
		        }

		        // numeral formatter
		        if (pps.numeral) {
		            // Do not show prefix when noImmediatePrefix is specified
		            // This mostly because we need to show user the native input placeholder
		            if (pps.prefix && pps.noImmediatePrefix && value.length === 0) {
		                pps.result = '';
		            } else {
		                pps.result = pps.numeralFormatter.format(value);
		            }
		            owner.updateValueState();

		            return;
		        }

		        // date
		        if (pps.date) {
		            value = pps.dateFormatter.getValidatedDate(value);
		        }

		        // time
		        if (pps.time) {
		            value = pps.timeFormatter.getValidatedTime(value);
		        }

		        // strip delimiters
		        value = Util.stripDelimiters(value, pps.delimiter, pps.delimiters);

		        // strip prefix
		        value = Util.getPrefixStrippedValue(
		            value, pps.prefix, pps.prefixLength,
		            pps.result, pps.delimiter, pps.delimiters, pps.noImmediatePrefix
		        );

		        // strip non-numeric characters
		        value = pps.numericOnly ? Util.strip(value, /[^\d]/g) : value;

		        // convert case
		        value = pps.uppercase ? value.toUpperCase() : value;
		        value = pps.lowercase ? value.toLowerCase() : value;

		        // prevent from showing prefix when no immediate option enabled with empty input value
		        if (pps.prefix && (!pps.noImmediatePrefix || value.length)) {
		            value = pps.prefix + value;

		            // no blocks specified, no need to do formatting
		            if (pps.blocksLength === 0) {
		                pps.result = value;
		                owner.updateValueState();

		                return;
		            }
		        }

		        // update credit card props
		        if (pps.creditCard) {
		            owner.updateCreditCardPropsByValue(value);
		        }

		        // strip over length characters
		        value = Util.headStr(value, pps.maxLength);

		        // apply blocks
		        pps.result = Util.getFormattedValue(
		            value,
		            pps.blocks, pps.blocksLength,
		            pps.delimiter, pps.delimiters, pps.delimiterLazyShow
		        );

		        owner.updateValueState();
		    },

		    updateCreditCardPropsByValue: function (value) {
		        var owner = this, pps = owner.properties,
		            Util = Cleave.Util,
		            creditCardInfo;

		        // At least one of the first 4 characters has changed
		        if (Util.headStr(pps.result, 4) === Util.headStr(value, 4)) {
		            return;
		        }

		        creditCardInfo = Cleave.CreditCardDetector.getInfo(value, pps.creditCardStrictMode);

		        pps.blocks = creditCardInfo.blocks;
		        pps.blocksLength = pps.blocks.length;
		        pps.maxLength = Util.getMaxLength(pps.blocks);

		        // credit card type changed
		        if (pps.creditCardType !== creditCardInfo.type) {
		            pps.creditCardType = creditCardInfo.type;

		            pps.onCreditCardTypeChanged.call(owner, pps.creditCardType);
		        }
		    },

		    updateValueState: function () {
		        var owner = this,
		            Util = Cleave.Util,
		            pps = owner.properties;

		        if (!owner.element) {
		            return;
		        }

		        var endPos = owner.element.selectionEnd;
		        var oldValue = owner.element.value;
		        var newValue = pps.result;

		        endPos = Util.getNextCursorPosition(endPos, oldValue, newValue, pps.delimiter, pps.delimiters);

		        // fix Android browser type="text" input field
		        // cursor not jumping issue
		        if (owner.isAndroid) {
		            window.setTimeout(function () {
		                owner.element.value = newValue;
		                Util.setSelection(owner.element, endPos, pps.document, false);
		                owner.callOnValueChanged();
		            }, 1);

		            return;
		        }

		        owner.element.value = newValue;
		        Util.setSelection(owner.element, endPos, pps.document, false);
		        owner.callOnValueChanged();
		    },

		    callOnValueChanged: function () {
		        var owner = this,
		            pps = owner.properties;

		        pps.onValueChanged.call(owner, {
		            target: {
		                value: pps.result,
		                rawValue: owner.getRawValue()
		            }
		        });
		    },

		    setPhoneRegionCode: function (phoneRegionCode) {
		        var owner = this, pps = owner.properties;

		        pps.phoneRegionCode = phoneRegionCode;
		        owner.initPhoneFormatter();
		        owner.onChange();
		    },

		    setRawValue: function (value) {
		        var owner = this, pps = owner.properties;

		        value = value !== undefined && value !== null ? value.toString() : '';

		        if (pps.numeral) {
		            value = value.replace('.', pps.numeralDecimalMark);
		        }

		        pps.postDelimiterBackspace = false;

		        owner.element.value = value;
		        owner.onInput(value);
		    },

		    getRawValue: function () {
		        var owner = this,
		            pps = owner.properties,
		            Util = Cleave.Util,
		            rawValue = owner.element.value;

		        if (pps.rawValueTrimPrefix) {
		            rawValue = Util.getPrefixStrippedValue(rawValue, pps.prefix, pps.prefixLength, pps.result, pps.delimiter, pps.delimiters);
		        }

		        if (pps.numeral) {
		            rawValue = pps.numeralFormatter.getRawValue(rawValue);
		        } else {
		            rawValue = Util.stripDelimiters(rawValue, pps.delimiter, pps.delimiters);
		        }

		        return rawValue;
		    },

		    getISOFormatDate: function () {
		        var owner = this,
		            pps = owner.properties;

		        return pps.date ? pps.dateFormatter.getISOFormatDate() : '';
		    },

		    getISOFormatTime: function () {
		        var owner = this,
		            pps = owner.properties;

		        return pps.time ? pps.timeFormatter.getISOFormatTime() : '';
		    },

		    getFormattedValue: function () {
		        return this.element.value;
		    },

		    destroy: function () {
		        var owner = this;

		        owner.element.removeEventListener('input', owner.onChangeListener);
		        owner.element.removeEventListener('keydown', owner.onKeyDownListener);
		        owner.element.removeEventListener('focus', owner.onFocusListener);
		        owner.element.removeEventListener('cut', owner.onCutListener);
		        owner.element.removeEventListener('copy', owner.onCopyListener);
		    },

		    toString: function () {
		        return '[Cleave Object]';
		    }
		};

		Cleave.NumeralFormatter = __webpack_require__(1);
		Cleave.DateFormatter = __webpack_require__(2);
		Cleave.TimeFormatter = __webpack_require__(3);
		Cleave.PhoneFormatter = __webpack_require__(4);
		Cleave.CreditCardDetector = __webpack_require__(5);
		Cleave.Util = __webpack_require__(6);
		Cleave.DefaultProperties = __webpack_require__(7);

		// for angular directive
		((typeof global === 'object' && global) ? global : window)['Cleave'] = Cleave;

		// CommonJS
		module.exports = Cleave;

		/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

	/***/ }),
	/* 1 */
	/***/ (function(module, exports) {

		'use strict';

		var NumeralFormatter = function (numeralDecimalMark,
		                                 numeralIntegerScale,
		                                 numeralDecimalScale,
		                                 numeralThousandsGroupStyle,
		                                 numeralPositiveOnly,
		                                 stripLeadingZeroes,
		                                 prefix,
		                                 signBeforePrefix,
		                                 delimiter) {
		    var owner = this;

		    owner.numeralDecimalMark = numeralDecimalMark || '.';
		    owner.numeralIntegerScale = numeralIntegerScale > 0 ? numeralIntegerScale : 0;
		    owner.numeralDecimalScale = numeralDecimalScale >= 0 ? numeralDecimalScale : 2;
		    owner.numeralThousandsGroupStyle = numeralThousandsGroupStyle || NumeralFormatter.groupStyle.thousand;
		    owner.numeralPositiveOnly = !!numeralPositiveOnly;
		    owner.stripLeadingZeroes = stripLeadingZeroes !== false;
		    owner.prefix = (prefix || prefix === '') ? prefix : '';
		    owner.signBeforePrefix = !!signBeforePrefix;
		    owner.delimiter = (delimiter || delimiter === '') ? delimiter : ',';
		    owner.delimiterRE = delimiter ? new RegExp('\\' + delimiter, 'g') : '';
		};

		NumeralFormatter.groupStyle = {
		    thousand: 'thousand',
		    lakh:     'lakh',
		    wan:      'wan',
		    none:     'none'    
		};

		NumeralFormatter.prototype = {
		    getRawValue: function (value) {
		        return value.replace(this.delimiterRE, '').replace(this.numeralDecimalMark, '.');
		    },

		    format: function (value) {
		        var owner = this, parts, partSign, partSignAndPrefix, partInteger, partDecimal = '';

		        // strip alphabet letters
		        value = value.replace(/[A-Za-z]/g, '')
		            // replace the first decimal mark with reserved placeholder
		            .replace(owner.numeralDecimalMark, 'M')

		            // strip non numeric letters except minus and "M"
		            // this is to ensure prefix has been stripped
		            .replace(/[^\dM-]/g, '')

		            // replace the leading minus with reserved placeholder
		            .replace(/^\-/, 'N')

		            // strip the other minus sign (if present)
		            .replace(/\-/g, '')

		            // replace the minus sign (if present)
		            .replace('N', owner.numeralPositiveOnly ? '' : '-')

		            // replace decimal mark
		            .replace('M', owner.numeralDecimalMark);

		        // strip any leading zeros
		        if (owner.stripLeadingZeroes) {
		            value = value.replace(/^(-)?0+(?=\d)/, '$1');
		        }

		        partSign = value.slice(0, 1) === '-' ? '-' : '';
		        if (typeof owner.prefix != 'undefined') {
		            if (owner.signBeforePrefix) {
		                partSignAndPrefix = partSign + owner.prefix;
		            } else {
		                partSignAndPrefix = owner.prefix + partSign;
		            }
		        } else {
		            partSignAndPrefix = partSign;
		        }
		        
		        partInteger = value;

		        if (value.indexOf(owner.numeralDecimalMark) >= 0) {
		            parts = value.split(owner.numeralDecimalMark);
		            partInteger = parts[0];
		            partDecimal = owner.numeralDecimalMark + parts[1].slice(0, owner.numeralDecimalScale);
		        }

		        if(partSign === '-') {
		            partInteger = partInteger.slice(1);
		        }

		        if (owner.numeralIntegerScale > 0) {
		          partInteger = partInteger.slice(0, owner.numeralIntegerScale);
		        }

		        switch (owner.numeralThousandsGroupStyle) {
		        case NumeralFormatter.groupStyle.lakh:
		            partInteger = partInteger.replace(/(\d)(?=(\d\d)+\d$)/g, '$1' + owner.delimiter);

		            break;

		        case NumeralFormatter.groupStyle.wan:
		            partInteger = partInteger.replace(/(\d)(?=(\d{4})+$)/g, '$1' + owner.delimiter);

		            break;

		        case NumeralFormatter.groupStyle.thousand:
		            partInteger = partInteger.replace(/(\d)(?=(\d{3})+$)/g, '$1' + owner.delimiter);

		            break;
		        }

		        return partSignAndPrefix + partInteger.toString() + (owner.numeralDecimalScale > 0 ? partDecimal.toString() : '');
		    }
		};

		module.exports = NumeralFormatter;


	/***/ }),
	/* 2 */
	/***/ (function(module, exports) {

		'use strict';

		var DateFormatter = function (datePattern, dateMin, dateMax) {
		    var owner = this;

		    owner.date = [];
		    owner.blocks = [];
		    owner.datePattern = datePattern;
		    owner.dateMin = dateMin
		      .split('-')
		      .reverse()
		      .map(function(x) {
		        return parseInt(x, 10);
		      });
		    if (owner.dateMin.length === 2) owner.dateMin.unshift(0);

		    owner.dateMax = dateMax
		      .split('-')
		      .reverse()
		      .map(function(x) {
		        return parseInt(x, 10);
		      });
		    if (owner.dateMax.length === 2) owner.dateMax.unshift(0);
		    
		    owner.initBlocks();
		};

		DateFormatter.prototype = {
		    initBlocks: function () {
		        var owner = this;
		        owner.datePattern.forEach(function (value) {
		            if (value === 'Y') {
		                owner.blocks.push(4);
		            } else {
		                owner.blocks.push(2);
		            }
		        });
		    },

		    getISOFormatDate: function () {
		        var owner = this,
		            date = owner.date;

		        return date[2] ? (
		            date[2] + '-' + owner.addLeadingZero(date[1]) + '-' + owner.addLeadingZero(date[0])
		        ) : '';
		    },

		    getBlocks: function () {
		        return this.blocks;
		    },

		    getValidatedDate: function (value) {
		        var owner = this, result = '';

		        value = value.replace(/[^\d]/g, '');

		        owner.blocks.forEach(function (length, index) {
		            if (value.length > 0) {
		                var sub = value.slice(0, length),
		                    sub0 = sub.slice(0, 1),
		                    rest = value.slice(length);

		                switch (owner.datePattern[index]) {
		                case 'd':
		                    if (sub === '00') {
		                        sub = '01';
		                    } else if (parseInt(sub0, 10) > 3) {
		                        sub = '0' + sub0;
		                    } else if (parseInt(sub, 10) > 31) {
		                        sub = '31';
		                    }

		                    break;

		                case 'm':
		                    if (sub === '00') {
		                        sub = '01';
		                    } else if (parseInt(sub0, 10) > 1) {
		                        sub = '0' + sub0;
		                    } else if (parseInt(sub, 10) > 12) {
		                        sub = '12';
		                    }

		                    break;
		                }

		                result += sub;

		                // update remaining string
		                value = rest;
		            }
		        });

		        return this.getFixedDateString(result);
		    },

		    getFixedDateString: function (value) {
		        var owner = this, datePattern = owner.datePattern, date = [],
		            dayIndex = 0, monthIndex = 0, yearIndex = 0,
		            dayStartIndex = 0, monthStartIndex = 0, yearStartIndex = 0,
		            day, month, year, fullYearDone = false;

		        // mm-dd || dd-mm
		        if (value.length === 4 && datePattern[0].toLowerCase() !== 'y' && datePattern[1].toLowerCase() !== 'y') {
		            dayStartIndex = datePattern[0] === 'd' ? 0 : 2;
		            monthStartIndex = 2 - dayStartIndex;
		            day = parseInt(value.slice(dayStartIndex, dayStartIndex + 2), 10);
		            month = parseInt(value.slice(monthStartIndex, monthStartIndex + 2), 10);

		            date = this.getFixedDate(day, month, 0);
		        }

		        // yyyy-mm-dd || yyyy-dd-mm || mm-dd-yyyy || dd-mm-yyyy || dd-yyyy-mm || mm-yyyy-dd
		        if (value.length === 8) {
		            datePattern.forEach(function (type, index) {
		                switch (type) {
		                case 'd':
		                    dayIndex = index;
		                    break;
		                case 'm':
		                    monthIndex = index;
		                    break;
		                default:
		                    yearIndex = index;
		                    break;
		                }
		            });

		            yearStartIndex = yearIndex * 2;
		            dayStartIndex = (dayIndex <= yearIndex) ? dayIndex * 2 : (dayIndex * 2 + 2);
		            monthStartIndex = (monthIndex <= yearIndex) ? monthIndex * 2 : (monthIndex * 2 + 2);

		            day = parseInt(value.slice(dayStartIndex, dayStartIndex + 2), 10);
		            month = parseInt(value.slice(monthStartIndex, monthStartIndex + 2), 10);
		            year = parseInt(value.slice(yearStartIndex, yearStartIndex + 4), 10);

		            fullYearDone = value.slice(yearStartIndex, yearStartIndex + 4).length === 4;

		            date = this.getFixedDate(day, month, year);
		        }

		        // mm-yy || yy-mm
		        if (value.length === 4 && (datePattern[0] === 'y' || datePattern[1] === 'y')) {
		            monthStartIndex = datePattern[0] === 'm' ? 0 : 2;
		            yearStartIndex = 2 - monthStartIndex;
		            month = parseInt(value.slice(monthStartIndex, monthStartIndex + 2), 10);
		            year = parseInt(value.slice(yearStartIndex, yearStartIndex + 2), 10);

		            fullYearDone = value.slice(yearStartIndex, yearStartIndex + 2).length === 2;

		            date = [0, month, year];
		        }

		        // mm-yyyy || yyyy-mm
		        if (value.length === 6 && (datePattern[0] === 'Y' || datePattern[1] === 'Y')) {
		            monthStartIndex = datePattern[0] === 'm' ? 0 : 4;
		            yearStartIndex = 2 - 0.5 * monthStartIndex;
		            month = parseInt(value.slice(monthStartIndex, monthStartIndex + 2), 10);
		            year = parseInt(value.slice(yearStartIndex, yearStartIndex + 4), 10);

		            fullYearDone = value.slice(yearStartIndex, yearStartIndex + 4).length === 4;

		            date = [0, month, year];
		        }

		        date = owner.getRangeFixedDate(date);
		        owner.date = date;

		        var result = date.length === 0 ? value : datePattern.reduce(function (previous, current) {
		            switch (current) {
		            case 'd':
		                return previous + (date[0] === 0 ? '' : owner.addLeadingZero(date[0]));
		            case 'm':
		                return previous + (date[1] === 0 ? '' : owner.addLeadingZero(date[1]));
		            case 'y':
		                return previous + (fullYearDone ? owner.addLeadingZeroForYear(date[2], false) : '');
		            case 'Y':
		                return previous + (fullYearDone ? owner.addLeadingZeroForYear(date[2], true) : '');
		            }
		        }, '');

		        return result;
		    },

		    getRangeFixedDate: function (date) {
		        var owner = this,
		            datePattern = owner.datePattern,
		            dateMin = owner.dateMin || [],
		            dateMax = owner.dateMax || [];

		        if (!date.length || (dateMin.length < 3 && dateMax.length < 3)) return date;

		        if (
		          datePattern.find(function(x) {
		            return x.toLowerCase() === 'y';
		          }) &&
		          date[2] === 0
		        ) return date;

		        if (dateMax.length && (dateMax[2] < date[2] || (
		          dateMax[2] === date[2] && (dateMax[1] < date[1] || (
		            dateMax[1] === date[1] && dateMax[0] < date[0]
		          ))
		        ))) return dateMax;

		        if (dateMin.length && (dateMin[2] > date[2] || (
		          dateMin[2] === date[2] && (dateMin[1] > date[1] || (
		            dateMin[1] === date[1] && dateMin[0] > date[0]
		          ))
		        ))) return dateMin;

		        return date;
		    },

		    getFixedDate: function (day, month, year) {
		        day = Math.min(day, 31);
		        month = Math.min(month, 12);
		        year = parseInt((year || 0), 10);

		        if ((month < 7 && month % 2 === 0) || (month > 8 && month % 2 === 1)) {
		            day = Math.min(day, month === 2 ? (this.isLeapYear(year) ? 29 : 28) : 30);
		        }

		        return [day, month, year];
		    },

		    isLeapYear: function (year) {
		        return ((year % 4 === 0) && (year % 100 !== 0)) || (year % 400 === 0);
		    },

		    addLeadingZero: function (number) {
		        return (number < 10 ? '0' : '') + number;
		    },

		    addLeadingZeroForYear: function (number, fullYearMode) {
		        if (fullYearMode) {
		            return (number < 10 ? '000' : (number < 100 ? '00' : (number < 1000 ? '0' : ''))) + number;
		        }

		        return (number < 10 ? '0' : '') + number;
		    }
		};

		module.exports = DateFormatter;


	/***/ }),
	/* 3 */
	/***/ (function(module, exports) {

		'use strict';

		var TimeFormatter = function (timePattern, timeFormat) {
		    var owner = this;

		    owner.time = [];
		    owner.blocks = [];
		    owner.timePattern = timePattern;
		    owner.timeFormat = timeFormat;
		    owner.initBlocks();
		};

		TimeFormatter.prototype = {
		    initBlocks: function () {
		        var owner = this;
		        owner.timePattern.forEach(function () {
		            owner.blocks.push(2);
		        });
		    },

		    getISOFormatTime: function () {
		        var owner = this,
		            time = owner.time;

		        return time[2] ? (
		            owner.addLeadingZero(time[0]) + ':' + owner.addLeadingZero(time[1]) + ':' + owner.addLeadingZero(time[2])
		        ) : '';
		    },

		    getBlocks: function () {
		        return this.blocks;
		    },

		    getTimeFormatOptions: function () {
		        var owner = this;
		        if (String(owner.timeFormat) === '12') {
		            return {
		                maxHourFirstDigit: 1,
		                maxHours: 12,
		                maxMinutesFirstDigit: 5,
		                maxMinutes: 60
		            };
		        }

		        return {
		            maxHourFirstDigit: 2,
		            maxHours: 23,
		            maxMinutesFirstDigit: 5,
		            maxMinutes: 60
		        };
		    },

		    getValidatedTime: function (value) {
		        var owner = this, result = '';

		        value = value.replace(/[^\d]/g, '');

		        var timeFormatOptions = owner.getTimeFormatOptions();

		        owner.blocks.forEach(function (length, index) {
		            if (value.length > 0) {
		                var sub = value.slice(0, length),
		                    sub0 = sub.slice(0, 1),
		                    rest = value.slice(length);

		                switch (owner.timePattern[index]) {

		                case 'h':
		                    if (parseInt(sub0, 10) > timeFormatOptions.maxHourFirstDigit) {
		                        sub = '0' + sub0;
		                    } else if (parseInt(sub, 10) > timeFormatOptions.maxHours) {
		                        sub = timeFormatOptions.maxHours + '';
		                    }

		                    break;

		                case 'm':
		                case 's':
		                    if (parseInt(sub0, 10) > timeFormatOptions.maxMinutesFirstDigit) {
		                        sub = '0' + sub0;
		                    } else if (parseInt(sub, 10) > timeFormatOptions.maxMinutes) {
		                        sub = timeFormatOptions.maxMinutes + '';
		                    }
		                    break;
		                }

		                result += sub;

		                // update remaining string
		                value = rest;
		            }
		        });

		        return this.getFixedTimeString(result);
		    },

		    getFixedTimeString: function (value) {
		        var owner = this, timePattern = owner.timePattern, time = [],
		            secondIndex = 0, minuteIndex = 0, hourIndex = 0,
		            secondStartIndex = 0, minuteStartIndex = 0, hourStartIndex = 0,
		            second, minute, hour;

		        if (value.length === 6) {
		            timePattern.forEach(function (type, index) {
		                switch (type) {
		                case 's':
		                    secondIndex = index * 2;
		                    break;
		                case 'm':
		                    minuteIndex = index * 2;
		                    break;
		                case 'h':
		                    hourIndex = index * 2;
		                    break;
		                }
		            });

		            hourStartIndex = hourIndex;
		            minuteStartIndex = minuteIndex;
		            secondStartIndex = secondIndex;

		            second = parseInt(value.slice(secondStartIndex, secondStartIndex + 2), 10);
		            minute = parseInt(value.slice(minuteStartIndex, minuteStartIndex + 2), 10);
		            hour = parseInt(value.slice(hourStartIndex, hourStartIndex + 2), 10);

		            time = this.getFixedTime(hour, minute, second);
		        }

		        if (value.length === 4 && owner.timePattern.indexOf('s') < 0) {
		            timePattern.forEach(function (type, index) {
		                switch (type) {
		                case 'm':
		                    minuteIndex = index * 2;
		                    break;
		                case 'h':
		                    hourIndex = index * 2;
		                    break;
		                }
		            });

		            hourStartIndex = hourIndex;
		            minuteStartIndex = minuteIndex;

		            second = 0;
		            minute = parseInt(value.slice(minuteStartIndex, minuteStartIndex + 2), 10);
		            hour = parseInt(value.slice(hourStartIndex, hourStartIndex + 2), 10);

		            time = this.getFixedTime(hour, minute, second);
		        }

		        owner.time = time;

		        return time.length === 0 ? value : timePattern.reduce(function (previous, current) {
		            switch (current) {
		            case 's':
		                return previous + owner.addLeadingZero(time[2]);
		            case 'm':
		                return previous + owner.addLeadingZero(time[1]);
		            case 'h':
		                return previous + owner.addLeadingZero(time[0]);
		            }
		        }, '');
		    },

		    getFixedTime: function (hour, minute, second) {
		        second = Math.min(parseInt(second || 0, 10), 60);
		        minute = Math.min(minute, 60);
		        hour = Math.min(hour, 60);

		        return [hour, minute, second];
		    },

		    addLeadingZero: function (number) {
		        return (number < 10 ? '0' : '') + number;
		    }
		};

		module.exports = TimeFormatter;


	/***/ }),
	/* 4 */
	/***/ (function(module, exports) {

		'use strict';

		var PhoneFormatter = function (formatter, delimiter) {
		    var owner = this;

		    owner.delimiter = (delimiter || delimiter === '') ? delimiter : ' ';
		    owner.delimiterRE = delimiter ? new RegExp('\\' + delimiter, 'g') : '';

		    owner.formatter = formatter;
		};

		PhoneFormatter.prototype = {
		    setFormatter: function (formatter) {
		        this.formatter = formatter;
		    },

		    format: function (phoneNumber) {
		        var owner = this;

		        owner.formatter.clear();

		        // only keep number and +
		        phoneNumber = phoneNumber.replace(/[^\d+]/g, '');

		        // strip non-leading +
		        phoneNumber = phoneNumber.replace(/^\+/, 'B').replace(/\+/g, '').replace('B', '+');

		        // strip delimiter
		        phoneNumber = phoneNumber.replace(owner.delimiterRE, '');

		        var result = '', current, validated = false;

		        for (var i = 0, iMax = phoneNumber.length; i < iMax; i++) {
		            current = owner.formatter.inputDigit(phoneNumber.charAt(i));

		            // has ()- or space inside
		            if (/[\s()-]/g.test(current)) {
		                result = current;

		                validated = true;
		            } else {
		                if (!validated) {
		                    result = current;
		                }
		                // else: over length input
		                // it turns to invalid number again
		            }
		        }

		        // strip ()
		        // e.g. US: 7161234567 returns (716) 123-4567
		        result = result.replace(/[()]/g, '');
		        // replace library delimiter with user customized delimiter
		        result = result.replace(/[\s-]/g, owner.delimiter);

		        return result;
		    }
		};

		module.exports = PhoneFormatter;


	/***/ }),
	/* 5 */
	/***/ (function(module, exports) {

		'use strict';

		var CreditCardDetector = {
		    blocks: {
		        uatp:          [4, 5, 6],
		        amex:          [4, 6, 5],
		        diners:        [4, 6, 4],
		        discover:      [4, 4, 4, 4],
		        mastercard:    [4, 4, 4, 4],
		        dankort:       [4, 4, 4, 4],
		        instapayment:  [4, 4, 4, 4],
		        jcb15:         [4, 6, 5],
		        jcb:           [4, 4, 4, 4],
		        maestro:       [4, 4, 4, 4],
		        visa:          [4, 4, 4, 4],
		        mir:           [4, 4, 4, 4],
		        unionPay:      [4, 4, 4, 4],
		        general:       [4, 4, 4, 4]
		    },

		    re: {
		        // starts with 1; 15 digits, not starts with 1800 (jcb card)
		        uatp: /^(?!1800)1\d{0,14}/,

		        // starts with 34/37; 15 digits
		        amex: /^3[47]\d{0,13}/,

		        // starts with 6011/65/644-649; 16 digits
		        discover: /^(?:6011|65\d{0,2}|64[4-9]\d?)\d{0,12}/,

		        // starts with 300-305/309 or 36/38/39; 14 digits
		        diners: /^3(?:0([0-5]|9)|[689]\d?)\d{0,11}/,

		        // starts with 51-55/2221–2720; 16 digits
		        mastercard: /^(5[1-5]\d{0,2}|22[2-9]\d{0,1}|2[3-7]\d{0,2})\d{0,12}/,

		        // starts with 5019/4175/4571; 16 digits
		        dankort: /^(5019|4175|4571)\d{0,12}/,

		        // starts with 637-639; 16 digits
		        instapayment: /^63[7-9]\d{0,13}/,

		        // starts with 2131/1800; 15 digits
		        jcb15: /^(?:2131|1800)\d{0,11}/,

		        // starts with 2131/1800/35; 16 digits
		        jcb: /^(?:35\d{0,2})\d{0,12}/,

		        // starts with 50/56-58/6304/67; 16 digits
		        maestro: /^(?:5[0678]\d{0,2}|6304|67\d{0,2})\d{0,12}/,

		        // starts with 22; 16 digits
		        mir: /^220[0-4]\d{0,12}/,

		        // starts with 4; 16 digits
		        visa: /^4\d{0,15}/,

		        // starts with 62; 16 digits
		        unionPay: /^62\d{0,14}/
		    },

		    getStrictBlocks: function (block) {
		      var total = block.reduce(function (prev, current) {
		        return prev + current;
		      }, 0);

		      return block.concat(19 - total);
		    },

		    getInfo: function (value, strictMode) {
		        var blocks = CreditCardDetector.blocks,
		            re = CreditCardDetector.re;

		        // Some credit card can have up to 19 digits number.
		        // Set strictMode to true will remove the 16 max-length restrain,
		        // however, I never found any website validate card number like
		        // this, hence probably you don't want to enable this option.
		        strictMode = !!strictMode;

		        for (var key in re) {
		            if (re[key].test(value)) {
		                var matchedBlocks = blocks[key];
		                return {
		                    type: key,
		                    blocks: strictMode ? this.getStrictBlocks(matchedBlocks) : matchedBlocks
		                };
		            }
		        }

		        return {
		            type: 'unknown',
		            blocks: strictMode ? this.getStrictBlocks(blocks.general) : blocks.general
		        };
		    }
		};

		module.exports = CreditCardDetector;


	/***/ }),
	/* 6 */
	/***/ (function(module, exports) {

		'use strict';

		var Util = {
		    noop: function () {
		    },

		    strip: function (value, re) {
		        return value.replace(re, '');
		    },

		    getPostDelimiter: function (value, delimiter, delimiters) {
		        // single delimiter
		        if (delimiters.length === 0) {
		            return value.slice(-delimiter.length) === delimiter ? delimiter : '';
		        }

		        // multiple delimiters
		        var matchedDelimiter = '';
		        delimiters.forEach(function (current) {
		            if (value.slice(-current.length) === current) {
		                matchedDelimiter = current;
		            }
		        });

		        return matchedDelimiter;
		    },

		    getDelimiterREByDelimiter: function (delimiter) {
		        return new RegExp(delimiter.replace(/([.?*+^$[\]\\(){}|-])/g, '\\$1'), 'g');
		    },

		    getNextCursorPosition: function (prevPos, oldValue, newValue, delimiter, delimiters) {
		      // If cursor was at the end of value, just place it back.
		      // Because new value could contain additional chars.
		      if (oldValue.length === prevPos) {
		          return newValue.length;
		      }

		      return prevPos + this.getPositionOffset(prevPos, oldValue, newValue, delimiter ,delimiters);
		    },

		    getPositionOffset: function (prevPos, oldValue, newValue, delimiter, delimiters) {
		        var oldRawValue, newRawValue, lengthOffset;

		        oldRawValue = this.stripDelimiters(oldValue.slice(0, prevPos), delimiter, delimiters);
		        newRawValue = this.stripDelimiters(newValue.slice(0, prevPos), delimiter, delimiters);
		        lengthOffset = oldRawValue.length - newRawValue.length;

		        return (lengthOffset !== 0) ? (lengthOffset / Math.abs(lengthOffset)) : 0;
		    },

		    stripDelimiters: function (value, delimiter, delimiters) {
		        var owner = this;

		        // single delimiter
		        if (delimiters.length === 0) {
		            var delimiterRE = delimiter ? owner.getDelimiterREByDelimiter(delimiter) : '';

		            return value.replace(delimiterRE, '');
		        }

		        // multiple delimiters
		        delimiters.forEach(function (current) {
		            current.split('').forEach(function (letter) {
		                value = value.replace(owner.getDelimiterREByDelimiter(letter), '');
		            });
		        });

		        return value;
		    },

		    headStr: function (str, length) {
		        return str.slice(0, length);
		    },

		    getMaxLength: function (blocks) {
		        return blocks.reduce(function (previous, current) {
		            return previous + current;
		        }, 0);
		    },

		    // strip prefix
		    // Before type  |   After type    |     Return value
		    // PEFIX-...    |   PEFIX-...     |     ''
		    // PREFIX-123   |   PEFIX-123     |     123
		    // PREFIX-123   |   PREFIX-23     |     23
		    // PREFIX-123   |   PREFIX-1234   |     1234
		    getPrefixStrippedValue: function (value, prefix, prefixLength, prevResult, delimiter, delimiters, noImmediatePrefix) {
		        // No prefix
		        if (prefixLength === 0) {
		          return value;
		        }

		        // Pre result prefix string does not match pre-defined prefix
		        if (prevResult.slice(0, prefixLength) !== prefix) {
		          // Check if the first time user entered something
		          if (noImmediatePrefix && !prevResult && value) return value;

		          return '';
		        }

		        var prevValue = this.stripDelimiters(prevResult, delimiter, delimiters);

		        // New value has issue, someone typed in between prefix letters
		        // Revert to pre value
		        if (value.slice(0, prefixLength) !== prefix) {
		          return prevValue.slice(prefixLength);
		        }

		        // No issue, strip prefix for new value
		        return value.slice(prefixLength);
		    },

		    getFirstDiffIndex: function (prev, current) {
		        var index = 0;

		        while (prev.charAt(index) === current.charAt(index)) {
		            if (prev.charAt(index++) === '') {
		                return -1;
		            }
		        }

		        return index;
		    },

		    getFormattedValue: function (value, blocks, blocksLength, delimiter, delimiters, delimiterLazyShow) {
		        var result = '',
		            multipleDelimiters = delimiters.length > 0,
		            currentDelimiter;

		        // no options, normal input
		        if (blocksLength === 0) {
		            return value;
		        }

		        blocks.forEach(function (length, index) {
		            if (value.length > 0) {
		                var sub = value.slice(0, length),
		                    rest = value.slice(length);

		                if (multipleDelimiters) {
		                    currentDelimiter = delimiters[delimiterLazyShow ? (index - 1) : index] || currentDelimiter;
		                } else {
		                    currentDelimiter = delimiter;
		                }

		                if (delimiterLazyShow) {
		                    if (index > 0) {
		                        result += currentDelimiter;
		                    }

		                    result += sub;
		                } else {
		                    result += sub;

		                    if (sub.length === length && index < blocksLength - 1) {
		                        result += currentDelimiter;
		                    }
		                }

		                // update remaining string
		                value = rest;
		            }
		        });

		        return result;
		    },

		    // move cursor to the end
		    // the first time user focuses on an input with prefix
		    fixPrefixCursor: function (el, prefix, delimiter, delimiters) {
		        if (!el) {
		            return;
		        }

		        var val = el.value,
		            appendix = delimiter || (delimiters[0] || ' ');

		        if (!el.setSelectionRange || !prefix || (prefix.length + appendix.length) < val.length) {
		            return;
		        }

		        var len = val.length * 2;

		        // set timeout to avoid blink
		        setTimeout(function () {
		            el.setSelectionRange(len, len);
		        }, 1);
		    },

		    // Check if input field is fully selected
		    checkFullSelection: function(value) {
		      try {
		        var selection = window.getSelection() || document.getSelection() || {};
		        return selection.toString().length === value.length;
		      } catch (ex) {
		        // Ignore
		      }

		      return false;
		    },

		    setSelection: function (element, position, doc) {
		        if (element !== this.getActiveElement(doc)) {
		            return;
		        }

		        // cursor is already in the end
		        if (element && element.value.length <= position) {
		          return;
		        }

		        if (element.createTextRange) {
		            var range = element.createTextRange();

		            range.move('character', position);
		            range.select();
		        } else {
		            try {
		                element.setSelectionRange(position, position);
		            } catch (e) {
		                // eslint-disable-next-line
		                console.warn('The input element type does not support selection');
		            }
		        }
		    },

		    getActiveElement: function(parent) {
		        var activeElement = parent.activeElement;
		        if (activeElement && activeElement.shadowRoot) {
		            return this.getActiveElement(activeElement.shadowRoot);
		        }
		        return activeElement;
		    },

		    isAndroid: function () {
		        return navigator && /android/i.test(navigator.userAgent);
		    },

		    // On Android chrome, the keyup and keydown events
		    // always return key code 229 as a composition that
		    // buffers the user’s keystrokes
		    // see https://github.com/nosir/cleave.js/issues/147
		    isAndroidBackspaceKeydown: function (lastInputValue, currentInputValue) {
		        if (!this.isAndroid() || !lastInputValue || !currentInputValue) {
		            return false;
		        }

		        return currentInputValue === lastInputValue.slice(0, -1);
		    }
		};

		module.exports = Util;


	/***/ }),
	/* 7 */
	/***/ (function(module, exports) {

		/* WEBPACK VAR INJECTION */(function(global) {'use strict';

		/**
		 * Props Assignment
		 *
		 * Separate this, so react module can share the usage
		 */
		var DefaultProperties = {
		    // Maybe change to object-assign
		    // for now just keep it as simple
		    assign: function (target, opts) {
		        target = target || {};
		        opts = opts || {};

		        // credit card
		        target.creditCard = !!opts.creditCard;
		        target.creditCardStrictMode = !!opts.creditCardStrictMode;
		        target.creditCardType = '';
		        target.onCreditCardTypeChanged = opts.onCreditCardTypeChanged || (function () {});

		        // phone
		        target.phone = !!opts.phone;
		        target.phoneRegionCode = opts.phoneRegionCode || 'AU';
		        target.phoneFormatter = {};

		        // time
		        target.time = !!opts.time;
		        target.timePattern = opts.timePattern || ['h', 'm', 's'];
		        target.timeFormat = opts.timeFormat || '24';
		        target.timeFormatter = {};

		        // date
		        target.date = !!opts.date;
		        target.datePattern = opts.datePattern || ['d', 'm', 'Y'];
		        target.dateMin = opts.dateMin || '';
		        target.dateMax = opts.dateMax || '';
		        target.dateFormatter = {};

		        // numeral
		        target.numeral = !!opts.numeral;
		        target.numeralIntegerScale = opts.numeralIntegerScale > 0 ? opts.numeralIntegerScale : 0;
		        target.numeralDecimalScale = opts.numeralDecimalScale >= 0 ? opts.numeralDecimalScale : 2;
		        target.numeralDecimalMark = opts.numeralDecimalMark || '.';
		        target.numeralThousandsGroupStyle = opts.numeralThousandsGroupStyle || 'thousand';
		        target.numeralPositiveOnly = !!opts.numeralPositiveOnly;
		        target.stripLeadingZeroes = opts.stripLeadingZeroes !== false;
		        target.signBeforePrefix = !!opts.signBeforePrefix;

		        // others
		        target.numericOnly = target.creditCard || target.date || !!opts.numericOnly;

		        target.uppercase = !!opts.uppercase;
		        target.lowercase = !!opts.lowercase;

		        target.prefix = (target.creditCard || target.date) ? '' : (opts.prefix || '');
		        target.noImmediatePrefix = !!opts.noImmediatePrefix;
		        target.prefixLength = target.prefix.length;
		        target.rawValueTrimPrefix = !!opts.rawValueTrimPrefix;
		        target.copyDelimiter = !!opts.copyDelimiter;

		        target.initValue = (opts.initValue !== undefined && opts.initValue !== null) ? opts.initValue.toString() : '';

		        target.delimiter =
		            (opts.delimiter || opts.delimiter === '') ? opts.delimiter :
		                (opts.date ? '/' :
		                    (opts.time ? ':' :
		                        (opts.numeral ? ',' :
		                            (opts.phone ? ' ' :
		                                ' '))));
		        target.delimiterLength = target.delimiter.length;
		        target.delimiterLazyShow = !!opts.delimiterLazyShow;
		        target.delimiters = opts.delimiters || [];

		        target.blocks = opts.blocks || [];
		        target.blocksLength = target.blocks.length;

		        target.root = (typeof global === 'object' && global) ? global : window;
		        target.document = opts.document || target.root.document;

		        target.maxLength = 0;

		        target.backspace = false;
		        target.result = '';

		        target.onValueChanged = opts.onValueChanged || (function () {});

		        return target;
		    }
		};

		module.exports = DefaultProperties;

		/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

	/***/ })
	/******/ ])
	});
	;

/***/ }),
/* 59 */
/***/ (function(module, exports) {

	
	/* automatically adjust font size when targetElement exceeds widthLimit */
	/* Requirement:
	    widthLimit can be a positive number or a function. When in oneLineMode, widthLimit can be negative,
	        in this case, the width of targetElement will be computed dynamically as width limit.

	    if oneLineMode is set to false, target element's width sould automatically cover its content
	        for example: add "width: fit-content;" to targetElement. the measure of text length will be based on
	        target element's length.

	    if oneLineMode is true (default), the width of text content of target elements will be computed,
	        as single line text. font size adjustment will base on that.
	    */
	function textAdjustSize(targetElement, widthLimit, minFontSize, oneLineMode) {
	    minFontSize = minFontSize || 5;
	    if (oneLineMode == undefined) oneLineMode = true;

	    // get text width assuming that text content is in one single line
	    function getOneLineTextWidth(text, font) {
	        var f = font || '12px arial',
	            o = $('<div>' + text + '</div>')
	            .css({ 'position': 'absolute', 'float': 'left', 'white-space': 'nowrap', 'visibility': 'hidden', 'font': f })
	            .appendTo($('body')),
	            w = o.width();
	        o.remove();
	        return w;
	    }
	    targetElement.each(function(ind, element) {
	        // different way to get text content
	        var content = ($(element).is('input')) ?
	            $(element).val() : $(element).html();

	        var currentWidth = (oneLineMode) ?
	            function(size) {
	                return getOneLineTextWidth(content, $(element).css('font') || size + ' ' + $(element).css('fontFamily'));
	            } :
	            function() {
	                return $(element).width();
	            };

	        var widthLimitFunc;
	        if (widthLimit < 0) {
	            if (oneLineMode) {
	                widthLimitFunc = function() {
	                    return $(element).width();
	                };
	            } else {
	                console.error('widthLimit should be negative only in oneLineMode');
	                return -1;
	            }
	        } else if (typeof widthLimit === "function") {
	            widthLimitFunc = widthLimit;
	        } else {
	            widthLimitFunc = function() {
	                return widthLimit
	            };
	        }
	        // reset to default font size
	        $(element).css("fontSize", "");
	        // get default font size
	        var size = parseInt($(element).css('fontSize')); // get default font size
	        // start adjust font size until width matches requirement
	        while (currentWidth(size + 'px') > widthLimitFunc()) {

	            size--;
	            if (size < minFontSize) return;
	            $(element).css("fontSize", size + 'px');
	        }
	    })
	};

	window.textAdjustSize = textAdjustSize;

/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*! nouislider - 14.0.3 - 10/10/2019 */
	(function(factory) {
	    if (true) {
	        // AMD. Register as an anonymous module.
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    } else if (typeof exports === "object") {
	        // Node/CommonJS
	        module.exports = factory();
	    } else {
	        // Browser globals
	        window.noUiSlider = factory();
	    }
	})(function() {
	    "use strict";

	    var VERSION = "14.0.3";

	    //region Helper Methods

	    function isValidFormatter(entry) {
	        return typeof entry === "object" && typeof entry.to === "function" && typeof entry.from === "function";
	    }

	    function removeElement(el) {
	        el.parentElement.removeChild(el);
	    }

	    function isSet(value) {
	        return value !== null && value !== undefined;
	    }

	    // Bindable version
	    function preventDefault(e) {
	        e.preventDefault();
	    }

	    // Removes duplicates from an array.
	    function unique(array) {
	        return array.filter(function(a) {
	            return !this[a] ? (this[a] = true) : false;
	        }, {});
	    }

	    // Round a value to the closest 'to'.
	    function closest(value, to) {
	        return Math.round(value / to) * to;
	    }

	    // Current position of an element relative to the document.
	    function offset(elem, orientation) {
	        var rect = elem.getBoundingClientRect();
	        var doc = elem.ownerDocument;
	        var docElem = doc.documentElement;
	        var pageOffset = getPageOffset(doc);

	        // getBoundingClientRect contains left scroll in Chrome on Android.
	        // I haven't found a feature detection that proves this. Worst case
	        // scenario on mis-match: the 'tap' feature on horizontal sliders breaks.
	        if (/webkit.*Chrome.*Mobile/i.test(navigator.userAgent)) {
	            pageOffset.x = 0;
	        }

	        return orientation
	            ? rect.top + pageOffset.y - docElem.clientTop
	            : rect.left + pageOffset.x - docElem.clientLeft;
	    }

	    // Checks whether a value is numerical.
	    function isNumeric(a) {
	        return typeof a === "number" && !isNaN(a) && isFinite(a);
	    }

	    // Sets a class and removes it after [duration] ms.
	    function addClassFor(element, className, duration) {
	        if (duration > 0) {
	            addClass(element, className);
	            setTimeout(function() {
	                removeClass(element, className);
	            }, duration);
	        }
	    }

	    // Limits a value to 0 - 100
	    function limit(a) {
	        return Math.max(Math.min(a, 100), 0);
	    }

	    // Wraps a variable as an array, if it isn't one yet.
	    // Note that an input array is returned by reference!
	    function asArray(a) {
	        return Array.isArray(a) ? a : [a];
	    }

	    // Counts decimals
	    function countDecimals(numStr) {
	        numStr = String(numStr);
	        var pieces = numStr.split(".");
	        return pieces.length > 1 ? pieces[1].length : 0;
	    }

	    // http://youmightnotneedjquery.com/#add_class
	    function addClass(el, className) {
	        if (el.classList) {
	            el.classList.add(className);
	        } else {
	            el.className += " " + className;
	        }
	    }

	    // http://youmightnotneedjquery.com/#remove_class
	    function removeClass(el, className) {
	        if (el.classList) {
	            el.classList.remove(className);
	        } else {
	            el.className = el.className.replace(
	                new RegExp("(^|\\b)" + className.split(" ").join("|") + "(\\b|$)", "gi"),
	                " "
	            );
	        }
	    }

	    // https://plainjs.com/javascript/attributes/adding-removing-and-testing-for-classes-9/
	    function hasClass(el, className) {
	        return el.classList
	            ? el.classList.contains(className)
	            : new RegExp("\\b" + className + "\\b").test(el.className);
	    }

	    // https://developer.mozilla.org/en-US/docs/Web/API/Window/scrollY#Notes
	    function getPageOffset(doc) {
	        var supportPageOffset = window.pageXOffset !== undefined;
	        var isCSS1Compat = (doc.compatMode || "") === "CSS1Compat";
	        var x = supportPageOffset
	            ? window.pageXOffset
	            : isCSS1Compat
	                ? doc.documentElement.scrollLeft
	                : doc.body.scrollLeft;
	        var y = supportPageOffset
	            ? window.pageYOffset
	            : isCSS1Compat
	                ? doc.documentElement.scrollTop
	                : doc.body.scrollTop;

	        return {
	            x: x,
	            y: y
	        };
	    }

	    // we provide a function to compute constants instead
	    // of accessing window.* as soon as the module needs it
	    // so that we do not compute anything if not needed
	    function getActions() {
	        // Determine the events to bind. IE11 implements pointerEvents without
	        // a prefix, which breaks compatibility with the IE10 implementation.
	        return window.navigator.pointerEnabled
	            ? {
	                  start: "pointerdown",
	                  move: "pointermove",
	                  end: "pointerup"
	              }
	            : window.navigator.msPointerEnabled
	                ? {
	                      start: "MSPointerDown",
	                      move: "MSPointerMove",
	                      end: "MSPointerUp"
	                  }
	                : {
	                      start: "mousedown touchstart",
	                      move: "mousemove touchmove",
	                      end: "mouseup touchend"
	                  };
	    }

	    // https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md
	    // Issue #785
	    function getSupportsPassive() {
	        var supportsPassive = false;

	        /* eslint-disable */
	        try {
	            var opts = Object.defineProperty({}, "passive", {
	                get: function() {
	                    supportsPassive = true;
	                }
	            });

	            window.addEventListener("test", null, opts);
	        } catch (e) {}
	        /* eslint-enable */

	        return supportsPassive;
	    }

	    function getSupportsTouchActionNone() {
	        return window.CSS && CSS.supports && CSS.supports("touch-action", "none");
	    }

	    //endregion

	    //region Range Calculation

	    // Determine the size of a sub-range in relation to a full range.
	    function subRangeRatio(pa, pb) {
	        return 100 / (pb - pa);
	    }

	    // (percentage) How many percent is this value of this range?
	    function fromPercentage(range, value) {
	        return (value * 100) / (range[1] - range[0]);
	    }

	    // (percentage) Where is this value on this range?
	    function toPercentage(range, value) {
	        return fromPercentage(range, range[0] < 0 ? value + Math.abs(range[0]) : value - range[0]);
	    }

	    // (value) How much is this percentage on this range?
	    function isPercentage(range, value) {
	        return (value * (range[1] - range[0])) / 100 + range[0];
	    }

	    function getJ(value, arr) {
	        var j = 1;

	        while (value >= arr[j]) {
	            j += 1;
	        }

	        return j;
	    }

	    // (percentage) Input a value, find where, on a scale of 0-100, it applies.
	    function toStepping(xVal, xPct, value) {
	        if (value >= xVal.slice(-1)[0]) {
	            return 100;
	        }

	        var j = getJ(value, xVal);
	        var va = xVal[j - 1];
	        var vb = xVal[j];
	        var pa = xPct[j - 1];
	        var pb = xPct[j];

	        return pa + toPercentage([va, vb], value) / subRangeRatio(pa, pb);
	    }

	    // (value) Input a percentage, find where it is on the specified range.
	    function fromStepping(xVal, xPct, value) {
	        // There is no range group that fits 100
	        if (value >= 100) {
	            return xVal.slice(-1)[0];
	        }

	        var j = getJ(value, xPct);
	        var va = xVal[j - 1];
	        var vb = xVal[j];
	        var pa = xPct[j - 1];
	        var pb = xPct[j];

	        return isPercentage([va, vb], (value - pa) * subRangeRatio(pa, pb));
	    }

	    // (percentage) Get the step that applies at a certain value.
	    function getStep(xPct, xSteps, snap, value) {
	        if (value === 100) {
	            return value;
	        }

	        var j = getJ(value, xPct);
	        var a = xPct[j - 1];
	        var b = xPct[j];

	        // If 'snap' is set, steps are used as fixed points on the slider.
	        if (snap) {
	            // Find the closest position, a or b.
	            if (value - a > (b - a) / 2) {
	                return b;
	            }

	            return a;
	        }

	        if (!xSteps[j - 1]) {
	            return value;
	        }

	        return xPct[j - 1] + closest(value - xPct[j - 1], xSteps[j - 1]);
	    }

	    function handleEntryPoint(index, value, that) {
	        var percentage;

	        // Wrap numerical input in an array.
	        if (typeof value === "number") {
	            value = [value];
	        }

	        // Reject any invalid input, by testing whether value is an array.
	        if (!Array.isArray(value)) {
	            throw new Error("noUiSlider (" + VERSION + "): 'range' contains invalid value.");
	        }

	        // Covert min/max syntax to 0 and 100.
	        if (index === "min") {
	            percentage = 0;
	        } else if (index === "max") {
	            percentage = 100;
	        } else {
	            percentage = parseFloat(index);
	        }

	        // Check for correct input.
	        if (!isNumeric(percentage) || !isNumeric(value[0])) {
	            throw new Error("noUiSlider (" + VERSION + "): 'range' value isn't numeric.");
	        }

	        // Store values.
	        that.xPct.push(percentage);
	        that.xVal.push(value[0]);

	        // NaN will evaluate to false too, but to keep
	        // logging clear, set step explicitly. Make sure
	        // not to override the 'step' setting with false.
	        if (!percentage) {
	            if (!isNaN(value[1])) {
	                that.xSteps[0] = value[1];
	            }
	        } else {
	            that.xSteps.push(isNaN(value[1]) ? false : value[1]);
	        }

	        that.xHighestCompleteStep.push(0);
	    }

	    function handleStepPoint(i, n, that) {
	        // Ignore 'false' stepping.
	        if (!n) {
	            return;
	        }

	        // Step over zero-length ranges (#948);
	        if (that.xVal[i] === that.xVal[i + 1]) {
	            that.xSteps[i] = that.xHighestCompleteStep[i] = that.xVal[i];

	            return;
	        }

	        // Factor to range ratio
	        that.xSteps[i] =
	            fromPercentage([that.xVal[i], that.xVal[i + 1]], n) / subRangeRatio(that.xPct[i], that.xPct[i + 1]);

	        var totalSteps = (that.xVal[i + 1] - that.xVal[i]) / that.xNumSteps[i];
	        var highestStep = Math.ceil(Number(totalSteps.toFixed(3)) - 1);
	        var step = that.xVal[i] + that.xNumSteps[i] * highestStep;

	        that.xHighestCompleteStep[i] = step;
	    }

	    //endregion

	    //region Spectrum

	    function Spectrum(entry, snap, singleStep) {
	        this.xPct = [];
	        this.xVal = [];
	        this.xSteps = [singleStep || false];
	        this.xNumSteps = [false];
	        this.xHighestCompleteStep = [];

	        this.snap = snap;

	        var index;
	        var ordered = []; // [0, 'min'], [1, '50%'], [2, 'max']

	        // Map the object keys to an array.
	        for (index in entry) {
	            if (entry.hasOwnProperty(index)) {
	                ordered.push([entry[index], index]);
	            }
	        }

	        // Sort all entries by value (numeric sort).
	        if (ordered.length && typeof ordered[0][0] === "object") {
	            ordered.sort(function(a, b) {
	                return a[0][0] - b[0][0];
	            });
	        } else {
	            ordered.sort(function(a, b) {
	                return a[0] - b[0];
	            });
	        }

	        // Convert all entries to subranges.
	        for (index = 0; index < ordered.length; index++) {
	            handleEntryPoint(ordered[index][1], ordered[index][0], this);
	        }

	        // Store the actual step values.
	        // xSteps is sorted in the same order as xPct and xVal.
	        this.xNumSteps = this.xSteps.slice(0);

	        // Convert all numeric steps to the percentage of the subrange they represent.
	        for (index = 0; index < this.xNumSteps.length; index++) {
	            handleStepPoint(index, this.xNumSteps[index], this);
	        }
	    }

	    Spectrum.prototype.getMargin = function(value) {
	        var step = this.xNumSteps[0];

	        if (step && (value / step) % 1 !== 0) {
	            throw new Error("noUiSlider (" + VERSION + "): 'limit', 'margin' and 'padding' must be divisible by step.");
	        }

	        return this.xPct.length === 2 ? fromPercentage(this.xVal, value) : false;
	    };

	    Spectrum.prototype.toStepping = function(value) {
	        value = toStepping(this.xVal, this.xPct, value);

	        return value;
	    };

	    Spectrum.prototype.fromStepping = function(value) {
	        return fromStepping(this.xVal, this.xPct, value);
	    };

	    Spectrum.prototype.getStep = function(value) {
	        value = getStep(this.xPct, this.xSteps, this.snap, value);

	        return value;
	    };

	    Spectrum.prototype.getDefaultStep = function(value, isDown, size) {
	        var j = getJ(value, this.xPct);

	        // When at the top or stepping down, look at the previous sub-range
	        if (value === 100 || (isDown && value === this.xPct[j - 1])) {
	            j = Math.max(j - 1, 1);
	        }

	        return (this.xVal[j] - this.xVal[j - 1]) / size;
	    };

	    Spectrum.prototype.getNearbySteps = function(value) {
	        var j = getJ(value, this.xPct);

	        return {
	            stepBefore: {
	                startValue: this.xVal[j - 2],
	                step: this.xNumSteps[j - 2],
	                highestStep: this.xHighestCompleteStep[j - 2]
	            },
	            thisStep: {
	                startValue: this.xVal[j - 1],
	                step: this.xNumSteps[j - 1],
	                highestStep: this.xHighestCompleteStep[j - 1]
	            },
	            stepAfter: {
	                startValue: this.xVal[j],
	                step: this.xNumSteps[j],
	                highestStep: this.xHighestCompleteStep[j]
	            }
	        };
	    };

	    Spectrum.prototype.countStepDecimals = function() {
	        var stepDecimals = this.xNumSteps.map(countDecimals);
	        return Math.max.apply(null, stepDecimals);
	    };

	    // Outside testing
	    Spectrum.prototype.convert = function(value) {
	        return this.getStep(this.toStepping(value));
	    };

	    //endregion

	    //region Options

	    /*	Every input option is tested and parsed. This'll prevent
	        endless validation in internal methods. These tests are
	        structured with an item for every option available. An
	        option can be marked as required by setting the 'r' flag.
	        The testing function is provided with three arguments:
	            - The provided value for the option;
	            - A reference to the options object;
	            - The name for the option;

	        The testing function returns false when an error is detected,
	        or true when everything is OK. It can also modify the option
	        object, to make sure all values can be correctly looped elsewhere. */

	    var defaultFormatter = {
	        to: function(value) {
	            return value !== undefined && value.toFixed(2);
	        },
	        from: Number
	    };

	    function validateFormat(entry) {
	        // Any object with a to and from method is supported.
	        if (isValidFormatter(entry)) {
	            return true;
	        }

	        throw new Error("noUiSlider (" + VERSION + "): 'format' requires 'to' and 'from' methods.");
	    }

	    function testStep(parsed, entry) {
	        if (!isNumeric(entry)) {
	            throw new Error("noUiSlider (" + VERSION + "): 'step' is not numeric.");
	        }

	        // The step option can still be used to set stepping
	        // for linear sliders. Overwritten if set in 'range'.
	        parsed.singleStep = entry;
	    }

	    function testRange(parsed, entry) {
	        // Filter incorrect input.
	        if (typeof entry !== "object" || Array.isArray(entry)) {
	            throw new Error("noUiSlider (" + VERSION + "): 'range' is not an object.");
	        }

	        // Catch missing start or end.
	        if (entry.min === undefined || entry.max === undefined) {
	            throw new Error("noUiSlider (" + VERSION + "): Missing 'min' or 'max' in 'range'.");
	        }

	        // Catch equal start or end.
	        if (entry.min === entry.max) {
	            throw new Error("noUiSlider (" + VERSION + "): 'range' 'min' and 'max' cannot be equal.");
	        }

	        parsed.spectrum = new Spectrum(entry, parsed.snap, parsed.singleStep);
	    }

	    function testStart(parsed, entry) {
	        entry = asArray(entry);

	        // Validate input. Values aren't tested, as the public .val method
	        // will always provide a valid location.
	        if (!Array.isArray(entry) || !entry.length) {
	            throw new Error("noUiSlider (" + VERSION + "): 'start' option is incorrect.");
	        }

	        // Store the number of handles.
	        parsed.handles = entry.length;

	        // When the slider is initialized, the .val method will
	        // be called with the start options.
	        parsed.start = entry;
	    }

	    function testSnap(parsed, entry) {
	        // Enforce 100% stepping within subranges.
	        parsed.snap = entry;

	        if (typeof entry !== "boolean") {
	            throw new Error("noUiSlider (" + VERSION + "): 'snap' option must be a boolean.");
	        }
	    }

	    function testAnimate(parsed, entry) {
	        // Enforce 100% stepping within subranges.
	        parsed.animate = entry;

	        if (typeof entry !== "boolean") {
	            throw new Error("noUiSlider (" + VERSION + "): 'animate' option must be a boolean.");
	        }
	    }

	    function testAnimationDuration(parsed, entry) {
	        parsed.animationDuration = entry;

	        if (typeof entry !== "number") {
	            throw new Error("noUiSlider (" + VERSION + "): 'animationDuration' option must be a number.");
	        }
	    }

	    function testConnect(parsed, entry) {
	        var connect = [false];
	        var i;

	        // Map legacy options
	        if (entry === "lower") {
	            entry = [true, false];
	        } else if (entry === "upper") {
	            entry = [false, true];
	        }

	        // Handle boolean options
	        if (entry === true || entry === false) {
	            for (i = 1; i < parsed.handles; i++) {
	                connect.push(entry);
	            }

	            connect.push(false);
	        }

	        // Reject invalid input
	        else if (!Array.isArray(entry) || !entry.length || entry.length !== parsed.handles + 1) {
	            throw new Error("noUiSlider (" + VERSION + "): 'connect' option doesn't match handle count.");
	        } else {
	            connect = entry;
	        }

	        parsed.connect = connect;
	    }

	    function testOrientation(parsed, entry) {
	        // Set orientation to an a numerical value for easy
	        // array selection.
	        switch (entry) {
	            case "horizontal":
	                parsed.ort = 0;
	                break;
	            case "vertical":
	                parsed.ort = 1;
	                break;
	            default:
	                throw new Error("noUiSlider (" + VERSION + "): 'orientation' option is invalid.");
	        }
	    }

	    function testMargin(parsed, entry) {
	        if (!isNumeric(entry)) {
	            throw new Error("noUiSlider (" + VERSION + "): 'margin' option must be numeric.");
	        }

	        // Issue #582
	        if (entry === 0) {
	            return;
	        }

	        parsed.margin = parsed.spectrum.getMargin(entry);

	        if (!parsed.margin) {
	            throw new Error("noUiSlider (" + VERSION + "): 'margin' option is only supported on linear sliders.");
	        }
	    }

	    function testLimit(parsed, entry) {
	        if (!isNumeric(entry)) {
	            throw new Error("noUiSlider (" + VERSION + "): 'limit' option must be numeric.");
	        }

	        parsed.limit = parsed.spectrum.getMargin(entry);

	        if (!parsed.limit || parsed.handles < 2) {
	            throw new Error(
	                "noUiSlider (" +
	                    VERSION +
	                    "): 'limit' option is only supported on linear sliders with 2 or more handles."
	            );
	        }
	    }

	    function testPadding(parsed, entry) {
	        if (!isNumeric(entry) && !Array.isArray(entry)) {
	            throw new Error(
	                "noUiSlider (" + VERSION + "): 'padding' option must be numeric or array of exactly 2 numbers."
	            );
	        }

	        if (Array.isArray(entry) && !(entry.length === 2 || isNumeric(entry[0]) || isNumeric(entry[1]))) {
	            throw new Error(
	                "noUiSlider (" + VERSION + "): 'padding' option must be numeric or array of exactly 2 numbers."
	            );
	        }

	        if (entry === 0) {
	            return;
	        }

	        if (!Array.isArray(entry)) {
	            entry = [entry, entry];
	        }

	        // 'getMargin' returns false for invalid values.
	        parsed.padding = [parsed.spectrum.getMargin(entry[0]), parsed.spectrum.getMargin(entry[1])];

	        if (parsed.padding[0] === false || parsed.padding[1] === false) {
	            throw new Error("noUiSlider (" + VERSION + "): 'padding' option is only supported on linear sliders.");
	        }

	        if (parsed.padding[0] < 0 || parsed.padding[1] < 0) {
	            throw new Error("noUiSlider (" + VERSION + "): 'padding' option must be a positive number(s).");
	        }

	        if (parsed.padding[0] + parsed.padding[1] > 100) {
	            throw new Error("noUiSlider (" + VERSION + "): 'padding' option must not exceed 100% of the range.");
	        }
	    }

	    function testDirection(parsed, entry) {
	        // Set direction as a numerical value for easy parsing.
	        // Invert connection for RTL sliders, so that the proper
	        // handles get the connect/background classes.
	        switch (entry) {
	            case "ltr":
	                parsed.dir = 0;
	                break;
	            case "rtl":
	                parsed.dir = 1;
	                break;
	            default:
	                throw new Error("noUiSlider (" + VERSION + "): 'direction' option was not recognized.");
	        }
	    }

	    function testBehaviour(parsed, entry) {
	        // Make sure the input is a string.
	        if (typeof entry !== "string") {
	            throw new Error("noUiSlider (" + VERSION + "): 'behaviour' must be a string containing options.");
	        }

	        // Check if the string contains any keywords.
	        // None are required.
	        var tap = entry.indexOf("tap") >= 0;
	        var drag = entry.indexOf("drag") >= 0;
	        var fixed = entry.indexOf("fixed") >= 0;
	        var snap = entry.indexOf("snap") >= 0;
	        var hover = entry.indexOf("hover") >= 0;
	        var unconstrained = entry.indexOf("unconstrained") >= 0;

	        if (fixed) {
	            if (parsed.handles !== 2) {
	                throw new Error("noUiSlider (" + VERSION + "): 'fixed' behaviour must be used with 2 handles");
	            }

	            // Use margin to enforce fixed state
	            testMargin(parsed, parsed.start[1] - parsed.start[0]);
	        }

	        if (unconstrained && (parsed.margin || parsed.limit)) {
	            throw new Error(
	                "noUiSlider (" + VERSION + "): 'unconstrained' behaviour cannot be used with margin or limit"
	            );
	        }

	        parsed.events = {
	            tap: tap || snap,
	            drag: drag,
	            fixed: fixed,
	            snap: snap,
	            hover: hover,
	            unconstrained: unconstrained
	        };
	    }

	    function testTooltips(parsed, entry) {
	        if (entry === false) {
	            return;
	        }

	        if (entry === true) {
	            parsed.tooltips = [];

	            for (var i = 0; i < parsed.handles; i++) {
	                parsed.tooltips.push(true);
	            }
	        } else {
	            parsed.tooltips = asArray(entry);

	            if (parsed.tooltips.length !== parsed.handles) {
	                throw new Error("noUiSlider (" + VERSION + "): must pass a formatter for all handles.");
	            }

	            parsed.tooltips.forEach(function(formatter) {
	                if (
	                    typeof formatter !== "boolean" &&
	                    (typeof formatter !== "object" || typeof formatter.to !== "function")
	                ) {
	                    throw new Error("noUiSlider (" + VERSION + "): 'tooltips' must be passed a formatter or 'false'.");
	                }
	            });
	        }
	    }

	    function testAriaFormat(parsed, entry) {
	        parsed.ariaFormat = entry;
	        validateFormat(entry);
	    }

	    function testFormat(parsed, entry) {
	        parsed.format = entry;
	        validateFormat(entry);
	    }

	    function testKeyboardSupport(parsed, entry) {
	        parsed.keyboardSupport = entry;

	        if (typeof entry !== "boolean") {
	            throw new Error("noUiSlider (" + VERSION + "): 'keyboardSupport' option must be a boolean.");
	        }
	    }

	    function testDocumentElement(parsed, entry) {
	        // This is an advanced option. Passed values are used without validation.
	        parsed.documentElement = entry;
	    }

	    function testCssPrefix(parsed, entry) {
	        if (typeof entry !== "string" && entry !== false) {
	            throw new Error("noUiSlider (" + VERSION + "): 'cssPrefix' must be a string or `false`.");
	        }

	        parsed.cssPrefix = entry;
	    }

	    function testCssClasses(parsed, entry) {
	        if (typeof entry !== "object") {
	            throw new Error("noUiSlider (" + VERSION + "): 'cssClasses' must be an object.");
	        }

	        if (typeof parsed.cssPrefix === "string") {
	            parsed.cssClasses = {};

	            for (var key in entry) {
	                if (!entry.hasOwnProperty(key)) {
	                    continue;
	                }

	                parsed.cssClasses[key] = parsed.cssPrefix + entry[key];
	            }
	        } else {
	            parsed.cssClasses = entry;
	        }
	    }

	    // Test all developer settings and parse to assumption-safe values.
	    function testOptions(options) {
	        // To prove a fix for #537, freeze options here.
	        // If the object is modified, an error will be thrown.
	        // Object.freeze(options);

	        var parsed = {
	            margin: 0,
	            limit: 0,
	            padding: 0,
	            animate: true,
	            animationDuration: 300,
	            ariaFormat: defaultFormatter,
	            format: defaultFormatter
	        };

	        // Tests are executed in the order they are presented here.
	        var tests = {
	            step: { r: false, t: testStep },
	            start: { r: true, t: testStart },
	            connect: { r: true, t: testConnect },
	            direction: { r: true, t: testDirection },
	            snap: { r: false, t: testSnap },
	            animate: { r: false, t: testAnimate },
	            animationDuration: { r: false, t: testAnimationDuration },
	            range: { r: true, t: testRange },
	            orientation: { r: false, t: testOrientation },
	            margin: { r: false, t: testMargin },
	            limit: { r: false, t: testLimit },
	            padding: { r: false, t: testPadding },
	            behaviour: { r: true, t: testBehaviour },
	            ariaFormat: { r: false, t: testAriaFormat },
	            format: { r: false, t: testFormat },
	            tooltips: { r: false, t: testTooltips },
	            keyboardSupport: { r: true, t: testKeyboardSupport },
	            documentElement: { r: false, t: testDocumentElement },
	            cssPrefix: { r: true, t: testCssPrefix },
	            cssClasses: { r: true, t: testCssClasses }
	        };

	        var defaults = {
	            connect: false,
	            direction: "ltr",
	            behaviour: "tap",
	            orientation: "horizontal",
	            keyboardSupport: true,
	            cssPrefix: "noUi-",
	            cssClasses: {
	                target: "target",
	                base: "base",
	                origin: "origin",
	                handle: "handle",
	                handleLower: "handle-lower",
	                handleUpper: "handle-upper",
	                touchArea: "touch-area",
	                horizontal: "horizontal",
	                vertical: "vertical",
	                background: "background",
	                connect: "connect",
	                connects: "connects",
	                ltr: "ltr",
	                rtl: "rtl",
	                draggable: "draggable",
	                drag: "state-drag",
	                tap: "state-tap",
	                active: "active",
	                tooltip: "tooltip",
	                pips: "pips",
	                pipsHorizontal: "pips-horizontal",
	                pipsVertical: "pips-vertical",
	                marker: "marker",
	                markerHorizontal: "marker-horizontal",
	                markerVertical: "marker-vertical",
	                markerNormal: "marker-normal",
	                markerLarge: "marker-large",
	                markerSub: "marker-sub",
	                value: "value",
	                valueHorizontal: "value-horizontal",
	                valueVertical: "value-vertical",
	                valueNormal: "value-normal",
	                valueLarge: "value-large",
	                valueSub: "value-sub"
	            }
	        };

	        // AriaFormat defaults to regular format, if any.
	        if (options.format && !options.ariaFormat) {
	            options.ariaFormat = options.format;
	        }

	        // Run all options through a testing mechanism to ensure correct
	        // input. It should be noted that options might get modified to
	        // be handled properly. E.g. wrapping integers in arrays.
	        Object.keys(tests).forEach(function(name) {
	            // If the option isn't set, but it is required, throw an error.
	            if (!isSet(options[name]) && defaults[name] === undefined) {
	                if (tests[name].r) {
	                    throw new Error("noUiSlider (" + VERSION + "): '" + name + "' is required.");
	                }

	                return true;
	            }

	            tests[name].t(parsed, !isSet(options[name]) ? defaults[name] : options[name]);
	        });

	        // Forward pips options
	        parsed.pips = options.pips;

	        // All recent browsers accept unprefixed transform.
	        // We need -ms- for IE9 and -webkit- for older Android;
	        // Assume use of -webkit- if unprefixed and -ms- are not supported.
	        // https://caniuse.com/#feat=transforms2d
	        var d = document.createElement("div");
	        var msPrefix = d.style.msTransform !== undefined;
	        var noPrefix = d.style.transform !== undefined;

	        parsed.transformRule = noPrefix ? "transform" : msPrefix ? "msTransform" : "webkitTransform";

	        // Pips don't move, so we can place them using left/top.
	        var styles = [["left", "top"], ["right", "bottom"]];

	        parsed.style = styles[parsed.dir][parsed.ort];

	        return parsed;
	    }

	    //endregion

	    function scope(target, options, originalOptions) {
	        var actions = getActions();
	        var supportsTouchActionNone = getSupportsTouchActionNone();
	        var supportsPassive = supportsTouchActionNone && getSupportsPassive();

	        // All variables local to 'scope' are prefixed with 'scope_'

	        // Slider DOM Nodes
	        var scope_Target = target;
	        var scope_Base;
	        var scope_Handles;
	        var scope_Connects;
	        var scope_Pips;
	        var scope_Tooltips;

	        // Slider state values
	        var scope_Spectrum = options.spectrum;
	        var scope_Values = [];
	        var scope_Locations = [];
	        var scope_HandleNumbers = [];
	        var scope_ActiveHandlesCount = 0;
	        var scope_Events = {};

	        // Exposed API
	        var scope_Self;

	        // Document Nodes
	        var scope_Document = target.ownerDocument;
	        var scope_DocumentElement = options.documentElement || scope_Document.documentElement;
	        var scope_Body = scope_Document.body;

	        // Pips constants
	        var PIPS_NONE = -1;
	        var PIPS_NO_VALUE = 0;
	        var PIPS_LARGE_VALUE = 1;
	        var PIPS_SMALL_VALUE = 2;

	        // For horizontal sliders in standard ltr documents,
	        // make .noUi-origin overflow to the left so the document doesn't scroll.
	        var scope_DirOffset = scope_Document.dir === "rtl" || options.ort === 1 ? 0 : 100;

	        // Creates a node, adds it to target, returns the new node.
	        function addNodeTo(addTarget, className) {
	            var div = scope_Document.createElement("div");

	            if (className) {
	                addClass(div, className);
	            }

	            addTarget.appendChild(div);

	            return div;
	        }

	        // Append a origin to the base
	        function addOrigin(base, handleNumber) {
	            var origin = addNodeTo(base, options.cssClasses.origin);
	            var handle = addNodeTo(origin, options.cssClasses.handle);

	            addNodeTo(handle, options.cssClasses.touchArea);

	            handle.setAttribute("data-handle", handleNumber);

	            if (options.keyboardSupport) {
	                // https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex
	                // 0 = focusable and reachable
	                handle.setAttribute("tabindex", "0");
	                handle.addEventListener("keydown", function(event) {
	                    return eventKeydown(event, handleNumber);
	                });
	            }

	            handle.setAttribute("role", "slider");
	            handle.setAttribute("aria-orientation", options.ort ? "vertical" : "horizontal");

	            if (handleNumber === 0) {
	                addClass(handle, options.cssClasses.handleLower);
	            } else if (handleNumber === options.handles - 1) {
	                addClass(handle, options.cssClasses.handleUpper);
	            }

	            return origin;
	        }

	        // Insert nodes for connect elements
	        function addConnect(base, add) {
	            if (!add) {
	                return false;
	            }

	            return addNodeTo(base, options.cssClasses.connect);
	        }

	        // Add handles to the slider base.
	        function addElements(connectOptions, base) {
	            var connectBase = addNodeTo(base, options.cssClasses.connects);

	            scope_Handles = [];
	            scope_Connects = [];

	            scope_Connects.push(addConnect(connectBase, connectOptions[0]));

	            // [::::O====O====O====]
	            // connectOptions = [0, 1, 1, 1]

	            for (var i = 0; i < options.handles; i++) {
	                // Keep a list of all added handles.
	                scope_Handles.push(addOrigin(base, i));
	                scope_HandleNumbers[i] = i;
	                scope_Connects.push(addConnect(connectBase, connectOptions[i + 1]));
	            }
	        }

	        // Initialize a single slider.
	        function addSlider(addTarget) {
	            // Apply classes and data to the target.
	            addClass(addTarget, options.cssClasses.target);

	            if (options.dir === 0) {
	                addClass(addTarget, options.cssClasses.ltr);
	            } else {
	                addClass(addTarget, options.cssClasses.rtl);
	            }

	            if (options.ort === 0) {
	                addClass(addTarget, options.cssClasses.horizontal);
	            } else {
	                addClass(addTarget, options.cssClasses.vertical);
	            }

	            return addNodeTo(addTarget, options.cssClasses.base);
	        }

	        function addTooltip(handle, handleNumber) {
	            if (!options.tooltips[handleNumber]) {
	                return false;
	            }

	            return addNodeTo(handle.firstChild, options.cssClasses.tooltip);
	        }

	        function isSliderDisabled() {
	            return scope_Target.hasAttribute("disabled");
	        }

	        // Disable the slider dragging if any handle is disabled
	        function isHandleDisabled(handleNumber) {
	            var handleOrigin = scope_Handles[handleNumber];
	            return handleOrigin.hasAttribute("disabled");
	        }

	        function removeTooltips() {
	            if (scope_Tooltips) {
	                removeEvent("update.tooltips");
	                scope_Tooltips.forEach(function(tooltip) {
	                    if (tooltip) {
	                        removeElement(tooltip);
	                    }
	                });
	                scope_Tooltips = null;
	            }
	        }

	        // The tooltips option is a shorthand for using the 'update' event.
	        function tooltips() {
	            removeTooltips();

	            // Tooltips are added with options.tooltips in original order.
	            scope_Tooltips = scope_Handles.map(addTooltip);

	            bindEvent("update.tooltips", function(values, handleNumber, unencoded) {
	                if (!scope_Tooltips[handleNumber]) {
	                    return;
	                }

	                var formattedValue = values[handleNumber];

	                if (options.tooltips[handleNumber] !== true) {
	                    formattedValue = options.tooltips[handleNumber].to(unencoded[handleNumber]);
	                }

	                scope_Tooltips[handleNumber].innerHTML = formattedValue;
	            });
	        }

	        function aria() {
	            bindEvent("update", function(values, handleNumber, unencoded, tap, positions) {
	                // Update Aria Values for all handles, as a change in one changes min and max values for the next.
	                scope_HandleNumbers.forEach(function(index) {
	                    var handle = scope_Handles[index];

	                    var min = checkHandlePosition(scope_Locations, index, 0, true, true, true);
	                    var max = checkHandlePosition(scope_Locations, index, 100, true, true, true);

	                    var now = positions[index];

	                    // Formatted value for display
	                    var text = options.ariaFormat.to(unencoded[index]);

	                    // Map to slider range values
	                    min = scope_Spectrum.fromStepping(min).toFixed(1);
	                    max = scope_Spectrum.fromStepping(max).toFixed(1);
	                    now = scope_Spectrum.fromStepping(now).toFixed(1);

	                    handle.children[0].setAttribute("aria-valuemin", min);
	                    handle.children[0].setAttribute("aria-valuemax", max);
	                    handle.children[0].setAttribute("aria-valuenow", now);
	                    handle.children[0].setAttribute("aria-valuetext", text);
	                });
	            });
	        }

	        function getGroup(mode, values, stepped) {
	            // Use the range.
	            if (mode === "range" || mode === "steps") {
	                return scope_Spectrum.xVal;
	            }

	            if (mode === "count") {
	                if (values < 2) {
	                    throw new Error("noUiSlider (" + VERSION + "): 'values' (>= 2) required for mode 'count'.");
	                }

	                // Divide 0 - 100 in 'count' parts.
	                var interval = values - 1;
	                var spread = 100 / interval;

	                values = [];

	                // List these parts and have them handled as 'positions'.
	                while (interval--) {
	                    values[interval] = interval * spread;
	                }

	                values.push(100);

	                mode = "positions";
	            }

	            if (mode === "positions") {
	                // Map all percentages to on-range values.
	                return values.map(function(value) {
	                    return scope_Spectrum.fromStepping(stepped ? scope_Spectrum.getStep(value) : value);
	                });
	            }

	            if (mode === "values") {
	                // If the value must be stepped, it needs to be converted to a percentage first.
	                if (stepped) {
	                    return values.map(function(value) {
	                        // Convert to percentage, apply step, return to value.
	                        return scope_Spectrum.fromStepping(scope_Spectrum.getStep(scope_Spectrum.toStepping(value)));
	                    });
	                }

	                // Otherwise, we can simply use the values.
	                return values;
	            }
	        }

	        function generateSpread(density, mode, group) {
	            function safeIncrement(value, increment) {
	                // Avoid floating point variance by dropping the smallest decimal places.
	                return (value + increment).toFixed(7) / 1;
	            }

	            var indexes = {};
	            var firstInRange = scope_Spectrum.xVal[0];
	            var lastInRange = scope_Spectrum.xVal[scope_Spectrum.xVal.length - 1];
	            var ignoreFirst = false;
	            var ignoreLast = false;
	            var prevPct = 0;

	            // Create a copy of the group, sort it and filter away all duplicates.
	            group = unique(
	                group.slice().sort(function(a, b) {
	                    return a - b;
	                })
	            );

	            // Make sure the range starts with the first element.
	            if (group[0] !== firstInRange) {
	                group.unshift(firstInRange);
	                ignoreFirst = true;
	            }

	            // Likewise for the last one.
	            if (group[group.length - 1] !== lastInRange) {
	                group.push(lastInRange);
	                ignoreLast = true;
	            }

	            group.forEach(function(current, index) {
	                // Get the current step and the lower + upper positions.
	                var step;
	                var i;
	                var q;
	                var low = current;
	                var high = group[index + 1];
	                var newPct;
	                var pctDifference;
	                var pctPos;
	                var type;
	                var steps;
	                var realSteps;
	                var stepSize;
	                var isSteps = mode === "steps";

	                // When using 'steps' mode, use the provided steps.
	                // Otherwise, we'll step on to the next subrange.
	                if (isSteps) {
	                    step = scope_Spectrum.xNumSteps[index];
	                }

	                // Default to a 'full' step.
	                if (!step) {
	                    step = high - low;
	                }

	                // Low can be 0, so test for false. If high is undefined,
	                // we are at the last subrange. Index 0 is already handled.
	                if (low === false || high === undefined) {
	                    return;
	                }

	                // Make sure step isn't 0, which would cause an infinite loop (#654)
	                step = Math.max(step, 0.0000001);

	                // Find all steps in the subrange.
	                for (i = low; i <= high; i = safeIncrement(i, step)) {
	                    // Get the percentage value for the current step,
	                    // calculate the size for the subrange.
	                    newPct = scope_Spectrum.toStepping(i);
	                    pctDifference = newPct - prevPct;

	                    steps = pctDifference / density;
	                    realSteps = Math.round(steps);

	                    // This ratio represents the amount of percentage-space a point indicates.
	                    // For a density 1 the points/percentage = 1. For density 2, that percentage needs to be re-divided.
	                    // Round the percentage offset to an even number, then divide by two
	                    // to spread the offset on both sides of the range.
	                    stepSize = pctDifference / realSteps;

	                    // Divide all points evenly, adding the correct number to this subrange.
	                    // Run up to <= so that 100% gets a point, event if ignoreLast is set.
	                    for (q = 1; q <= realSteps; q += 1) {
	                        // The ratio between the rounded value and the actual size might be ~1% off.
	                        // Correct the percentage offset by the number of points
	                        // per subrange. density = 1 will result in 100 points on the
	                        // full range, 2 for 50, 4 for 25, etc.
	                        pctPos = prevPct + q * stepSize;
	                        indexes[pctPos.toFixed(5)] = [scope_Spectrum.fromStepping(pctPos), 0];
	                    }

	                    // Determine the point type.
	                    type = group.indexOf(i) > -1 ? PIPS_LARGE_VALUE : isSteps ? PIPS_SMALL_VALUE : PIPS_NO_VALUE;

	                    // Enforce the 'ignoreFirst' option by overwriting the type for 0.
	                    if (!index && ignoreFirst) {
	                        type = 0;
	                    }

	                    if (!(i === high && ignoreLast)) {
	                        // Mark the 'type' of this point. 0 = plain, 1 = real value, 2 = step value.
	                        indexes[newPct.toFixed(5)] = [i, type];
	                    }

	                    // Update the percentage count.
	                    prevPct = newPct;
	                }
	            });

	            return indexes;
	        }

	        function addMarking(spread, filterFunc, formatter) {
	            var element = scope_Document.createElement("div");

	            var valueSizeClasses = [];
	            valueSizeClasses[PIPS_NO_VALUE] = options.cssClasses.valueNormal;
	            valueSizeClasses[PIPS_LARGE_VALUE] = options.cssClasses.valueLarge;
	            valueSizeClasses[PIPS_SMALL_VALUE] = options.cssClasses.valueSub;

	            var markerSizeClasses = [];
	            markerSizeClasses[PIPS_NO_VALUE] = options.cssClasses.markerNormal;
	            markerSizeClasses[PIPS_LARGE_VALUE] = options.cssClasses.markerLarge;
	            markerSizeClasses[PIPS_SMALL_VALUE] = options.cssClasses.markerSub;

	            var valueOrientationClasses = [options.cssClasses.valueHorizontal, options.cssClasses.valueVertical];
	            var markerOrientationClasses = [options.cssClasses.markerHorizontal, options.cssClasses.markerVertical];

	            addClass(element, options.cssClasses.pips);
	            addClass(element, options.ort === 0 ? options.cssClasses.pipsHorizontal : options.cssClasses.pipsVertical);

	            function getClasses(type, source) {
	                var a = source === options.cssClasses.value;
	                var orientationClasses = a ? valueOrientationClasses : markerOrientationClasses;
	                var sizeClasses = a ? valueSizeClasses : markerSizeClasses;

	                return source + " " + orientationClasses[options.ort] + " " + sizeClasses[type];
	            }

	            function addSpread(offset, value, type) {
	                // Apply the filter function, if it is set.
	                type = filterFunc ? filterFunc(value, type) : type;

	                if (type === PIPS_NONE) {
	                    return;
	                }

	                // Add a marker for every point
	                var node = addNodeTo(element, false);
	                node.className = getClasses(type, options.cssClasses.marker);
	                node.style[options.style] = offset + "%";

	                // Values are only appended for points marked '1' or '2'.
	                if (type > PIPS_NO_VALUE) {
	                    node = addNodeTo(element, false);
	                    node.className = getClasses(type, options.cssClasses.value);
	                    node.setAttribute("data-value", value);
	                    node.style[options.style] = offset + "%";
	                    node.innerHTML = formatter.to(value);
	                }
	            }

	            // Append all points.
	            Object.keys(spread).forEach(function(offset) {
	                addSpread(offset, spread[offset][0], spread[offset][1]);
	            });

	            return element;
	        }

	        function removePips() {
	            if (scope_Pips) {
	                removeElement(scope_Pips);
	                scope_Pips = null;
	            }
	        }

	        function pips(grid) {
	            // Fix #669
	            removePips();

	            var mode = grid.mode;
	            var density = grid.density || 1;
	            var filter = grid.filter || false;
	            var values = grid.values || false;
	            var stepped = grid.stepped || false;
	            var group = getGroup(mode, values, stepped);
	            var spread = generateSpread(density, mode, group);
	            var format = grid.format || {
	                to: Math.round
	            };

	            scope_Pips = scope_Target.appendChild(addMarking(spread, filter, format));

	            return scope_Pips;
	        }

	        // Shorthand for base dimensions.
	        function baseSize() {
	            var rect = scope_Base.getBoundingClientRect();
	            var alt = "offset" + ["Width", "Height"][options.ort];
	            return options.ort === 0 ? rect.width || scope_Base[alt] : rect.height || scope_Base[alt];
	        }

	        // Handler for attaching events trough a proxy.
	        function attachEvent(events, element, callback, data) {
	            // This function can be used to 'filter' events to the slider.
	            // element is a node, not a nodeList

	            var method = function(e) {
	                e = fixEvent(e, data.pageOffset, data.target || element);

	                // fixEvent returns false if this event has a different target
	                // when handling (multi-) touch events;
	                if (!e) {
	                    return false;
	                }

	                // doNotReject is passed by all end events to make sure released touches
	                // are not rejected, leaving the slider "stuck" to the cursor;
	                if (isSliderDisabled() && !data.doNotReject) {
	                    return false;
	                }

	                // Stop if an active 'tap' transition is taking place.
	                if (hasClass(scope_Target, options.cssClasses.tap) && !data.doNotReject) {
	                    return false;
	                }

	                // Ignore right or middle clicks on start #454
	                if (events === actions.start && e.buttons !== undefined && e.buttons > 1) {
	                    return false;
	                }

	                // Ignore right or middle clicks on start #454
	                if (data.hover && e.buttons) {
	                    return false;
	                }

	                // 'supportsPassive' is only true if a browser also supports touch-action: none in CSS.
	                // iOS safari does not, so it doesn't get to benefit from passive scrolling. iOS does support
	                // touch-action: manipulation, but that allows panning, which breaks
	                // sliders after zooming/on non-responsive pages.
	                // See: https://bugs.webkit.org/show_bug.cgi?id=133112
	                if (!supportsPassive) {
	                    e.preventDefault();
	                }

	                e.calcPoint = e.points[options.ort];

	                // Call the event handler with the event [ and additional data ].
	                callback(e, data);
	            };

	            var methods = [];

	            // Bind a closure on the target for every event type.
	            events.split(" ").forEach(function(eventName) {
	                element.addEventListener(eventName, method, supportsPassive ? { passive: true } : false);
	                methods.push([eventName, method]);
	            });

	            return methods;
	        }

	        // Provide a clean event with standardized offset values.
	        function fixEvent(e, pageOffset, eventTarget) {
	            // Filter the event to register the type, which can be
	            // touch, mouse or pointer. Offset changes need to be
	            // made on an event specific basis.
	            var touch = e.type.indexOf("touch") === 0;
	            var mouse = e.type.indexOf("mouse") === 0;
	            var pointer = e.type.indexOf("pointer") === 0;

	            var x;
	            var y;

	            // IE10 implemented pointer events with a prefix;
	            if (e.type.indexOf("MSPointer") === 0) {
	                pointer = true;
	            }

	            // The only thing one handle should be concerned about is the touches that originated on top of it.
	            if (touch) {
	                // Returns true if a touch originated on the target.
	                var isTouchOnTarget = function(checkTouch) {
	                    return checkTouch.target === eventTarget || eventTarget.contains(checkTouch.target);
	                };

	                // In the case of touchstart events, we need to make sure there is still no more than one
	                // touch on the target so we look amongst all touches.
	                if (e.type === "touchstart") {
	                    var targetTouches = Array.prototype.filter.call(e.touches, isTouchOnTarget);

	                    // Do not support more than one touch per handle.
	                    if (targetTouches.length > 1) {
	                        return false;
	                    }

	                    x = targetTouches[0].pageX;
	                    y = targetTouches[0].pageY;
	                } else {
	                    // In the other cases, find on changedTouches is enough.
	                    var targetTouch = Array.prototype.find.call(e.changedTouches, isTouchOnTarget);

	                    // Cancel if the target touch has not moved.
	                    if (!targetTouch) {
	                        return false;
	                    }

	                    x = targetTouch.pageX;
	                    y = targetTouch.pageY;
	                }
	            }

	            pageOffset = pageOffset || getPageOffset(scope_Document);

	            if (mouse || pointer) {
	                x = e.clientX + pageOffset.x;
	                y = e.clientY + pageOffset.y;
	            }

	            e.pageOffset = pageOffset;
	            e.points = [x, y];
	            e.cursor = mouse || pointer; // Fix #435

	            return e;
	        }

	        // Translate a coordinate in the document to a percentage on the slider
	        function calcPointToPercentage(calcPoint) {
	            var location = calcPoint - offset(scope_Base, options.ort);
	            var proposal = (location * 100) / baseSize();

	            // Clamp proposal between 0% and 100%
	            // Out-of-bound coordinates may occur when .noUi-base pseudo-elements
	            // are used (e.g. contained handles feature)
	            proposal = limit(proposal);

	            return options.dir ? 100 - proposal : proposal;
	        }

	        // Find handle closest to a certain percentage on the slider
	        function getClosestHandle(clickedPosition) {
	            var smallestDifference = 100;
	            var handleNumber = false;

	            scope_Handles.forEach(function(handle, index) {
	                // Disabled handles are ignored
	                if (isHandleDisabled(index)) {
	                    return;
	                }

	                var handlePosition = scope_Locations[index];
	                var differenceWithThisHandle = Math.abs(handlePosition - clickedPosition);

	                // Initial state
	                var clickAtEdge = differenceWithThisHandle === 100 && smallestDifference === 100;

	                // Difference with this handle is smaller than the previously checked handle
	                var isCloser = differenceWithThisHandle < smallestDifference;
	                var isCloserAfter = differenceWithThisHandle <= smallestDifference && clickedPosition > handlePosition;

	                if (isCloser || isCloserAfter || clickAtEdge) {
	                    handleNumber = index;
	                    smallestDifference = differenceWithThisHandle;
	                }
	            });

	            return handleNumber;
	        }

	        // Fire 'end' when a mouse or pen leaves the document.
	        function documentLeave(event, data) {
	            if (event.type === "mouseout" && event.target.nodeName === "HTML" && event.relatedTarget === null) {
	                eventEnd(event, data);
	            }
	        }

	        // Handle movement on document for handle and range drag.
	        function eventMove(event, data) {
	            // Fix #498
	            // Check value of .buttons in 'start' to work around a bug in IE10 mobile (data.buttonsProperty).
	            // https://connect.microsoft.com/IE/feedback/details/927005/mobile-ie10-windows-phone-buttons-property-of-pointermove-event-always-zero
	            // IE9 has .buttons and .which zero on mousemove.
	            // Firefox breaks the spec MDN defines.
	            if (navigator.appVersion.indexOf("MSIE 9") === -1 && event.buttons === 0 && data.buttonsProperty !== 0) {
	                return eventEnd(event, data);
	            }

	            // Check if we are moving up or down
	            var movement = (options.dir ? -1 : 1) * (event.calcPoint - data.startCalcPoint);

	            // Convert the movement into a percentage of the slider width/height
	            var proposal = (movement * 100) / data.baseSize;

	            moveHandles(movement > 0, proposal, data.locations, data.handleNumbers);
	        }

	        // Unbind move events on document, call callbacks.
	        function eventEnd(event, data) {
	            // The handle is no longer active, so remove the class.
	            if (data.handle) {
	                removeClass(data.handle, options.cssClasses.active);
	                scope_ActiveHandlesCount -= 1;
	            }

	            // Unbind the move and end events, which are added on 'start'.
	            data.listeners.forEach(function(c) {
	                scope_DocumentElement.removeEventListener(c[0], c[1]);
	            });

	            if (scope_ActiveHandlesCount === 0) {
	                // Remove dragging class.
	                removeClass(scope_Target, options.cssClasses.drag);
	                setZindex();

	                // Remove cursor styles and text-selection events bound to the body.
	                if (event.cursor) {
	                    scope_Body.style.cursor = "";
	                    scope_Body.removeEventListener("selectstart", preventDefault);
	                }
	            }

	            data.handleNumbers.forEach(function(handleNumber) {
	                fireEvent("change", handleNumber);
	                fireEvent("set", handleNumber);
	                fireEvent("end", handleNumber);
	            });
	        }

	        // Bind move events on document.
	        function eventStart(event, data) {
	            // Ignore event if any handle is disabled
	            if (data.handleNumbers.some(isHandleDisabled)) {
	                return false;
	            }

	            var handle;

	            if (data.handleNumbers.length === 1) {
	                var handleOrigin = scope_Handles[data.handleNumbers[0]];

	                handle = handleOrigin.children[0];
	                scope_ActiveHandlesCount += 1;

	                // Mark the handle as 'active' so it can be styled.
	                addClass(handle, options.cssClasses.active);
	            }

	            // A drag should never propagate up to the 'tap' event.
	            event.stopPropagation();

	            // Record the event listeners.
	            var listeners = [];

	            // Attach the move and end events.
	            var moveEvent = attachEvent(actions.move, scope_DocumentElement, eventMove, {
	                // The event target has changed so we need to propagate the original one so that we keep
	                // relying on it to extract target touches.
	                target: event.target,
	                handle: handle,
	                listeners: listeners,
	                startCalcPoint: event.calcPoint,
	                baseSize: baseSize(),
	                pageOffset: event.pageOffset,
	                handleNumbers: data.handleNumbers,
	                buttonsProperty: event.buttons,
	                locations: scope_Locations.slice()
	            });

	            var endEvent = attachEvent(actions.end, scope_DocumentElement, eventEnd, {
	                target: event.target,
	                handle: handle,
	                listeners: listeners,
	                doNotReject: true,
	                handleNumbers: data.handleNumbers
	            });

	            var outEvent = attachEvent("mouseout", scope_DocumentElement, documentLeave, {
	                target: event.target,
	                handle: handle,
	                listeners: listeners,
	                doNotReject: true,
	                handleNumbers: data.handleNumbers
	            });

	            // We want to make sure we pushed the listeners in the listener list rather than creating
	            // a new one as it has already been passed to the event handlers.
	            listeners.push.apply(listeners, moveEvent.concat(endEvent, outEvent));

	            // Text selection isn't an issue on touch devices,
	            // so adding cursor styles can be skipped.
	            if (event.cursor) {
	                // Prevent the 'I' cursor and extend the range-drag cursor.
	                scope_Body.style.cursor = getComputedStyle(event.target).cursor;

	                // Mark the target with a dragging state.
	                if (scope_Handles.length > 1) {
	                    addClass(scope_Target, options.cssClasses.drag);
	                }

	                // Prevent text selection when dragging the handles.
	                // In noUiSlider <= 9.2.0, this was handled by calling preventDefault on mouse/touch start/move,
	                // which is scroll blocking. The selectstart event is supported by FireFox starting from version 52,
	                // meaning the only holdout is iOS Safari. This doesn't matter: text selection isn't triggered there.
	                // The 'cursor' flag is false.
	                // See: http://caniuse.com/#search=selectstart
	                scope_Body.addEventListener("selectstart", preventDefault, false);
	            }

	            data.handleNumbers.forEach(function(handleNumber) {
	                fireEvent("start", handleNumber);
	            });
	        }

	        // Move closest handle to tapped location.
	        function eventTap(event) {
	            // The tap event shouldn't propagate up
	            event.stopPropagation();

	            var proposal = calcPointToPercentage(event.calcPoint);
	            var handleNumber = getClosestHandle(proposal);

	            // Tackle the case that all handles are 'disabled'.
	            if (handleNumber === false) {
	                return false;
	            }

	            // Flag the slider as it is now in a transitional state.
	            // Transition takes a configurable amount of ms (default 300). Re-enable the slider after that.
	            if (!options.events.snap) {
	                addClassFor(scope_Target, options.cssClasses.tap, options.animationDuration);
	            }

	            setHandle(handleNumber, proposal, true, true);

	            setZindex();

	            fireEvent("slide", handleNumber, true);
	            fireEvent("update", handleNumber, true);
	            fireEvent("change", handleNumber, true);
	            fireEvent("set", handleNumber, true);

	            if (options.events.snap) {
	                eventStart(event, { handleNumbers: [handleNumber] });
	            }
	        }

	        // Fires a 'hover' event for a hovered mouse/pen position.
	        function eventHover(event) {
	            var proposal = calcPointToPercentage(event.calcPoint);

	            var to = scope_Spectrum.getStep(proposal);
	            var value = scope_Spectrum.fromStepping(to);

	            Object.keys(scope_Events).forEach(function(targetEvent) {
	                if ("hover" === targetEvent.split(".")[0]) {
	                    scope_Events[targetEvent].forEach(function(callback) {
	                        callback.call(scope_Self, value);
	                    });
	                }
	            });
	        }

	        // Handles keydown on focused handles
	        // Don't move the document when pressing arrow keys on focused handles
	        function eventKeydown(event, handleNumber) {
	            if (isSliderDisabled() || isHandleDisabled(handleNumber)) {
	                return false;
	            }

	            var horizontalKeys = ["Left", "Right"];
	            var verticalKeys = ["Down", "Up"];

	            if (options.dir && !options.ort) {
	                // On an right-to-left slider, the left and right keys act inverted
	                horizontalKeys.reverse();
	            } else if (options.ort && !options.dir) {
	                // On a top-to-bottom slider, the up and down keys act inverted
	                verticalKeys.reverse();
	            }

	            // Strip "Arrow" for IE compatibility. https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key
	            var key = event.key.replace("Arrow", "");
	            var isDown = key === verticalKeys[0] || key === horizontalKeys[0];
	            var isUp = key === verticalKeys[1] || key === horizontalKeys[1];

	            if (!isDown && !isUp) {
	                return true;
	            }

	            event.preventDefault();

	            var direction = isDown ? 0 : 1;
	            var steps = getNextStepsForHandle(handleNumber);
	            var step = steps[direction];

	            // At the edge of a slider, do nothing
	            if (step === null) {
	                return false;
	            }

	            // No step set, use the default of 10% of the sub-range
	            if (step === false) {
	                step = scope_Spectrum.getDefaultStep(scope_Locations[handleNumber], isDown, 10);
	            }

	            // Step over zero-length ranges (#948);
	            step = Math.max(step, 0.0000001);

	            // Decrement for down steps
	            step = (isDown ? -1 : 1) * step;

	            setHandle(handleNumber, scope_Spectrum.toStepping(scope_Values[handleNumber] + step), true, true);

	            fireEvent("slide", handleNumber);
	            fireEvent("update", handleNumber);
	            fireEvent("change", handleNumber);
	            fireEvent("set", handleNumber);

	            return false;
	        }

	        // Attach events to several slider parts.
	        function bindSliderEvents(behaviour) {
	            // Attach the standard drag event to the handles.
	            if (!behaviour.fixed) {
	                scope_Handles.forEach(function(handle, index) {
	                    // These events are only bound to the visual handle
	                    // element, not the 'real' origin element.
	                    attachEvent(actions.start, handle.children[0], eventStart, {
	                        handleNumbers: [index]
	                    });
	                });
	            }

	            // Attach the tap event to the slider base.
	            if (behaviour.tap) {
	                attachEvent(actions.start, scope_Base, eventTap, {});
	            }

	            // Fire hover events
	            if (behaviour.hover) {
	                attachEvent(actions.move, scope_Base, eventHover, {
	                    hover: true
	                });
	            }

	            // Make the range draggable.
	            if (behaviour.drag) {
	                scope_Connects.forEach(function(connect, index) {
	                    if (connect === false || index === 0 || index === scope_Connects.length - 1) {
	                        return;
	                    }

	                    var handleBefore = scope_Handles[index - 1];
	                    var handleAfter = scope_Handles[index];
	                    var eventHolders = [connect];

	                    addClass(connect, options.cssClasses.draggable);

	                    // When the range is fixed, the entire range can
	                    // be dragged by the handles. The handle in the first
	                    // origin will propagate the start event upward,
	                    // but it needs to be bound manually on the other.
	                    if (behaviour.fixed) {
	                        eventHolders.push(handleBefore.children[0]);
	                        eventHolders.push(handleAfter.children[0]);
	                    }

	                    eventHolders.forEach(function(eventHolder) {
	                        attachEvent(actions.start, eventHolder, eventStart, {
	                            handles: [handleBefore, handleAfter],
	                            handleNumbers: [index - 1, index]
	                        });
	                    });
	                });
	            }
	        }

	        // Attach an event to this slider, possibly including a namespace
	        function bindEvent(namespacedEvent, callback) {
	            scope_Events[namespacedEvent] = scope_Events[namespacedEvent] || [];
	            scope_Events[namespacedEvent].push(callback);

	            // If the event bound is 'update,' fire it immediately for all handles.
	            if (namespacedEvent.split(".")[0] === "update") {
	                scope_Handles.forEach(function(a, index) {
	                    fireEvent("update", index);
	                });
	            }
	        }

	        // Undo attachment of event
	        function removeEvent(namespacedEvent) {
	            var event = namespacedEvent && namespacedEvent.split(".")[0];
	            var namespace = event && namespacedEvent.substring(event.length);

	            Object.keys(scope_Events).forEach(function(bind) {
	                var tEvent = bind.split(".")[0];
	                var tNamespace = bind.substring(tEvent.length);

	                if ((!event || event === tEvent) && (!namespace || namespace === tNamespace)) {
	                    delete scope_Events[bind];
	                }
	            });
	        }

	        // External event handling
	        function fireEvent(eventName, handleNumber, tap) {
	            Object.keys(scope_Events).forEach(function(targetEvent) {
	                var eventType = targetEvent.split(".")[0];

	                if (eventName === eventType) {
	                    scope_Events[targetEvent].forEach(function(callback) {
	                        callback.call(
	                            // Use the slider public API as the scope ('this')
	                            scope_Self,
	                            // Return values as array, so arg_1[arg_2] is always valid.
	                            scope_Values.map(options.format.to),
	                            // Handle index, 0 or 1
	                            handleNumber,
	                            // Un-formatted slider values
	                            scope_Values.slice(),
	                            // Event is fired by tap, true or false
	                            tap || false,
	                            // Left offset of the handle, in relation to the slider
	                            scope_Locations.slice()
	                        );
	                    });
	                }
	            });
	        }

	        // Split out the handle positioning logic so the Move event can use it, too
	        function checkHandlePosition(reference, handleNumber, to, lookBackward, lookForward, getValue) {
	            // For sliders with multiple handles, limit movement to the other handle.
	            // Apply the margin option by adding it to the handle positions.
	            if (scope_Handles.length > 1 && !options.events.unconstrained) {
	                if (lookBackward && handleNumber > 0) {
	                    to = Math.max(to, reference[handleNumber - 1] + options.margin);
	                }

	                if (lookForward && handleNumber < scope_Handles.length - 1) {
	                    to = Math.min(to, reference[handleNumber + 1] - options.margin);
	                }
	            }

	            // The limit option has the opposite effect, limiting handles to a
	            // maximum distance from another. Limit must be > 0, as otherwise
	            // handles would be unmovable.
	            if (scope_Handles.length > 1 && options.limit) {
	                if (lookBackward && handleNumber > 0) {
	                    to = Math.min(to, reference[handleNumber - 1] + options.limit);
	                }

	                if (lookForward && handleNumber < scope_Handles.length - 1) {
	                    to = Math.max(to, reference[handleNumber + 1] - options.limit);
	                }
	            }

	            // The padding option keeps the handles a certain distance from the
	            // edges of the slider. Padding must be > 0.
	            if (options.padding) {
	                if (handleNumber === 0) {
	                    to = Math.max(to, options.padding[0]);
	                }

	                if (handleNumber === scope_Handles.length - 1) {
	                    to = Math.min(to, 100 - options.padding[1]);
	                }
	            }

	            to = scope_Spectrum.getStep(to);

	            // Limit percentage to the 0 - 100 range
	            to = limit(to);

	            // Return false if handle can't move
	            if (to === reference[handleNumber] && !getValue) {
	                return false;
	            }

	            return to;
	        }

	        // Uses slider orientation to create CSS rules. a = base value;
	        function inRuleOrder(v, a) {
	            var o = options.ort;
	            return (o ? a : v) + ", " + (o ? v : a);
	        }

	        // Moves handle(s) by a percentage
	        // (bool, % to move, [% where handle started, ...], [index in scope_Handles, ...])
	        function moveHandles(upward, proposal, locations, handleNumbers) {
	            var proposals = locations.slice();

	            var b = [!upward, upward];
	            var f = [upward, !upward];

	            // Copy handleNumbers so we don't change the dataset
	            handleNumbers = handleNumbers.slice();

	            // Check to see which handle is 'leading'.
	            // If that one can't move the second can't either.
	            if (upward) {
	                handleNumbers.reverse();
	            }

	            // Step 1: get the maximum percentage that any of the handles can move
	            if (handleNumbers.length > 1) {
	                handleNumbers.forEach(function(handleNumber, o) {
	                    var to = checkHandlePosition(
	                        proposals,
	                        handleNumber,
	                        proposals[handleNumber] + proposal,
	                        b[o],
	                        f[o],
	                        false
	                    );

	                    // Stop if one of the handles can't move.
	                    if (to === false) {
	                        proposal = 0;
	                    } else {
	                        proposal = to - proposals[handleNumber];
	                        proposals[handleNumber] = to;
	                    }
	                });
	            }

	            // If using one handle, check backward AND forward
	            else {
	                b = f = [true];
	            }

	            var state = false;

	            // Step 2: Try to set the handles with the found percentage
	            handleNumbers.forEach(function(handleNumber, o) {
	                state = setHandle(handleNumber, locations[handleNumber] + proposal, b[o], f[o]) || state;
	            });

	            // Step 3: If a handle moved, fire events
	            if (state) {
	                handleNumbers.forEach(function(handleNumber) {
	                    fireEvent("update", handleNumber);
	                    fireEvent("slide", handleNumber);
	                });
	            }
	        }

	        // Takes a base value and an offset. This offset is used for the connect bar size.
	        // In the initial design for this feature, the origin element was 1% wide.
	        // Unfortunately, a rounding bug in Chrome makes it impossible to implement this feature
	        // in this manner: https://bugs.chromium.org/p/chromium/issues/detail?id=798223
	        function transformDirection(a, b) {
	            return options.dir ? 100 - a - b : a;
	        }

	        // Updates scope_Locations and scope_Values, updates visual state
	        function updateHandlePosition(handleNumber, to) {
	            // Update locations.
	            scope_Locations[handleNumber] = to;

	            // Convert the value to the slider stepping/range.
	            scope_Values[handleNumber] = scope_Spectrum.fromStepping(to);

	            var translation = 10 * (transformDirection(to, 0) - scope_DirOffset);
	            var translateRule = "translate(" + inRuleOrder(translation + "%", "0") + ")";

	            scope_Handles[handleNumber].style[options.transformRule] = translateRule;

	            updateConnect(handleNumber);
	            updateConnect(handleNumber + 1);
	        }

	        // Handles before the slider middle are stacked later = higher,
	        // Handles after the middle later is lower
	        // [[7] [8] .......... | .......... [5] [4]
	        function setZindex() {
	            scope_HandleNumbers.forEach(function(handleNumber) {
	                var dir = scope_Locations[handleNumber] > 50 ? -1 : 1;
	                var zIndex = 3 + (scope_Handles.length + dir * handleNumber);
	                scope_Handles[handleNumber].style.zIndex = zIndex;
	            });
	        }

	        // Test suggested values and apply margin, step.
	        function setHandle(handleNumber, to, lookBackward, lookForward) {
	            to = checkHandlePosition(scope_Locations, handleNumber, to, lookBackward, lookForward, false);

	            if (to === false) {
	                return false;
	            }

	            updateHandlePosition(handleNumber, to);

	            return true;
	        }

	        // Updates style attribute for connect nodes
	        function updateConnect(index) {
	            // Skip connects set to false
	            if (!scope_Connects[index]) {
	                return;
	            }

	            var l = 0;
	            var h = 100;

	            if (index !== 0) {
	                l = scope_Locations[index - 1];
	            }

	            if (index !== scope_Connects.length - 1) {
	                h = scope_Locations[index];
	            }

	            // We use two rules:
	            // 'translate' to change the left/top offset;
	            // 'scale' to change the width of the element;
	            // As the element has a width of 100%, a translation of 100% is equal to 100% of the parent (.noUi-base)
	            var connectWidth = h - l;
	            var translateRule = "translate(" + inRuleOrder(transformDirection(l, connectWidth) + "%", "0") + ")";
	            var scaleRule = "scale(" + inRuleOrder(connectWidth / 100, "1") + ")";

	            scope_Connects[index].style[options.transformRule] = translateRule + " " + scaleRule;
	        }

	        // Parses value passed to .set method. Returns current value if not parse-able.
	        function resolveToValue(to, handleNumber) {
	            // Setting with null indicates an 'ignore'.
	            // Inputting 'false' is invalid.
	            if (to === null || to === false || to === undefined) {
	                return scope_Locations[handleNumber];
	            }

	            // If a formatted number was passed, attempt to decode it.
	            if (typeof to === "number") {
	                to = String(to);
	            }

	            to = options.format.from(to);
	            to = scope_Spectrum.toStepping(to);

	            // If parsing the number failed, use the current value.
	            if (to === false || isNaN(to)) {
	                return scope_Locations[handleNumber];
	            }

	            return to;
	        }

	        // Set the slider value.
	        function valueSet(input, fireSetEvent) {
	            var values = asArray(input);
	            var isInit = scope_Locations[0] === undefined;

	            // Event fires by default
	            fireSetEvent = fireSetEvent === undefined ? true : !!fireSetEvent;

	            // Animation is optional.
	            // Make sure the initial values were set before using animated placement.
	            if (options.animate && !isInit) {
	                addClassFor(scope_Target, options.cssClasses.tap, options.animationDuration);
	            }

	            // First pass, without lookAhead but with lookBackward. Values are set from left to right.
	            scope_HandleNumbers.forEach(function(handleNumber) {
	                setHandle(handleNumber, resolveToValue(values[handleNumber], handleNumber), true, false);
	            });

	            var i = scope_HandleNumbers.length === 1 ? 0 : 1;

	            // Secondary passes. Now that all base values are set, apply constraints.
	            // Iterate all handles to ensure constraints are applied for the entire slider (Issue #1009)
	            for (; i < scope_HandleNumbers.length; ++i) {
	                scope_HandleNumbers.forEach(function(handleNumber) {
	                    setHandle(handleNumber, scope_Locations[handleNumber], true, true);
	                });
	            }

	            setZindex();

	            scope_HandleNumbers.forEach(function(handleNumber) {
	                fireEvent("update", handleNumber);

	                // Fire the event only for handles that received a new value, as per #579
	                if (values[handleNumber] !== null && fireSetEvent) {
	                    fireEvent("set", handleNumber);
	                }
	            });
	        }

	        // Reset slider to initial values
	        function valueReset(fireSetEvent) {
	            valueSet(options.start, fireSetEvent);
	        }

	        // Set value for a single handle
	        function valueSetHandle(handleNumber, value, fireSetEvent) {
	            // Ensure numeric input
	            handleNumber = Number(handleNumber);

	            if (!(handleNumber >= 0 && handleNumber < scope_HandleNumbers.length)) {
	                throw new Error("noUiSlider (" + VERSION + "): invalid handle number, got: " + handleNumber);
	            }

	            // Look both backward and forward, since we don't want this handle to "push" other handles (#960);
	            setHandle(handleNumber, resolveToValue(value, handleNumber), true, true);

	            fireEvent("update", handleNumber);

	            if (fireSetEvent) {
	                fireEvent("set", handleNumber);
	            }
	        }

	        // Get the slider value.
	        function valueGet() {
	            var values = scope_Values.map(options.format.to);

	            // If only one handle is used, return a single value.
	            if (values.length === 1) {
	                return values[0];
	            }

	            return values;
	        }

	        // Removes classes from the root and empties it.
	        function destroy() {
	            for (var key in options.cssClasses) {
	                if (!options.cssClasses.hasOwnProperty(key)) {
	                    continue;
	                }
	                removeClass(scope_Target, options.cssClasses[key]);
	            }

	            while (scope_Target.firstChild) {
	                scope_Target.removeChild(scope_Target.firstChild);
	            }

	            delete scope_Target.noUiSlider;
	        }

	        function getNextStepsForHandle(handleNumber) {
	            var location = scope_Locations[handleNumber];
	            var nearbySteps = scope_Spectrum.getNearbySteps(location);
	            var value = scope_Values[handleNumber];
	            var increment = nearbySteps.thisStep.step;
	            var decrement = null;

	            // If snapped, directly use defined step value
	            if (options.snap) {
	                return [
	                    value - nearbySteps.stepBefore.startValue || null,
	                    nearbySteps.stepAfter.startValue - value || null
	                ];
	            }

	            // If the next value in this step moves into the next step,
	            // the increment is the start of the next step - the current value
	            if (increment !== false) {
	                if (value + increment > nearbySteps.stepAfter.startValue) {
	                    increment = nearbySteps.stepAfter.startValue - value;
	                }
	            }

	            // If the value is beyond the starting point
	            if (value > nearbySteps.thisStep.startValue) {
	                decrement = nearbySteps.thisStep.step;
	            } else if (nearbySteps.stepBefore.step === false) {
	                decrement = false;
	            }

	            // If a handle is at the start of a step, it always steps back into the previous step first
	            else {
	                decrement = value - nearbySteps.stepBefore.highestStep;
	            }

	            // Now, if at the slider edges, there is no in/decrement
	            if (location === 100) {
	                increment = null;
	            } else if (location === 0) {
	                decrement = null;
	            }

	            // As per #391, the comparison for the decrement step can have some rounding issues.
	            var stepDecimals = scope_Spectrum.countStepDecimals();

	            // Round per #391
	            if (increment !== null && increment !== false) {
	                increment = Number(increment.toFixed(stepDecimals));
	            }

	            if (decrement !== null && decrement !== false) {
	                decrement = Number(decrement.toFixed(stepDecimals));
	            }

	            return [decrement, increment];
	        }

	        // Get the current step size for the slider.
	        function getNextSteps() {
	            return scope_HandleNumbers.map(getNextStepsForHandle);
	        }

	        // Updateable: margin, limit, padding, step, range, animate, snap
	        function updateOptions(optionsToUpdate, fireSetEvent) {
	            // Spectrum is created using the range, snap, direction and step options.
	            // 'snap' and 'step' can be updated.
	            // If 'snap' and 'step' are not passed, they should remain unchanged.
	            var v = valueGet();

	            var updateAble = [
	                "margin",
	                "limit",
	                "padding",
	                "range",
	                "animate",
	                "snap",
	                "step",
	                "format",
	                "pips",
	                "tooltips"
	            ];

	            // Only change options that we're actually passed to update.
	            updateAble.forEach(function(name) {
	                // Check for undefined. null removes the value.
	                if (optionsToUpdate[name] !== undefined) {
	                    originalOptions[name] = optionsToUpdate[name];
	                }
	            });

	            var newOptions = testOptions(originalOptions);

	            // Load new options into the slider state
	            updateAble.forEach(function(name) {
	                if (optionsToUpdate[name] !== undefined) {
	                    options[name] = newOptions[name];
	                }
	            });

	            scope_Spectrum = newOptions.spectrum;

	            // Limit, margin and padding depend on the spectrum but are stored outside of it. (#677)
	            options.margin = newOptions.margin;
	            options.limit = newOptions.limit;
	            options.padding = newOptions.padding;

	            // Update pips, removes existing.
	            if (options.pips) {
	                pips(options.pips);
	            } else {
	                removePips();
	            }

	            // Update tooltips, removes existing.
	            if (options.tooltips) {
	                tooltips();
	            } else {
	                removeTooltips();
	            }

	            // Invalidate the current positioning so valueSet forces an update.
	            scope_Locations = [];
	            valueSet(optionsToUpdate.start || v, fireSetEvent);
	        }

	        // Initialization steps
	        function setupSlider() {
	            // Create the base element, initialize HTML and set classes.
	            // Add handles and connect elements.
	            scope_Base = addSlider(scope_Target);

	            addElements(options.connect, scope_Base);

	            // Attach user events.
	            bindSliderEvents(options.events);

	            // Use the public value method to set the start values.
	            valueSet(options.start);

	            if (options.pips) {
	                pips(options.pips);
	            }

	            if (options.tooltips) {
	                tooltips();
	            }

	            aria();
	        }

	        setupSlider();

	        // noinspection JSUnusedGlobalSymbols
	        scope_Self = {
	            destroy: destroy,
	            steps: getNextSteps,
	            on: bindEvent,
	            off: removeEvent,
	            get: valueGet,
	            set: valueSet,
	            setHandle: valueSetHandle,
	            reset: valueReset,
	            // Exposed for unit testing, don't use this in your application.
	            __moveHandles: function(a, b, c) {
	                moveHandles(a, b, scope_Locations, c);
	            },
	            options: originalOptions, // Issue #600, #678
	            updateOptions: updateOptions,
	            target: scope_Target, // Issue #597
	            removePips: removePips,
	            removeTooltips: removeTooltips,
	            pips: pips // Issue #594
	        };

	        return scope_Self;
	    }

	    // Run the standard initializer
	    function initialize(target, originalOptions) {
	        if (!target || !target.nodeName) {
	            throw new Error("noUiSlider (" + VERSION + "): create requires a single element, got: " + target);
	        }

	        // Throw an error if the slider was already initialized.
	        if (target.noUiSlider) {
	            throw new Error("noUiSlider (" + VERSION + "): Slider was already initialized.");
	        }

	        // Test the options and create the slider environment;
	        var options = testOptions(originalOptions, target);
	        var api = scope(target, options, originalOptions);

	        target.noUiSlider = api;

	        return api;
	    }

	    // Use an object instead of a function for future expandability;
	    return {
	        // Exposed for unit testing, don't use this in your application.
	        __spectrum: Spectrum,
	        version: VERSION,
	        create: initialize
	    };
	});


/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (factory) {

	    if ( true ) {

	        // AMD. Register as an anonymous module.
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

	    } else if ( typeof exports === 'object' ) {

	        // Node/CommonJS
	        module.exports = factory();

	    } else {

	        // Browser globals
	        window.wNumb = factory();
	    }

	}(function(){

		'use strict';

	var FormatOptions = [
		'decimals',
		'thousand',
		'mark',
		'prefix',
		'suffix',
		'encoder',
		'decoder',
		'negativeBefore',
		'negative',
		'edit',
		'undo'
	];

	// General

		// Reverse a string
		function strReverse ( a ) {
			return a.split('').reverse().join('');
		}

		// Check if a string starts with a specified prefix.
		function strStartsWith ( input, match ) {
			return input.substring(0, match.length) === match;
		}

		// Check is a string ends in a specified suffix.
		function strEndsWith ( input, match ) {
			return input.slice(-1 * match.length) === match;
		}

		// Throw an error if formatting options are incompatible.
		function throwEqualError( F, a, b ) {
			if ( (F[a] || F[b]) && (F[a] === F[b]) ) {
				throw new Error(a);
			}
		}

		// Check if a number is finite and not NaN
		function isValidNumber ( input ) {
			return typeof input === 'number' && isFinite( input );
		}

		// Provide rounding-accurate toFixed method.
		// Borrowed: http://stackoverflow.com/a/21323330/775265
		function toFixed ( value, exp ) {
			value = value.toString().split('e');
			value = Math.round(+(value[0] + 'e' + (value[1] ? (+value[1] + exp) : exp)));
			value = value.toString().split('e');
			return (+(value[0] + 'e' + (value[1] ? (+value[1] - exp) : -exp))).toFixed(exp);
		}


	// Formatting

		// Accept a number as input, output formatted string.
		function formatTo ( decimals, thousand, mark, prefix, suffix, encoder, decoder, negativeBefore, negative, edit, undo, input ) {

			var originalInput = input, inputIsNegative, inputPieces, inputBase, inputDecimals = '', output = '';

			// Apply user encoder to the input.
			// Expected outcome: number.
			if ( encoder ) {
				input = encoder(input);
			}

			// Stop if no valid number was provided, the number is infinite or NaN.
			if ( !isValidNumber(input) ) {
				return false;
			}

			// Rounding away decimals might cause a value of -0
			// when using very small ranges. Remove those cases.
			if ( decimals !== false && parseFloat(input.toFixed(decimals)) === 0 ) {
				input = 0;
			}

			// Formatting is done on absolute numbers,
			// decorated by an optional negative symbol.
			if ( input < 0 ) {
				inputIsNegative = true;
				input = Math.abs(input);
			}

			// Reduce the number of decimals to the specified option.
			if ( decimals !== false ) {
				input = toFixed( input, decimals );
			}

			// Transform the number into a string, so it can be split.
			input = input.toString();

			// Break the number on the decimal separator.
			if ( input.indexOf('.') !== -1 ) {
				inputPieces = input.split('.');

				inputBase = inputPieces[0];

				if ( mark ) {
					inputDecimals = mark + inputPieces[1];
				}

			} else {

			// If it isn't split, the entire number will do.
				inputBase = input;
			}

			// Group numbers in sets of three.
			if ( thousand ) {
				inputBase = strReverse(inputBase).match(/.{1,3}/g);
				inputBase = strReverse(inputBase.join( strReverse( thousand ) ));
			}

			// If the number is negative, prefix with negation symbol.
			if ( inputIsNegative && negativeBefore ) {
				output += negativeBefore;
			}

			// Prefix the number
			if ( prefix ) {
				output += prefix;
			}

			// Normal negative option comes after the prefix. Defaults to '-'.
			if ( inputIsNegative && negative ) {
				output += negative;
			}

			// Append the actual number.
			output += inputBase;
			output += inputDecimals;

			// Apply the suffix.
			if ( suffix ) {
				output += suffix;
			}

			// Run the output through a user-specified post-formatter.
			if ( edit ) {
				output = edit ( output, originalInput );
			}

			// All done.
			return output;
		}

		// Accept a sting as input, output decoded number.
		function formatFrom ( decimals, thousand, mark, prefix, suffix, encoder, decoder, negativeBefore, negative, edit, undo, input ) {

			var originalInput = input, inputIsNegative, output = '';

			// User defined pre-decoder. Result must be a non empty string.
			if ( undo ) {
				input = undo(input);
			}

			// Test the input. Can't be empty.
			if ( !input || typeof input !== 'string' ) {
				return false;
			}

			// If the string starts with the negativeBefore value: remove it.
			// Remember is was there, the number is negative.
			if ( negativeBefore && strStartsWith(input, negativeBefore) ) {
				input = input.replace(negativeBefore, '');
				inputIsNegative = true;
			}

			// Repeat the same procedure for the prefix.
			if ( prefix && strStartsWith(input, prefix) ) {
				input = input.replace(prefix, '');
			}

			// And again for negative.
			if ( negative && strStartsWith(input, negative) ) {
				input = input.replace(negative, '');
				inputIsNegative = true;
			}

			// Remove the suffix.
			// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/slice
			if ( suffix && strEndsWith(input, suffix) ) {
				input = input.slice(0, -1 * suffix.length);
			}

			// Remove the thousand grouping.
			if ( thousand ) {
				input = input.split(thousand).join('');
			}

			// Set the decimal separator back to period.
			if ( mark ) {
				input = input.replace(mark, '.');
			}

			// Prepend the negative symbol.
			if ( inputIsNegative ) {
				output += '-';
			}

			// Add the number
			output += input;

			// Trim all non-numeric characters (allow '.' and '-');
			output = output.replace(/[^0-9\.\-.]/g, '');

			// The value contains no parse-able number.
			if ( output === '' ) {
				return false;
			}

			// Covert to number.
			output = Number(output);

			// Run the user-specified post-decoder.
			if ( decoder ) {
				output = decoder(output);
			}

			// Check is the output is valid, otherwise: return false.
			if ( !isValidNumber(output) ) {
				return false;
			}

			return output;
		}


	// Framework

		// Validate formatting options
		function validate ( inputOptions ) {

			var i, optionName, optionValue,
				filteredOptions = {};

			if ( inputOptions['suffix'] === undefined ) {
				inputOptions['suffix'] = inputOptions['postfix'];
			}

			for ( i = 0; i < FormatOptions.length; i+=1 ) {

				optionName = FormatOptions[i];
				optionValue = inputOptions[optionName];

				if ( optionValue === undefined ) {

					// Only default if negativeBefore isn't set.
					if ( optionName === 'negative' && !filteredOptions.negativeBefore ) {
						filteredOptions[optionName] = '-';
					// Don't set a default for mark when 'thousand' is set.
					} else if ( optionName === 'mark' && filteredOptions.thousand !== '.' ) {
						filteredOptions[optionName] = '.';
					} else {
						filteredOptions[optionName] = false;
					}

				// Floating points in JS are stable up to 7 decimals.
				} else if ( optionName === 'decimals' ) {
					if ( optionValue >= 0 && optionValue < 8 ) {
						filteredOptions[optionName] = optionValue;
					} else {
						throw new Error(optionName);
					}

				// These options, when provided, must be functions.
				} else if ( optionName === 'encoder' || optionName === 'decoder' || optionName === 'edit' || optionName === 'undo' ) {
					if ( typeof optionValue === 'function' ) {
						filteredOptions[optionName] = optionValue;
					} else {
						throw new Error(optionName);
					}

				// Other options are strings.
				} else {

					if ( typeof optionValue === 'string' ) {
						filteredOptions[optionName] = optionValue;
					} else {
						throw new Error(optionName);
					}
				}
			}

			// Some values can't be extracted from a
			// string if certain combinations are present.
			throwEqualError(filteredOptions, 'mark', 'thousand');
			throwEqualError(filteredOptions, 'prefix', 'negative');
			throwEqualError(filteredOptions, 'prefix', 'negativeBefore');

			return filteredOptions;
		}

		// Pass all options as function arguments
		function passAll ( options, method, input ) {
			var i, args = [];

			// Add all options in order of FormatOptions
			for ( i = 0; i < FormatOptions.length; i+=1 ) {
				args.push(options[FormatOptions[i]]);
			}

			// Append the input, then call the method, presenting all
			// options as arguments.
			args.push(input);
			return method.apply('', args);
		}

		function wNumb ( options ) {

			if ( !(this instanceof wNumb) ) {
				return new wNumb ( options );
			}

			if ( typeof options !== "object" ) {
				return;
			}

			options = validate(options);

			// Call 'formatTo' with proper arguments.
			this.to = function ( input ) {
				return passAll(options, formatTo, input);
			};

			// Call 'formatFrom' with proper arguments.
			this.from = function ( input ) {
				return passAll(options, formatFrom, input);
			};
		}

		return wNumb;

	}));


/***/ }),
/* 62 */
/***/ (function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;(typeof navigator !== "undefined") && (function(root, factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
	            return factory(root);
	        }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    } else if (typeof module === "object" && module.exports) {
	        module.exports = factory(root);
	    } else {
	        root.lottie = factory(root);
	        root.bodymovin = root.lottie;
	    }
	}((window || {}), function(window) {
		/* global locationHref:writable, animationManager, subframeEnabled:writable, defaultCurveSegments:writable, roundValues,
	expressionsPlugin:writable, PropertyFactory, ShapePropertyFactory, Matrix, idPrefix:writable */
	/* exported locationHref, subframeEnabled, expressionsPlugin, idPrefix */

	'use strict';

	/* exported svgNS, locationHref, initialDefaultFrame */

	var svgNS = 'http://www.w3.org/2000/svg';

	var locationHref = '';

	var initialDefaultFrame = -999999;

	/* global createSizedArray */
	/* exported subframeEnabled, expressionsPlugin, isSafari, cachedColors, bmPow, bmSqrt, bmFloor, bmMax, bmMin, ProjectInterface,
	defaultCurveSegments, degToRads, roundCorner, bmRnd, styleDiv, BMEnterFrameEvent, BMCompleteEvent, BMCompleteLoopEvent,
	BMSegmentStartEvent, BMDestroyEvent, BMRenderFrameErrorEvent, BMConfigErrorEvent, BMAnimationConfigErrorEvent, createElementID,
	addSaturationToRGB, addBrightnessToRGB, addHueToRGB, rgbToHex */

	var subframeEnabled = true;
	var idPrefix = '';
	var expressionsPlugin;
	var isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
	var cachedColors = {};
	var bmRnd;
	var bmPow = Math.pow;
	var bmSqrt = Math.sqrt;
	var bmFloor = Math.floor;
	var bmMax = Math.max;
	var bmMin = Math.min;

	var BMMath = {};
	(function () {
	  var propertyNames = ['abs', 'acos', 'acosh', 'asin', 'asinh', 'atan', 'atanh', 'atan2', 'ceil', 'cbrt', 'expm1', 'clz32', 'cos', 'cosh', 'exp', 'floor', 'fround', 'hypot', 'imul', 'log', 'log1p', 'log2', 'log10', 'max', 'min', 'pow', 'random', 'round', 'sign', 'sin', 'sinh', 'sqrt', 'tan', 'tanh', 'trunc', 'E', 'LN10', 'LN2', 'LOG10E', 'LOG2E', 'PI', 'SQRT1_2', 'SQRT2'];
	  var i;
	  var len = propertyNames.length;
	  for (i = 0; i < len; i += 1) {
	    BMMath[propertyNames[i]] = Math[propertyNames[i]];
	  }
	}());

	function ProjectInterface() { return {}; }

	BMMath.random = Math.random;
	BMMath.abs = function (val) {
	  var tOfVal = typeof val;
	  if (tOfVal === 'object' && val.length) {
	    var absArr = createSizedArray(val.length);
	    var i;
	    var len = val.length;
	    for (i = 0; i < len; i += 1) {
	      absArr[i] = Math.abs(val[i]);
	    }
	    return absArr;
	  }
	  return Math.abs(val);
	};
	var defaultCurveSegments = 150;
	var degToRads = Math.PI / 180;
	var roundCorner = 0.5519;

	function roundValues(flag) {
	  if (flag) {
	    bmRnd = Math.round;
	  } else {
	    bmRnd = function (val) {
	      return val;
	    };
	  }
	}
	roundValues(false);

	function styleDiv(element) {
	  element.style.position = 'absolute';
	  element.style.top = 0;
	  element.style.left = 0;
	  element.style.display = 'block';
	  element.style.transformOrigin = '0 0';
	  element.style.webkitTransformOrigin = '0 0';
	  element.style.backfaceVisibility = 'visible';
	  element.style.webkitBackfaceVisibility = 'visible';
	  element.style.transformStyle = 'preserve-3d';
	  element.style.webkitTransformStyle = 'preserve-3d';
	  element.style.mozTransformStyle = 'preserve-3d';
	}

	function BMEnterFrameEvent(type, currentTime, totalTime, frameMultiplier) {
	  this.type = type;
	  this.currentTime = currentTime;
	  this.totalTime = totalTime;
	  this.direction = frameMultiplier < 0 ? -1 : 1;
	}

	function BMCompleteEvent(type, frameMultiplier) {
	  this.type = type;
	  this.direction = frameMultiplier < 0 ? -1 : 1;
	}

	function BMCompleteLoopEvent(type, totalLoops, currentLoop, frameMultiplier) {
	  this.type = type;
	  this.currentLoop = currentLoop;
	  this.totalLoops = totalLoops;
	  this.direction = frameMultiplier < 0 ? -1 : 1;
	}

	function BMSegmentStartEvent(type, firstFrame, totalFrames) {
	  this.type = type;
	  this.firstFrame = firstFrame;
	  this.totalFrames = totalFrames;
	}

	function BMDestroyEvent(type, target) {
	  this.type = type;
	  this.target = target;
	}

	function BMRenderFrameErrorEvent(nativeError, currentTime) {
	  this.type = 'renderFrameError';
	  this.nativeError = nativeError;
	  this.currentTime = currentTime;
	}

	function BMConfigErrorEvent(nativeError) {
	  this.type = 'configError';
	  this.nativeError = nativeError;
	}

	function BMAnimationConfigErrorEvent(type, nativeError) {
	  this.type = type;
	  this.nativeError = nativeError;
	}

	var createElementID = (function () {
	  var _count = 0;
	  return function createID() {
	    _count += 1;
	    return idPrefix + '__lottie_element_' + _count;
	  };
	}());

	function HSVtoRGB(h, s, v) {
	  var r;
	  var g;
	  var b;
	  var i;
	  var f;
	  var p;
	  var q;
	  var t;
	  i = Math.floor(h * 6);
	  f = h * 6 - i;
	  p = v * (1 - s);
	  q = v * (1 - f * s);
	  t = v * (1 - (1 - f) * s);
	  switch (i % 6) {
	    case 0: r = v; g = t; b = p; break;
	    case 1: r = q; g = v; b = p; break;
	    case 2: r = p; g = v; b = t; break;
	    case 3: r = p; g = q; b = v; break;
	    case 4: r = t; g = p; b = v; break;
	    case 5: r = v; g = p; b = q; break;
	    default: break;
	  }
	  return [r,
	    g,
	    b];
	}

	function RGBtoHSV(r, g, b) {
	  var max = Math.max(r, g, b);
	  var min = Math.min(r, g, b);
	  var d = max - min;
	  var h;
	  var s = (max === 0 ? 0 : d / max);
	  var v = max / 255;

	  switch (max) {
	    case min: h = 0; break;
	    case r: h = (g - b) + d * (g < b ? 6 : 0); h /= 6 * d; break;
	    case g: h = (b - r) + d * 2; h /= 6 * d; break;
	    case b: h = (r - g) + d * 4; h /= 6 * d; break;
	    default: break;
	  }

	  return [
	    h,
	    s,
	    v,
	  ];
	}

	function addSaturationToRGB(color, offset) {
	  var hsv = RGBtoHSV(color[0] * 255, color[1] * 255, color[2] * 255);
	  hsv[1] += offset;
	  if (hsv[1] > 1) {
	    hsv[1] = 1;
	  } else if (hsv[1] <= 0) {
	    hsv[1] = 0;
	  }
	  return HSVtoRGB(hsv[0], hsv[1], hsv[2]);
	}

	function addBrightnessToRGB(color, offset) {
	  var hsv = RGBtoHSV(color[0] * 255, color[1] * 255, color[2] * 255);
	  hsv[2] += offset;
	  if (hsv[2] > 1) {
	    hsv[2] = 1;
	  } else if (hsv[2] < 0) {
	    hsv[2] = 0;
	  }
	  return HSVtoRGB(hsv[0], hsv[1], hsv[2]);
	}

	function addHueToRGB(color, offset) {
	  var hsv = RGBtoHSV(color[0] * 255, color[1] * 255, color[2] * 255);
	  hsv[0] += offset / 360;
	  if (hsv[0] > 1) {
	    hsv[0] -= 1;
	  } else if (hsv[0] < 0) {
	    hsv[0] += 1;
	  }
	  return HSVtoRGB(hsv[0], hsv[1], hsv[2]);
	}

	var rgbToHex = (function () {
	  var colorMap = [];
	  var i;
	  var hex;
	  for (i = 0; i < 256; i += 1) {
	    hex = i.toString(16);
	    colorMap[i] = hex.length === 1 ? '0' + hex : hex;
	  }

	  return function (r, g, b) {
	    if (r < 0) {
	      r = 0;
	    }
	    if (g < 0) {
	      g = 0;
	    }
	    if (b < 0) {
	      b = 0;
	    }
	    return '#' + colorMap[r] + colorMap[g] + colorMap[b];
	  };
	}());

	function BaseEvent() {}
	BaseEvent.prototype = {
	  triggerEvent: function (eventName, args) {
	    if (this._cbs[eventName]) {
	      var callbacks = this._cbs[eventName];
	      for (var i = 0; i < callbacks.length; i += 1) {
	        callbacks[i](args);
	      }
	    }
	  },
	  addEventListener: function (eventName, callback) {
	    if (!this._cbs[eventName]) {
	      this._cbs[eventName] = [];
	    }
	    this._cbs[eventName].push(callback);

	    return function () {
	      this.removeEventListener(eventName, callback);
	    }.bind(this);
	  },
	  removeEventListener: function (eventName, callback) {
	    if (!callback) {
	      this._cbs[eventName] = null;
	    } else if (this._cbs[eventName]) {
	      var i = 0;
	      var len = this._cbs[eventName].length;
	      while (i < len) {
	        if (this._cbs[eventName][i] === callback) {
	          this._cbs[eventName].splice(i, 1);
	          i -= 1;
	          len -= 1;
	        }
	        i += 1;
	      }
	      if (!this._cbs[eventName].length) {
	        this._cbs[eventName] = null;
	      }
	    }
	  },
	};

	/* exported createTypedArray, createSizedArray */

	var createTypedArray = (function () {
	  function createRegularArray(type, len) {
	    var i = 0;
	    var arr = [];
	    var value;
	    switch (type) {
	      case 'int16':
	      case 'uint8c':
	        value = 1;
	        break;
	      default:
	        value = 1.1;
	        break;
	    }
	    for (i = 0; i < len; i += 1) {
	      arr.push(value);
	    }
	    return arr;
	  }
	  function createTypedArrayFactory(type, len) {
	    if (type === 'float32') {
	      return new Float32Array(len);
	    } if (type === 'int16') {
	      return new Int16Array(len);
	    } if (type === 'uint8c') {
	      return new Uint8ClampedArray(len);
	    }
	    return createRegularArray(type, len);
	  }
	  if (typeof Uint8ClampedArray === 'function' && typeof Float32Array === 'function') {
	    return createTypedArrayFactory;
	  }
	  return createRegularArray;
	}());

	function createSizedArray(len) {
	  return Array.apply(null, { length: len });
	}

	/* global svgNS */
	/* exported createNS */

	function createNS(type) {
	  // return {appendChild:function(){},setAttribute:function(){},style:{}}
	  return document.createElementNS(svgNS, type);
	}

	/* exported createTag */

	function createTag(type) {
	  // return {appendChild:function(){},setAttribute:function(){},style:{}}
	  return document.createElement(type);
	}

	function DynamicPropertyContainer() {}
	DynamicPropertyContainer.prototype = {
	  addDynamicProperty: function (prop) {
	    if (this.dynamicProperties.indexOf(prop) === -1) {
	      this.dynamicProperties.push(prop);
	      this.container.addDynamicProperty(this);
	      this._isAnimated = true;
	    }
	  },
	  iterateDynamicProperties: function () {
	    this._mdf = false;
	    var i;
	    var len = this.dynamicProperties.length;
	    for (i = 0; i < len; i += 1) {
	      this.dynamicProperties[i].getValue();
	      if (this.dynamicProperties[i]._mdf) {
	        this._mdf = true;
	      }
	    }
	  },
	  initDynamicPropertyContainer: function (container) {
	    this.container = container;
	    this.dynamicProperties = [];
	    this._mdf = false;
	    this._isAnimated = false;
	  },
	};

	/* exported getBlendMode */

	var getBlendMode = (function () {
	  var blendModeEnums = {
	    0: 'source-over',
	    1: 'multiply',
	    2: 'screen',
	    3: 'overlay',
	    4: 'darken',
	    5: 'lighten',
	    6: 'color-dodge',
	    7: 'color-burn',
	    8: 'hard-light',
	    9: 'soft-light',
	    10: 'difference',
	    11: 'exclusion',
	    12: 'hue',
	    13: 'saturation',
	    14: 'color',
	    15: 'luminosity',
	  };

	  return function (mode) {
	    return blendModeEnums[mode] || '';
	  };
	}());

	/* exported lineCapEnum, lineJoinEnum */

	var lineCapEnum = {
	  1: 'butt',
	  2: 'round',
	  3: 'square',
	};

	var lineJoinEnum = {
	  1: 'miter',
	  2: 'round',
	  3: 'bevel',
	};

	/* global createTypedArray */

	/*!
	 Transformation Matrix v2.0
	 (c) Epistemex 2014-2015
	 www.epistemex.com
	 By Ken Fyrstenberg
	 Contributions by leeoniya.
	 License: MIT, header required.
	 */

	/**
	 * 2D transformation matrix object initialized with identity matrix.
	 *
	 * The matrix can synchronize a canvas context by supplying the context
	 * as an argument, or later apply current absolute transform to an
	 * existing context.
	 *
	 * All values are handled as floating point values.
	 *
	 * @param {CanvasRenderingContext2D} [context] - Optional context to sync with Matrix
	 * @prop {number} a - scale x
	 * @prop {number} b - shear y
	 * @prop {number} c - shear x
	 * @prop {number} d - scale y
	 * @prop {number} e - translate x
	 * @prop {number} f - translate y
	 * @prop {CanvasRenderingContext2D|null} [context=null] - set or get current canvas context
	 * @constructor
	 */

	var Matrix = (function () {
	  var _cos = Math.cos;
	  var _sin = Math.sin;
	  var _tan = Math.tan;
	  var _rnd = Math.round;

	  function reset() {
	    this.props[0] = 1;
	    this.props[1] = 0;
	    this.props[2] = 0;
	    this.props[3] = 0;
	    this.props[4] = 0;
	    this.props[5] = 1;
	    this.props[6] = 0;
	    this.props[7] = 0;
	    this.props[8] = 0;
	    this.props[9] = 0;
	    this.props[10] = 1;
	    this.props[11] = 0;
	    this.props[12] = 0;
	    this.props[13] = 0;
	    this.props[14] = 0;
	    this.props[15] = 1;
	    return this;
	  }

	  function rotate(angle) {
	    if (angle === 0) {
	      return this;
	    }
	    var mCos = _cos(angle);
	    var mSin = _sin(angle);
	    return this._t(mCos, -mSin, 0, 0, mSin, mCos, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
	  }

	  function rotateX(angle) {
	    if (angle === 0) {
	      return this;
	    }
	    var mCos = _cos(angle);
	    var mSin = _sin(angle);
	    return this._t(1, 0, 0, 0, 0, mCos, -mSin, 0, 0, mSin, mCos, 0, 0, 0, 0, 1);
	  }

	  function rotateY(angle) {
	    if (angle === 0) {
	      return this;
	    }
	    var mCos = _cos(angle);
	    var mSin = _sin(angle);
	    return this._t(mCos, 0, mSin, 0, 0, 1, 0, 0, -mSin, 0, mCos, 0, 0, 0, 0, 1);
	  }

	  function rotateZ(angle) {
	    if (angle === 0) {
	      return this;
	    }
	    var mCos = _cos(angle);
	    var mSin = _sin(angle);
	    return this._t(mCos, -mSin, 0, 0, mSin, mCos, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
	  }

	  function shear(sx, sy) {
	    return this._t(1, sy, sx, 1, 0, 0);
	  }

	  function skew(ax, ay) {
	    return this.shear(_tan(ax), _tan(ay));
	  }

	  function skewFromAxis(ax, angle) {
	    var mCos = _cos(angle);
	    var mSin = _sin(angle);
	    return this._t(mCos, mSin, 0, 0, -mSin, mCos, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)
	      ._t(1, 0, 0, 0, _tan(ax), 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)
	      ._t(mCos, -mSin, 0, 0, mSin, mCos, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
	    // return this._t(mCos, mSin, -mSin, mCos, 0, 0)._t(1, 0, _tan(ax), 1, 0, 0)._t(mCos, -mSin, mSin, mCos, 0, 0);
	  }

	  function scale(sx, sy, sz) {
	    if (!sz && sz !== 0) {
	      sz = 1;
	    }
	    if (sx === 1 && sy === 1 && sz === 1) {
	      return this;
	    }
	    return this._t(sx, 0, 0, 0, 0, sy, 0, 0, 0, 0, sz, 0, 0, 0, 0, 1);
	  }

	  function setTransform(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p) {
	    this.props[0] = a;
	    this.props[1] = b;
	    this.props[2] = c;
	    this.props[3] = d;
	    this.props[4] = e;
	    this.props[5] = f;
	    this.props[6] = g;
	    this.props[7] = h;
	    this.props[8] = i;
	    this.props[9] = j;
	    this.props[10] = k;
	    this.props[11] = l;
	    this.props[12] = m;
	    this.props[13] = n;
	    this.props[14] = o;
	    this.props[15] = p;
	    return this;
	  }

	  function translate(tx, ty, tz) {
	    tz = tz || 0;
	    if (tx !== 0 || ty !== 0 || tz !== 0) {
	      return this._t(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, tx, ty, tz, 1);
	    }
	    return this;
	  }

	  function transform(a2, b2, c2, d2, e2, f2, g2, h2, i2, j2, k2, l2, m2, n2, o2, p2) {
	    var _p = this.props;

	    if (a2 === 1 && b2 === 0 && c2 === 0 && d2 === 0 && e2 === 0 && f2 === 1 && g2 === 0 && h2 === 0 && i2 === 0 && j2 === 0 && k2 === 1 && l2 === 0) {
	      // NOTE: commenting this condition because TurboFan deoptimizes code when present
	      // if(m2 !== 0 || n2 !== 0 || o2 !== 0){
	      _p[12] = _p[12] * a2 + _p[15] * m2;
	      _p[13] = _p[13] * f2 + _p[15] * n2;
	      _p[14] = _p[14] * k2 + _p[15] * o2;
	      _p[15] *= p2;
	      // }
	      this._identityCalculated = false;
	      return this;
	    }

	    var a1 = _p[0];
	    var b1 = _p[1];
	    var c1 = _p[2];
	    var d1 = _p[3];
	    var e1 = _p[4];
	    var f1 = _p[5];
	    var g1 = _p[6];
	    var h1 = _p[7];
	    var i1 = _p[8];
	    var j1 = _p[9];
	    var k1 = _p[10];
	    var l1 = _p[11];
	    var m1 = _p[12];
	    var n1 = _p[13];
	    var o1 = _p[14];
	    var p1 = _p[15];

	    /* matrix order (canvas compatible):
	         * ace
	         * bdf
	         * 001
	         */
	    _p[0] = a1 * a2 + b1 * e2 + c1 * i2 + d1 * m2;
	    _p[1] = a1 * b2 + b1 * f2 + c1 * j2 + d1 * n2;
	    _p[2] = a1 * c2 + b1 * g2 + c1 * k2 + d1 * o2;
	    _p[3] = a1 * d2 + b1 * h2 + c1 * l2 + d1 * p2;

	    _p[4] = e1 * a2 + f1 * e2 + g1 * i2 + h1 * m2;
	    _p[5] = e1 * b2 + f1 * f2 + g1 * j2 + h1 * n2;
	    _p[6] = e1 * c2 + f1 * g2 + g1 * k2 + h1 * o2;
	    _p[7] = e1 * d2 + f1 * h2 + g1 * l2 + h1 * p2;

	    _p[8] = i1 * a2 + j1 * e2 + k1 * i2 + l1 * m2;
	    _p[9] = i1 * b2 + j1 * f2 + k1 * j2 + l1 * n2;
	    _p[10] = i1 * c2 + j1 * g2 + k1 * k2 + l1 * o2;
	    _p[11] = i1 * d2 + j1 * h2 + k1 * l2 + l1 * p2;

	    _p[12] = m1 * a2 + n1 * e2 + o1 * i2 + p1 * m2;
	    _p[13] = m1 * b2 + n1 * f2 + o1 * j2 + p1 * n2;
	    _p[14] = m1 * c2 + n1 * g2 + o1 * k2 + p1 * o2;
	    _p[15] = m1 * d2 + n1 * h2 + o1 * l2 + p1 * p2;

	    this._identityCalculated = false;
	    return this;
	  }

	  function isIdentity() {
	    if (!this._identityCalculated) {
	      this._identity = !(this.props[0] !== 1 || this.props[1] !== 0 || this.props[2] !== 0 || this.props[3] !== 0 || this.props[4] !== 0 || this.props[5] !== 1 || this.props[6] !== 0 || this.props[7] !== 0 || this.props[8] !== 0 || this.props[9] !== 0 || this.props[10] !== 1 || this.props[11] !== 0 || this.props[12] !== 0 || this.props[13] !== 0 || this.props[14] !== 0 || this.props[15] !== 1);
	      this._identityCalculated = true;
	    }
	    return this._identity;
	  }

	  function equals(matr) {
	    var i = 0;
	    while (i < 16) {
	      if (matr.props[i] !== this.props[i]) {
	        return false;
	      }
	      i += 1;
	    }
	    return true;
	  }

	  function clone(matr) {
	    var i;
	    for (i = 0; i < 16; i += 1) {
	      matr.props[i] = this.props[i];
	    }
	    return matr;
	  }

	  function cloneFromProps(props) {
	    var i;
	    for (i = 0; i < 16; i += 1) {
	      this.props[i] = props[i];
	    }
	  }

	  function applyToPoint(x, y, z) {
	    return {
	      x: x * this.props[0] + y * this.props[4] + z * this.props[8] + this.props[12],
	      y: x * this.props[1] + y * this.props[5] + z * this.props[9] + this.props[13],
	      z: x * this.props[2] + y * this.props[6] + z * this.props[10] + this.props[14],
	    };
	    /* return {
	         x: x * me.a + y * me.c + me.e,
	         y: x * me.b + y * me.d + me.f
	         }; */
	  }
	  function applyToX(x, y, z) {
	    return x * this.props[0] + y * this.props[4] + z * this.props[8] + this.props[12];
	  }
	  function applyToY(x, y, z) {
	    return x * this.props[1] + y * this.props[5] + z * this.props[9] + this.props[13];
	  }
	  function applyToZ(x, y, z) {
	    return x * this.props[2] + y * this.props[6] + z * this.props[10] + this.props[14];
	  }

	  function getInverseMatrix() {
	    var determinant = this.props[0] * this.props[5] - this.props[1] * this.props[4];
	    var a = this.props[5] / determinant;
	    var b = -this.props[1] / determinant;
	    var c = -this.props[4] / determinant;
	    var d = this.props[0] / determinant;
	    var e = (this.props[4] * this.props[13] - this.props[5] * this.props[12]) / determinant;
	    var f = -(this.props[0] * this.props[13] - this.props[1] * this.props[12]) / determinant;
	    var inverseMatrix = new Matrix();
	    inverseMatrix.props[0] = a;
	    inverseMatrix.props[1] = b;
	    inverseMatrix.props[4] = c;
	    inverseMatrix.props[5] = d;
	    inverseMatrix.props[12] = e;
	    inverseMatrix.props[13] = f;
	    return inverseMatrix;
	  }

	  function inversePoint(pt) {
	    var inverseMatrix = this.getInverseMatrix();
	    return inverseMatrix.applyToPointArray(pt[0], pt[1], pt[2] || 0);
	  }

	  function inversePoints(pts) {
	    var i;
	    var len = pts.length;
	    var retPts = [];
	    for (i = 0; i < len; i += 1) {
	      retPts[i] = inversePoint(pts[i]);
	    }
	    return retPts;
	  }

	  function applyToTriplePoints(pt1, pt2, pt3) {
	    var arr = createTypedArray('float32', 6);
	    if (this.isIdentity()) {
	      arr[0] = pt1[0];
	      arr[1] = pt1[1];
	      arr[2] = pt2[0];
	      arr[3] = pt2[1];
	      arr[4] = pt3[0];
	      arr[5] = pt3[1];
	    } else {
	      var p0 = this.props[0];
	      var p1 = this.props[1];
	      var p4 = this.props[4];
	      var p5 = this.props[5];
	      var p12 = this.props[12];
	      var p13 = this.props[13];
	      arr[0] = pt1[0] * p0 + pt1[1] * p4 + p12;
	      arr[1] = pt1[0] * p1 + pt1[1] * p5 + p13;
	      arr[2] = pt2[0] * p0 + pt2[1] * p4 + p12;
	      arr[3] = pt2[0] * p1 + pt2[1] * p5 + p13;
	      arr[4] = pt3[0] * p0 + pt3[1] * p4 + p12;
	      arr[5] = pt3[0] * p1 + pt3[1] * p5 + p13;
	    }
	    return arr;
	  }

	  function applyToPointArray(x, y, z) {
	    var arr;
	    if (this.isIdentity()) {
	      arr = [x, y, z];
	    } else {
	      arr = [
	        x * this.props[0] + y * this.props[4] + z * this.props[8] + this.props[12],
	        x * this.props[1] + y * this.props[5] + z * this.props[9] + this.props[13],
	        x * this.props[2] + y * this.props[6] + z * this.props[10] + this.props[14],
	      ];
	    }
	    return arr;
	  }

	  function applyToPointStringified(x, y) {
	    if (this.isIdentity()) {
	      return x + ',' + y;
	    }
	    var _p = this.props;
	    return Math.round((x * _p[0] + y * _p[4] + _p[12]) * 100) / 100 + ',' + Math.round((x * _p[1] + y * _p[5] + _p[13]) * 100) / 100;
	  }

	  function toCSS() {
	    // Doesn't make much sense to add this optimization. If it is an identity matrix, it's very likely this will get called only once since it won't be keyframed.
	    /* if(this.isIdentity()) {
	            return '';
	        } */
	    var i = 0;
	    var props = this.props;
	    var cssValue = 'matrix3d(';
	    var v = 10000;
	    while (i < 16) {
	      cssValue += _rnd(props[i] * v) / v;
	      cssValue += i === 15 ? ')' : ',';
	      i += 1;
	    }
	    return cssValue;
	  }

	  function roundMatrixProperty(val) {
	    var v = 10000;
	    if ((val < 0.000001 && val > 0) || (val > -0.000001 && val < 0)) {
	      return _rnd(val * v) / v;
	    }
	    return val;
	  }

	  function to2dCSS() {
	    // Doesn't make much sense to add this optimization. If it is an identity matrix, it's very likely this will get called only once since it won't be keyframed.
	    /* if(this.isIdentity()) {
	            return '';
	        } */
	    var props = this.props;
	    var _a = roundMatrixProperty(props[0]);
	    var _b = roundMatrixProperty(props[1]);
	    var _c = roundMatrixProperty(props[4]);
	    var _d = roundMatrixProperty(props[5]);
	    var _e = roundMatrixProperty(props[12]);
	    var _f = roundMatrixProperty(props[13]);
	    return 'matrix(' + _a + ',' + _b + ',' + _c + ',' + _d + ',' + _e + ',' + _f + ')';
	  }

	  return function () {
	    this.reset = reset;
	    this.rotate = rotate;
	    this.rotateX = rotateX;
	    this.rotateY = rotateY;
	    this.rotateZ = rotateZ;
	    this.skew = skew;
	    this.skewFromAxis = skewFromAxis;
	    this.shear = shear;
	    this.scale = scale;
	    this.setTransform = setTransform;
	    this.translate = translate;
	    this.transform = transform;
	    this.applyToPoint = applyToPoint;
	    this.applyToX = applyToX;
	    this.applyToY = applyToY;
	    this.applyToZ = applyToZ;
	    this.applyToPointArray = applyToPointArray;
	    this.applyToTriplePoints = applyToTriplePoints;
	    this.applyToPointStringified = applyToPointStringified;
	    this.toCSS = toCSS;
	    this.to2dCSS = to2dCSS;
	    this.clone = clone;
	    this.cloneFromProps = cloneFromProps;
	    this.equals = equals;
	    this.inversePoints = inversePoints;
	    this.inversePoint = inversePoint;
	    this.getInverseMatrix = getInverseMatrix;
	    this._t = this.transform;
	    this.isIdentity = isIdentity;
	    this._identity = true;
	    this._identityCalculated = false;

	    this.props = createTypedArray('float32', 16);
	    this.reset();
	  };
	}());

	/* eslint-disable */
	/*
	 Copyright 2014 David Bau.

	 Permission is hereby granted, free of charge, to any person obtaining
	 a copy of this software and associated documentation files (the
	 "Software"), to deal in the Software without restriction, including
	 without limitation the rights to use, copy, modify, merge, publish,
	 distribute, sublicense, and/or sell copies of the Software, and to
	 permit persons to whom the Software is furnished to do so, subject to
	 the following conditions:

	 The above copyright notice and this permission notice shall be
	 included in all copies or substantial portions of the Software.

	 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	 EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	 MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
	 IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
	 CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
	 TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
	 SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

	 */

	(function (pool, math) {
	//
	// The following constants are related to IEEE 754 limits.
	//
	    var global = this,
	        width = 256,        // each RC4 output is 0 <= x < 256
	        chunks = 6,         // at least six RC4 outputs for each double
	        digits = 52,        // there are 52 significant digits in a double
	        rngname = 'random', // rngname: name for Math.random and Math.seedrandom
	        startdenom = math.pow(width, chunks),
	        significance = math.pow(2, digits),
	        overflow = significance * 2,
	        mask = width - 1,
	        nodecrypto;         // node.js crypto module, initialized at the bottom.

	//
	// seedrandom()
	// This is the seedrandom function described above.
	//
	    function seedrandom(seed, options, callback) {
	        var key = [];
	        options = (options === true) ? { entropy: true } : (options || {});

	        // Flatten the seed string or build one from local entropy if needed.
	        var shortseed = mixkey(flatten(
	            options.entropy ? [seed, tostring(pool)] :
	                (seed === null) ? autoseed() : seed, 3), key);

	        // Use the seed to initialize an ARC4 generator.
	        var arc4 = new ARC4(key);

	        // This function returns a random double in [0, 1) that contains
	        // randomness in every bit of the mantissa of the IEEE 754 value.
	        var prng = function() {
	            var n = arc4.g(chunks),             // Start with a numerator n < 2 ^ 48
	                d = startdenom,                 //   and denominator d = 2 ^ 48.
	                x = 0;                          //   and no 'extra last byte'.
	            while (n < significance) {          // Fill up all significant digits by
	                n = (n + x) * width;              //   shifting numerator and
	                d *= width;                       //   denominator and generating a
	                x = arc4.g(1);                    //   new least-significant-byte.
	            }
	            while (n >= overflow) {             // To avoid rounding up, before adding
	                n /= 2;                           //   last byte, shift everything
	                d /= 2;                           //   right using integer math until
	                x >>>= 1;                         //   we have exactly the desired bits.
	            }
	            return (n + x) / d;                 // Form the number within [0, 1).
	        };

	        prng.int32 = function() { return arc4.g(4) | 0; };
	        prng.quick = function() { return arc4.g(4) / 0x100000000; };
	        prng.double = prng;

	        // Mix the randomness into accumulated entropy.
	        mixkey(tostring(arc4.S), pool);

	        // Calling convention: what to return as a function of prng, seed, is_math.
	        return (options.pass || callback ||
	        function(prng, seed, is_math_call, state) {
	            if (state) {
	                // Load the arc4 state from the given state if it has an S array.
	                if (state.S) { copy(state, arc4); }
	                // Only provide the .state method if requested via options.state.
	                prng.state = function() { return copy(arc4, {}); };
	            }

	            // If called as a method of Math (Math.seedrandom()), mutate
	            // Math.random because that is how seedrandom.js has worked since v1.0.
	            if (is_math_call) { math[rngname] = prng; return seed; }

	            // Otherwise, it is a newer calling convention, so return the
	            // prng directly.
	            else return prng;
	        })(
	            prng,
	            shortseed,
	            'global' in options ? options.global : (this == math),
	            options.state);
	    }
	    math['seed' + rngname] = seedrandom;

	//
	// ARC4
	//
	// An ARC4 implementation.  The constructor takes a key in the form of
	// an array of at most (width) integers that should be 0 <= x < (width).
	//
	// The g(count) method returns a pseudorandom integer that concatenates
	// the next (count) outputs from ARC4.  Its return value is a number x
	// that is in the range 0 <= x < (width ^ count).
	//
	    function ARC4(key) {
	        var t, keylen = key.length,
	            me = this, i = 0, j = me.i = me.j = 0, s = me.S = [];

	        // The empty key [] is treated as [0].
	        if (!keylen) { key = [keylen++]; }

	        // Set up S using the standard key scheduling algorithm.
	        while (i < width) {
	            s[i] = i++;
	        }
	        for (i = 0; i < width; i++) {
	            s[i] = s[j = mask & (j + key[i % keylen] + (t = s[i]))];
	            s[j] = t;
	        }

	        // The "g" method returns the next (count) outputs as one number.
	        me.g = function(count) {
	            // Using instance members instead of closure state nearly doubles speed.
	            var t, r = 0,
	                i = me.i, j = me.j, s = me.S;
	            while (count--) {
	                t = s[i = mask & (i + 1)];
	                r = r * width + s[mask & ((s[i] = s[j = mask & (j + t)]) + (s[j] = t))];
	            }
	            me.i = i; me.j = j;
	            return r;
	            // For robust unpredictability, the function call below automatically
	            // discards an initial batch of values.  This is called RC4-drop[256].
	            // See http://google.com/search?q=rsa+fluhrer+response&btnI
	        };
	    }

	//
	// copy()
	// Copies internal state of ARC4 to or from a plain object.
	//
	    function copy(f, t) {
	        t.i = f.i;
	        t.j = f.j;
	        t.S = f.S.slice();
	        return t;
	    }

	//
	// flatten()
	// Converts an object tree to nested arrays of strings.
	//
	    function flatten(obj, depth) {
	        var result = [], typ = (typeof obj), prop;
	        if (depth && typ == 'object') {
	            for (prop in obj) {
	                try { result.push(flatten(obj[prop], depth - 1)); } catch (e) {}
	            }
	        }
	        return (result.length ? result : typ == 'string' ? obj : obj + '\0');
	    }

	//
	// mixkey()
	// Mixes a string seed into a key that is an array of integers, and
	// returns a shortened string seed that is equivalent to the result key.
	//
	    function mixkey(seed, key) {
	        var stringseed = seed + '', smear, j = 0;
	        while (j < stringseed.length) {
	            key[mask & j] =
	                mask & ((smear ^= key[mask & j] * 19) + stringseed.charCodeAt(j++));
	        }
	        return tostring(key);
	    }

	//
	// autoseed()
	// Returns an object for autoseeding, using window.crypto and Node crypto
	// module if available.
	//
	    function autoseed() {
	        try {
	            if (nodecrypto) { return tostring(nodecrypto.randomBytes(width)); }
	            var out = new Uint8Array(width);
	            (global.crypto || global.msCrypto).getRandomValues(out);
	            return tostring(out);
	        } catch (e) {
	            var browser = global.navigator,
	                plugins = browser && browser.plugins;
	            return [+new Date(), global, plugins, global.screen, tostring(pool)];
	        }
	    }

	//
	// tostring()
	// Converts an array of charcodes to a string
	//
	    function tostring(a) {
	        return String.fromCharCode.apply(0, a);
	    }

	//
	// When seedrandom.js is loaded, we immediately mix a few bits
	// from the built-in RNG into the entropy pool.  Because we do
	// not want to interfere with deterministic PRNG state later,
	// seedrandom will not call math.random on its own again after
	// initialization.
	//
	    mixkey(math.random(), pool);

	//
	// Nodejs and AMD support: export the implementation as a module using
	// either convention.
	//

	// End anonymous scope, and pass initial values.
	})(
	    [],     // pool: entropy pool starts empty
	    BMMath    // math: package containing random, pow, and seedrandom
	);
	/* eslint-disable */
	var BezierFactory = (function () {
	  /**
	     * BezierEasing - use bezier curve for transition easing function
	     * by Gaëtan Renaudeau 2014 - 2015 – MIT License
	     *
	     * Credits: is based on Firefox's nsSMILKeySpline.cpp
	     * Usage:
	     * var spline = BezierEasing([ 0.25, 0.1, 0.25, 1.0 ])
	     * spline.get(x) => returns the easing value | x must be in [0, 1] range
	     *
	     */

	  var ob = {};
	  ob.getBezierEasing = getBezierEasing;
	  var beziers = {};

	  function getBezierEasing(a, b, c, d, nm) {
	    var str = nm || ('bez_' + a + '_' + b + '_' + c + '_' + d).replace(/\./g, 'p');
	    if (beziers[str]) {
	      return beziers[str];
	    }
	    var bezEasing = new BezierEasing([a, b, c, d]);
	    beziers[str] = bezEasing;
	    return bezEasing;
	  }

	  // These values are established by empiricism with tests (tradeoff: performance VS precision)
	  var NEWTON_ITERATIONS = 4;
	  var NEWTON_MIN_SLOPE = 0.001;
	  var SUBDIVISION_PRECISION = 0.0000001;
	  var SUBDIVISION_MAX_ITERATIONS = 10;

	  var kSplineTableSize = 11;
	  var kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);

	  var float32ArraySupported = typeof Float32Array === 'function';

	  function A(aA1, aA2) { return 1.0 - 3.0 * aA2 + 3.0 * aA1; }
	  function B(aA1, aA2) { return 3.0 * aA2 - 6.0 * aA1; }
	  function C(aA1) { return 3.0 * aA1; }

	  // Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.
	  function calcBezier(aT, aA1, aA2) {
	    return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;
	  }

	  // Returns dx/dt given t, x1, and x2, or dy/dt given t, y1, and y2.
	  function getSlope(aT, aA1, aA2) {
	    return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1);
	  }

	  function binarySubdivide(aX, aA, aB, mX1, mX2) {
	    var currentX,
	      currentT,
	      i = 0;
	    do {
	      currentT = aA + (aB - aA) / 2.0;
	      currentX = calcBezier(currentT, mX1, mX2) - aX;
	      if (currentX > 0.0) {
	        aB = currentT;
	      } else {
	        aA = currentT;
	      }
	    } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);
	    return currentT;
	  }

	  function newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {
	    for (var i = 0; i < NEWTON_ITERATIONS; ++i) {
	      var currentSlope = getSlope(aGuessT, mX1, mX2);
	      if (currentSlope === 0.0) return aGuessT;
	      var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
	      aGuessT -= currentX / currentSlope;
	    }
	    return aGuessT;
	  }

	  /**
	     * points is an array of [ mX1, mY1, mX2, mY2 ]
	     */
	  function BezierEasing(points) {
	    this._p = points;
	    this._mSampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);
	    this._precomputed = false;

	    this.get = this.get.bind(this);
	  }

	  BezierEasing.prototype = {

	    get: function (x) {
	      var mX1 = this._p[0],
	        mY1 = this._p[1],
	        mX2 = this._p[2],
	        mY2 = this._p[3];
	      if (!this._precomputed) this._precompute();
	      if (mX1 === mY1 && mX2 === mY2) return x; // linear
	      // Because JavaScript number are imprecise, we should guarantee the extremes are right.
	      if (x === 0) return 0;
	      if (x === 1) return 1;
	      return calcBezier(this._getTForX(x), mY1, mY2);
	    },

	    // Private part

	    _precompute: function () {
	      var mX1 = this._p[0],
	        mY1 = this._p[1],
	        mX2 = this._p[2],
	        mY2 = this._p[3];
	      this._precomputed = true;
	      if (mX1 !== mY1 || mX2 !== mY2) { this._calcSampleValues(); }
	    },

	    _calcSampleValues: function () {
	      var mX1 = this._p[0],
	        mX2 = this._p[2];
	      for (var i = 0; i < kSplineTableSize; ++i) {
	        this._mSampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);
	      }
	    },

	    /**
	         * getTForX chose the fastest heuristic to determine the percentage value precisely from a given X projection.
	         */
	    _getTForX: function (aX) {
	      var mX1 = this._p[0],
	        mX2 = this._p[2],
	        mSampleValues = this._mSampleValues;

	      var intervalStart = 0.0;
	      var currentSample = 1;
	      var lastSample = kSplineTableSize - 1;

	      for (; currentSample !== lastSample && mSampleValues[currentSample] <= aX; ++currentSample) {
	        intervalStart += kSampleStepSize;
	      }
	      --currentSample;

	      // Interpolate to provide an initial guess for t
	      var dist = (aX - mSampleValues[currentSample]) / (mSampleValues[currentSample + 1] - mSampleValues[currentSample]);
	      var guessForT = intervalStart + dist * kSampleStepSize;

	      var initialSlope = getSlope(guessForT, mX1, mX2);
	      if (initialSlope >= NEWTON_MIN_SLOPE) {
	        return newtonRaphsonIterate(aX, guessForT, mX1, mX2);
	      } if (initialSlope === 0.0) {
	        return guessForT;
	      }
	      return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);
	    },
	  };

	  return ob;
	}());

	(function () {
	  var lastTime = 0;
	  var vendors = ['ms', 'moz', 'webkit', 'o'];
	  for (var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) { // eslint-disable-line no-plusplus
	    window.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame'];
	    window.cancelAnimationFrame = window[vendors[x] + 'CancelAnimationFrame'] || window[vendors[x] + 'CancelRequestAnimationFrame'];
	  }
	  if (!window.requestAnimationFrame) {
	    window.requestAnimationFrame = function (callback) {
	      var currTime = new Date().getTime();
	      var timeToCall = Math.max(0, 16 - (currTime - lastTime));
	      var id = setTimeout(function () {
	        callback(currTime + timeToCall);
	      },
	      timeToCall);
	      lastTime = currTime + timeToCall;
	      return id;
	    };
	  }
	  if (!window.cancelAnimationFrame) {
	    window.cancelAnimationFrame = function (id) {
	      clearTimeout(id);
	    };
	  }
	}());

	/* exported extendPrototype, getDescriptor, createProxyFunction */

	function extendPrototype(sources, destination) {
	  var i;
	  var len = sources.length;
	  var sourcePrototype;
	  for (i = 0; i < len; i += 1) {
	    sourcePrototype = sources[i].prototype;
	    for (var attr in sourcePrototype) {
	      if (Object.prototype.hasOwnProperty.call(sourcePrototype, attr)) destination.prototype[attr] = sourcePrototype[attr];
	    }
	  }
	}

	function getDescriptor(object, prop) {
	  return Object.getOwnPropertyDescriptor(object, prop);
	}

	function createProxyFunction(prototype) {
	  function ProxyFunction() {}
	  ProxyFunction.prototype = prototype;
	  return ProxyFunction;
	}

	/* global segmentsLengthPool, defaultCurveSegments, createSizedArray, bmPow, bmSqrt, bmFloor, createTypedArray, bezierLengthPool */
	/* exported bez */

	function bezFunction() {
	  var math = Math;

	  function pointOnLine2D(x1, y1, x2, y2, x3, y3) {
	    var det1 = (x1 * y2) + (y1 * x3) + (x2 * y3) - (x3 * y2) - (y3 * x1) - (x2 * y1);
	    return det1 > -0.001 && det1 < 0.001;
	  }

	  function pointOnLine3D(x1, y1, z1, x2, y2, z2, x3, y3, z3) {
	    if (z1 === 0 && z2 === 0 && z3 === 0) {
	      return pointOnLine2D(x1, y1, x2, y2, x3, y3);
	    }
	    var dist1 = math.sqrt(math.pow(x2 - x1, 2) + math.pow(y2 - y1, 2) + math.pow(z2 - z1, 2));
	    var dist2 = math.sqrt(math.pow(x3 - x1, 2) + math.pow(y3 - y1, 2) + math.pow(z3 - z1, 2));
	    var dist3 = math.sqrt(math.pow(x3 - x2, 2) + math.pow(y3 - y2, 2) + math.pow(z3 - z2, 2));
	    var diffDist;
	    if (dist1 > dist2) {
	      if (dist1 > dist3) {
	        diffDist = dist1 - dist2 - dist3;
	      } else {
	        diffDist = dist3 - dist2 - dist1;
	      }
	    } else if (dist3 > dist2) {
	      diffDist = dist3 - dist2 - dist1;
	    } else {
	      diffDist = dist2 - dist1 - dist3;
	    }
	    return diffDist > -0.0001 && diffDist < 0.0001;
	  }

	  var getBezierLength = (function () {
	    return function (pt1, pt2, pt3, pt4) {
	      var curveSegments = defaultCurveSegments;
	      var k;
	      var i;
	      var len;
	      var ptCoord;
	      var perc;
	      var addedLength = 0;
	      var ptDistance;
	      var point = [];
	      var lastPoint = [];
	      var lengthData = bezierLengthPool.newElement();
	      len = pt3.length;
	      for (k = 0; k < curveSegments; k += 1) {
	        perc = k / (curveSegments - 1);
	        ptDistance = 0;
	        for (i = 0; i < len; i += 1) {
	          ptCoord = bmPow(1 - perc, 3) * pt1[i] + 3 * bmPow(1 - perc, 2) * perc * pt3[i] + 3 * (1 - perc) * bmPow(perc, 2) * pt4[i] + bmPow(perc, 3) * pt2[i];
	          point[i] = ptCoord;
	          if (lastPoint[i] !== null) {
	            ptDistance += bmPow(point[i] - lastPoint[i], 2);
	          }
	          lastPoint[i] = point[i];
	        }
	        if (ptDistance) {
	          ptDistance = bmSqrt(ptDistance);
	          addedLength += ptDistance;
	        }
	        lengthData.percents[k] = perc;
	        lengthData.lengths[k] = addedLength;
	      }
	      lengthData.addedLength = addedLength;
	      return lengthData;
	    };
	  }());

	  function getSegmentsLength(shapeData) {
	    var segmentsLength = segmentsLengthPool.newElement();
	    var closed = shapeData.c;
	    var pathV = shapeData.v;
	    var pathO = shapeData.o;
	    var pathI = shapeData.i;
	    var i;
	    var len = shapeData._length;
	    var lengths = segmentsLength.lengths;
	    var totalLength = 0;
	    for (i = 0; i < len - 1; i += 1) {
	      lengths[i] = getBezierLength(pathV[i], pathV[i + 1], pathO[i], pathI[i + 1]);
	      totalLength += lengths[i].addedLength;
	    }
	    if (closed && len) {
	      lengths[i] = getBezierLength(pathV[i], pathV[0], pathO[i], pathI[0]);
	      totalLength += lengths[i].addedLength;
	    }
	    segmentsLength.totalLength = totalLength;
	    return segmentsLength;
	  }

	  function BezierData(length) {
	    this.segmentLength = 0;
	    this.points = new Array(length);
	  }

	  function PointData(partial, point) {
	    this.partialLength = partial;
	    this.point = point;
	  }

	  var buildBezierData = (function () {
	    var storedData = {};

	    return function (pt1, pt2, pt3, pt4) {
	      var bezierName = (pt1[0] + '_' + pt1[1] + '_' + pt2[0] + '_' + pt2[1] + '_' + pt3[0] + '_' + pt3[1] + '_' + pt4[0] + '_' + pt4[1]).replace(/\./g, 'p');
	      if (!storedData[bezierName]) {
	        var curveSegments = defaultCurveSegments;
	        var k;
	        var i;
	        var len;
	        var ptCoord;
	        var perc;
	        var addedLength = 0;
	        var ptDistance;
	        var point;
	        var lastPoint = null;
	        if (pt1.length === 2 && (pt1[0] !== pt2[0] || pt1[1] !== pt2[1]) && pointOnLine2D(pt1[0], pt1[1], pt2[0], pt2[1], pt1[0] + pt3[0], pt1[1] + pt3[1]) && pointOnLine2D(pt1[0], pt1[1], pt2[0], pt2[1], pt2[0] + pt4[0], pt2[1] + pt4[1])) {
	          curveSegments = 2;
	        }
	        var bezierData = new BezierData(curveSegments);
	        len = pt3.length;
	        for (k = 0; k < curveSegments; k += 1) {
	          point = createSizedArray(len);
	          perc = k / (curveSegments - 1);
	          ptDistance = 0;
	          for (i = 0; i < len; i += 1) {
	            ptCoord = bmPow(1 - perc, 3) * pt1[i] + 3 * bmPow(1 - perc, 2) * perc * (pt1[i] + pt3[i]) + 3 * (1 - perc) * bmPow(perc, 2) * (pt2[i] + pt4[i]) + bmPow(perc, 3) * pt2[i];
	            point[i] = ptCoord;
	            if (lastPoint !== null) {
	              ptDistance += bmPow(point[i] - lastPoint[i], 2);
	            }
	          }
	          ptDistance = bmSqrt(ptDistance);
	          addedLength += ptDistance;
	          bezierData.points[k] = new PointData(ptDistance, point);
	          lastPoint = point;
	        }
	        bezierData.segmentLength = addedLength;
	        storedData[bezierName] = bezierData;
	      }
	      return storedData[bezierName];
	    };
	  }());

	  function getDistancePerc(perc, bezierData) {
	    var percents = bezierData.percents;
	    var lengths = bezierData.lengths;
	    var len = percents.length;
	    var initPos = bmFloor((len - 1) * perc);
	    var lengthPos = perc * bezierData.addedLength;
	    var lPerc = 0;
	    if (initPos === len - 1 || initPos === 0 || lengthPos === lengths[initPos]) {
	      return percents[initPos];
	    }
	    var dir = lengths[initPos] > lengthPos ? -1 : 1;
	    var flag = true;
	    while (flag) {
	      if (lengths[initPos] <= lengthPos && lengths[initPos + 1] > lengthPos) {
	        lPerc = (lengthPos - lengths[initPos]) / (lengths[initPos + 1] - lengths[initPos]);
	        flag = false;
	      } else {
	        initPos += dir;
	      }
	      if (initPos < 0 || initPos >= len - 1) {
	        // FIX for TypedArrays that don't store floating point values with enough accuracy
	        if (initPos === len - 1) {
	          return percents[initPos];
	        }
	        flag = false;
	      }
	    }
	    return percents[initPos] + (percents[initPos + 1] - percents[initPos]) * lPerc;
	  }

	  function getPointInSegment(pt1, pt2, pt3, pt4, percent, bezierData) {
	    var t1 = getDistancePerc(percent, bezierData);
	    var u1 = 1 - t1;
	    var ptX = math.round((u1 * u1 * u1 * pt1[0] + (t1 * u1 * u1 + u1 * t1 * u1 + u1 * u1 * t1) * pt3[0] + (t1 * t1 * u1 + u1 * t1 * t1 + t1 * u1 * t1) * pt4[0] + t1 * t1 * t1 * pt2[0]) * 1000) / 1000;
	    var ptY = math.round((u1 * u1 * u1 * pt1[1] + (t1 * u1 * u1 + u1 * t1 * u1 + u1 * u1 * t1) * pt3[1] + (t1 * t1 * u1 + u1 * t1 * t1 + t1 * u1 * t1) * pt4[1] + t1 * t1 * t1 * pt2[1]) * 1000) / 1000;
	    return [ptX, ptY];
	  }

	  var bezierSegmentPoints = createTypedArray('float32', 8);

	  function getNewSegment(pt1, pt2, pt3, pt4, startPerc, endPerc, bezierData) {
	    if (startPerc < 0) {
	      startPerc = 0;
	    } else if (startPerc > 1) {
	      startPerc = 1;
	    }
	    var t0 = getDistancePerc(startPerc, bezierData);
	    endPerc = endPerc > 1 ? 1 : endPerc;
	    var t1 = getDistancePerc(endPerc, bezierData);
	    var i;
	    var len = pt1.length;
	    var u0 = 1 - t0;
	    var u1 = 1 - t1;
	    var u0u0u0 = u0 * u0 * u0;
	    var t0u0u0_3 = t0 * u0 * u0 * 3; // eslint-disable-line camelcase
	    var t0t0u0_3 = t0 * t0 * u0 * 3; // eslint-disable-line camelcase
	    var t0t0t0 = t0 * t0 * t0;
	    //
	    var u0u0u1 = u0 * u0 * u1;
	    var t0u0u1_3 = t0 * u0 * u1 + u0 * t0 * u1 + u0 * u0 * t1; // eslint-disable-line camelcase
	    var t0t0u1_3 = t0 * t0 * u1 + u0 * t0 * t1 + t0 * u0 * t1; // eslint-disable-line camelcase
	    var t0t0t1 = t0 * t0 * t1;
	    //
	    var u0u1u1 = u0 * u1 * u1;
	    var t0u1u1_3 = t0 * u1 * u1 + u0 * t1 * u1 + u0 * u1 * t1; // eslint-disable-line camelcase
	    var t0t1u1_3 = t0 * t1 * u1 + u0 * t1 * t1 + t0 * u1 * t1; // eslint-disable-line camelcase
	    var t0t1t1 = t0 * t1 * t1;
	    //
	    var u1u1u1 = u1 * u1 * u1;
	    var t1u1u1_3 = t1 * u1 * u1 + u1 * t1 * u1 + u1 * u1 * t1; // eslint-disable-line camelcase
	    var t1t1u1_3 = t1 * t1 * u1 + u1 * t1 * t1 + t1 * u1 * t1; // eslint-disable-line camelcase
	    var t1t1t1 = t1 * t1 * t1;
	    for (i = 0; i < len; i += 1) {
	      bezierSegmentPoints[i * 4] = math.round((u0u0u0 * pt1[i] + t0u0u0_3 * pt3[i] + t0t0u0_3 * pt4[i] + t0t0t0 * pt2[i]) * 1000) / 1000; // eslint-disable-line camelcase
	      bezierSegmentPoints[i * 4 + 1] = math.round((u0u0u1 * pt1[i] + t0u0u1_3 * pt3[i] + t0t0u1_3 * pt4[i] + t0t0t1 * pt2[i]) * 1000) / 1000; // eslint-disable-line camelcase
	      bezierSegmentPoints[i * 4 + 2] = math.round((u0u1u1 * pt1[i] + t0u1u1_3 * pt3[i] + t0t1u1_3 * pt4[i] + t0t1t1 * pt2[i]) * 1000) / 1000; // eslint-disable-line camelcase
	      bezierSegmentPoints[i * 4 + 3] = math.round((u1u1u1 * pt1[i] + t1u1u1_3 * pt3[i] + t1t1u1_3 * pt4[i] + t1t1t1 * pt2[i]) * 1000) / 1000; // eslint-disable-line camelcase
	    }

	    return bezierSegmentPoints;
	  }

	  return {
	    getSegmentsLength: getSegmentsLength,
	    getNewSegment: getNewSegment,
	    getPointInSegment: getPointInSegment,
	    buildBezierData: buildBezierData,
	    pointOnLine2D: pointOnLine2D,
	    pointOnLine3D: pointOnLine3D,
	  };
	}

	var bez = bezFunction();

	/* exported dataManager */

	function dataFunctionManager() {
	  // var tCanvasHelper = createTag('canvas').getContext('2d');

	  function completeLayers(layers, comps, fontManager) {
	    var layerData;
	    var i;
	    var len = layers.length;
	    var j;
	    var jLen;
	    var k;
	    var kLen;
	    for (i = 0; i < len; i += 1) {
	      layerData = layers[i];
	      if (('ks' in layerData) && !layerData.completed) {
	        layerData.completed = true;
	        if (layerData.tt) {
	          layers[i - 1].td = layerData.tt;
	        }
	        if (layerData.hasMask) {
	          var maskProps = layerData.masksProperties;
	          jLen = maskProps.length;
	          for (j = 0; j < jLen; j += 1) {
	            if (maskProps[j].pt.k.i) {
	              convertPathsToAbsoluteValues(maskProps[j].pt.k);
	            } else {
	              kLen = maskProps[j].pt.k.length;
	              for (k = 0; k < kLen; k += 1) {
	                if (maskProps[j].pt.k[k].s) {
	                  convertPathsToAbsoluteValues(maskProps[j].pt.k[k].s[0]);
	                }
	                if (maskProps[j].pt.k[k].e) {
	                  convertPathsToAbsoluteValues(maskProps[j].pt.k[k].e[0]);
	                }
	              }
	            }
	          }
	        }
	        if (layerData.ty === 0) {
	          layerData.layers = findCompLayers(layerData.refId, comps);
	          completeLayers(layerData.layers, comps, fontManager);
	        } else if (layerData.ty === 4) {
	          completeShapes(layerData.shapes);
	        } else if (layerData.ty === 5) {
	          completeText(layerData, fontManager);
	        }
	      }
	    }
	  }

	  function findCompLayers(id, comps) {
	    var i = 0;
	    var len = comps.length;
	    while (i < len) {
	      if (comps[i].id === id) {
	        if (!comps[i].layers.__used) {
	          comps[i].layers.__used = true;
	          return comps[i].layers;
	        }
	        return JSON.parse(JSON.stringify(comps[i].layers));
	      }
	      i += 1;
	    }
	    return null;
	  }

	  function completeShapes(arr) {
	    var i;
	    var len = arr.length;
	    var j;
	    var jLen;
	    for (i = len - 1; i >= 0; i -= 1) {
	      if (arr[i].ty === 'sh') {
	        if (arr[i].ks.k.i) {
	          convertPathsToAbsoluteValues(arr[i].ks.k);
	        } else {
	          jLen = arr[i].ks.k.length;
	          for (j = 0; j < jLen; j += 1) {
	            if (arr[i].ks.k[j].s) {
	              convertPathsToAbsoluteValues(arr[i].ks.k[j].s[0]);
	            }
	            if (arr[i].ks.k[j].e) {
	              convertPathsToAbsoluteValues(arr[i].ks.k[j].e[0]);
	            }
	          }
	        }
	      } else if (arr[i].ty === 'gr') {
	        completeShapes(arr[i].it);
	      }
	    }
	  }

	  function convertPathsToAbsoluteValues(path) {
	    var i;
	    var len = path.i.length;
	    for (i = 0; i < len; i += 1) {
	      path.i[i][0] += path.v[i][0];
	      path.i[i][1] += path.v[i][1];
	      path.o[i][0] += path.v[i][0];
	      path.o[i][1] += path.v[i][1];
	    }
	  }

	  function checkVersion(minimum, animVersionString) {
	    var animVersion = animVersionString ? animVersionString.split('.') : [100, 100, 100];
	    if (minimum[0] > animVersion[0]) {
	      return true;
	    } if (animVersion[0] > minimum[0]) {
	      return false;
	    }
	    if (minimum[1] > animVersion[1]) {
	      return true;
	    } if (animVersion[1] > minimum[1]) {
	      return false;
	    }
	    if (minimum[2] > animVersion[2]) {
	      return true;
	    } if (animVersion[2] > minimum[2]) {
	      return false;
	    }
	    return null;
	  }

	  var checkText = (function () {
	    var minimumVersion = [4, 4, 14];

	    function updateTextLayer(textLayer) {
	      var documentData = textLayer.t.d;
	      textLayer.t.d = {
	        k: [
	          {
	            s: documentData,
	            t: 0,
	          },
	        ],
	      };
	    }

	    function iterateLayers(layers) {
	      var i;
	      var len = layers.length;
	      for (i = 0; i < len; i += 1) {
	        if (layers[i].ty === 5) {
	          updateTextLayer(layers[i]);
	        }
	      }
	    }

	    return function (animationData) {
	      if (checkVersion(minimumVersion, animationData.v)) {
	        iterateLayers(animationData.layers);
	        if (animationData.assets) {
	          var i;
	          var len = animationData.assets.length;
	          for (i = 0; i < len; i += 1) {
	            if (animationData.assets[i].layers) {
	              iterateLayers(animationData.assets[i].layers);
	            }
	          }
	        }
	      }
	    };
	  }());

	  var checkChars = (function () {
	    var minimumVersion = [4, 7, 99];
	    return function (animationData) {
	      if (animationData.chars && !checkVersion(minimumVersion, animationData.v)) {
	        var i;
	        var len = animationData.chars.length;
	        var j;
	        var jLen;
	        var pathData;
	        var paths;
	        for (i = 0; i < len; i += 1) {
	          if (animationData.chars[i].data && animationData.chars[i].data.shapes) {
	            paths = animationData.chars[i].data.shapes[0].it;
	            jLen = paths.length;

	            for (j = 0; j < jLen; j += 1) {
	              pathData = paths[j].ks.k;
	              if (!pathData.__converted) {
	                convertPathsToAbsoluteValues(paths[j].ks.k);
	                pathData.__converted = true;
	              }
	            }
	          }
	        }
	      }
	    };
	  }());

	  var checkColors = (function () {
	    var minimumVersion = [4, 1, 9];

	    function iterateShapes(shapes) {
	      var i;
	      var len = shapes.length;
	      var j;
	      var jLen;
	      for (i = 0; i < len; i += 1) {
	        if (shapes[i].ty === 'gr') {
	          iterateShapes(shapes[i].it);
	        } else if (shapes[i].ty === 'fl' || shapes[i].ty === 'st') {
	          if (shapes[i].c.k && shapes[i].c.k[0].i) {
	            jLen = shapes[i].c.k.length;
	            for (j = 0; j < jLen; j += 1) {
	              if (shapes[i].c.k[j].s) {
	                shapes[i].c.k[j].s[0] /= 255;
	                shapes[i].c.k[j].s[1] /= 255;
	                shapes[i].c.k[j].s[2] /= 255;
	                shapes[i].c.k[j].s[3] /= 255;
	              }
	              if (shapes[i].c.k[j].e) {
	                shapes[i].c.k[j].e[0] /= 255;
	                shapes[i].c.k[j].e[1] /= 255;
	                shapes[i].c.k[j].e[2] /= 255;
	                shapes[i].c.k[j].e[3] /= 255;
	              }
	            }
	          } else {
	            shapes[i].c.k[0] /= 255;
	            shapes[i].c.k[1] /= 255;
	            shapes[i].c.k[2] /= 255;
	            shapes[i].c.k[3] /= 255;
	          }
	        }
	      }
	    }

	    function iterateLayers(layers) {
	      var i;
	      var len = layers.length;
	      for (i = 0; i < len; i += 1) {
	        if (layers[i].ty === 4) {
	          iterateShapes(layers[i].shapes);
	        }
	      }
	    }

	    return function (animationData) {
	      if (checkVersion(minimumVersion, animationData.v)) {
	        iterateLayers(animationData.layers);
	        if (animationData.assets) {
	          var i;
	          var len = animationData.assets.length;
	          for (i = 0; i < len; i += 1) {
	            if (animationData.assets[i].layers) {
	              iterateLayers(animationData.assets[i].layers);
	            }
	          }
	        }
	      }
	    };
	  }());

	  var checkShapes = (function () {
	    var minimumVersion = [4, 4, 18];

	    function completeClosingShapes(arr) {
	      var i;
	      var len = arr.length;
	      var j;
	      var jLen;
	      for (i = len - 1; i >= 0; i -= 1) {
	        if (arr[i].ty === 'sh') {
	          if (arr[i].ks.k.i) {
	            arr[i].ks.k.c = arr[i].closed;
	          } else {
	            jLen = arr[i].ks.k.length;
	            for (j = 0; j < jLen; j += 1) {
	              if (arr[i].ks.k[j].s) {
	                arr[i].ks.k[j].s[0].c = arr[i].closed;
	              }
	              if (arr[i].ks.k[j].e) {
	                arr[i].ks.k[j].e[0].c = arr[i].closed;
	              }
	            }
	          }
	        } else if (arr[i].ty === 'gr') {
	          completeClosingShapes(arr[i].it);
	        }
	      }
	    }

	    function iterateLayers(layers) {
	      var layerData;
	      var i;
	      var len = layers.length;
	      var j;
	      var jLen;
	      var k;
	      var kLen;
	      for (i = 0; i < len; i += 1) {
	        layerData = layers[i];
	        if (layerData.hasMask) {
	          var maskProps = layerData.masksProperties;
	          jLen = maskProps.length;
	          for (j = 0; j < jLen; j += 1) {
	            if (maskProps[j].pt.k.i) {
	              maskProps[j].pt.k.c = maskProps[j].cl;
	            } else {
	              kLen = maskProps[j].pt.k.length;
	              for (k = 0; k < kLen; k += 1) {
	                if (maskProps[j].pt.k[k].s) {
	                  maskProps[j].pt.k[k].s[0].c = maskProps[j].cl;
	                }
	                if (maskProps[j].pt.k[k].e) {
	                  maskProps[j].pt.k[k].e[0].c = maskProps[j].cl;
	                }
	              }
	            }
	          }
	        }
	        if (layerData.ty === 4) {
	          completeClosingShapes(layerData.shapes);
	        }
	      }
	    }

	    return function (animationData) {
	      if (checkVersion(minimumVersion, animationData.v)) {
	        iterateLayers(animationData.layers);
	        if (animationData.assets) {
	          var i;
	          var len = animationData.assets.length;
	          for (i = 0; i < len; i += 1) {
	            if (animationData.assets[i].layers) {
	              iterateLayers(animationData.assets[i].layers);
	            }
	          }
	        }
	      }
	    };
	  }());

	  function completeData(animationData, fontManager) {
	    if (animationData.__complete) {
	      return;
	    }
	    checkColors(animationData);
	    checkText(animationData);
	    checkChars(animationData);
	    checkShapes(animationData);
	    completeLayers(animationData.layers, animationData.assets, fontManager);
	    animationData.__complete = true;
	  }

	  function completeText(data) {
	    if (data.t.a.length === 0 && !('m' in data.t.p)) {
	      data.singleShape = true;
	    }
	  }

	  var moduleOb = {};
	  moduleOb.completeData = completeData;
	  moduleOb.checkColors = checkColors;
	  moduleOb.checkChars = checkChars;
	  moduleOb.checkShapes = checkShapes;
	  moduleOb.completeLayers = completeLayers;

	  return moduleOb;
	}

	var dataManager = dataFunctionManager();

	/* exported getFontProperties */

	function getFontProperties(fontData) {
	  var styles = fontData.fStyle ? fontData.fStyle.split(' ') : [];

	  var fWeight = 'normal'; var
	    fStyle = 'normal';
	  var len = styles.length;
	  var styleName;
	  for (var i = 0; i < len; i += 1) {
	    styleName = styles[i].toLowerCase();
	    switch (styleName) {
	      case 'italic':
	        fStyle = 'italic';
	        break;
	      case 'bold':
	        fWeight = '700';
	        break;
	      case 'black':
	        fWeight = '900';
	        break;
	      case 'medium':
	        fWeight = '500';
	        break;
	      case 'regular':
	      case 'normal':
	        fWeight = '400';
	        break;
	      case 'light':
	      case 'thin':
	        fWeight = '200';
	        break;
	      default:
	        break;
	    }
	  }

	  return {
	    style: fStyle,
	    weight: fontData.fWeight || fWeight,
	  };
	}

	/* global createNS, createTag, getFontProperties */
	/* exported FontManager */

	var FontManager = (function () {
	  var maxWaitingTime = 5000;
	  var emptyChar = {
	    w: 0,
	    size: 0,
	    shapes: [],
	  };
	  var combinedCharacters = [];
	  // Hindi characters
	  combinedCharacters = combinedCharacters.concat([2304, 2305, 2306, 2307, 2362, 2363, 2364, 2364, 2366,
	    2367, 2368, 2369, 2370, 2371, 2372, 2373, 2374, 2375, 2376, 2377, 2378, 2379,
	    2380, 2381, 2382, 2383, 2387, 2388, 2389, 2390, 2391, 2402, 2403]);

	  var surrogateModifiers = [
	    'd83cdffb',
	    'd83cdffc',
	    'd83cdffd',
	    'd83cdffe',
	    'd83cdfff',
	  ];

	  var zeroWidthJoiner = [65039, 8205];

	  function trimFontOptions(font) {
	    var familyArray = font.split(',');
	    var i;
	    var len = familyArray.length;
	    var enabledFamilies = [];
	    for (i = 0; i < len; i += 1) {
	      if (familyArray[i] !== 'sans-serif' && familyArray[i] !== 'monospace') {
	        enabledFamilies.push(familyArray[i]);
	      }
	    }
	    return enabledFamilies.join(',');
	  }

	  function setUpNode(font, family) {
	    var parentNode = createTag('span');
	    // Node is invisible to screen readers.
	    parentNode.setAttribute('aria-hidden', true);
	    parentNode.style.fontFamily = family;
	    var node = createTag('span');
	    // Characters that vary significantly among different fonts
	    node.innerText = 'giItT1WQy@!-/#';
	    // Visible - so we can measure it - but not on the screen
	    parentNode.style.position = 'absolute';
	    parentNode.style.left = '-10000px';
	    parentNode.style.top = '-10000px';
	    // Large font size makes even subtle changes obvious
	    parentNode.style.fontSize = '300px';
	    // Reset any font properties
	    parentNode.style.fontVariant = 'normal';
	    parentNode.style.fontStyle = 'normal';
	    parentNode.style.fontWeight = 'normal';
	    parentNode.style.letterSpacing = '0';
	    parentNode.appendChild(node);
	    document.body.appendChild(parentNode);

	    // Remember width with no applied web font
	    var width = node.offsetWidth;
	    node.style.fontFamily = trimFontOptions(font) + ', ' + family;
	    return { node: node, w: width, parent: parentNode };
	  }

	  function checkLoadedFonts() {
	    var i;
	    var len = this.fonts.length;
	    var node;
	    var w;
	    var loadedCount = len;
	    for (i = 0; i < len; i += 1) {
	      if (this.fonts[i].loaded) {
	        loadedCount -= 1;
	      } else if (this.fonts[i].fOrigin === 'n' || this.fonts[i].origin === 0) {
	        this.fonts[i].loaded = true;
	      } else {
	        node = this.fonts[i].monoCase.node;
	        w = this.fonts[i].monoCase.w;
	        if (node.offsetWidth !== w) {
	          loadedCount -= 1;
	          this.fonts[i].loaded = true;
	        } else {
	          node = this.fonts[i].sansCase.node;
	          w = this.fonts[i].sansCase.w;
	          if (node.offsetWidth !== w) {
	            loadedCount -= 1;
	            this.fonts[i].loaded = true;
	          }
	        }
	        if (this.fonts[i].loaded) {
	          this.fonts[i].sansCase.parent.parentNode.removeChild(this.fonts[i].sansCase.parent);
	          this.fonts[i].monoCase.parent.parentNode.removeChild(this.fonts[i].monoCase.parent);
	        }
	      }
	    }

	    if (loadedCount !== 0 && Date.now() - this.initTime < maxWaitingTime) {
	      setTimeout(this.checkLoadedFontsBinded, 20);
	    } else {
	      setTimeout(this.setIsLoadedBinded, 10);
	    }
	  }

	  function createHelper(def, fontData) {
	    var tHelper = createNS('text');
	    tHelper.style.fontSize = '100px';
	    // tHelper.style.fontFamily = fontData.fFamily;

	    var fontProps = getFontProperties(fontData);
	    tHelper.setAttribute('font-family', fontData.fFamily);
	    tHelper.setAttribute('font-style', fontProps.style);
	    tHelper.setAttribute('font-weight', fontProps.weight);
	    tHelper.textContent = '1';
	    if (fontData.fClass) {
	      tHelper.style.fontFamily = 'inherit';
	      tHelper.setAttribute('class', fontData.fClass);
	    } else {
	      tHelper.style.fontFamily = fontData.fFamily;
	    }
	    def.appendChild(tHelper);
	    var tCanvasHelper = createTag('canvas').getContext('2d');
	    tCanvasHelper.font = fontData.fWeight + ' ' + fontData.fStyle + ' 100px ' + fontData.fFamily;
	    // tCanvasHelper.font = ' 100px '+ fontData.fFamily;
	    return tHelper;
	  }

	  function addFonts(fontData, defs) {
	    if (!fontData) {
	      this.isLoaded = true;
	      return;
	    }
	    if (this.chars) {
	      this.isLoaded = true;
	      this.fonts = fontData.list;
	      return;
	    }

	    var fontArr = fontData.list;
	    var i;
	    var len = fontArr.length;
	    var _pendingFonts = len;
	    for (i = 0; i < len; i += 1) {
	      var shouldLoadFont = true;
	      var loadedSelector;
	      var j;
	      fontArr[i].loaded = false;
	      fontArr[i].monoCase = setUpNode(fontArr[i].fFamily, 'monospace');
	      fontArr[i].sansCase = setUpNode(fontArr[i].fFamily, 'sans-serif');
	      if (!fontArr[i].fPath) {
	        fontArr[i].loaded = true;
	        _pendingFonts -= 1;
	      } else if (fontArr[i].fOrigin === 'p' || fontArr[i].origin === 3) {
	        loadedSelector = document.querySelectorAll('style[f-forigin="p"][f-family="' + fontArr[i].fFamily + '"], style[f-origin="3"][f-family="' + fontArr[i].fFamily + '"]');

	        if (loadedSelector.length > 0) {
	          shouldLoadFont = false;
	        }

	        if (shouldLoadFont) {
	          var s = createTag('style');
	          s.setAttribute('f-forigin', fontArr[i].fOrigin);
	          s.setAttribute('f-origin', fontArr[i].origin);
	          s.setAttribute('f-family', fontArr[i].fFamily);
	          s.type = 'text/css';
	          s.innerText = '@font-face {font-family: ' + fontArr[i].fFamily + "; font-style: normal; src: url('" + fontArr[i].fPath + "');}";
	          defs.appendChild(s);
	        }
	      } else if (fontArr[i].fOrigin === 'g' || fontArr[i].origin === 1) {
	        loadedSelector = document.querySelectorAll('link[f-forigin="g"], link[f-origin="1"]');

	        for (j = 0; j < loadedSelector.length; j += 1) {
	          if (loadedSelector[j].href.indexOf(fontArr[i].fPath) !== -1) {
	            // Font is already loaded
	            shouldLoadFont = false;
	          }
	        }

	        if (shouldLoadFont) {
	          var l = createTag('link');
	          l.setAttribute('f-forigin', fontArr[i].fOrigin);
	          l.setAttribute('f-origin', fontArr[i].origin);
	          l.type = 'text/css';
	          l.rel = 'stylesheet';
	          l.href = fontArr[i].fPath;
	          document.body.appendChild(l);
	        }
	      } else if (fontArr[i].fOrigin === 't' || fontArr[i].origin === 2) {
	        loadedSelector = document.querySelectorAll('script[f-forigin="t"], script[f-origin="2"]');

	        for (j = 0; j < loadedSelector.length; j += 1) {
	          if (fontArr[i].fPath === loadedSelector[j].src) {
	            // Font is already loaded
	            shouldLoadFont = false;
	          }
	        }

	        if (shouldLoadFont) {
	          var sc = createTag('link');
	          sc.setAttribute('f-forigin', fontArr[i].fOrigin);
	          sc.setAttribute('f-origin', fontArr[i].origin);
	          sc.setAttribute('rel', 'stylesheet');
	          sc.setAttribute('href', fontArr[i].fPath);
	          defs.appendChild(sc);
	        }
	      }
	      fontArr[i].helper = createHelper(defs, fontArr[i]);
	      fontArr[i].cache = {};
	      this.fonts.push(fontArr[i]);
	    }
	    if (_pendingFonts === 0) {
	      this.isLoaded = true;
	    } else {
	      // On some cases even if the font is loaded, it won't load correctly when measuring text on canvas.
	      // Adding this timeout seems to fix it
	      setTimeout(this.checkLoadedFonts.bind(this), 100);
	    }
	  }

	  function addChars(chars) {
	    if (!chars) {
	      return;
	    }
	    if (!this.chars) {
	      this.chars = [];
	    }
	    var i;
	    var len = chars.length;
	    var j;
	    var jLen = this.chars.length;
	    var found;
	    for (i = 0; i < len; i += 1) {
	      j = 0;
	      found = false;
	      while (j < jLen) {
	        if (this.chars[j].style === chars[i].style && this.chars[j].fFamily === chars[i].fFamily && this.chars[j].ch === chars[i].ch) {
	          found = true;
	        }
	        j += 1;
	      }
	      if (!found) {
	        this.chars.push(chars[i]);
	        jLen += 1;
	      }
	    }
	  }

	  function getCharData(char, style, font) {
	    var i = 0;
	    var len = this.chars.length;
	    while (i < len) {
	      if (this.chars[i].ch === char && this.chars[i].style === style && this.chars[i].fFamily === font) {
	        return this.chars[i];
	      }
	      i += 1;
	    }
	    if (((typeof char === 'string' && char.charCodeAt(0) !== 13) || !char)
	            && console
	            && console.warn // eslint-disable-line no-console
	            && !this._warned
	    ) {
	      this._warned = true;
	      console.warn('Missing character from exported characters list: ', char, style, font); // eslint-disable-line no-console
	    }
	    return emptyChar;
	  }

	  function measureText(char, fontName, size) {
	    var fontData = this.getFontByName(fontName);
	    var index = char.charCodeAt(0);
	    if (!fontData.cache[index + 1]) {
	      var tHelper = fontData.helper;
	      // Canvas version
	      // fontData.cache[index] = tHelper.measureText(char).width / 100;
	      // SVG version
	      // console.log(tHelper.getBBox().width)
	      if (char === ' ') {
	        tHelper.textContent = '|' + char + '|';
	        var doubleSize = tHelper.getComputedTextLength();
	        tHelper.textContent = '||';
	        var singleSize = tHelper.getComputedTextLength();
	        fontData.cache[index + 1] = (doubleSize - singleSize) / 100;
	      } else {
	        tHelper.textContent = char;
	        fontData.cache[index + 1] = (tHelper.getComputedTextLength()) / 100;
	      }
	    }
	    return fontData.cache[index + 1] * size;
	  }

	  function getFontByName(name) {
	    var i = 0;
	    var len = this.fonts.length;
	    while (i < len) {
	      if (this.fonts[i].fName === name) {
	        return this.fonts[i];
	      }
	      i += 1;
	    }
	    return this.fonts[0];
	  }

	  function isModifier(firstCharCode, secondCharCode) {
	    var sum = firstCharCode.toString(16) + secondCharCode.toString(16);
	    return surrogateModifiers.indexOf(sum) !== -1;
	  }

	  function isZeroWidthJoiner(firstCharCode, secondCharCode) {
	    if (!secondCharCode) {
	      return firstCharCode === zeroWidthJoiner[1];
	    }
	    return firstCharCode === zeroWidthJoiner[0] && secondCharCode === zeroWidthJoiner[1];
	  }

	  function isCombinedCharacter(char) {
	    return combinedCharacters.indexOf(char) !== -1;
	  }

	  function setIsLoaded() {
	    this.isLoaded = true;
	  }

	  var Font = function () {
	    this.fonts = [];
	    this.chars = null;
	    this.typekitLoaded = 0;
	    this.isLoaded = false;
	    this._warned = false;
	    this.initTime = Date.now();
	    this.setIsLoadedBinded = this.setIsLoaded.bind(this);
	    this.checkLoadedFontsBinded = this.checkLoadedFonts.bind(this);
	  };
	  Font.isModifier = isModifier;
	  Font.isZeroWidthJoiner = isZeroWidthJoiner;
	  Font.isCombinedCharacter = isCombinedCharacter;

	  var fontPrototype = {
	    addChars: addChars,
	    addFonts: addFonts,
	    getCharData: getCharData,
	    getFontByName: getFontByName,
	    measureText: measureText,
	    checkLoadedFonts: checkLoadedFonts,
	    setIsLoaded: setIsLoaded,
	  };

	  Font.prototype = fontPrototype;

	  return Font;
	}());

	/* global initialDefaultFrame, BezierFactory, degToRads, bez, createTypedArray */
	/* exported PropertyFactory */

	var PropertyFactory = (function () {
	  var initFrame = initialDefaultFrame;
	  var mathAbs = Math.abs;

	  function interpolateValue(frameNum, caching) {
	    var offsetTime = this.offsetTime;
	    var newValue;
	    if (this.propType === 'multidimensional') {
	      newValue = createTypedArray('float32', this.pv.length);
	    }
	    var iterationIndex = caching.lastIndex;
	    var i = iterationIndex;
	    var len = this.keyframes.length - 1;
	    var flag = true;
	    var keyData;
	    var nextKeyData;

	    while (flag) {
	      keyData = this.keyframes[i];
	      nextKeyData = this.keyframes[i + 1];
	      if (i === len - 1 && frameNum >= nextKeyData.t - offsetTime) {
	        if (keyData.h) {
	          keyData = nextKeyData;
	        }
	        iterationIndex = 0;
	        break;
	      }
	      if ((nextKeyData.t - offsetTime) > frameNum) {
	        iterationIndex = i;
	        break;
	      }
	      if (i < len - 1) {
	        i += 1;
	      } else {
	        iterationIndex = 0;
	        flag = false;
	      }
	    }

	    var k;
	    var kLen;
	    var perc;
	    var jLen;
	    var j;
	    var fnc;
	    var nextKeyTime = nextKeyData.t - offsetTime;
	    var keyTime = keyData.t - offsetTime;
	    var endValue;
	    if (keyData.to) {
	      if (!keyData.bezierData) {
	        keyData.bezierData = bez.buildBezierData(keyData.s, nextKeyData.s || keyData.e, keyData.to, keyData.ti);
	      }
	      var bezierData = keyData.bezierData;
	      if (frameNum >= nextKeyTime || frameNum < keyTime) {
	        var ind = frameNum >= nextKeyTime ? bezierData.points.length - 1 : 0;
	        kLen = bezierData.points[ind].point.length;
	        for (k = 0; k < kLen; k += 1) {
	          newValue[k] = bezierData.points[ind].point[k];
	        }
	        // caching._lastKeyframeIndex = -1;
	      } else {
	        if (keyData.__fnct) {
	          fnc = keyData.__fnct;
	        } else {
	          fnc = BezierFactory.getBezierEasing(keyData.o.x, keyData.o.y, keyData.i.x, keyData.i.y, keyData.n).get;
	          keyData.__fnct = fnc;
	        }
	        perc = fnc((frameNum - keyTime) / (nextKeyTime - keyTime));
	        var distanceInLine = bezierData.segmentLength * perc;

	        var segmentPerc;
	        var addedLength = (caching.lastFrame < frameNum && caching._lastKeyframeIndex === i) ? caching._lastAddedLength : 0;
	        j = (caching.lastFrame < frameNum && caching._lastKeyframeIndex === i) ? caching._lastPoint : 0;
	        flag = true;
	        jLen = bezierData.points.length;
	        while (flag) {
	          addedLength += bezierData.points[j].partialLength;
	          if (distanceInLine === 0 || perc === 0 || j === bezierData.points.length - 1) {
	            kLen = bezierData.points[j].point.length;
	            for (k = 0; k < kLen; k += 1) {
	              newValue[k] = bezierData.points[j].point[k];
	            }
	            break;
	          } else if (distanceInLine >= addedLength && distanceInLine < addedLength + bezierData.points[j + 1].partialLength) {
	            segmentPerc = (distanceInLine - addedLength) / bezierData.points[j + 1].partialLength;
	            kLen = bezierData.points[j].point.length;
	            for (k = 0; k < kLen; k += 1) {
	              newValue[k] = bezierData.points[j].point[k] + (bezierData.points[j + 1].point[k] - bezierData.points[j].point[k]) * segmentPerc;
	            }
	            break;
	          }
	          if (j < jLen - 1) {
	            j += 1;
	          } else {
	            flag = false;
	          }
	        }
	        caching._lastPoint = j;
	        caching._lastAddedLength = addedLength - bezierData.points[j].partialLength;
	        caching._lastKeyframeIndex = i;
	      }
	    } else {
	      var outX;
	      var outY;
	      var inX;
	      var inY;
	      var keyValue;
	      len = keyData.s.length;
	      endValue = nextKeyData.s || keyData.e;
	      if (this.sh && keyData.h !== 1) {
	        if (frameNum >= nextKeyTime) {
	          newValue[0] = endValue[0];
	          newValue[1] = endValue[1];
	          newValue[2] = endValue[2];
	        } else if (frameNum <= keyTime) {
	          newValue[0] = keyData.s[0];
	          newValue[1] = keyData.s[1];
	          newValue[2] = keyData.s[2];
	        } else {
	          var quatStart = createQuaternion(keyData.s);
	          var quatEnd = createQuaternion(endValue);
	          var time = (frameNum - keyTime) / (nextKeyTime - keyTime);
	          quaternionToEuler(newValue, slerp(quatStart, quatEnd, time));
	        }
	      } else {
	        for (i = 0; i < len; i += 1) {
	          if (keyData.h !== 1) {
	            if (frameNum >= nextKeyTime) {
	              perc = 1;
	            } else if (frameNum < keyTime) {
	              perc = 0;
	            } else {
	              if (keyData.o.x.constructor === Array) {
	                if (!keyData.__fnct) {
	                  keyData.__fnct = [];
	                }
	                if (!keyData.__fnct[i]) {
	                  outX = (typeof keyData.o.x[i] === 'undefined') ? keyData.o.x[0] : keyData.o.x[i];
	                  outY = (typeof keyData.o.y[i] === 'undefined') ? keyData.o.y[0] : keyData.o.y[i];
	                  inX = (typeof keyData.i.x[i] === 'undefined') ? keyData.i.x[0] : keyData.i.x[i];
	                  inY = (typeof keyData.i.y[i] === 'undefined') ? keyData.i.y[0] : keyData.i.y[i];
	                  fnc = BezierFactory.getBezierEasing(outX, outY, inX, inY).get;
	                  keyData.__fnct[i] = fnc;
	                } else {
	                  fnc = keyData.__fnct[i];
	                }
	              } else if (!keyData.__fnct) {
	                outX = keyData.o.x;
	                outY = keyData.o.y;
	                inX = keyData.i.x;
	                inY = keyData.i.y;
	                fnc = BezierFactory.getBezierEasing(outX, outY, inX, inY).get;
	                keyData.__fnct = fnc;
	              } else {
	                fnc = keyData.__fnct;
	              }
	              perc = fnc((frameNum - keyTime) / (nextKeyTime - keyTime));
	            }
	          }

	          endValue = nextKeyData.s || keyData.e;
	          keyValue = keyData.h === 1 ? keyData.s[i] : keyData.s[i] + (endValue[i] - keyData.s[i]) * perc;

	          if (this.propType === 'multidimensional') {
	            newValue[i] = keyValue;
	          } else {
	            newValue = keyValue;
	          }
	        }
	      }
	    }
	    caching.lastIndex = iterationIndex;
	    return newValue;
	  }

	  // based on @Toji's https://github.com/toji/gl-matrix/
	  function slerp(a, b, t) {
	    var out = [];
	    var ax = a[0];
	    var ay = a[1];
	    var az = a[2];
	    var aw = a[3];
	    var bx = b[0];
	    var by = b[1];
	    var bz = b[2];
	    var bw = b[3];

	    var omega;
	    var cosom;
	    var sinom;
	    var scale0;
	    var scale1;

	    cosom = ax * bx + ay * by + az * bz + aw * bw;
	    if (cosom < 0.0) {
	      cosom = -cosom;
	      bx = -bx;
	      by = -by;
	      bz = -bz;
	      bw = -bw;
	    }
	    if ((1.0 - cosom) > 0.000001) {
	      omega = Math.acos(cosom);
	      sinom = Math.sin(omega);
	      scale0 = Math.sin((1.0 - t) * omega) / sinom;
	      scale1 = Math.sin(t * omega) / sinom;
	    } else {
	      scale0 = 1.0 - t;
	      scale1 = t;
	    }
	    out[0] = scale0 * ax + scale1 * bx;
	    out[1] = scale0 * ay + scale1 * by;
	    out[2] = scale0 * az + scale1 * bz;
	    out[3] = scale0 * aw + scale1 * bw;

	    return out;
	  }

	  function quaternionToEuler(out, quat) {
	    var qx = quat[0];
	    var qy = quat[1];
	    var qz = quat[2];
	    var qw = quat[3];
	    var heading = Math.atan2(2 * qy * qw - 2 * qx * qz, 1 - 2 * qy * qy - 2 * qz * qz);
	    var attitude = Math.asin(2 * qx * qy + 2 * qz * qw);
	    var bank = Math.atan2(2 * qx * qw - 2 * qy * qz, 1 - 2 * qx * qx - 2 * qz * qz);
	    out[0] = heading / degToRads;
	    out[1] = attitude / degToRads;
	    out[2] = bank / degToRads;
	  }

	  function createQuaternion(values) {
	    var heading = values[0] * degToRads;
	    var attitude = values[1] * degToRads;
	    var bank = values[2] * degToRads;
	    var c1 = Math.cos(heading / 2);
	    var c2 = Math.cos(attitude / 2);
	    var c3 = Math.cos(bank / 2);
	    var s1 = Math.sin(heading / 2);
	    var s2 = Math.sin(attitude / 2);
	    var s3 = Math.sin(bank / 2);
	    var w = c1 * c2 * c3 - s1 * s2 * s3;
	    var x = s1 * s2 * c3 + c1 * c2 * s3;
	    var y = s1 * c2 * c3 + c1 * s2 * s3;
	    var z = c1 * s2 * c3 - s1 * c2 * s3;

	    return [x, y, z, w];
	  }

	  function getValueAtCurrentTime() {
	    var frameNum = this.comp.renderedFrame - this.offsetTime;
	    var initTime = this.keyframes[0].t - this.offsetTime;
	    var endTime = this.keyframes[this.keyframes.length - 1].t - this.offsetTime;
	    if (!(frameNum === this._caching.lastFrame || (this._caching.lastFrame !== initFrame && ((this._caching.lastFrame >= endTime && frameNum >= endTime) || (this._caching.lastFrame < initTime && frameNum < initTime))))) {
	      if (this._caching.lastFrame >= frameNum) {
	        this._caching._lastKeyframeIndex = -1;
	        this._caching.lastIndex = 0;
	      }

	      var renderResult = this.interpolateValue(frameNum, this._caching);
	      this.pv = renderResult;
	    }
	    this._caching.lastFrame = frameNum;
	    return this.pv;
	  }

	  function setVValue(val) {
	    var multipliedValue;
	    if (this.propType === 'unidimensional') {
	      multipliedValue = val * this.mult;
	      if (mathAbs(this.v - multipliedValue) > 0.00001) {
	        this.v = multipliedValue;
	        this._mdf = true;
	      }
	    } else {
	      var i = 0;
	      var len = this.v.length;
	      while (i < len) {
	        multipliedValue = val[i] * this.mult;
	        if (mathAbs(this.v[i] - multipliedValue) > 0.00001) {
	          this.v[i] = multipliedValue;
	          this._mdf = true;
	        }
	        i += 1;
	      }
	    }
	  }

	  function processEffectsSequence() {
	    if (this.elem.globalData.frameId === this.frameId || !this.effectsSequence.length) {
	      return;
	    }
	    if (this.lock) {
	      this.setVValue(this.pv);
	      return;
	    }
	    this.lock = true;
	    this._mdf = this._isFirstFrame;
	    var i;
	    var len = this.effectsSequence.length;
	    var finalValue = this.kf ? this.pv : this.data.k;
	    for (i = 0; i < len; i += 1) {
	      finalValue = this.effectsSequence[i](finalValue);
	    }
	    this.setVValue(finalValue);
	    this._isFirstFrame = false;
	    this.lock = false;
	    this.frameId = this.elem.globalData.frameId;
	  }

	  function addEffect(effectFunction) {
	    this.effectsSequence.push(effectFunction);
	    this.container.addDynamicProperty(this);
	  }

	  function ValueProperty(elem, data, mult, container) {
	    this.propType = 'unidimensional';
	    this.mult = mult || 1;
	    this.data = data;
	    this.v = mult ? data.k * mult : data.k;
	    this.pv = data.k;
	    this._mdf = false;
	    this.elem = elem;
	    this.container = container;
	    this.comp = elem.comp;
	    this.k = false;
	    this.kf = false;
	    this.vel = 0;
	    this.effectsSequence = [];
	    this._isFirstFrame = true;
	    this.getValue = processEffectsSequence;
	    this.setVValue = setVValue;
	    this.addEffect = addEffect;
	  }

	  function MultiDimensionalProperty(elem, data, mult, container) {
	    this.propType = 'multidimensional';
	    this.mult = mult || 1;
	    this.data = data;
	    this._mdf = false;
	    this.elem = elem;
	    this.container = container;
	    this.comp = elem.comp;
	    this.k = false;
	    this.kf = false;
	    this.frameId = -1;
	    var i;
	    var len = data.k.length;
	    this.v = createTypedArray('float32', len);
	    this.pv = createTypedArray('float32', len);
	    this.vel = createTypedArray('float32', len);
	    for (i = 0; i < len; i += 1) {
	      this.v[i] = data.k[i] * this.mult;
	      this.pv[i] = data.k[i];
	    }
	    this._isFirstFrame = true;
	    this.effectsSequence = [];
	    this.getValue = processEffectsSequence;
	    this.setVValue = setVValue;
	    this.addEffect = addEffect;
	  }

	  function KeyframedValueProperty(elem, data, mult, container) {
	    this.propType = 'unidimensional';
	    this.keyframes = data.k;
	    this.offsetTime = elem.data.st;
	    this.frameId = -1;
	    this._caching = {
	      lastFrame: initFrame, lastIndex: 0, value: 0, _lastKeyframeIndex: -1,
	    };
	    this.k = true;
	    this.kf = true;
	    this.data = data;
	    this.mult = mult || 1;
	    this.elem = elem;
	    this.container = container;
	    this.comp = elem.comp;
	    this.v = initFrame;
	    this.pv = initFrame;
	    this._isFirstFrame = true;
	    this.getValue = processEffectsSequence;
	    this.setVValue = setVValue;
	    this.interpolateValue = interpolateValue;
	    this.effectsSequence = [getValueAtCurrentTime.bind(this)];
	    this.addEffect = addEffect;
	  }

	  function KeyframedMultidimensionalProperty(elem, data, mult, container) {
	    this.propType = 'multidimensional';
	    var i;
	    var len = data.k.length;
	    var s;
	    var e;
	    var to;
	    var ti;
	    for (i = 0; i < len - 1; i += 1) {
	      if (data.k[i].to && data.k[i].s && data.k[i + 1] && data.k[i + 1].s) {
	        s = data.k[i].s;
	        e = data.k[i + 1].s;
	        to = data.k[i].to;
	        ti = data.k[i].ti;
	        if ((s.length === 2 && !(s[0] === e[0] && s[1] === e[1]) && bez.pointOnLine2D(s[0], s[1], e[0], e[1], s[0] + to[0], s[1] + to[1]) && bez.pointOnLine2D(s[0], s[1], e[0], e[1], e[0] + ti[0], e[1] + ti[1])) || (s.length === 3 && !(s[0] === e[0] && s[1] === e[1] && s[2] === e[2]) && bez.pointOnLine3D(s[0], s[1], s[2], e[0], e[1], e[2], s[0] + to[0], s[1] + to[1], s[2] + to[2]) && bez.pointOnLine3D(s[0], s[1], s[2], e[0], e[1], e[2], e[0] + ti[0], e[1] + ti[1], e[2] + ti[2]))) {
	          data.k[i].to = null;
	          data.k[i].ti = null;
	        }
	        if (s[0] === e[0] && s[1] === e[1] && to[0] === 0 && to[1] === 0 && ti[0] === 0 && ti[1] === 0) {
	          if (s.length === 2 || (s[2] === e[2] && to[2] === 0 && ti[2] === 0)) {
	            data.k[i].to = null;
	            data.k[i].ti = null;
	          }
	        }
	      }
	    }
	    this.effectsSequence = [getValueAtCurrentTime.bind(this)];
	    this.data = data;
	    this.keyframes = data.k;
	    this.offsetTime = elem.data.st;
	    this.k = true;
	    this.kf = true;
	    this._isFirstFrame = true;
	    this.mult = mult || 1;
	    this.elem = elem;
	    this.container = container;
	    this.comp = elem.comp;
	    this.getValue = processEffectsSequence;
	    this.setVValue = setVValue;
	    this.interpolateValue = interpolateValue;
	    this.frameId = -1;
	    var arrLen = data.k[0].s.length;
	    this.v = createTypedArray('float32', arrLen);
	    this.pv = createTypedArray('float32', arrLen);
	    for (i = 0; i < arrLen; i += 1) {
	      this.v[i] = initFrame;
	      this.pv[i] = initFrame;
	    }
	    this._caching = { lastFrame: initFrame, lastIndex: 0, value: createTypedArray('float32', arrLen) };
	    this.addEffect = addEffect;
	  }

	  function getProp(elem, data, type, mult, container) {
	    var p;
	    if (!data.k.length) {
	      p = new ValueProperty(elem, data, mult, container);
	    } else if (typeof (data.k[0]) === 'number') {
	      p = new MultiDimensionalProperty(elem, data, mult, container);
	    } else {
	      switch (type) {
	        case 0:
	          p = new KeyframedValueProperty(elem, data, mult, container);
	          break;
	        case 1:
	          p = new KeyframedMultidimensionalProperty(elem, data, mult, container);
	          break;
	        default:
	          break;
	      }
	    }
	    if (p.effectsSequence.length) {
	      container.addDynamicProperty(p);
	    }
	    return p;
	  }

	  var ob = {
	    getProp: getProp,
	  };
	  return ob;
	}());

	/* global Matrix, degToRads, PropertyFactory, extendPrototype, DynamicPropertyContainer */
	/* exported TransformPropertyFactory */

	var TransformPropertyFactory = (function () {
	  var defaultVector = [0, 0];

	  function applyToMatrix(mat) {
	    var _mdf = this._mdf;
	    this.iterateDynamicProperties();
	    this._mdf = this._mdf || _mdf;
	    if (this.a) {
	      mat.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]);
	    }
	    if (this.s) {
	      mat.scale(this.s.v[0], this.s.v[1], this.s.v[2]);
	    }
	    if (this.sk) {
	      mat.skewFromAxis(-this.sk.v, this.sa.v);
	    }
	    if (this.r) {
	      mat.rotate(-this.r.v);
	    } else {
	      mat.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2])
	        .rotateY(this.or.v[1])
	        .rotateX(this.or.v[0]);
	    }
	    if (this.data.p.s) {
	      if (this.data.p.z) {
	        mat.translate(this.px.v, this.py.v, -this.pz.v);
	      } else {
	        mat.translate(this.px.v, this.py.v, 0);
	      }
	    } else {
	      mat.translate(this.p.v[0], this.p.v[1], -this.p.v[2]);
	    }
	  }
	  function processKeys(forceRender) {
	    if (this.elem.globalData.frameId === this.frameId) {
	      return;
	    }
	    if (this._isDirty) {
	      this.precalculateMatrix();
	      this._isDirty = false;
	    }

	    this.iterateDynamicProperties();

	    if (this._mdf || forceRender) {
	      var frameRate;
	      this.v.cloneFromProps(this.pre.props);
	      if (this.appliedTransformations < 1) {
	        this.v.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]);
	      }
	      if (this.appliedTransformations < 2) {
	        this.v.scale(this.s.v[0], this.s.v[1], this.s.v[2]);
	      }
	      if (this.sk && this.appliedTransformations < 3) {
	        this.v.skewFromAxis(-this.sk.v, this.sa.v);
	      }
	      if (this.r && this.appliedTransformations < 4) {
	        this.v.rotate(-this.r.v);
	      } else if (!this.r && this.appliedTransformations < 4) {
	        this.v.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2])
	          .rotateY(this.or.v[1])
	          .rotateX(this.or.v[0]);
	      }
	      if (this.autoOriented) {
	        var v1;
	        var v2;
	        frameRate = this.elem.globalData.frameRate;
	        if (this.p && this.p.keyframes && this.p.getValueAtTime) {
	          if (this.p._caching.lastFrame + this.p.offsetTime <= this.p.keyframes[0].t) {
	            v1 = this.p.getValueAtTime((this.p.keyframes[0].t + 0.01) / frameRate, 0);
	            v2 = this.p.getValueAtTime(this.p.keyframes[0].t / frameRate, 0);
	          } else if (this.p._caching.lastFrame + this.p.offsetTime >= this.p.keyframes[this.p.keyframes.length - 1].t) {
	            v1 = this.p.getValueAtTime((this.p.keyframes[this.p.keyframes.length - 1].t / frameRate), 0);
	            v2 = this.p.getValueAtTime((this.p.keyframes[this.p.keyframes.length - 1].t - 0.05) / frameRate, 0);
	          } else {
	            v1 = this.p.pv;
	            v2 = this.p.getValueAtTime((this.p._caching.lastFrame + this.p.offsetTime - 0.01) / frameRate, this.p.offsetTime);
	          }
	        } else if (this.px && this.px.keyframes && this.py.keyframes && this.px.getValueAtTime && this.py.getValueAtTime) {
	          v1 = [];
	          v2 = [];
	          var px = this.px;
	          var py = this.py;
	          if (px._caching.lastFrame + px.offsetTime <= px.keyframes[0].t) {
	            v1[0] = px.getValueAtTime((px.keyframes[0].t + 0.01) / frameRate, 0);
	            v1[1] = py.getValueAtTime((py.keyframes[0].t + 0.01) / frameRate, 0);
	            v2[0] = px.getValueAtTime((px.keyframes[0].t) / frameRate, 0);
	            v2[1] = py.getValueAtTime((py.keyframes[0].t) / frameRate, 0);
	          } else if (px._caching.lastFrame + px.offsetTime >= px.keyframes[px.keyframes.length - 1].t) {
	            v1[0] = px.getValueAtTime((px.keyframes[px.keyframes.length - 1].t / frameRate), 0);
	            v1[1] = py.getValueAtTime((py.keyframes[py.keyframes.length - 1].t / frameRate), 0);
	            v2[0] = px.getValueAtTime((px.keyframes[px.keyframes.length - 1].t - 0.01) / frameRate, 0);
	            v2[1] = py.getValueAtTime((py.keyframes[py.keyframes.length - 1].t - 0.01) / frameRate, 0);
	          } else {
	            v1 = [px.pv, py.pv];
	            v2[0] = px.getValueAtTime((px._caching.lastFrame + px.offsetTime - 0.01) / frameRate, px.offsetTime);
	            v2[1] = py.getValueAtTime((py._caching.lastFrame + py.offsetTime - 0.01) / frameRate, py.offsetTime);
	          }
	        } else {
	          v2 = defaultVector;
	          v1 = v2;
	        }
	        this.v.rotate(-Math.atan2(v1[1] - v2[1], v1[0] - v2[0]));
	      }
	      if (this.data.p && this.data.p.s) {
	        if (this.data.p.z) {
	          this.v.translate(this.px.v, this.py.v, -this.pz.v);
	        } else {
	          this.v.translate(this.px.v, this.py.v, 0);
	        }
	      } else {
	        this.v.translate(this.p.v[0], this.p.v[1], -this.p.v[2]);
	      }
	    }
	    this.frameId = this.elem.globalData.frameId;
	  }

	  function precalculateMatrix() {
	    if (!this.a.k) {
	      this.pre.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]);
	      this.appliedTransformations = 1;
	    } else {
	      return;
	    }
	    if (!this.s.effectsSequence.length) {
	      this.pre.scale(this.s.v[0], this.s.v[1], this.s.v[2]);
	      this.appliedTransformations = 2;
	    } else {
	      return;
	    }
	    if (this.sk) {
	      if (!this.sk.effectsSequence.length && !this.sa.effectsSequence.length) {
	        this.pre.skewFromAxis(-this.sk.v, this.sa.v);
	        this.appliedTransformations = 3;
	      } else {
	        return;
	      }
	    }
	    if (this.r) {
	      if (!this.r.effectsSequence.length) {
	        this.pre.rotate(-this.r.v);
	        this.appliedTransformations = 4;
	      }
	    } else if (!this.rz.effectsSequence.length && !this.ry.effectsSequence.length && !this.rx.effectsSequence.length && !this.or.effectsSequence.length) {
	      this.pre.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2])
	        .rotateY(this.or.v[1])
	        .rotateX(this.or.v[0]);
	      this.appliedTransformations = 4;
	    }
	  }

	  function autoOrient() {
	    //
	    // var prevP = this.getValueAtTime();
	  }

	  function addDynamicProperty(prop) {
	    this._addDynamicProperty(prop);
	    this.elem.addDynamicProperty(prop);
	    this._isDirty = true;
	  }

	  function TransformProperty(elem, data, container) {
	    this.elem = elem;
	    this.frameId = -1;
	    this.propType = 'transform';
	    this.data = data;
	    this.v = new Matrix();
	    // Precalculated matrix with non animated properties
	    this.pre = new Matrix();
	    this.appliedTransformations = 0;
	    this.initDynamicPropertyContainer(container || elem);
	    if (data.p && data.p.s) {
	      this.px = PropertyFactory.getProp(elem, data.p.x, 0, 0, this);
	      this.py = PropertyFactory.getProp(elem, data.p.y, 0, 0, this);
	      if (data.p.z) {
	        this.pz = PropertyFactory.getProp(elem, data.p.z, 0, 0, this);
	      }
	    } else {
	      this.p = PropertyFactory.getProp(elem, data.p || { k: [0, 0, 0] }, 1, 0, this);
	    }
	    if (data.rx) {
	      this.rx = PropertyFactory.getProp(elem, data.rx, 0, degToRads, this);
	      this.ry = PropertyFactory.getProp(elem, data.ry, 0, degToRads, this);
	      this.rz = PropertyFactory.getProp(elem, data.rz, 0, degToRads, this);
	      if (data.or.k[0].ti) {
	        var i;
	        var len = data.or.k.length;
	        for (i = 0; i < len; i += 1) {
	          data.or.k[i].to = null;
	          data.or.k[i].ti = null;
	        }
	      }
	      this.or = PropertyFactory.getProp(elem, data.or, 1, degToRads, this);
	      // sh Indicates it needs to be capped between -180 and 180
	      this.or.sh = true;
	    } else {
	      this.r = PropertyFactory.getProp(elem, data.r || { k: 0 }, 0, degToRads, this);
	    }
	    if (data.sk) {
	      this.sk = PropertyFactory.getProp(elem, data.sk, 0, degToRads, this);
	      this.sa = PropertyFactory.getProp(elem, data.sa, 0, degToRads, this);
	    }
	    this.a = PropertyFactory.getProp(elem, data.a || { k: [0, 0, 0] }, 1, 0, this);
	    this.s = PropertyFactory.getProp(elem, data.s || { k: [100, 100, 100] }, 1, 0.01, this);
	    // Opacity is not part of the transform properties, that's why it won't use this.dynamicProperties. That way transforms won't get updated if opacity changes.
	    if (data.o) {
	      this.o = PropertyFactory.getProp(elem, data.o, 0, 0.01, elem);
	    } else {
	      this.o = { _mdf: false, v: 1 };
	    }
	    this._isDirty = true;
	    if (!this.dynamicProperties.length) {
	      this.getValue(true);
	    }
	  }

	  TransformProperty.prototype = {
	    applyToMatrix: applyToMatrix,
	    getValue: processKeys,
	    precalculateMatrix: precalculateMatrix,
	    autoOrient: autoOrient,
	  };

	  extendPrototype([DynamicPropertyContainer], TransformProperty);
	  TransformProperty.prototype.addDynamicProperty = addDynamicProperty;
	  TransformProperty.prototype._addDynamicProperty = DynamicPropertyContainer.prototype.addDynamicProperty;

	  function getTransformProperty(elem, data, container) {
	    return new TransformProperty(elem, data, container);
	  }

	  return {
	    getTransformProperty: getTransformProperty,
	  };
	}());

	/* global createSizedArray, createSizedArray, pointPool */

	function ShapePath() {
	  this.c = false;
	  this._length = 0;
	  this._maxLength = 8;
	  this.v = createSizedArray(this._maxLength);
	  this.o = createSizedArray(this._maxLength);
	  this.i = createSizedArray(this._maxLength);
	}

	ShapePath.prototype.setPathData = function (closed, len) {
	  this.c = closed;
	  this.setLength(len);
	  var i = 0;
	  while (i < len) {
	    this.v[i] = pointPool.newElement();
	    this.o[i] = pointPool.newElement();
	    this.i[i] = pointPool.newElement();
	    i += 1;
	  }
	};

	ShapePath.prototype.setLength = function (len) {
	  while (this._maxLength < len) {
	    this.doubleArrayLength();
	  }
	  this._length = len;
	};

	ShapePath.prototype.doubleArrayLength = function () {
	  this.v = this.v.concat(createSizedArray(this._maxLength));
	  this.i = this.i.concat(createSizedArray(this._maxLength));
	  this.o = this.o.concat(createSizedArray(this._maxLength));
	  this._maxLength *= 2;
	};

	ShapePath.prototype.setXYAt = function (x, y, type, pos, replace) {
	  var arr;
	  this._length = Math.max(this._length, pos + 1);
	  if (this._length >= this._maxLength) {
	    this.doubleArrayLength();
	  }
	  switch (type) {
	    case 'v':
	      arr = this.v;
	      break;
	    case 'i':
	      arr = this.i;
	      break;
	    case 'o':
	      arr = this.o;
	      break;
	    default:
	      arr = [];
	      break;
	  }
	  if (!arr[pos] || (arr[pos] && !replace)) {
	    arr[pos] = pointPool.newElement();
	  }
	  arr[pos][0] = x;
	  arr[pos][1] = y;
	};

	ShapePath.prototype.setTripleAt = function (vX, vY, oX, oY, iX, iY, pos, replace) {
	  this.setXYAt(vX, vY, 'v', pos, replace);
	  this.setXYAt(oX, oY, 'o', pos, replace);
	  this.setXYAt(iX, iY, 'i', pos, replace);
	};

	ShapePath.prototype.reverse = function () {
	  var newPath = new ShapePath();
	  newPath.setPathData(this.c, this._length);
	  var vertices = this.v;
	  var outPoints = this.o;
	  var inPoints = this.i;
	  var init = 0;
	  if (this.c) {
	    newPath.setTripleAt(vertices[0][0], vertices[0][1], inPoints[0][0], inPoints[0][1], outPoints[0][0], outPoints[0][1], 0, false);
	    init = 1;
	  }
	  var cnt = this._length - 1;
	  var len = this._length;

	  var i;
	  for (i = init; i < len; i += 1) {
	    newPath.setTripleAt(vertices[cnt][0], vertices[cnt][1], inPoints[cnt][0], inPoints[cnt][1], outPoints[cnt][0], outPoints[cnt][1], i, false);
	    cnt -= 1;
	  }
	  return newPath;
	};

	/* global extendPrototype, roundCorner, BezierFactory, shapePool, degToRads,
	  shapeCollectionPool, PropertyFactory, bmMin, DynamicPropertyContainer */
	/* exported ShapePropertyFactory */

	var ShapePropertyFactory = (function () {
	  var initFrame = -999999;

	  function interpolateShape(frameNum, previousValue, caching) {
	    var iterationIndex = caching.lastIndex;
	    var keyPropS;
	    var keyPropE;
	    var isHold;
	    var j;
	    var k;
	    var jLen;
	    var kLen;
	    var perc;
	    var vertexValue;
	    var kf = this.keyframes;
	    if (frameNum < kf[0].t - this.offsetTime) {
	      keyPropS = kf[0].s[0];
	      isHold = true;
	      iterationIndex = 0;
	    } else if (frameNum >= kf[kf.length - 1].t - this.offsetTime) {
	      keyPropS = kf[kf.length - 1].s ? kf[kf.length - 1].s[0] : kf[kf.length - 2].e[0];
	      /* if(kf[kf.length - 1].s){
	                keyPropS = kf[kf.length - 1].s[0];
	            }else{
	                keyPropS = kf[kf.length - 2].e[0];
	            } */
	      isHold = true;
	    } else {
	      var i = iterationIndex;
	      var len = kf.length - 1;
	      var flag = true;
	      var keyData;
	      var nextKeyData;
	      while (flag) {
	        keyData = kf[i];
	        nextKeyData = kf[i + 1];
	        if ((nextKeyData.t - this.offsetTime) > frameNum) {
	          break;
	        }
	        if (i < len - 1) {
	          i += 1;
	        } else {
	          flag = false;
	        }
	      }
	      isHold = keyData.h === 1;
	      iterationIndex = i;
	      if (!isHold) {
	        if (frameNum >= nextKeyData.t - this.offsetTime) {
	          perc = 1;
	        } else if (frameNum < keyData.t - this.offsetTime) {
	          perc = 0;
	        } else {
	          var fnc;
	          if (keyData.__fnct) {
	            fnc = keyData.__fnct;
	          } else {
	            fnc = BezierFactory.getBezierEasing(keyData.o.x, keyData.o.y, keyData.i.x, keyData.i.y).get;
	            keyData.__fnct = fnc;
	          }
	          perc = fnc((frameNum - (keyData.t - this.offsetTime)) / ((nextKeyData.t - this.offsetTime) - (keyData.t - this.offsetTime)));
	        }
	        keyPropE = nextKeyData.s ? nextKeyData.s[0] : keyData.e[0];
	      }
	      keyPropS = keyData.s[0];
	    }
	    jLen = previousValue._length;
	    kLen = keyPropS.i[0].length;
	    caching.lastIndex = iterationIndex;

	    for (j = 0; j < jLen; j += 1) {
	      for (k = 0; k < kLen; k += 1) {
	        vertexValue = isHold ? keyPropS.i[j][k] : keyPropS.i[j][k] + (keyPropE.i[j][k] - keyPropS.i[j][k]) * perc;
	        previousValue.i[j][k] = vertexValue;
	        vertexValue = isHold ? keyPropS.o[j][k] : keyPropS.o[j][k] + (keyPropE.o[j][k] - keyPropS.o[j][k]) * perc;
	        previousValue.o[j][k] = vertexValue;
	        vertexValue = isHold ? keyPropS.v[j][k] : keyPropS.v[j][k] + (keyPropE.v[j][k] - keyPropS.v[j][k]) * perc;
	        previousValue.v[j][k] = vertexValue;
	      }
	    }
	  }

	  function interpolateShapeCurrentTime() {
	    var frameNum = this.comp.renderedFrame - this.offsetTime;
	    var initTime = this.keyframes[0].t - this.offsetTime;
	    var endTime = this.keyframes[this.keyframes.length - 1].t - this.offsetTime;
	    var lastFrame = this._caching.lastFrame;
	    if (!(lastFrame !== initFrame && ((lastFrame < initTime && frameNum < initTime) || (lastFrame > endTime && frameNum > endTime)))) {
	      /// /
	      this._caching.lastIndex = lastFrame < frameNum ? this._caching.lastIndex : 0;
	      this.interpolateShape(frameNum, this.pv, this._caching);
	      /// /
	    }
	    this._caching.lastFrame = frameNum;
	    return this.pv;
	  }

	  function resetShape() {
	    this.paths = this.localShapeCollection;
	  }

	  function shapesEqual(shape1, shape2) {
	    if (shape1._length !== shape2._length || shape1.c !== shape2.c) {
	      return false;
	    }
	    var i;
	    var len = shape1._length;
	    for (i = 0; i < len; i += 1) {
	      if (shape1.v[i][0] !== shape2.v[i][0]
	            || shape1.v[i][1] !== shape2.v[i][1]
	            || shape1.o[i][0] !== shape2.o[i][0]
	            || shape1.o[i][1] !== shape2.o[i][1]
	            || shape1.i[i][0] !== shape2.i[i][0]
	            || shape1.i[i][1] !== shape2.i[i][1]) {
	        return false;
	      }
	    }
	    return true;
	  }

	  function setVValue(newPath) {
	    if (!shapesEqual(this.v, newPath)) {
	      this.v = shapePool.clone(newPath);
	      this.localShapeCollection.releaseShapes();
	      this.localShapeCollection.addShape(this.v);
	      this._mdf = true;
	      this.paths = this.localShapeCollection;
	    }
	  }

	  function processEffectsSequence() {
	    if (this.elem.globalData.frameId === this.frameId) {
	      return;
	    } if (!this.effectsSequence.length) {
	      this._mdf = false;
	      return;
	    }
	    if (this.lock) {
	      this.setVValue(this.pv);
	      return;
	    }
	    this.lock = true;
	    this._mdf = false;
	    var finalValue;
	    if (this.kf) {
	      finalValue = this.pv;
	    } else if (this.data.ks) {
	      finalValue = this.data.ks.k;
	    } else {
	      finalValue = this.data.pt.k;
	    }
	    var i;
	    var len = this.effectsSequence.length;
	    for (i = 0; i < len; i += 1) {
	      finalValue = this.effectsSequence[i](finalValue);
	    }
	    this.setVValue(finalValue);
	    this.lock = false;
	    this.frameId = this.elem.globalData.frameId;
	  }

	  function ShapeProperty(elem, data, type) {
	    this.propType = 'shape';
	    this.comp = elem.comp;
	    this.container = elem;
	    this.elem = elem;
	    this.data = data;
	    this.k = false;
	    this.kf = false;
	    this._mdf = false;
	    var pathData = type === 3 ? data.pt.k : data.ks.k;
	    this.v = shapePool.clone(pathData);
	    this.pv = shapePool.clone(this.v);
	    this.localShapeCollection = shapeCollectionPool.newShapeCollection();
	    this.paths = this.localShapeCollection;
	    this.paths.addShape(this.v);
	    this.reset = resetShape;
	    this.effectsSequence = [];
	  }

	  function addEffect(effectFunction) {
	    this.effectsSequence.push(effectFunction);
	    this.container.addDynamicProperty(this);
	  }

	  ShapeProperty.prototype.interpolateShape = interpolateShape;
	  ShapeProperty.prototype.getValue = processEffectsSequence;
	  ShapeProperty.prototype.setVValue = setVValue;
	  ShapeProperty.prototype.addEffect = addEffect;

	  function KeyframedShapeProperty(elem, data, type) {
	    this.propType = 'shape';
	    this.comp = elem.comp;
	    this.elem = elem;
	    this.container = elem;
	    this.offsetTime = elem.data.st;
	    this.keyframes = type === 3 ? data.pt.k : data.ks.k;
	    this.k = true;
	    this.kf = true;
	    var len = this.keyframes[0].s[0].i.length;
	    this.v = shapePool.newElement();
	    this.v.setPathData(this.keyframes[0].s[0].c, len);
	    this.pv = shapePool.clone(this.v);
	    this.localShapeCollection = shapeCollectionPool.newShapeCollection();
	    this.paths = this.localShapeCollection;
	    this.paths.addShape(this.v);
	    this.lastFrame = initFrame;
	    this.reset = resetShape;
	    this._caching = { lastFrame: initFrame, lastIndex: 0 };
	    this.effectsSequence = [interpolateShapeCurrentTime.bind(this)];
	  }
	  KeyframedShapeProperty.prototype.getValue = processEffectsSequence;
	  KeyframedShapeProperty.prototype.interpolateShape = interpolateShape;
	  KeyframedShapeProperty.prototype.setVValue = setVValue;
	  KeyframedShapeProperty.prototype.addEffect = addEffect;

	  var EllShapeProperty = (function () {
	    var cPoint = roundCorner;

	    function EllShapePropertyFactory(elem, data) {
	      /* this.v = {
	                v: createSizedArray(4),
	                i: createSizedArray(4),
	                o: createSizedArray(4),
	                c: true
	            }; */
	      this.v = shapePool.newElement();
	      this.v.setPathData(true, 4);
	      this.localShapeCollection = shapeCollectionPool.newShapeCollection();
	      this.paths = this.localShapeCollection;
	      this.localShapeCollection.addShape(this.v);
	      this.d = data.d;
	      this.elem = elem;
	      this.comp = elem.comp;
	      this.frameId = -1;
	      this.initDynamicPropertyContainer(elem);
	      this.p = PropertyFactory.getProp(elem, data.p, 1, 0, this);
	      this.s = PropertyFactory.getProp(elem, data.s, 1, 0, this);
	      if (this.dynamicProperties.length) {
	        this.k = true;
	      } else {
	        this.k = false;
	        this.convertEllToPath();
	      }
	    }

	    EllShapePropertyFactory.prototype = {
	      reset: resetShape,
	      getValue: function () {
	        if (this.elem.globalData.frameId === this.frameId) {
	          return;
	        }
	        this.frameId = this.elem.globalData.frameId;
	        this.iterateDynamicProperties();

	        if (this._mdf) {
	          this.convertEllToPath();
	        }
	      },
	      convertEllToPath: function () {
	        var p0 = this.p.v[0];
	        var p1 = this.p.v[1];
	        var s0 = this.s.v[0] / 2;
	        var s1 = this.s.v[1] / 2;
	        var _cw = this.d !== 3;
	        var _v = this.v;
	        _v.v[0][0] = p0;
	        _v.v[0][1] = p1 - s1;
	        _v.v[1][0] = _cw ? p0 + s0 : p0 - s0;
	        _v.v[1][1] = p1;
	        _v.v[2][0] = p0;
	        _v.v[2][1] = p1 + s1;
	        _v.v[3][0] = _cw ? p0 - s0 : p0 + s0;
	        _v.v[3][1] = p1;
	        _v.i[0][0] = _cw ? p0 - s0 * cPoint : p0 + s0 * cPoint;
	        _v.i[0][1] = p1 - s1;
	        _v.i[1][0] = _cw ? p0 + s0 : p0 - s0;
	        _v.i[1][1] = p1 - s1 * cPoint;
	        _v.i[2][0] = _cw ? p0 + s0 * cPoint : p0 - s0 * cPoint;
	        _v.i[2][1] = p1 + s1;
	        _v.i[3][0] = _cw ? p0 - s0 : p0 + s0;
	        _v.i[3][1] = p1 + s1 * cPoint;
	        _v.o[0][0] = _cw ? p0 + s0 * cPoint : p0 - s0 * cPoint;
	        _v.o[0][1] = p1 - s1;
	        _v.o[1][0] = _cw ? p0 + s0 : p0 - s0;
	        _v.o[1][1] = p1 + s1 * cPoint;
	        _v.o[2][0] = _cw ? p0 - s0 * cPoint : p0 + s0 * cPoint;
	        _v.o[2][1] = p1 + s1;
	        _v.o[3][0] = _cw ? p0 - s0 : p0 + s0;
	        _v.o[3][1] = p1 - s1 * cPoint;
	      },
	    };

	    extendPrototype([DynamicPropertyContainer], EllShapePropertyFactory);

	    return EllShapePropertyFactory;
	  }());

	  var StarShapeProperty = (function () {
	    function StarShapePropertyFactory(elem, data) {
	      this.v = shapePool.newElement();
	      this.v.setPathData(true, 0);
	      this.elem = elem;
	      this.comp = elem.comp;
	      this.data = data;
	      this.frameId = -1;
	      this.d = data.d;
	      this.initDynamicPropertyContainer(elem);
	      if (data.sy === 1) {
	        this.ir = PropertyFactory.getProp(elem, data.ir, 0, 0, this);
	        this.is = PropertyFactory.getProp(elem, data.is, 0, 0.01, this);
	        this.convertToPath = this.convertStarToPath;
	      } else {
	        this.convertToPath = this.convertPolygonToPath;
	      }
	      this.pt = PropertyFactory.getProp(elem, data.pt, 0, 0, this);
	      this.p = PropertyFactory.getProp(elem, data.p, 1, 0, this);
	      this.r = PropertyFactory.getProp(elem, data.r, 0, degToRads, this);
	      this.or = PropertyFactory.getProp(elem, data.or, 0, 0, this);
	      this.os = PropertyFactory.getProp(elem, data.os, 0, 0.01, this);
	      this.localShapeCollection = shapeCollectionPool.newShapeCollection();
	      this.localShapeCollection.addShape(this.v);
	      this.paths = this.localShapeCollection;
	      if (this.dynamicProperties.length) {
	        this.k = true;
	      } else {
	        this.k = false;
	        this.convertToPath();
	      }
	    }

	    StarShapePropertyFactory.prototype = {
	      reset: resetShape,
	      getValue: function () {
	        if (this.elem.globalData.frameId === this.frameId) {
	          return;
	        }
	        this.frameId = this.elem.globalData.frameId;
	        this.iterateDynamicProperties();
	        if (this._mdf) {
	          this.convertToPath();
	        }
	      },
	      convertStarToPath: function () {
	        var numPts = Math.floor(this.pt.v) * 2;
	        var angle = (Math.PI * 2) / numPts;
	        /* this.v.v.length = numPts;
	                this.v.i.length = numPts;
	                this.v.o.length = numPts; */
	        var longFlag = true;
	        var longRad = this.or.v;
	        var shortRad = this.ir.v;
	        var longRound = this.os.v;
	        var shortRound = this.is.v;
	        var longPerimSegment = (2 * Math.PI * longRad) / (numPts * 2);
	        var shortPerimSegment = (2 * Math.PI * shortRad) / (numPts * 2);
	        var i;
	        var rad;
	        var roundness;
	        var perimSegment;
	        var currentAng = -Math.PI / 2;
	        currentAng += this.r.v;
	        var dir = this.data.d === 3 ? -1 : 1;
	        this.v._length = 0;
	        for (i = 0; i < numPts; i += 1) {
	          rad = longFlag ? longRad : shortRad;
	          roundness = longFlag ? longRound : shortRound;
	          perimSegment = longFlag ? longPerimSegment : shortPerimSegment;
	          var x = rad * Math.cos(currentAng);
	          var y = rad * Math.sin(currentAng);
	          var ox = x === 0 && y === 0 ? 0 : y / Math.sqrt(x * x + y * y);
	          var oy = x === 0 && y === 0 ? 0 : -x / Math.sqrt(x * x + y * y);
	          x += +this.p.v[0];
	          y += +this.p.v[1];
	          this.v.setTripleAt(x, y, x - ox * perimSegment * roundness * dir, y - oy * perimSegment * roundness * dir, x + ox * perimSegment * roundness * dir, y + oy * perimSegment * roundness * dir, i, true);

	          /* this.v.v[i] = [x,y];
	                    this.v.i[i] = [x+ox*perimSegment*roundness*dir,y+oy*perimSegment*roundness*dir];
	                    this.v.o[i] = [x-ox*perimSegment*roundness*dir,y-oy*perimSegment*roundness*dir];
	                    this.v._length = numPts; */
	          longFlag = !longFlag;
	          currentAng += angle * dir;
	        }
	      },
	      convertPolygonToPath: function () {
	        var numPts = Math.floor(this.pt.v);
	        var angle = (Math.PI * 2) / numPts;
	        var rad = this.or.v;
	        var roundness = this.os.v;
	        var perimSegment = (2 * Math.PI * rad) / (numPts * 4);
	        var i;
	        var currentAng = -Math.PI * 0.5;
	        var dir = this.data.d === 3 ? -1 : 1;
	        currentAng += this.r.v;
	        this.v._length = 0;
	        for (i = 0; i < numPts; i += 1) {
	          var x = rad * Math.cos(currentAng);
	          var y = rad * Math.sin(currentAng);
	          var ox = x === 0 && y === 0 ? 0 : y / Math.sqrt(x * x + y * y);
	          var oy = x === 0 && y === 0 ? 0 : -x / Math.sqrt(x * x + y * y);
	          x += +this.p.v[0];
	          y += +this.p.v[1];
	          this.v.setTripleAt(x, y, x - ox * perimSegment * roundness * dir, y - oy * perimSegment * roundness * dir, x + ox * perimSegment * roundness * dir, y + oy * perimSegment * roundness * dir, i, true);
	          currentAng += angle * dir;
	        }
	        this.paths.length = 0;
	        this.paths[0] = this.v;
	      },

	    };
	    extendPrototype([DynamicPropertyContainer], StarShapePropertyFactory);

	    return StarShapePropertyFactory;
	  }());

	  var RectShapeProperty = (function () {
	    function RectShapePropertyFactory(elem, data) {
	      this.v = shapePool.newElement();
	      this.v.c = true;
	      this.localShapeCollection = shapeCollectionPool.newShapeCollection();
	      this.localShapeCollection.addShape(this.v);
	      this.paths = this.localShapeCollection;
	      this.elem = elem;
	      this.comp = elem.comp;
	      this.frameId = -1;
	      this.d = data.d;
	      this.initDynamicPropertyContainer(elem);
	      this.p = PropertyFactory.getProp(elem, data.p, 1, 0, this);
	      this.s = PropertyFactory.getProp(elem, data.s, 1, 0, this);
	      this.r = PropertyFactory.getProp(elem, data.r, 0, 0, this);
	      if (this.dynamicProperties.length) {
	        this.k = true;
	      } else {
	        this.k = false;
	        this.convertRectToPath();
	      }
	    }

	    RectShapePropertyFactory.prototype = {
	      convertRectToPath: function () {
	        var p0 = this.p.v[0];
	        var p1 = this.p.v[1];
	        var v0 = this.s.v[0] / 2;
	        var v1 = this.s.v[1] / 2;
	        var round = bmMin(v0, v1, this.r.v);
	        var cPoint = round * (1 - roundCorner);
	        this.v._length = 0;

	        if (this.d === 2 || this.d === 1) {
	          this.v.setTripleAt(p0 + v0, p1 - v1 + round, p0 + v0, p1 - v1 + round, p0 + v0, p1 - v1 + cPoint, 0, true);
	          this.v.setTripleAt(p0 + v0, p1 + v1 - round, p0 + v0, p1 + v1 - cPoint, p0 + v0, p1 + v1 - round, 1, true);
	          if (round !== 0) {
	            this.v.setTripleAt(p0 + v0 - round, p1 + v1, p0 + v0 - round, p1 + v1, p0 + v0 - cPoint, p1 + v1, 2, true);
	            this.v.setTripleAt(p0 - v0 + round, p1 + v1, p0 - v0 + cPoint, p1 + v1, p0 - v0 + round, p1 + v1, 3, true);
	            this.v.setTripleAt(p0 - v0, p1 + v1 - round, p0 - v0, p1 + v1 - round, p0 - v0, p1 + v1 - cPoint, 4, true);
	            this.v.setTripleAt(p0 - v0, p1 - v1 + round, p0 - v0, p1 - v1 + cPoint, p0 - v0, p1 - v1 + round, 5, true);
	            this.v.setTripleAt(p0 - v0 + round, p1 - v1, p0 - v0 + round, p1 - v1, p0 - v0 + cPoint, p1 - v1, 6, true);
	            this.v.setTripleAt(p0 + v0 - round, p1 - v1, p0 + v0 - cPoint, p1 - v1, p0 + v0 - round, p1 - v1, 7, true);
	          } else {
	            this.v.setTripleAt(p0 - v0, p1 + v1, p0 - v0 + cPoint, p1 + v1, p0 - v0, p1 + v1, 2);
	            this.v.setTripleAt(p0 - v0, p1 - v1, p0 - v0, p1 - v1 + cPoint, p0 - v0, p1 - v1, 3);
	          }
	        } else {
	          this.v.setTripleAt(p0 + v0, p1 - v1 + round, p0 + v0, p1 - v1 + cPoint, p0 + v0, p1 - v1 + round, 0, true);
	          if (round !== 0) {
	            this.v.setTripleAt(p0 + v0 - round, p1 - v1, p0 + v0 - round, p1 - v1, p0 + v0 - cPoint, p1 - v1, 1, true);
	            this.v.setTripleAt(p0 - v0 + round, p1 - v1, p0 - v0 + cPoint, p1 - v1, p0 - v0 + round, p1 - v1, 2, true);
	            this.v.setTripleAt(p0 - v0, p1 - v1 + round, p0 - v0, p1 - v1 + round, p0 - v0, p1 - v1 + cPoint, 3, true);
	            this.v.setTripleAt(p0 - v0, p1 + v1 - round, p0 - v0, p1 + v1 - cPoint, p0 - v0, p1 + v1 - round, 4, true);
	            this.v.setTripleAt(p0 - v0 + round, p1 + v1, p0 - v0 + round, p1 + v1, p0 - v0 + cPoint, p1 + v1, 5, true);
	            this.v.setTripleAt(p0 + v0 - round, p1 + v1, p0 + v0 - cPoint, p1 + v1, p0 + v0 - round, p1 + v1, 6, true);
	            this.v.setTripleAt(p0 + v0, p1 + v1 - round, p0 + v0, p1 + v1 - round, p0 + v0, p1 + v1 - cPoint, 7, true);
	          } else {
	            this.v.setTripleAt(p0 - v0, p1 - v1, p0 - v0 + cPoint, p1 - v1, p0 - v0, p1 - v1, 1, true);
	            this.v.setTripleAt(p0 - v0, p1 + v1, p0 - v0, p1 + v1 - cPoint, p0 - v0, p1 + v1, 2, true);
	            this.v.setTripleAt(p0 + v0, p1 + v1, p0 + v0 - cPoint, p1 + v1, p0 + v0, p1 + v1, 3, true);
	          }
	        }
	      },
	      getValue: function () {
	        if (this.elem.globalData.frameId === this.frameId) {
	          return;
	        }
	        this.frameId = this.elem.globalData.frameId;
	        this.iterateDynamicProperties();
	        if (this._mdf) {
	          this.convertRectToPath();
	        }
	      },
	      reset: resetShape,
	    };
	    extendPrototype([DynamicPropertyContainer], RectShapePropertyFactory);

	    return RectShapePropertyFactory;
	  }());

	  function getShapeProp(elem, data, type) {
	    var prop;
	    if (type === 3 || type === 4) {
	      var dataProp = type === 3 ? data.pt : data.ks;
	      var keys = dataProp.k;
	      if (keys.length) {
	        prop = new KeyframedShapeProperty(elem, data, type);
	      } else {
	        prop = new ShapeProperty(elem, data, type);
	      }
	    } else if (type === 5) {
	      prop = new RectShapeProperty(elem, data);
	    } else if (type === 6) {
	      prop = new EllShapeProperty(elem, data);
	    } else if (type === 7) {
	      prop = new StarShapeProperty(elem, data);
	    }
	    if (prop.k) {
	      elem.addDynamicProperty(prop);
	    }
	    return prop;
	  }

	  function getConstructorFunction() {
	    return ShapeProperty;
	  }

	  function getKeyframedConstructorFunction() {
	    return KeyframedShapeProperty;
	  }

	  var ob = {};
	  ob.getShapeProp = getShapeProp;
	  ob.getConstructorFunction = getConstructorFunction;
	  ob.getKeyframedConstructorFunction = getKeyframedConstructorFunction;
	  return ob;
	}());

	/* global shapeCollectionPool, initialDefaultFrame, extendPrototype, DynamicPropertyContainer */
	/* exported ShapeModifiers */

	var ShapeModifiers = (function () {
	  var ob = {};
	  var modifiers = {};
	  ob.registerModifier = registerModifier;
	  ob.getModifier = getModifier;

	  function registerModifier(nm, factory) {
	    if (!modifiers[nm]) {
	      modifiers[nm] = factory;
	    }
	  }

	  function getModifier(nm, elem, data) {
	    return new modifiers[nm](elem, data);
	  }

	  return ob;
	}());

	function ShapeModifier() {}
	ShapeModifier.prototype.initModifierProperties = function () {};
	ShapeModifier.prototype.addShapeToModifier = function () {};
	ShapeModifier.prototype.addShape = function (data) {
	  if (!this.closed) {
	    // Adding shape to dynamic properties. It covers the case where a shape has no effects applied, to reset it's _mdf state on every tick.
	    data.sh.container.addDynamicProperty(data.sh);
	    var shapeData = { shape: data.sh, data: data, localShapeCollection: shapeCollectionPool.newShapeCollection() };
	    this.shapes.push(shapeData);
	    this.addShapeToModifier(shapeData);
	    if (this._isAnimated) {
	      data.setAsAnimated();
	    }
	  }
	};
	ShapeModifier.prototype.init = function (elem, data) {
	  this.shapes = [];
	  this.elem = elem;
	  this.initDynamicPropertyContainer(elem);
	  this.initModifierProperties(elem, data);
	  this.frameId = initialDefaultFrame;
	  this.closed = false;
	  this.k = false;
	  if (this.dynamicProperties.length) {
	    this.k = true;
	  } else {
	    this.getValue(true);
	  }
	};
	ShapeModifier.prototype.processKeys = function () {
	  if (this.elem.globalData.frameId === this.frameId) {
	    return;
	  }
	  this.frameId = this.elem.globalData.frameId;
	  this.iterateDynamicProperties();
	};

	extendPrototype([DynamicPropertyContainer], ShapeModifier);

	/* global extendPrototype, ShapeModifier, PropertyFactory, segmentsLengthPool, bez, shapePool, ShapeModifiers */

	function TrimModifier() {
	}
	extendPrototype([ShapeModifier], TrimModifier);
	TrimModifier.prototype.initModifierProperties = function (elem, data) {
	  this.s = PropertyFactory.getProp(elem, data.s, 0, 0.01, this);
	  this.e = PropertyFactory.getProp(elem, data.e, 0, 0.01, this);
	  this.o = PropertyFactory.getProp(elem, data.o, 0, 0, this);
	  this.sValue = 0;
	  this.eValue = 0;
	  this.getValue = this.processKeys;
	  this.m = data.m;
	  this._isAnimated = !!this.s.effectsSequence.length || !!this.e.effectsSequence.length || !!this.o.effectsSequence.length;
	};

	TrimModifier.prototype.addShapeToModifier = function (shapeData) {
	  shapeData.pathsData = [];
	};

	TrimModifier.prototype.calculateShapeEdges = function (s, e, shapeLength, addedLength, totalModifierLength) {
	  var segments = [];
	  if (e <= 1) {
	    segments.push({
	      s: s,
	      e: e,
	    });
	  } else if (s >= 1) {
	    segments.push({
	      s: s - 1,
	      e: e - 1,
	    });
	  } else {
	    segments.push({
	      s: s,
	      e: 1,
	    });
	    segments.push({
	      s: 0,
	      e: e - 1,
	    });
	  }
	  var shapeSegments = [];
	  var i;
	  var len = segments.length;
	  var segmentOb;
	  for (i = 0; i < len; i += 1) {
	    segmentOb = segments[i];
	    if (!(segmentOb.e * totalModifierLength < addedLength || segmentOb.s * totalModifierLength > addedLength + shapeLength)) {
	      var shapeS;
	      var shapeE;
	      if (segmentOb.s * totalModifierLength <= addedLength) {
	        shapeS = 0;
	      } else {
	        shapeS = (segmentOb.s * totalModifierLength - addedLength) / shapeLength;
	      }
	      if (segmentOb.e * totalModifierLength >= addedLength + shapeLength) {
	        shapeE = 1;
	      } else {
	        shapeE = ((segmentOb.e * totalModifierLength - addedLength) / shapeLength);
	      }
	      shapeSegments.push([shapeS, shapeE]);
	    }
	  }
	  if (!shapeSegments.length) {
	    shapeSegments.push([0, 0]);
	  }
	  return shapeSegments;
	};

	TrimModifier.prototype.releasePathsData = function (pathsData) {
	  var i;
	  var len = pathsData.length;
	  for (i = 0; i < len; i += 1) {
	    segmentsLengthPool.release(pathsData[i]);
	  }
	  pathsData.length = 0;
	  return pathsData;
	};

	TrimModifier.prototype.processShapes = function (_isFirstFrame) {
	  var s;
	  var e;
	  if (this._mdf || _isFirstFrame) {
	    var o = (this.o.v % 360) / 360;
	    if (o < 0) {
	      o += 1;
	    }
	    if (this.s.v > 1) {
	      s = 1 + o;
	    } else if (this.s.v < 0) {
	      s = 0 + o;
	    } else {
	      s = this.s.v + o;
	    }
	    if (this.e.v > 1) {
	      e = 1 + o;
	    } else if (this.e.v < 0) {
	      e = 0 + o;
	    } else {
	      e = this.e.v + o;
	    }

	    if (s > e) {
	      var _s = s;
	      s = e;
	      e = _s;
	    }
	    s = Math.round(s * 10000) * 0.0001;
	    e = Math.round(e * 10000) * 0.0001;
	    this.sValue = s;
	    this.eValue = e;
	  } else {
	    s = this.sValue;
	    e = this.eValue;
	  }
	  var shapePaths;
	  var i;
	  var len = this.shapes.length;
	  var j;
	  var jLen;
	  var pathsData;
	  var pathData;
	  var totalShapeLength;
	  var totalModifierLength = 0;

	  if (e === s) {
	    for (i = 0; i < len; i += 1) {
	      this.shapes[i].localShapeCollection.releaseShapes();
	      this.shapes[i].shape._mdf = true;
	      this.shapes[i].shape.paths = this.shapes[i].localShapeCollection;
	      if (this._mdf) {
	        this.shapes[i].pathsData.length = 0;
	      }
	    }
	  } else if (!((e === 1 && s === 0) || (e === 0 && s === 1))) {
	    var segments = [];
	    var shapeData;
	    var localShapeCollection;
	    for (i = 0; i < len; i += 1) {
	      shapeData = this.shapes[i];
	      // if shape hasn't changed and trim properties haven't changed, cached previous path can be used
	      if (!shapeData.shape._mdf && !this._mdf && !_isFirstFrame && this.m !== 2) {
	        shapeData.shape.paths = shapeData.localShapeCollection;
	      } else {
	        shapePaths = shapeData.shape.paths;
	        jLen = shapePaths._length;
	        totalShapeLength = 0;
	        if (!shapeData.shape._mdf && shapeData.pathsData.length) {
	          totalShapeLength = shapeData.totalShapeLength;
	        } else {
	          pathsData = this.releasePathsData(shapeData.pathsData);
	          for (j = 0; j < jLen; j += 1) {
	            pathData = bez.getSegmentsLength(shapePaths.shapes[j]);
	            pathsData.push(pathData);
	            totalShapeLength += pathData.totalLength;
	          }
	          shapeData.totalShapeLength = totalShapeLength;
	          shapeData.pathsData = pathsData;
	        }

	        totalModifierLength += totalShapeLength;
	        shapeData.shape._mdf = true;
	      }
	    }
	    var shapeS = s;
	    var shapeE = e;
	    var addedLength = 0;
	    var edges;
	    for (i = len - 1; i >= 0; i -= 1) {
	      shapeData = this.shapes[i];
	      if (shapeData.shape._mdf) {
	        localShapeCollection = shapeData.localShapeCollection;
	        localShapeCollection.releaseShapes();
	        // if m === 2 means paths are trimmed individually so edges need to be found for this specific shape relative to whoel group
	        if (this.m === 2 && len > 1) {
	          edges = this.calculateShapeEdges(s, e, shapeData.totalShapeLength, addedLength, totalModifierLength);
	          addedLength += shapeData.totalShapeLength;
	        } else {
	          edges = [[shapeS, shapeE]];
	        }
	        jLen = edges.length;
	        for (j = 0; j < jLen; j += 1) {
	          shapeS = edges[j][0];
	          shapeE = edges[j][1];
	          segments.length = 0;
	          if (shapeE <= 1) {
	            segments.push({
	              s: shapeData.totalShapeLength * shapeS,
	              e: shapeData.totalShapeLength * shapeE,
	            });
	          } else if (shapeS >= 1) {
	            segments.push({
	              s: shapeData.totalShapeLength * (shapeS - 1),
	              e: shapeData.totalShapeLength * (shapeE - 1),
	            });
	          } else {
	            segments.push({
	              s: shapeData.totalShapeLength * shapeS,
	              e: shapeData.totalShapeLength,
	            });
	            segments.push({
	              s: 0,
	              e: shapeData.totalShapeLength * (shapeE - 1),
	            });
	          }
	          var newShapesData = this.addShapes(shapeData, segments[0]);
	          if (segments[0].s !== segments[0].e) {
	            if (segments.length > 1) {
	              var lastShapeInCollection = shapeData.shape.paths.shapes[shapeData.shape.paths._length - 1];
	              if (lastShapeInCollection.c) {
	                var lastShape = newShapesData.pop();
	                this.addPaths(newShapesData, localShapeCollection);
	                newShapesData = this.addShapes(shapeData, segments[1], lastShape);
	              } else {
	                this.addPaths(newShapesData, localShapeCollection);
	                newShapesData = this.addShapes(shapeData, segments[1]);
	              }
	            }
	            this.addPaths(newShapesData, localShapeCollection);
	          }
	        }
	        shapeData.shape.paths = localShapeCollection;
	      }
	    }
	  } else if (this._mdf) {
	    for (i = 0; i < len; i += 1) {
	      // Releasign Trim Cached paths data when no trim applied in case shapes are modified inbetween.
	      // Don't remove this even if it's losing cached info.
	      this.shapes[i].pathsData.length = 0;
	      this.shapes[i].shape._mdf = true;
	    }
	  }
	};

	TrimModifier.prototype.addPaths = function (newPaths, localShapeCollection) {
	  var i;
	  var len = newPaths.length;
	  for (i = 0; i < len; i += 1) {
	    localShapeCollection.addShape(newPaths[i]);
	  }
	};

	TrimModifier.prototype.addSegment = function (pt1, pt2, pt3, pt4, shapePath, pos, newShape) {
	  shapePath.setXYAt(pt2[0], pt2[1], 'o', pos);
	  shapePath.setXYAt(pt3[0], pt3[1], 'i', pos + 1);
	  if (newShape) {
	    shapePath.setXYAt(pt1[0], pt1[1], 'v', pos);
	  }
	  shapePath.setXYAt(pt4[0], pt4[1], 'v', pos + 1);
	};

	TrimModifier.prototype.addSegmentFromArray = function (points, shapePath, pos, newShape) {
	  shapePath.setXYAt(points[1], points[5], 'o', pos);
	  shapePath.setXYAt(points[2], points[6], 'i', pos + 1);
	  if (newShape) {
	    shapePath.setXYAt(points[0], points[4], 'v', pos);
	  }
	  shapePath.setXYAt(points[3], points[7], 'v', pos + 1);
	};

	TrimModifier.prototype.addShapes = function (shapeData, shapeSegment, shapePath) {
	  var pathsData = shapeData.pathsData;
	  var shapePaths = shapeData.shape.paths.shapes;
	  var i;
	  var len = shapeData.shape.paths._length;
	  var j;
	  var jLen;
	  var addedLength = 0;
	  var currentLengthData;
	  var segmentCount;
	  var lengths;
	  var segment;
	  var shapes = [];
	  var initPos;
	  var newShape = true;
	  if (!shapePath) {
	    shapePath = shapePool.newElement();
	    segmentCount = 0;
	    initPos = 0;
	  } else {
	    segmentCount = shapePath._length;
	    initPos = shapePath._length;
	  }
	  shapes.push(shapePath);
	  for (i = 0; i < len; i += 1) {
	    lengths = pathsData[i].lengths;
	    shapePath.c = shapePaths[i].c;
	    jLen = shapePaths[i].c ? lengths.length : lengths.length + 1;
	    for (j = 1; j < jLen; j += 1) {
	      currentLengthData = lengths[j - 1];
	      if (addedLength + currentLengthData.addedLength < shapeSegment.s) {
	        addedLength += currentLengthData.addedLength;
	        shapePath.c = false;
	      } else if (addedLength > shapeSegment.e) {
	        shapePath.c = false;
	        break;
	      } else {
	        if (shapeSegment.s <= addedLength && shapeSegment.e >= addedLength + currentLengthData.addedLength) {
	          this.addSegment(shapePaths[i].v[j - 1], shapePaths[i].o[j - 1], shapePaths[i].i[j], shapePaths[i].v[j], shapePath, segmentCount, newShape);
	          newShape = false;
	        } else {
	          segment = bez.getNewSegment(shapePaths[i].v[j - 1], shapePaths[i].v[j], shapePaths[i].o[j - 1], shapePaths[i].i[j], (shapeSegment.s - addedLength) / currentLengthData.addedLength, (shapeSegment.e - addedLength) / currentLengthData.addedLength, lengths[j - 1]);
	          this.addSegmentFromArray(segment, shapePath, segmentCount, newShape);
	          // this.addSegment(segment.pt1, segment.pt3, segment.pt4, segment.pt2, shapePath, segmentCount, newShape);
	          newShape = false;
	          shapePath.c = false;
	        }
	        addedLength += currentLengthData.addedLength;
	        segmentCount += 1;
	      }
	    }
	    if (shapePaths[i].c && lengths.length) {
	      currentLengthData = lengths[j - 1];
	      if (addedLength <= shapeSegment.e) {
	        var segmentLength = lengths[j - 1].addedLength;
	        if (shapeSegment.s <= addedLength && shapeSegment.e >= addedLength + segmentLength) {
	          this.addSegment(shapePaths[i].v[j - 1], shapePaths[i].o[j - 1], shapePaths[i].i[0], shapePaths[i].v[0], shapePath, segmentCount, newShape);
	          newShape = false;
	        } else {
	          segment = bez.getNewSegment(shapePaths[i].v[j - 1], shapePaths[i].v[0], shapePaths[i].o[j - 1], shapePaths[i].i[0], (shapeSegment.s - addedLength) / segmentLength, (shapeSegment.e - addedLength) / segmentLength, lengths[j - 1]);
	          this.addSegmentFromArray(segment, shapePath, segmentCount, newShape);
	          // this.addSegment(segment.pt1, segment.pt3, segment.pt4, segment.pt2, shapePath, segmentCount, newShape);
	          newShape = false;
	          shapePath.c = false;
	        }
	      } else {
	        shapePath.c = false;
	      }
	      addedLength += currentLengthData.addedLength;
	      segmentCount += 1;
	    }
	    if (shapePath._length) {
	      shapePath.setXYAt(shapePath.v[initPos][0], shapePath.v[initPos][1], 'i', initPos);
	      shapePath.setXYAt(shapePath.v[shapePath._length - 1][0], shapePath.v[shapePath._length - 1][1], 'o', shapePath._length - 1);
	    }
	    if (addedLength > shapeSegment.e) {
	      break;
	    }
	    if (i < len - 1) {
	      shapePath = shapePool.newElement();
	      newShape = true;
	      shapes.push(shapePath);
	      segmentCount = 0;
	    }
	  }
	  return shapes;
	};

	ShapeModifiers.registerModifier('tm', TrimModifier);

	/* global extendPrototype, ShapeModifier, PropertyFactory, shapePool, roundCorner, ShapeModifiers */

	function RoundCornersModifier() {}
	extendPrototype([ShapeModifier], RoundCornersModifier);
	RoundCornersModifier.prototype.initModifierProperties = function (elem, data) {
	  this.getValue = this.processKeys;
	  this.rd = PropertyFactory.getProp(elem, data.r, 0, null, this);
	  this._isAnimated = !!this.rd.effectsSequence.length;
	};

	RoundCornersModifier.prototype.processPath = function (path, round) {
	  var clonedPath = shapePool.newElement();
	  clonedPath.c = path.c;
	  var i;
	  var len = path._length;
	  var currentV;
	  var currentI;
	  var currentO;
	  var closerV;
	  var distance;
	  var newPosPerc;
	  var index = 0;
	  var vX;
	  var vY;
	  var oX;
	  var oY;
	  var iX;
	  var iY;
	  for (i = 0; i < len; i += 1) {
	    currentV = path.v[i];
	    currentO = path.o[i];
	    currentI = path.i[i];
	    if (currentV[0] === currentO[0] && currentV[1] === currentO[1] && currentV[0] === currentI[0] && currentV[1] === currentI[1]) {
	      if ((i === 0 || i === len - 1) && !path.c) {
	        clonedPath.setTripleAt(currentV[0], currentV[1], currentO[0], currentO[1], currentI[0], currentI[1], index);
	        /* clonedPath.v[index] = currentV;
	                clonedPath.o[index] = currentO;
	                clonedPath.i[index] = currentI; */
	        index += 1;
	      } else {
	        if (i === 0) {
	          closerV = path.v[len - 1];
	        } else {
	          closerV = path.v[i - 1];
	        }
	        distance = Math.sqrt(Math.pow(currentV[0] - closerV[0], 2) + Math.pow(currentV[1] - closerV[1], 2));
	        newPosPerc = distance ? Math.min(distance / 2, round) / distance : 0;
	        iX = currentV[0] + (closerV[0] - currentV[0]) * newPosPerc;
	        vX = iX;
	        iY = currentV[1] - (currentV[1] - closerV[1]) * newPosPerc;
	        vY = iY;
	        oX = vX - (vX - currentV[0]) * roundCorner;
	        oY = vY - (vY - currentV[1]) * roundCorner;
	        clonedPath.setTripleAt(vX, vY, oX, oY, iX, iY, index);
	        index += 1;

	        if (i === len - 1) {
	          closerV = path.v[0];
	        } else {
	          closerV = path.v[i + 1];
	        }
	        distance = Math.sqrt(Math.pow(currentV[0] - closerV[0], 2) + Math.pow(currentV[1] - closerV[1], 2));
	        newPosPerc = distance ? Math.min(distance / 2, round) / distance : 0;
	        oX = currentV[0] + (closerV[0] - currentV[0]) * newPosPerc;
	        vX = oX;
	        oY = currentV[1] + (closerV[1] - currentV[1]) * newPosPerc;
	        vY = oY;
	        iX = vX - (vX - currentV[0]) * roundCorner;
	        iY = vY - (vY - currentV[1]) * roundCorner;
	        clonedPath.setTripleAt(vX, vY, oX, oY, iX, iY, index);
	        index += 1;
	      }
	    } else {
	      clonedPath.setTripleAt(path.v[i][0], path.v[i][1], path.o[i][0], path.o[i][1], path.i[i][0], path.i[i][1], index);
	      index += 1;
	    }
	  }
	  return clonedPath;
	};

	RoundCornersModifier.prototype.processShapes = function (_isFirstFrame) {
	  var shapePaths;
	  var i;
	  var len = this.shapes.length;
	  var j;
	  var jLen;
	  var rd = this.rd.v;

	  if (rd !== 0) {
	    var shapeData;
	    var localShapeCollection;
	    for (i = 0; i < len; i += 1) {
	      shapeData = this.shapes[i];
	      localShapeCollection = shapeData.localShapeCollection;
	      if (!(!shapeData.shape._mdf && !this._mdf && !_isFirstFrame)) {
	        localShapeCollection.releaseShapes();
	        shapeData.shape._mdf = true;
	        shapePaths = shapeData.shape.paths.shapes;
	        jLen = shapeData.shape.paths._length;
	        for (j = 0; j < jLen; j += 1) {
	          localShapeCollection.addShape(this.processPath(shapePaths[j], rd));
	        }
	      }
	      shapeData.shape.paths = shapeData.localShapeCollection;
	    }
	  }
	  if (!this.dynamicProperties.length) {
	    this._mdf = false;
	  }
	};

	ShapeModifiers.registerModifier('rd', RoundCornersModifier);

	/* global extendPrototype, ShapeModifier, PropertyFactory, shapePool, ShapeModifiers */

	function PuckerAndBloatModifier() {}
	extendPrototype([ShapeModifier], PuckerAndBloatModifier);
	PuckerAndBloatModifier.prototype.initModifierProperties = function (elem, data) {
	  this.getValue = this.processKeys;
	  this.amount = PropertyFactory.getProp(elem, data.a, 0, null, this);
	  this._isAnimated = !!this.amount.effectsSequence.length;
	};

	PuckerAndBloatModifier.prototype.processPath = function (path, amount) {
	  var percent = amount / 100;
	  var centerPoint = [0, 0];
	  var pathLength = path._length;
	  var i = 0;
	  for (i = 0; i < pathLength; i += 1) {
	    centerPoint[0] += path.v[i][0];
	    centerPoint[1] += path.v[i][1];
	  }
	  centerPoint[0] /= pathLength;
	  centerPoint[1] /= pathLength;
	  var clonedPath = shapePool.newElement();
	  clonedPath.c = path.c;
	  var vX;
	  var vY;
	  var oX;
	  var oY;
	  var iX;
	  var iY;
	  for (i = 0; i < pathLength; i += 1) {
	    vX = path.v[i][0] + (centerPoint[0] - path.v[i][0]) * percent;
	    vY = path.v[i][1] + (centerPoint[1] - path.v[i][1]) * percent;
	    oX = path.o[i][0] + (centerPoint[0] - path.o[i][0]) * -percent;
	    oY = path.o[i][1] + (centerPoint[1] - path.o[i][1]) * -percent;
	    iX = path.i[i][0] + (centerPoint[0] - path.i[i][0]) * -percent;
	    iY = path.i[i][1] + (centerPoint[1] - path.i[i][1]) * -percent;
	    clonedPath.setTripleAt(vX, vY, oX, oY, iX, iY, i);
	  }
	  return clonedPath;
	};

	PuckerAndBloatModifier.prototype.processShapes = function (_isFirstFrame) {
	  var shapePaths;
	  var i;
	  var len = this.shapes.length;
	  var j;
	  var jLen;
	  var amount = this.amount.v;

	  if (amount !== 0) {
	    var shapeData;
	    var localShapeCollection;
	    for (i = 0; i < len; i += 1) {
	      shapeData = this.shapes[i];
	      localShapeCollection = shapeData.localShapeCollection;
	      if (!(!shapeData.shape._mdf && !this._mdf && !_isFirstFrame)) {
	        localShapeCollection.releaseShapes();
	        shapeData.shape._mdf = true;
	        shapePaths = shapeData.shape.paths.shapes;
	        jLen = shapeData.shape.paths._length;
	        for (j = 0; j < jLen; j += 1) {
	          localShapeCollection.addShape(this.processPath(shapePaths[j], amount));
	        }
	      }
	      shapeData.shape.paths = shapeData.localShapeCollection;
	    }
	  }
	  if (!this.dynamicProperties.length) {
	    this._mdf = false;
	  }
	};
	ShapeModifiers.registerModifier('pb', PuckerAndBloatModifier);

	/* global extendPrototype, ShapeModifier, TransformPropertyFactory, PropertyFactory, Matrix, ShapeModifiers */

	function RepeaterModifier() {}
	extendPrototype([ShapeModifier], RepeaterModifier);

	RepeaterModifier.prototype.initModifierProperties = function (elem, data) {
	  this.getValue = this.processKeys;
	  this.c = PropertyFactory.getProp(elem, data.c, 0, null, this);
	  this.o = PropertyFactory.getProp(elem, data.o, 0, null, this);
	  this.tr = TransformPropertyFactory.getTransformProperty(elem, data.tr, this);
	  this.so = PropertyFactory.getProp(elem, data.tr.so, 0, 0.01, this);
	  this.eo = PropertyFactory.getProp(elem, data.tr.eo, 0, 0.01, this);
	  this.data = data;
	  if (!this.dynamicProperties.length) {
	    this.getValue(true);
	  }
	  this._isAnimated = !!this.dynamicProperties.length;
	  this.pMatrix = new Matrix();
	  this.rMatrix = new Matrix();
	  this.sMatrix = new Matrix();
	  this.tMatrix = new Matrix();
	  this.matrix = new Matrix();
	};

	RepeaterModifier.prototype.applyTransforms = function (pMatrix, rMatrix, sMatrix, transform, perc, inv) {
	  var dir = inv ? -1 : 1;
	  var scaleX = transform.s.v[0] + (1 - transform.s.v[0]) * (1 - perc);
	  var scaleY = transform.s.v[1] + (1 - transform.s.v[1]) * (1 - perc);
	  pMatrix.translate(transform.p.v[0] * dir * perc, transform.p.v[1] * dir * perc, transform.p.v[2]);
	  rMatrix.translate(-transform.a.v[0], -transform.a.v[1], transform.a.v[2]);
	  rMatrix.rotate(-transform.r.v * dir * perc);
	  rMatrix.translate(transform.a.v[0], transform.a.v[1], transform.a.v[2]);
	  sMatrix.translate(-transform.a.v[0], -transform.a.v[1], transform.a.v[2]);
	  sMatrix.scale(inv ? 1 / scaleX : scaleX, inv ? 1 / scaleY : scaleY);
	  sMatrix.translate(transform.a.v[0], transform.a.v[1], transform.a.v[2]);
	};

	RepeaterModifier.prototype.init = function (elem, arr, pos, elemsData) {
	  this.elem = elem;
	  this.arr = arr;
	  this.pos = pos;
	  this.elemsData = elemsData;
	  this._currentCopies = 0;
	  this._elements = [];
	  this._groups = [];
	  this.frameId = -1;
	  this.initDynamicPropertyContainer(elem);
	  this.initModifierProperties(elem, arr[pos]);
	  while (pos > 0) {
	    pos -= 1;
	    // this._elements.unshift(arr.splice(pos,1)[0]);
	    this._elements.unshift(arr[pos]);
	  }
	  if (this.dynamicProperties.length) {
	    this.k = true;
	  } else {
	    this.getValue(true);
	  }
	};

	RepeaterModifier.prototype.resetElements = function (elements) {
	  var i;
	  var len = elements.length;
	  for (i = 0; i < len; i += 1) {
	    elements[i]._processed = false;
	    if (elements[i].ty === 'gr') {
	      this.resetElements(elements[i].it);
	    }
	  }
	};

	RepeaterModifier.prototype.cloneElements = function (elements) {
	  var newElements = JSON.parse(JSON.stringify(elements));
	  this.resetElements(newElements);
	  return newElements;
	};

	RepeaterModifier.prototype.changeGroupRender = function (elements, renderFlag) {
	  var i;
	  var len = elements.length;
	  for (i = 0; i < len; i += 1) {
	    elements[i]._render = renderFlag;
	    if (elements[i].ty === 'gr') {
	      this.changeGroupRender(elements[i].it, renderFlag);
	    }
	  }
	};

	RepeaterModifier.prototype.processShapes = function (_isFirstFrame) {
	  var items;
	  var itemsTransform;
	  var i;
	  var dir;
	  var cont;
	  var hasReloaded = false;
	  if (this._mdf || _isFirstFrame) {
	    var copies = Math.ceil(this.c.v);
	    if (this._groups.length < copies) {
	      while (this._groups.length < copies) {
	        var group = {
	          it: this.cloneElements(this._elements),
	          ty: 'gr',
	        };
	        group.it.push({
	          a: { a: 0, ix: 1, k: [0, 0] }, nm: 'Transform', o: { a: 0, ix: 7, k: 100 }, p: { a: 0, ix: 2, k: [0, 0] }, r: { a: 1, ix: 6, k: [{ s: 0, e: 0, t: 0 }, { s: 0, e: 0, t: 1 }] }, s: { a: 0, ix: 3, k: [100, 100] }, sa: { a: 0, ix: 5, k: 0 }, sk: { a: 0, ix: 4, k: 0 }, ty: 'tr',
	        });

	        this.arr.splice(0, 0, group);
	        this._groups.splice(0, 0, group);
	        this._currentCopies += 1;
	      }
	      this.elem.reloadShapes();
	      hasReloaded = true;
	    }
	    cont = 0;
	    var renderFlag;
	    for (i = 0; i <= this._groups.length - 1; i += 1) {
	      renderFlag = cont < copies;
	      this._groups[i]._render = renderFlag;
	      this.changeGroupRender(this._groups[i].it, renderFlag);
	      if (!renderFlag) {
	        var elems = this.elemsData[i].it;
	        var transformData = elems[elems.length - 1];
	        if (transformData.transform.op.v !== 0) {
	          transformData.transform.op._mdf = true;
	          transformData.transform.op.v = 0;
	        } else {
	          transformData.transform.op._mdf = false;
	        }
	      }
	      cont += 1;
	    }

	    this._currentCopies = copies;
	    /// /

	    var offset = this.o.v;
	    var offsetModulo = offset % 1;
	    var roundOffset = offset > 0 ? Math.floor(offset) : Math.ceil(offset);
	    var pProps = this.pMatrix.props;
	    var rProps = this.rMatrix.props;
	    var sProps = this.sMatrix.props;
	    this.pMatrix.reset();
	    this.rMatrix.reset();
	    this.sMatrix.reset();
	    this.tMatrix.reset();
	    this.matrix.reset();
	    var iteration = 0;

	    if (offset > 0) {
	      while (iteration < roundOffset) {
	        this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, false);
	        iteration += 1;
	      }
	      if (offsetModulo) {
	        this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, offsetModulo, false);
	        iteration += offsetModulo;
	      }
	    } else if (offset < 0) {
	      while (iteration > roundOffset) {
	        this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, true);
	        iteration -= 1;
	      }
	      if (offsetModulo) {
	        this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, -offsetModulo, true);
	        iteration -= offsetModulo;
	      }
	    }
	    i = this.data.m === 1 ? 0 : this._currentCopies - 1;
	    dir = this.data.m === 1 ? 1 : -1;
	    cont = this._currentCopies;
	    var j;
	    var jLen;
	    while (cont) {
	      items = this.elemsData[i].it;
	      itemsTransform = items[items.length - 1].transform.mProps.v.props;
	      jLen = itemsTransform.length;
	      items[items.length - 1].transform.mProps._mdf = true;
	      items[items.length - 1].transform.op._mdf = true;
	      items[items.length - 1].transform.op.v = this._currentCopies === 1
	        ? this.so.v
	        : this.so.v + (this.eo.v - this.so.v) * (i / (this._currentCopies - 1));

	      if (iteration !== 0) {
	        if ((i !== 0 && dir === 1) || (i !== this._currentCopies - 1 && dir === -1)) {
	          this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, false);
	        }
	        this.matrix.transform(rProps[0], rProps[1], rProps[2], rProps[3], rProps[4], rProps[5], rProps[6], rProps[7], rProps[8], rProps[9], rProps[10], rProps[11], rProps[12], rProps[13], rProps[14], rProps[15]);
	        this.matrix.transform(sProps[0], sProps[1], sProps[2], sProps[3], sProps[4], sProps[5], sProps[6], sProps[7], sProps[8], sProps[9], sProps[10], sProps[11], sProps[12], sProps[13], sProps[14], sProps[15]);
	        this.matrix.transform(pProps[0], pProps[1], pProps[2], pProps[3], pProps[4], pProps[5], pProps[6], pProps[7], pProps[8], pProps[9], pProps[10], pProps[11], pProps[12], pProps[13], pProps[14], pProps[15]);

	        for (j = 0; j < jLen; j += 1) {
	          itemsTransform[j] = this.matrix.props[j];
	        }
	        this.matrix.reset();
	      } else {
	        this.matrix.reset();
	        for (j = 0; j < jLen; j += 1) {
	          itemsTransform[j] = this.matrix.props[j];
	        }
	      }
	      iteration += 1;
	      cont -= 1;
	      i += dir;
	    }
	  } else {
	    cont = this._currentCopies;
	    i = 0;
	    dir = 1;
	    while (cont) {
	      items = this.elemsData[i].it;
	      itemsTransform = items[items.length - 1].transform.mProps.v.props;
	      items[items.length - 1].transform.mProps._mdf = false;
	      items[items.length - 1].transform.op._mdf = false;
	      cont -= 1;
	      i += dir;
	    }
	  }
	  return hasReloaded;
	};

	RepeaterModifier.prototype.addShape = function () {};

	ShapeModifiers.registerModifier('rp', RepeaterModifier);

	/* global createSizedArray, shapePool */

	function ShapeCollection() {
	  this._length = 0;
	  this._maxLength = 4;
	  this.shapes = createSizedArray(this._maxLength);
	}

	ShapeCollection.prototype.addShape = function (shapeData) {
	  if (this._length === this._maxLength) {
	    this.shapes = this.shapes.concat(createSizedArray(this._maxLength));
	    this._maxLength *= 2;
	  }
	  this.shapes[this._length] = shapeData;
	  this._length += 1;
	};

	ShapeCollection.prototype.releaseShapes = function () {
	  var i;
	  for (i = 0; i < this._length; i += 1) {
	    shapePool.release(this.shapes[i]);
	  }
	  this._length = 0;
	};

	/* global createSizedArray, createTypedArray, PropertyFactory, extendPrototype, DynamicPropertyContainer */

	function DashProperty(elem, data, renderer, container) {
	  this.elem = elem;
	  this.frameId = -1;
	  this.dataProps = createSizedArray(data.length);
	  this.renderer = renderer;
	  this.k = false;
	  this.dashStr = '';
	  this.dashArray = createTypedArray('float32', data.length ? data.length - 1 : 0);
	  this.dashoffset = createTypedArray('float32', 1);
	  this.initDynamicPropertyContainer(container);
	  var i;
	  var len = data.length || 0;
	  var prop;
	  for (i = 0; i < len; i += 1) {
	    prop = PropertyFactory.getProp(elem, data[i].v, 0, 0, this);
	    this.k = prop.k || this.k;
	    this.dataProps[i] = { n: data[i].n, p: prop };
	  }
	  if (!this.k) {
	    this.getValue(true);
	  }
	  this._isAnimated = this.k;
	}

	DashProperty.prototype.getValue = function (forceRender) {
	  if (this.elem.globalData.frameId === this.frameId && !forceRender) {
	    return;
	  }
	  this.frameId = this.elem.globalData.frameId;
	  this.iterateDynamicProperties();
	  this._mdf = this._mdf || forceRender;
	  if (this._mdf) {
	    var i = 0;
	    var len = this.dataProps.length;
	    if (this.renderer === 'svg') {
	      this.dashStr = '';
	    }
	    for (i = 0; i < len; i += 1) {
	      if (this.dataProps[i].n !== 'o') {
	        if (this.renderer === 'svg') {
	          this.dashStr += ' ' + this.dataProps[i].p.v;
	        } else {
	          this.dashArray[i] = this.dataProps[i].p.v;
	        }
	      } else {
	        this.dashoffset[0] = this.dataProps[i].p.v;
	      }
	    }
	  }
	};
	extendPrototype([DynamicPropertyContainer], DashProperty);

	/* global createTypedArray, PropertyFactory, extendPrototype, DynamicPropertyContainer */
	function GradientProperty(elem, data, container) {
	  this.data = data;
	  this.c = createTypedArray('uint8c', data.p * 4);
	  var cLength = data.k.k[0].s ? (data.k.k[0].s.length - data.p * 4) : data.k.k.length - data.p * 4;
	  this.o = createTypedArray('float32', cLength);
	  this._cmdf = false;
	  this._omdf = false;
	  this._collapsable = this.checkCollapsable();
	  this._hasOpacity = cLength;
	  this.initDynamicPropertyContainer(container);
	  this.prop = PropertyFactory.getProp(elem, data.k, 1, null, this);
	  this.k = this.prop.k;
	  this.getValue(true);
	}

	GradientProperty.prototype.comparePoints = function (values, points) {
	  var i = 0;
	  var len = this.o.length / 2;
	  var diff;
	  while (i < len) {
	    diff = Math.abs(values[i * 4] - values[points * 4 + i * 2]);
	    if (diff > 0.01) {
	      return false;
	    }
	    i += 1;
	  }
	  return true;
	};

	GradientProperty.prototype.checkCollapsable = function () {
	  if (this.o.length / 2 !== this.c.length / 4) {
	    return false;
	  }
	  if (this.data.k.k[0].s) {
	    var i = 0;
	    var len = this.data.k.k.length;
	    while (i < len) {
	      if (!this.comparePoints(this.data.k.k[i].s, this.data.p)) {
	        return false;
	      }
	      i += 1;
	    }
	  } else if (!this.comparePoints(this.data.k.k, this.data.p)) {
	    return false;
	  }
	  return true;
	};

	GradientProperty.prototype.getValue = function (forceRender) {
	  this.prop.getValue();
	  this._mdf = false;
	  this._cmdf = false;
	  this._omdf = false;
	  if (this.prop._mdf || forceRender) {
	    var i;
	    var len = this.data.p * 4;
	    var mult;
	    var val;
	    for (i = 0; i < len; i += 1) {
	      mult = i % 4 === 0 ? 100 : 255;
	      val = Math.round(this.prop.v[i] * mult);
	      if (this.c[i] !== val) {
	        this.c[i] = val;
	        this._cmdf = !forceRender;
	      }
	    }
	    if (this.o.length) {
	      len = this.prop.v.length;
	      for (i = this.data.p * 4; i < len; i += 1) {
	        mult = i % 2 === 0 ? 100 : 1;
	        val = i % 2 === 0 ? Math.round(this.prop.v[i] * 100) : this.prop.v[i];
	        if (this.o[i - this.data.p * 4] !== val) {
	          this.o[i - this.data.p * 4] = val;
	          this._omdf = !forceRender;
	        }
	      }
	    }
	    this._mdf = !forceRender;
	  }
	};

	extendPrototype([DynamicPropertyContainer], GradientProperty);

	/* exported buildShapeString */

	var buildShapeString = function (pathNodes, length, closed, mat) {
	  if (length === 0) {
	    return '';
	  }
	  var _o = pathNodes.o;
	  var _i = pathNodes.i;
	  var _v = pathNodes.v;
	  var i;
	  var shapeString = ' M' + mat.applyToPointStringified(_v[0][0], _v[0][1]);
	  for (i = 1; i < length; i += 1) {
	    shapeString += ' C' + mat.applyToPointStringified(_o[i - 1][0], _o[i - 1][1]) + ' ' + mat.applyToPointStringified(_i[i][0], _i[i][1]) + ' ' + mat.applyToPointStringified(_v[i][0], _v[i][1]);
	  }
	  if (closed && length) {
	    shapeString += ' C' + mat.applyToPointStringified(_o[i - 1][0], _o[i - 1][1]) + ' ' + mat.applyToPointStringified(_i[0][0], _i[0][1]) + ' ' + mat.applyToPointStringified(_v[0][0], _v[0][1]);
	    shapeString += 'z';
	  }
	  return shapeString;
	};

	/* global Howl */
	/* exported audioControllerFactory */

	var audioControllerFactory = (function () {
	  function AudioController(audioFactory) {
	    this.audios = [];
	    this.audioFactory = audioFactory;
	    this._volume = 1;
	    this._isMuted = false;
	  }

	  AudioController.prototype = {
	    addAudio: function (audio) {
	      this.audios.push(audio);
	    },
	    pause: function () {
	      var i;
	      var len = this.audios.length;
	      for (i = 0; i < len; i += 1) {
	        this.audios[i].pause();
	      }
	    },
	    resume: function () {
	      var i;
	      var len = this.audios.length;
	      for (i = 0; i < len; i += 1) {
	        this.audios[i].resume();
	      }
	    },
	    setRate: function (rateValue) {
	      var i;
	      var len = this.audios.length;
	      for (i = 0; i < len; i += 1) {
	        this.audios[i].setRate(rateValue);
	      }
	    },
	    createAudio: function (assetPath) {
	      if (this.audioFactory) {
	        return this.audioFactory(assetPath);
	      } if (Howl) {
	        return new Howl({
	          src: [assetPath],
	        });
	      }
	      return {
	        isPlaying: false,
	        play: function () { this.isPlaying = true; },
	        seek: function () { this.isPlaying = false; },
	        playing: function () {},
	        rate: function () {},
	        setVolume: function () {},
	      };
	    },
	    setAudioFactory: function (audioFactory) {
	      this.audioFactory = audioFactory;
	    },
	    setVolume: function (value) {
	      this._volume = value;
	      this._updateVolume();
	    },
	    mute: function () {
	      this._isMuted = true;
	      this._updateVolume();
	    },
	    unmute: function () {
	      this._isMuted = false;
	      this._updateVolume();
	    },
	    getVolume: function () {
	      return this._volume;
	    },
	    _updateVolume: function () {
	      var i;
	      var len = this.audios.length;
	      for (i = 0; i < len; i += 1) {
	        this.audios[i].volume(this._volume * (this._isMuted ? 0 : 1));
	      }
	    },
	  };

	  return function () {
	    return new AudioController();
	  };
	}());

	/* global createTag, createNS, isSafari, assetLoader */
	/* exported ImagePreloader */

	var ImagePreloader = (function () {
	  var proxyImage = (function () {
	    var canvas = createTag('canvas');
	    canvas.width = 1;
	    canvas.height = 1;
	    var ctx = canvas.getContext('2d');
	    ctx.fillStyle = 'rgba(0,0,0,0)';
	    ctx.fillRect(0, 0, 1, 1);
	    return canvas;
	  }());

	  function imageLoaded() {
	    this.loadedAssets += 1;
	    if (this.loadedAssets === this.totalImages && this.loadedFootagesCount === this.totalFootages) {
	      if (this.imagesLoadedCb) {
	        this.imagesLoadedCb(null);
	      }
	    }
	  }
	  function footageLoaded() {
	    this.loadedFootagesCount += 1;
	    if (this.loadedAssets === this.totalImages && this.loadedFootagesCount === this.totalFootages) {
	      if (this.imagesLoadedCb) {
	        this.imagesLoadedCb(null);
	      }
	    }
	  }

	  function getAssetsPath(assetData, assetsPath, originalPath) {
	    var path = '';
	    if (assetData.e) {
	      path = assetData.p;
	    } else if (assetsPath) {
	      var imagePath = assetData.p;
	      if (imagePath.indexOf('images/') !== -1) {
	        imagePath = imagePath.split('/')[1];
	      }
	      path = assetsPath + imagePath;
	    } else {
	      path = originalPath;
	      path += assetData.u ? assetData.u : '';
	      path += assetData.p;
	    }
	    return path;
	  }

	  function testImageLoaded(img) {
	    var _count = 0;
	    var intervalId = setInterval(function () {
	      var box = img.getBBox();
	      if (box.width || _count > 500) {
	        this._imageLoaded();
	        clearInterval(intervalId);
	      }
	      _count += 1;
	    }.bind(this), 50);
	  }

	  function createImageData(assetData) {
	    var path = getAssetsPath(assetData, this.assetsPath, this.path);
	    var img = createNS('image');
	    if (isSafari) {
	      this.testImageLoaded(img);
	    } else {
	      img.addEventListener('load', this._imageLoaded, false);
	    }
	    img.addEventListener('error', function () {
	      ob.img = proxyImage;
	      this._imageLoaded();
	    }.bind(this), false);
	    img.setAttributeNS('http://www.w3.org/1999/xlink', 'href', path);
	    if (this._elementHelper.append) {
	      this._elementHelper.append(img);
	    } else {
	      this._elementHelper.appendChild(img);
	    }
	    var ob = {
	      img: img,
	      assetData: assetData,
	    };
	    return ob;
	  }

	  function createImgData(assetData) {
	    var path = getAssetsPath(assetData, this.assetsPath, this.path);
	    var img = createTag('img');
	    img.crossOrigin = 'anonymous';
	    img.addEventListener('load', this._imageLoaded, false);
	    img.addEventListener('error', function () {
	      ob.img = proxyImage;
	      this._imageLoaded();
	    }.bind(this), false);
	    img.src = path;
	    var ob = {
	      img: img,
	      assetData: assetData,
	    };
	    return ob;
	  }

	  function createFootageData(data) {
	    var ob = {
	      assetData: data,
	    };
	    var path = getAssetsPath(data, this.assetsPath, this.path);
	    assetLoader.load(path, function (footageData) {
	      ob.img = footageData;
	      this._footageLoaded();
	    }.bind(this), function () {
	      ob.img = {};
	      this._footageLoaded();
	    }.bind(this));
	    return ob;
	  }

	  function loadAssets(assets, cb) {
	    this.imagesLoadedCb = cb;
	    var i;
	    var len = assets.length;
	    for (i = 0; i < len; i += 1) {
	      if (!assets[i].layers) {
	        if (!assets[i].t || assets[i].t === 'seq') {
	          this.totalImages += 1;
	          this.images.push(this._createImageData(assets[i]));
	        } else if (assets[i].t === 3) {
	          this.totalFootages += 1;
	          this.images.push(this.createFootageData(assets[i]));
	        }
	      }
	    }
	  }

	  function setPath(path) {
	    this.path = path || '';
	  }

	  function setAssetsPath(path) {
	    this.assetsPath = path || '';
	  }

	  function getAsset(assetData) {
	    var i = 0;
	    var len = this.images.length;
	    while (i < len) {
	      if (this.images[i].assetData === assetData) {
	        return this.images[i].img;
	      }
	      i += 1;
	    }
	    return null;
	  }

	  function destroy() {
	    this.imagesLoadedCb = null;
	    this.images.length = 0;
	  }

	  function loadedImages() {
	    return this.totalImages === this.loadedAssets;
	  }

	  function loadedFootages() {
	    return this.totalFootages === this.loadedFootagesCount;
	  }

	  function setCacheType(type, elementHelper) {
	    if (type === 'svg') {
	      this._elementHelper = elementHelper;
	      this._createImageData = this.createImageData.bind(this);
	    } else {
	      this._createImageData = this.createImgData.bind(this);
	    }
	  }

	  function ImagePreloaderFactory() {
	    this._imageLoaded = imageLoaded.bind(this);
	    this._footageLoaded = footageLoaded.bind(this);
	    this.testImageLoaded = testImageLoaded.bind(this);
	    this.createFootageData = createFootageData.bind(this);
	    this.assetsPath = '';
	    this.path = '';
	    this.totalImages = 0;
	    this.totalFootages = 0;
	    this.loadedAssets = 0;
	    this.loadedFootagesCount = 0;
	    this.imagesLoadedCb = null;
	    this.images = [];
	  }

	  ImagePreloaderFactory.prototype = {
	    loadAssets: loadAssets,
	    setAssetsPath: setAssetsPath,
	    setPath: setPath,
	    loadedImages: loadedImages,
	    loadedFootages: loadedFootages,
	    destroy: destroy,
	    getAsset: getAsset,
	    createImgData: createImgData,
	    createImageData: createImageData,
	    imageLoaded: imageLoaded,
	    footageLoaded: footageLoaded,
	    setCacheType: setCacheType,
	  };

	  return ImagePreloaderFactory;
	}());

	/* exported featureSupport */

	var featureSupport = (function () {
	  var ob = {
	    maskType: true,
	  };
	  if (/MSIE 10/i.test(navigator.userAgent) || /MSIE 9/i.test(navigator.userAgent) || /rv:11.0/i.test(navigator.userAgent) || /Edge\/\d./i.test(navigator.userAgent)) {
	    ob.maskType = false;
	  }
	  return ob;
	}());

	/* global createNS */
	/* exported filtersFactory */

	var filtersFactory = (function () {
	  var ob = {};
	  ob.createFilter = createFilter;
	  ob.createAlphaToLuminanceFilter = createAlphaToLuminanceFilter;

	  function createFilter(filId, skipCoordinates) {
	    var fil = createNS('filter');
	    fil.setAttribute('id', filId);
	    if (skipCoordinates !== true) {
	      fil.setAttribute('filterUnits', 'objectBoundingBox');
	      fil.setAttribute('x', '0%');
	      fil.setAttribute('y', '0%');
	      fil.setAttribute('width', '100%');
	      fil.setAttribute('height', '100%');
	    }
	    return fil;
	  }

	  function createAlphaToLuminanceFilter() {
	    var feColorMatrix = createNS('feColorMatrix');
	    feColorMatrix.setAttribute('type', 'matrix');
	    feColorMatrix.setAttribute('color-interpolation-filters', 'sRGB');
	    feColorMatrix.setAttribute('values', '0 0 0 1 0  0 0 0 1 0  0 0 0 1 0  0 0 0 1 1');
	    return feColorMatrix;
	  }

	  return ob;
	}());

	/* exported assetLoader */

	var assetLoader = (function () {
	  function formatResponse(xhr) {
	    if (xhr.response && typeof xhr.response === 'object') {
	      return xhr.response;
	    } if (xhr.response && typeof xhr.response === 'string') {
	      return JSON.parse(xhr.response);
	    } if (xhr.responseText) {
	      return JSON.parse(xhr.responseText);
	    }
	    return null;
	  }

	  function loadAsset(path, callback, errorCallback) {
	    var response;
	    var xhr = new XMLHttpRequest();
	    // set responseType after calling open or IE will break.
	    try {
	      // This crashes on Android WebView prior to KitKat
	      xhr.responseType = 'json';
	    } catch (err) {} // eslint-disable-line no-empty
	    xhr.onreadystatechange = function () {
	      if (xhr.readyState === 4) {
	        if (xhr.status === 200) {
	          response = formatResponse(xhr);
	          callback(response);
	        } else {
	          try {
	            response = formatResponse(xhr);
	            callback(response);
	          } catch (err) {
	            if (errorCallback) {
	              errorCallback(err);
	            }
	          }
	        }
	      }
	    };
	    xhr.open('GET', path, true);
	    xhr.send();
	  }
	  return {
	    load: loadAsset,
	  };
	}());

	/* global createSizedArray, PropertyFactory, TextAnimatorDataProperty, bez, addHueToRGB,
	  addSaturationToRGB, addBrightnessToRGB, LetterProps, Matrix, extendPrototype, DynamicPropertyContainer */

	function TextAnimatorProperty(textData, renderType, elem) {
	  this._isFirstFrame = true;
	  this._hasMaskedPath = false;
	  this._frameId = -1;
	  this._textData = textData;
	  this._renderType = renderType;
	  this._elem = elem;
	  this._animatorsData = createSizedArray(this._textData.a.length);
	  this._pathData = {};
	  this._moreOptions = {
	    alignment: {},
	  };
	  this.renderedLetters = [];
	  this.lettersChangedFlag = false;
	  this.initDynamicPropertyContainer(elem);
	}

	TextAnimatorProperty.prototype.searchProperties = function () {
	  var i;
	  var len = this._textData.a.length;
	  var animatorProps;
	  var getProp = PropertyFactory.getProp;
	  for (i = 0; i < len; i += 1) {
	    animatorProps = this._textData.a[i];
	    this._animatorsData[i] = new TextAnimatorDataProperty(this._elem, animatorProps, this);
	  }
	  if (this._textData.p && 'm' in this._textData.p) {
	    this._pathData = {
	      f: getProp(this._elem, this._textData.p.f, 0, 0, this),
	      l: getProp(this._elem, this._textData.p.l, 0, 0, this),
	      r: this._textData.p.r,
	      m: this._elem.maskManager.getMaskProperty(this._textData.p.m),
	    };
	    this._hasMaskedPath = true;
	  } else {
	    this._hasMaskedPath = false;
	  }
	  this._moreOptions.alignment = getProp(this._elem, this._textData.m.a, 1, 0, this);
	};

	TextAnimatorProperty.prototype.getMeasures = function (documentData, lettersChangedFlag) {
	  this.lettersChangedFlag = lettersChangedFlag;
	  if (!this._mdf && !this._isFirstFrame && !lettersChangedFlag && (!this._hasMaskedPath || !this._pathData.m._mdf)) {
	    return;
	  }
	  this._isFirstFrame = false;
	  var alignment = this._moreOptions.alignment.v;
	  var animators = this._animatorsData;
	  var textData = this._textData;
	  var matrixHelper = this.mHelper;
	  var renderType = this._renderType;
	  var renderedLettersCount = this.renderedLetters.length;
	  var xPos;
	  var yPos;
	  var i;
	  var len;
	  var letters = documentData.l;
	  var pathInfo;
	  var currentLength;
	  var currentPoint;
	  var segmentLength;
	  var flag;
	  var pointInd;
	  var segmentInd;
	  var prevPoint;
	  var points;
	  var segments;
	  var partialLength;
	  var totalLength;
	  var perc;
	  var tanAngle;
	  var mask;
	  if (this._hasMaskedPath) {
	    mask = this._pathData.m;
	    if (!this._pathData.n || this._pathData._mdf) {
	      var paths = mask.v;
	      if (this._pathData.r) {
	        paths = paths.reverse();
	      }
	      // TODO: release bezier data cached from previous pathInfo: this._pathData.pi
	      pathInfo = {
	        tLength: 0,
	        segments: [],
	      };
	      len = paths._length - 1;
	      var bezierData;
	      totalLength = 0;
	      for (i = 0; i < len; i += 1) {
	        bezierData = bez.buildBezierData(paths.v[i],
	          paths.v[i + 1],
	          [paths.o[i][0] - paths.v[i][0], paths.o[i][1] - paths.v[i][1]],
	          [paths.i[i + 1][0] - paths.v[i + 1][0], paths.i[i + 1][1] - paths.v[i + 1][1]]);
	        pathInfo.tLength += bezierData.segmentLength;
	        pathInfo.segments.push(bezierData);
	        totalLength += bezierData.segmentLength;
	      }
	      i = len;
	      if (mask.v.c) {
	        bezierData = bez.buildBezierData(paths.v[i],
	          paths.v[0],
	          [paths.o[i][0] - paths.v[i][0], paths.o[i][1] - paths.v[i][1]],
	          [paths.i[0][0] - paths.v[0][0], paths.i[0][1] - paths.v[0][1]]);
	        pathInfo.tLength += bezierData.segmentLength;
	        pathInfo.segments.push(bezierData);
	        totalLength += bezierData.segmentLength;
	      }
	      this._pathData.pi = pathInfo;
	    }
	    pathInfo = this._pathData.pi;

	    currentLength = this._pathData.f.v;
	    segmentInd = 0;
	    pointInd = 1;
	    segmentLength = 0;
	    flag = true;
	    segments = pathInfo.segments;
	    if (currentLength < 0 && mask.v.c) {
	      if (pathInfo.tLength < Math.abs(currentLength)) {
	        currentLength = -Math.abs(currentLength) % pathInfo.tLength;
	      }
	      segmentInd = segments.length - 1;
	      points = segments[segmentInd].points;
	      pointInd = points.length - 1;
	      while (currentLength < 0) {
	        currentLength += points[pointInd].partialLength;
	        pointInd -= 1;
	        if (pointInd < 0) {
	          segmentInd -= 1;
	          points = segments[segmentInd].points;
	          pointInd = points.length - 1;
	        }
	      }
	    }
	    points = segments[segmentInd].points;
	    prevPoint = points[pointInd - 1];
	    currentPoint = points[pointInd];
	    partialLength = currentPoint.partialLength;
	  }

	  len = letters.length;
	  xPos = 0;
	  yPos = 0;
	  var yOff = documentData.finalSize * 1.2 * 0.714;
	  var firstLine = true;
	  var animatorProps;
	  var animatorSelector;
	  var j;
	  var jLen;
	  var letterValue;

	  jLen = animators.length;

	  var mult;
	  var ind = -1;
	  var offf;
	  var xPathPos;
	  var yPathPos;
	  var initPathPos = currentLength;
	  var initSegmentInd = segmentInd;
	  var initPointInd = pointInd;
	  var currentLine = -1;
	  var elemOpacity;
	  var sc;
	  var sw;
	  var fc;
	  var k;
	  var letterSw;
	  var letterSc;
	  var letterFc;
	  var letterM = '';
	  var letterP = this.defaultPropsArray;
	  var letterO;

	  //
	  if (documentData.j === 2 || documentData.j === 1) {
	    var animatorJustifyOffset = 0;
	    var animatorFirstCharOffset = 0;
	    var justifyOffsetMult = documentData.j === 2 ? -0.5 : -1;
	    var lastIndex = 0;
	    var isNewLine = true;

	    for (i = 0; i < len; i += 1) {
	      if (letters[i].n) {
	        if (animatorJustifyOffset) {
	          animatorJustifyOffset += animatorFirstCharOffset;
	        }
	        while (lastIndex < i) {
	          letters[lastIndex].animatorJustifyOffset = animatorJustifyOffset;
	          lastIndex += 1;
	        }
	        animatorJustifyOffset = 0;
	        isNewLine = true;
	      } else {
	        for (j = 0; j < jLen; j += 1) {
	          animatorProps = animators[j].a;
	          if (animatorProps.t.propType) {
	            if (isNewLine && documentData.j === 2) {
	              animatorFirstCharOffset += animatorProps.t.v * justifyOffsetMult;
	            }
	            animatorSelector = animators[j].s;
	            mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars);
	            if (mult.length) {
	              animatorJustifyOffset += animatorProps.t.v * mult[0] * justifyOffsetMult;
	            } else {
	              animatorJustifyOffset += animatorProps.t.v * mult * justifyOffsetMult;
	            }
	          }
	        }
	        isNewLine = false;
	      }
	    }
	    if (animatorJustifyOffset) {
	      animatorJustifyOffset += animatorFirstCharOffset;
	    }
	    while (lastIndex < i) {
	      letters[lastIndex].animatorJustifyOffset = animatorJustifyOffset;
	      lastIndex += 1;
	    }
	  }
	  //

	  for (i = 0; i < len; i += 1) {
	    matrixHelper.reset();
	    elemOpacity = 1;
	    if (letters[i].n) {
	      xPos = 0;
	      yPos += documentData.yOffset;
	      yPos += firstLine ? 1 : 0;
	      currentLength = initPathPos;
	      firstLine = false;
	      if (this._hasMaskedPath) {
	        segmentInd = initSegmentInd;
	        pointInd = initPointInd;
	        points = segments[segmentInd].points;
	        prevPoint = points[pointInd - 1];
	        currentPoint = points[pointInd];
	        partialLength = currentPoint.partialLength;
	        segmentLength = 0;
	      }
	      letterM = '';
	      letterFc = '';
	      letterSw = '';
	      letterO = '';
	      letterP = this.defaultPropsArray;
	    } else {
	      if (this._hasMaskedPath) {
	        if (currentLine !== letters[i].line) {
	          switch (documentData.j) {
	            case 1:
	              currentLength += totalLength - documentData.lineWidths[letters[i].line];
	              break;
	            case 2:
	              currentLength += (totalLength - documentData.lineWidths[letters[i].line]) / 2;
	              break;
	            default:
	              break;
	          }
	          currentLine = letters[i].line;
	        }
	        if (ind !== letters[i].ind) {
	          if (letters[ind]) {
	            currentLength += letters[ind].extra;
	          }
	          currentLength += letters[i].an / 2;
	          ind = letters[i].ind;
	        }
	        currentLength += (alignment[0] * letters[i].an) * 0.005;
	        var animatorOffset = 0;
	        for (j = 0; j < jLen; j += 1) {
	          animatorProps = animators[j].a;
	          if (animatorProps.p.propType) {
	            animatorSelector = animators[j].s;
	            mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars);
	            if (mult.length) {
	              animatorOffset += animatorProps.p.v[0] * mult[0];
	            } else {
	              animatorOffset += animatorProps.p.v[0] * mult;
	            }
	          }
	          if (animatorProps.a.propType) {
	            animatorSelector = animators[j].s;
	            mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars);
	            if (mult.length) {
	              animatorOffset += animatorProps.a.v[0] * mult[0];
	            } else {
	              animatorOffset += animatorProps.a.v[0] * mult;
	            }
	          }
	        }
	        flag = true;
	        while (flag) {
	          if (segmentLength + partialLength >= currentLength + animatorOffset || !points) {
	            perc = (currentLength + animatorOffset - segmentLength) / currentPoint.partialLength;
	            xPathPos = prevPoint.point[0] + (currentPoint.point[0] - prevPoint.point[0]) * perc;
	            yPathPos = prevPoint.point[1] + (currentPoint.point[1] - prevPoint.point[1]) * perc;
	            matrixHelper.translate((-alignment[0] * letters[i].an) * 0.005, -(alignment[1] * yOff) * 0.01);
	            flag = false;
	          } else if (points) {
	            segmentLength += currentPoint.partialLength;
	            pointInd += 1;
	            if (pointInd >= points.length) {
	              pointInd = 0;
	              segmentInd += 1;
	              if (!segments[segmentInd]) {
	                if (mask.v.c) {
	                  pointInd = 0;
	                  segmentInd = 0;
	                  points = segments[segmentInd].points;
	                } else {
	                  segmentLength -= currentPoint.partialLength;
	                  points = null;
	                }
	              } else {
	                points = segments[segmentInd].points;
	              }
	            }
	            if (points) {
	              prevPoint = currentPoint;
	              currentPoint = points[pointInd];
	              partialLength = currentPoint.partialLength;
	            }
	          }
	        }
	        offf = letters[i].an / 2 - letters[i].add;
	        matrixHelper.translate(-offf, 0, 0);
	      } else {
	        offf = letters[i].an / 2 - letters[i].add;
	        matrixHelper.translate(-offf, 0, 0);

	        // Grouping alignment
	        matrixHelper.translate((-alignment[0] * letters[i].an) * 0.005, (-alignment[1] * yOff) * 0.01, 0);
	      }

	      for (j = 0; j < jLen; j += 1) {
	        animatorProps = animators[j].a;
	        if (animatorProps.t.propType) {
	          animatorSelector = animators[j].s;
	          mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars);
	          // This condition is to prevent applying tracking to first character in each line. Might be better to use a boolean "isNewLine"
	          if (xPos !== 0 || documentData.j !== 0) {
	            if (this._hasMaskedPath) {
	              if (mult.length) {
	                currentLength += animatorProps.t.v * mult[0];
	              } else {
	                currentLength += animatorProps.t.v * mult;
	              }
	            } else if (mult.length) {
	              xPos += animatorProps.t.v * mult[0];
	            } else {
	              xPos += animatorProps.t.v * mult;
	            }
	          }
	        }
	      }
	      if (documentData.strokeWidthAnim) {
	        sw = documentData.sw || 0;
	      }
	      if (documentData.strokeColorAnim) {
	        if (documentData.sc) {
	          sc = [documentData.sc[0], documentData.sc[1], documentData.sc[2]];
	        } else {
	          sc = [0, 0, 0];
	        }
	      }
	      if (documentData.fillColorAnim && documentData.fc) {
	        fc = [documentData.fc[0], documentData.fc[1], documentData.fc[2]];
	      }
	      for (j = 0; j < jLen; j += 1) {
	        animatorProps = animators[j].a;
	        if (animatorProps.a.propType) {
	          animatorSelector = animators[j].s;
	          mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars);

	          if (mult.length) {
	            matrixHelper.translate(-animatorProps.a.v[0] * mult[0], -animatorProps.a.v[1] * mult[1], animatorProps.a.v[2] * mult[2]);
	          } else {
	            matrixHelper.translate(-animatorProps.a.v[0] * mult, -animatorProps.a.v[1] * mult, animatorProps.a.v[2] * mult);
	          }
	        }
	      }
	      for (j = 0; j < jLen; j += 1) {
	        animatorProps = animators[j].a;
	        if (animatorProps.s.propType) {
	          animatorSelector = animators[j].s;
	          mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars);
	          if (mult.length) {
	            matrixHelper.scale(1 + ((animatorProps.s.v[0] - 1) * mult[0]), 1 + ((animatorProps.s.v[1] - 1) * mult[1]), 1);
	          } else {
	            matrixHelper.scale(1 + ((animatorProps.s.v[0] - 1) * mult), 1 + ((animatorProps.s.v[1] - 1) * mult), 1);
	          }
	        }
	      }
	      for (j = 0; j < jLen; j += 1) {
	        animatorProps = animators[j].a;
	        animatorSelector = animators[j].s;
	        mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars);
	        if (animatorProps.sk.propType) {
	          if (mult.length) {
	            matrixHelper.skewFromAxis(-animatorProps.sk.v * mult[0], animatorProps.sa.v * mult[1]);
	          } else {
	            matrixHelper.skewFromAxis(-animatorProps.sk.v * mult, animatorProps.sa.v * mult);
	          }
	        }
	        if (animatorProps.r.propType) {
	          if (mult.length) {
	            matrixHelper.rotateZ(-animatorProps.r.v * mult[2]);
	          } else {
	            matrixHelper.rotateZ(-animatorProps.r.v * mult);
	          }
	        }
	        if (animatorProps.ry.propType) {
	          if (mult.length) {
	            matrixHelper.rotateY(animatorProps.ry.v * mult[1]);
	          } else {
	            matrixHelper.rotateY(animatorProps.ry.v * mult);
	          }
	        }
	        if (animatorProps.rx.propType) {
	          if (mult.length) {
	            matrixHelper.rotateX(animatorProps.rx.v * mult[0]);
	          } else {
	            matrixHelper.rotateX(animatorProps.rx.v * mult);
	          }
	        }
	        if (animatorProps.o.propType) {
	          if (mult.length) {
	            elemOpacity += ((animatorProps.o.v) * mult[0] - elemOpacity) * mult[0];
	          } else {
	            elemOpacity += ((animatorProps.o.v) * mult - elemOpacity) * mult;
	          }
	        }
	        if (documentData.strokeWidthAnim && animatorProps.sw.propType) {
	          if (mult.length) {
	            sw += animatorProps.sw.v * mult[0];
	          } else {
	            sw += animatorProps.sw.v * mult;
	          }
	        }
	        if (documentData.strokeColorAnim && animatorProps.sc.propType) {
	          for (k = 0; k < 3; k += 1) {
	            if (mult.length) {
	              sc[k] += (animatorProps.sc.v[k] - sc[k]) * mult[0];
	            } else {
	              sc[k] += (animatorProps.sc.v[k] - sc[k]) * mult;
	            }
	          }
	        }
	        if (documentData.fillColorAnim && documentData.fc) {
	          if (animatorProps.fc.propType) {
	            for (k = 0; k < 3; k += 1) {
	              if (mult.length) {
	                fc[k] += (animatorProps.fc.v[k] - fc[k]) * mult[0];
	              } else {
	                fc[k] += (animatorProps.fc.v[k] - fc[k]) * mult;
	              }
	            }
	          }
	          if (animatorProps.fh.propType) {
	            if (mult.length) {
	              fc = addHueToRGB(fc, animatorProps.fh.v * mult[0]);
	            } else {
	              fc = addHueToRGB(fc, animatorProps.fh.v * mult);
	            }
	          }
	          if (animatorProps.fs.propType) {
	            if (mult.length) {
	              fc = addSaturationToRGB(fc, animatorProps.fs.v * mult[0]);
	            } else {
	              fc = addSaturationToRGB(fc, animatorProps.fs.v * mult);
	            }
	          }
	          if (animatorProps.fb.propType) {
	            if (mult.length) {
	              fc = addBrightnessToRGB(fc, animatorProps.fb.v * mult[0]);
	            } else {
	              fc = addBrightnessToRGB(fc, animatorProps.fb.v * mult);
	            }
	          }
	        }
	      }

	      for (j = 0; j < jLen; j += 1) {
	        animatorProps = animators[j].a;

	        if (animatorProps.p.propType) {
	          animatorSelector = animators[j].s;
	          mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars);
	          if (this._hasMaskedPath) {
	            if (mult.length) {
	              matrixHelper.translate(0, animatorProps.p.v[1] * mult[0], -animatorProps.p.v[2] * mult[1]);
	            } else {
	              matrixHelper.translate(0, animatorProps.p.v[1] * mult, -animatorProps.p.v[2] * mult);
	            }
	          } else if (mult.length) {
	            matrixHelper.translate(animatorProps.p.v[0] * mult[0], animatorProps.p.v[1] * mult[1], -animatorProps.p.v[2] * mult[2]);
	          } else {
	            matrixHelper.translate(animatorProps.p.v[0] * mult, animatorProps.p.v[1] * mult, -animatorProps.p.v[2] * mult);
	          }
	        }
	      }
	      if (documentData.strokeWidthAnim) {
	        letterSw = sw < 0 ? 0 : sw;
	      }
	      if (documentData.strokeColorAnim) {
	        letterSc = 'rgb(' + Math.round(sc[0] * 255) + ',' + Math.round(sc[1] * 255) + ',' + Math.round(sc[2] * 255) + ')';
	      }
	      if (documentData.fillColorAnim && documentData.fc) {
	        letterFc = 'rgb(' + Math.round(fc[0] * 255) + ',' + Math.round(fc[1] * 255) + ',' + Math.round(fc[2] * 255) + ')';
	      }

	      if (this._hasMaskedPath) {
	        matrixHelper.translate(0, -documentData.ls);

	        matrixHelper.translate(0, (alignment[1] * yOff) * 0.01 + yPos, 0);
	        if (textData.p.p) {
	          tanAngle = (currentPoint.point[1] - prevPoint.point[1]) / (currentPoint.point[0] - prevPoint.point[0]);
	          var rot = (Math.atan(tanAngle) * 180) / Math.PI;
	          if (currentPoint.point[0] < prevPoint.point[0]) {
	            rot += 180;
	          }
	          matrixHelper.rotate((-rot * Math.PI) / 180);
	        }
	        matrixHelper.translate(xPathPos, yPathPos, 0);
	        currentLength -= (alignment[0] * letters[i].an) * 0.005;
	        if (letters[i + 1] && ind !== letters[i + 1].ind) {
	          currentLength += letters[i].an / 2;
	          currentLength += (documentData.tr * 0.001) * documentData.finalSize;
	        }
	      } else {
	        matrixHelper.translate(xPos, yPos, 0);

	        if (documentData.ps) {
	          // matrixHelper.translate(documentData.ps[0],documentData.ps[1],0);
	          matrixHelper.translate(documentData.ps[0], documentData.ps[1] + documentData.ascent, 0);
	        }
	        switch (documentData.j) {
	          case 1:
	            matrixHelper.translate(letters[i].animatorJustifyOffset + documentData.justifyOffset + (documentData.boxWidth - documentData.lineWidths[letters[i].line]), 0, 0);
	            break;
	          case 2:
	            matrixHelper.translate(letters[i].animatorJustifyOffset + documentData.justifyOffset + (documentData.boxWidth - documentData.lineWidths[letters[i].line]) / 2, 0, 0);
	            break;
	          default:
	            break;
	        }
	        matrixHelper.translate(0, -documentData.ls);
	        matrixHelper.translate(offf, 0, 0);
	        matrixHelper.translate((alignment[0] * letters[i].an) * 0.005, (alignment[1] * yOff) * 0.01, 0);
	        xPos += letters[i].l + (documentData.tr * 0.001) * documentData.finalSize;
	      }
	      if (renderType === 'html') {
	        letterM = matrixHelper.toCSS();
	      } else if (renderType === 'svg') {
	        letterM = matrixHelper.to2dCSS();
	      } else {
	        letterP = [matrixHelper.props[0], matrixHelper.props[1], matrixHelper.props[2], matrixHelper.props[3], matrixHelper.props[4], matrixHelper.props[5], matrixHelper.props[6], matrixHelper.props[7], matrixHelper.props[8], matrixHelper.props[9], matrixHelper.props[10], matrixHelper.props[11], matrixHelper.props[12], matrixHelper.props[13], matrixHelper.props[14], matrixHelper.props[15]];
	      }
	      letterO = elemOpacity;
	    }

	    if (renderedLettersCount <= i) {
	      letterValue = new LetterProps(letterO, letterSw, letterSc, letterFc, letterM, letterP);
	      this.renderedLetters.push(letterValue);
	      renderedLettersCount += 1;
	      this.lettersChangedFlag = true;
	    } else {
	      letterValue = this.renderedLetters[i];
	      this.lettersChangedFlag = letterValue.update(letterO, letterSw, letterSc, letterFc, letterM, letterP) || this.lettersChangedFlag;
	    }
	  }
	};

	TextAnimatorProperty.prototype.getValue = function () {
	  if (this._elem.globalData.frameId === this._frameId) {
	    return;
	  }
	  this._frameId = this._elem.globalData.frameId;
	  this.iterateDynamicProperties();
	};

	TextAnimatorProperty.prototype.mHelper = new Matrix();
	TextAnimatorProperty.prototype.defaultPropsArray = [];
	extendPrototype([DynamicPropertyContainer], TextAnimatorProperty);

	/* global PropertyFactory, degToRads, TextSelectorProp */
	/* exported TextAnimatorDataProperty */

	function TextAnimatorDataProperty(elem, animatorProps, container) {
	  var defaultData = { propType: false };
	  var getProp = PropertyFactory.getProp;
	  var textAnimatorAnimatables = animatorProps.a;
	  this.a = {
	    r: textAnimatorAnimatables.r ? getProp(elem, textAnimatorAnimatables.r, 0, degToRads, container) : defaultData,
	    rx: textAnimatorAnimatables.rx ? getProp(elem, textAnimatorAnimatables.rx, 0, degToRads, container) : defaultData,
	    ry: textAnimatorAnimatables.ry ? getProp(elem, textAnimatorAnimatables.ry, 0, degToRads, container) : defaultData,
	    sk: textAnimatorAnimatables.sk ? getProp(elem, textAnimatorAnimatables.sk, 0, degToRads, container) : defaultData,
	    sa: textAnimatorAnimatables.sa ? getProp(elem, textAnimatorAnimatables.sa, 0, degToRads, container) : defaultData,
	    s: textAnimatorAnimatables.s ? getProp(elem, textAnimatorAnimatables.s, 1, 0.01, container) : defaultData,
	    a: textAnimatorAnimatables.a ? getProp(elem, textAnimatorAnimatables.a, 1, 0, container) : defaultData,
	    o: textAnimatorAnimatables.o ? getProp(elem, textAnimatorAnimatables.o, 0, 0.01, container) : defaultData,
	    p: textAnimatorAnimatables.p ? getProp(elem, textAnimatorAnimatables.p, 1, 0, container) : defaultData,
	    sw: textAnimatorAnimatables.sw ? getProp(elem, textAnimatorAnimatables.sw, 0, 0, container) : defaultData,
	    sc: textAnimatorAnimatables.sc ? getProp(elem, textAnimatorAnimatables.sc, 1, 0, container) : defaultData,
	    fc: textAnimatorAnimatables.fc ? getProp(elem, textAnimatorAnimatables.fc, 1, 0, container) : defaultData,
	    fh: textAnimatorAnimatables.fh ? getProp(elem, textAnimatorAnimatables.fh, 0, 0, container) : defaultData,
	    fs: textAnimatorAnimatables.fs ? getProp(elem, textAnimatorAnimatables.fs, 0, 0.01, container) : defaultData,
	    fb: textAnimatorAnimatables.fb ? getProp(elem, textAnimatorAnimatables.fb, 0, 0.01, container) : defaultData,
	    t: textAnimatorAnimatables.t ? getProp(elem, textAnimatorAnimatables.t, 0, 0, container) : defaultData,
	  };

	  this.s = TextSelectorProp.getTextSelectorProp(elem, animatorProps.s, container);
	  this.s.t = animatorProps.s.t;
	}

	function LetterProps(o, sw, sc, fc, m, p) {
	  this.o = o;
	  this.sw = sw;
	  this.sc = sc;
	  this.fc = fc;
	  this.m = m;
	  this.p = p;
	  this._mdf = {
	    o: true,
	    sw: !!sw,
	    sc: !!sc,
	    fc: !!fc,
	    m: true,
	    p: true,
	  };
	}

	LetterProps.prototype.update = function (o, sw, sc, fc, m, p) {
	  this._mdf.o = false;
	  this._mdf.sw = false;
	  this._mdf.sc = false;
	  this._mdf.fc = false;
	  this._mdf.m = false;
	  this._mdf.p = false;
	  var updated = false;

	  if (this.o !== o) {
	    this.o = o;
	    this._mdf.o = true;
	    updated = true;
	  }
	  if (this.sw !== sw) {
	    this.sw = sw;
	    this._mdf.sw = true;
	    updated = true;
	  }
	  if (this.sc !== sc) {
	    this.sc = sc;
	    this._mdf.sc = true;
	    updated = true;
	  }
	  if (this.fc !== fc) {
	    this.fc = fc;
	    this._mdf.fc = true;
	    updated = true;
	  }
	  if (this.m !== m) {
	    this.m = m;
	    this._mdf.m = true;
	    updated = true;
	  }
	  if (p.length && (this.p[0] !== p[0] || this.p[1] !== p[1] || this.p[4] !== p[4] || this.p[5] !== p[5] || this.p[12] !== p[12] || this.p[13] !== p[13])) {
	    this.p = p;
	    this._mdf.p = true;
	    updated = true;
	  }
	  return updated;
	};

	/* global FontManager, initialDefaultFrame, getFontProperties */
	/* exported TextProperty */

	function TextProperty(elem, data) {
	  this._frameId = initialDefaultFrame;
	  this.pv = '';
	  this.v = '';
	  this.kf = false;
	  this._isFirstFrame = true;
	  this._mdf = false;
	  this.data = data;
	  this.elem = elem;
	  this.comp = this.elem.comp;
	  this.keysIndex = 0;
	  this.canResize = false;
	  this.minimumFontSize = 1;
	  this.effectsSequence = [];
	  this.currentData = {
	    ascent: 0,
	    boxWidth: this.defaultBoxWidth,
	    f: '',
	    fStyle: '',
	    fWeight: '',
	    fc: '',
	    j: '',
	    justifyOffset: '',
	    l: [],
	    lh: 0,
	    lineWidths: [],
	    ls: '',
	    of: '',
	    s: '',
	    sc: '',
	    sw: 0,
	    t: 0,
	    tr: 0,
	    sz: 0,
	    ps: null,
	    fillColorAnim: false,
	    strokeColorAnim: false,
	    strokeWidthAnim: false,
	    yOffset: 0,
	    finalSize: 0,
	    finalText: [],
	    finalLineHeight: 0,
	    __complete: false,

	  };
	  this.copyData(this.currentData, this.data.d.k[0].s);

	  if (!this.searchProperty()) {
	    this.completeTextData(this.currentData);
	  }
	}

	TextProperty.prototype.defaultBoxWidth = [0, 0];

	TextProperty.prototype.copyData = function (obj, data) {
	  for (var s in data) {
	    if (Object.prototype.hasOwnProperty.call(data, s)) {
	      obj[s] = data[s];
	    }
	  }
	  return obj;
	};

	TextProperty.prototype.setCurrentData = function (data) {
	  if (!data.__complete) {
	    this.completeTextData(data);
	  }
	  this.currentData = data;
	  this.currentData.boxWidth = this.currentData.boxWidth || this.defaultBoxWidth;
	  this._mdf = true;
	};

	TextProperty.prototype.searchProperty = function () {
	  return this.searchKeyframes();
	};

	TextProperty.prototype.searchKeyframes = function () {
	  this.kf = this.data.d.k.length > 1;
	  if (this.kf) {
	    this.addEffect(this.getKeyframeValue.bind(this));
	  }
	  return this.kf;
	};

	TextProperty.prototype.addEffect = function (effectFunction) {
	  this.effectsSequence.push(effectFunction);
	  this.elem.addDynamicProperty(this);
	};

	TextProperty.prototype.getValue = function (_finalValue) {
	  if ((this.elem.globalData.frameId === this.frameId || !this.effectsSequence.length) && !_finalValue) {
	    return;
	  }
	  this.currentData.t = this.data.d.k[this.keysIndex].s.t;
	  var currentValue = this.currentData;
	  var currentIndex = this.keysIndex;
	  if (this.lock) {
	    this.setCurrentData(this.currentData);
	    return;
	  }
	  this.lock = true;
	  this._mdf = false;
	  var i; var
	    len = this.effectsSequence.length;
	  var finalValue = _finalValue || this.data.d.k[this.keysIndex].s;
	  for (i = 0; i < len; i += 1) {
	    // Checking if index changed to prevent creating a new object every time the expression updates.
	    if (currentIndex !== this.keysIndex) {
	      finalValue = this.effectsSequence[i](finalValue, finalValue.t);
	    } else {
	      finalValue = this.effectsSequence[i](this.currentData, finalValue.t);
	    }
	  }
	  if (currentValue !== finalValue) {
	    this.setCurrentData(finalValue);
	  }
	  this.v = this.currentData;
	  this.pv = this.v;
	  this.lock = false;
	  this.frameId = this.elem.globalData.frameId;
	};

	TextProperty.prototype.getKeyframeValue = function () {
	  var textKeys = this.data.d.k;
	  var frameNum = this.elem.comp.renderedFrame;
	  var i = 0; var
	    len = textKeys.length;
	  while (i <= len - 1) {
	    if (i === len - 1 || textKeys[i + 1].t > frameNum) {
	      break;
	    }
	    i += 1;
	  }
	  if (this.keysIndex !== i) {
	    this.keysIndex = i;
	  }
	  return this.data.d.k[this.keysIndex].s;
	};

	TextProperty.prototype.buildFinalText = function (text) {
	  var charactersArray = [];
	  var i = 0;
	  var len = text.length;
	  var charCode;
	  var secondCharCode;
	  var shouldCombine = false;
	  while (i < len) {
	    charCode = text.charCodeAt(i);
	    if (FontManager.isCombinedCharacter(charCode)) {
	      charactersArray[charactersArray.length - 1] += text.charAt(i);
	    } else if (charCode >= 0xD800 && charCode <= 0xDBFF) {
	      secondCharCode = text.charCodeAt(i + 1);
	      if (secondCharCode >= 0xDC00 && secondCharCode <= 0xDFFF) {
	        if (shouldCombine || FontManager.isModifier(charCode, secondCharCode)) {
	          charactersArray[charactersArray.length - 1] += text.substr(i, 2);
	          shouldCombine = false;
	        } else {
	          charactersArray.push(text.substr(i, 2));
	        }
	        i += 1;
	      } else {
	        charactersArray.push(text.charAt(i));
	      }
	    } else if (charCode > 0xDBFF) {
	      secondCharCode = text.charCodeAt(i + 1);
	      if (FontManager.isZeroWidthJoiner(charCode, secondCharCode)) {
	        shouldCombine = true;
	        charactersArray[charactersArray.length - 1] += text.substr(i, 2);
	        i += 1;
	      } else {
	        charactersArray.push(text.charAt(i));
	      }
	    } else if (FontManager.isZeroWidthJoiner(charCode)) {
	      charactersArray[charactersArray.length - 1] += text.charAt(i);
	      shouldCombine = true;
	    } else {
	      charactersArray.push(text.charAt(i));
	    }
	    i += 1;
	  }
	  return charactersArray;
	};

	TextProperty.prototype.completeTextData = function (documentData) {
	  documentData.__complete = true;
	  var fontManager = this.elem.globalData.fontManager;
	  var data = this.data;
	  var letters = [];
	  var i; var
	    len;
	  var newLineFlag; var index = 0; var
	    val;
	  var anchorGrouping = data.m.g;
	  var currentSize = 0; var currentPos = 0; var currentLine = 0; var
	    lineWidths = [];
	  var lineWidth = 0;
	  var maxLineWidth = 0;
	  var j; var
	    jLen;
	  var fontData = fontManager.getFontByName(documentData.f);
	  var charData; var
	    cLength = 0;

	  var fontProps = getFontProperties(fontData);
	  documentData.fWeight = fontProps.weight;
	  documentData.fStyle = fontProps.style;
	  documentData.finalSize = documentData.s;
	  documentData.finalText = this.buildFinalText(documentData.t);
	  len = documentData.finalText.length;
	  documentData.finalLineHeight = documentData.lh;
	  var trackingOffset = (documentData.tr / 1000) * documentData.finalSize;
	  var charCode;
	  if (documentData.sz) {
	    var flag = true;
	    var boxWidth = documentData.sz[0];
	    var boxHeight = documentData.sz[1];
	    var currentHeight; var
	      finalText;
	    while (flag) {
	      finalText = this.buildFinalText(documentData.t);
	      currentHeight = 0;
	      lineWidth = 0;
	      len = finalText.length;
	      trackingOffset = (documentData.tr / 1000) * documentData.finalSize;
	      var lastSpaceIndex = -1;
	      for (i = 0; i < len; i += 1) {
	        charCode = finalText[i].charCodeAt(0);
	        newLineFlag = false;
	        if (finalText[i] === ' ') {
	          lastSpaceIndex = i;
	        } else if (charCode === 13 || charCode === 3) {
	          lineWidth = 0;
	          newLineFlag = true;
	          currentHeight += documentData.finalLineHeight || documentData.finalSize * 1.2;
	        }
	        if (fontManager.chars) {
	          charData = fontManager.getCharData(finalText[i], fontData.fStyle, fontData.fFamily);
	          cLength = newLineFlag ? 0 : (charData.w * documentData.finalSize) / 100;
	        } else {
	          // tCanvasHelper.font = documentData.s + 'px '+ fontData.fFamily;
	          cLength = fontManager.measureText(finalText[i], documentData.f, documentData.finalSize);
	        }
	        if (lineWidth + cLength > boxWidth && finalText[i] !== ' ') {
	          if (lastSpaceIndex === -1) {
	            len += 1;
	          } else {
	            i = lastSpaceIndex;
	          }
	          currentHeight += documentData.finalLineHeight || documentData.finalSize * 1.2;
	          finalText.splice(i, lastSpaceIndex === i ? 1 : 0, '\r');
	          // finalText = finalText.substr(0,i) + "\r" + finalText.substr(i === lastSpaceIndex ? i + 1 : i);
	          lastSpaceIndex = -1;
	          lineWidth = 0;
	        } else {
	          lineWidth += cLength;
	          lineWidth += trackingOffset;
	        }
	      }
	      currentHeight += (fontData.ascent * documentData.finalSize) / 100;
	      if (this.canResize && documentData.finalSize > this.minimumFontSize && boxHeight < currentHeight) {
	        documentData.finalSize -= 1;
	        documentData.finalLineHeight = (documentData.finalSize * documentData.lh) / documentData.s;
	      } else {
	        documentData.finalText = finalText;
	        len = documentData.finalText.length;
	        flag = false;
	      }
	    }
	  }
	  lineWidth = -trackingOffset;
	  cLength = 0;
	  var uncollapsedSpaces = 0;
	  var currentChar;
	  for (i = 0; i < len; i += 1) {
	    newLineFlag = false;
	    currentChar = documentData.finalText[i];
	    charCode = currentChar.charCodeAt(0);
	    if (charCode === 13 || charCode === 3) {
	      uncollapsedSpaces = 0;
	      lineWidths.push(lineWidth);
	      maxLineWidth = lineWidth > maxLineWidth ? lineWidth : maxLineWidth;
	      lineWidth = -2 * trackingOffset;
	      val = '';
	      newLineFlag = true;
	      currentLine += 1;
	    } else {
	      val = currentChar;
	    }
	    if (fontManager.chars) {
	      charData = fontManager.getCharData(currentChar, fontData.fStyle, fontManager.getFontByName(documentData.f).fFamily);
	      cLength = newLineFlag ? 0 : (charData.w * documentData.finalSize) / 100;
	    } else {
	      // var charWidth = fontManager.measureText(val, documentData.f, documentData.finalSize);
	      // tCanvasHelper.font = documentData.finalSize + 'px '+ fontManager.getFontByName(documentData.f).fFamily;
	      cLength = fontManager.measureText(val, documentData.f, documentData.finalSize);
	    }

	    //
	    if (currentChar === ' ') {
	      uncollapsedSpaces += cLength + trackingOffset;
	    } else {
	      lineWidth += cLength + trackingOffset + uncollapsedSpaces;
	      uncollapsedSpaces = 0;
	    }
	    letters.push({
	      l: cLength, an: cLength, add: currentSize, n: newLineFlag, anIndexes: [], val: val, line: currentLine, animatorJustifyOffset: 0,
	    });
	    if (anchorGrouping == 2) { // eslint-disable-line eqeqeq
	      currentSize += cLength;
	      if (val === '' || val === ' ' || i === len - 1) {
	        if (val === '' || val === ' ') {
	          currentSize -= cLength;
	        }
	        while (currentPos <= i) {
	          letters[currentPos].an = currentSize;
	          letters[currentPos].ind = index;
	          letters[currentPos].extra = cLength;
	          currentPos += 1;
	        }
	        index += 1;
	        currentSize = 0;
	      }
	    } else if (anchorGrouping == 3) { // eslint-disable-line eqeqeq
	      currentSize += cLength;
	      if (val === '' || i === len - 1) {
	        if (val === '') {
	          currentSize -= cLength;
	        }
	        while (currentPos <= i) {
	          letters[currentPos].an = currentSize;
	          letters[currentPos].ind = index;
	          letters[currentPos].extra = cLength;
	          currentPos += 1;
	        }
	        currentSize = 0;
	        index += 1;
	      }
	    } else {
	      letters[index].ind = index;
	      letters[index].extra = 0;
	      index += 1;
	    }
	  }
	  documentData.l = letters;
	  maxLineWidth = lineWidth > maxLineWidth ? lineWidth : maxLineWidth;
	  lineWidths.push(lineWidth);
	  if (documentData.sz) {
	    documentData.boxWidth = documentData.sz[0];
	    documentData.justifyOffset = 0;
	  } else {
	    documentData.boxWidth = maxLineWidth;
	    switch (documentData.j) {
	      case 1:
	        documentData.justifyOffset = -documentData.boxWidth;
	        break;
	      case 2:
	        documentData.justifyOffset = -documentData.boxWidth / 2;
	        break;
	      default:
	        documentData.justifyOffset = 0;
	    }
	  }
	  documentData.lineWidths = lineWidths;

	  var animators = data.a; var animatorData; var
	    letterData;
	  jLen = animators.length;
	  var based; var ind; var
	    indexes = [];
	  for (j = 0; j < jLen; j += 1) {
	    animatorData = animators[j];
	    if (animatorData.a.sc) {
	      documentData.strokeColorAnim = true;
	    }
	    if (animatorData.a.sw) {
	      documentData.strokeWidthAnim = true;
	    }
	    if (animatorData.a.fc || animatorData.a.fh || animatorData.a.fs || animatorData.a.fb) {
	      documentData.fillColorAnim = true;
	    }
	    ind = 0;
	    based = animatorData.s.b;
	    for (i = 0; i < len; i += 1) {
	      letterData = letters[i];
	      letterData.anIndexes[j] = ind;
	      if ((based == 1 && letterData.val !== '') || (based == 2 && letterData.val !== '' && letterData.val !== ' ') || (based == 3 && (letterData.n || letterData.val == ' ' || i == len - 1)) || (based == 4 && (letterData.n || i == len - 1))) { // eslint-disable-line eqeqeq
	        if (animatorData.s.rn === 1) {
	          indexes.push(ind);
	        }
	        ind += 1;
	      }
	    }
	    data.a[j].s.totalChars = ind;
	    var currentInd = -1; var
	      newInd;
	    if (animatorData.s.rn === 1) {
	      for (i = 0; i < len; i += 1) {
	        letterData = letters[i];
	        if (currentInd != letterData.anIndexes[j]) { // eslint-disable-line eqeqeq
	          currentInd = letterData.anIndexes[j];
	          newInd = indexes.splice(Math.floor(Math.random() * indexes.length), 1)[0];
	        }
	        letterData.anIndexes[j] = newInd;
	      }
	    }
	  }
	  documentData.yOffset = documentData.finalLineHeight || documentData.finalSize * 1.2;
	  documentData.ls = documentData.ls || 0;
	  documentData.ascent = (fontData.ascent * documentData.finalSize) / 100;
	};

	TextProperty.prototype.updateDocumentData = function (newData, index) {
	  index = index === undefined ? this.keysIndex : index;
	  var dData = this.copyData({}, this.data.d.k[index].s);
	  dData = this.copyData(dData, newData);
	  this.data.d.k[index].s = dData;
	  this.recalculate(index);
	  this.elem.addDynamicProperty(this);
	};

	TextProperty.prototype.recalculate = function (index) {
	  var dData = this.data.d.k[index].s;
	  dData.__complete = false;
	  this.keysIndex = 0;
	  this._isFirstFrame = true;
	  this.getValue(dData);
	};

	TextProperty.prototype.canResizeFont = function (_canResize) {
	  this.canResize = _canResize;
	  this.recalculate(this.keysIndex);
	  this.elem.addDynamicProperty(this);
	};

	TextProperty.prototype.setMinimumFontSize = function (_fontValue) {
	  this.minimumFontSize = Math.floor(_fontValue) || 1;
	  this.recalculate(this.keysIndex);
	  this.elem.addDynamicProperty(this);
	};

	/* global extendPrototype, BezierFactory, PropertyFactory, DynamicPropertyContainer */
	/* exported TextSelectorProp */

	var TextSelectorProp = (function () {
	  var max = Math.max;
	  var min = Math.min;
	  var floor = Math.floor;

	  function TextSelectorPropFactory(elem, data) {
	    this._currentTextLength = -1;
	    this.k = false;
	    this.data = data;
	    this.elem = elem;
	    this.comp = elem.comp;
	    this.finalS = 0;
	    this.finalE = 0;
	    this.initDynamicPropertyContainer(elem);
	    this.s = PropertyFactory.getProp(elem, data.s || { k: 0 }, 0, 0, this);
	    if ('e' in data) {
	      this.e = PropertyFactory.getProp(elem, data.e, 0, 0, this);
	    } else {
	      this.e = { v: 100 };
	    }
	    this.o = PropertyFactory.getProp(elem, data.o || { k: 0 }, 0, 0, this);
	    this.xe = PropertyFactory.getProp(elem, data.xe || { k: 0 }, 0, 0, this);
	    this.ne = PropertyFactory.getProp(elem, data.ne || { k: 0 }, 0, 0, this);
	    this.a = PropertyFactory.getProp(elem, data.a, 0, 0.01, this);
	    if (!this.dynamicProperties.length) {
	      this.getValue();
	    }
	  }

	  TextSelectorPropFactory.prototype = {
	    getMult: function (ind) {
	      if (this._currentTextLength !== this.elem.textProperty.currentData.l.length) {
	        this.getValue();
	      }
	      // var easer = bez.getEasingCurve(this.ne.v/100,0,1-this.xe.v/100,1);
	      var x1 = 0;
	      var y1 = 0;
	      var x2 = 1;
	      var y2 = 1;
	      if (this.ne.v > 0) {
	        x1 = this.ne.v / 100.0;
	      } else {
	        y1 = -this.ne.v / 100.0;
	      }
	      if (this.xe.v > 0) {
	        x2 = 1.0 - this.xe.v / 100.0;
	      } else {
	        y2 = 1.0 + this.xe.v / 100.0;
	      }
	      var easer = BezierFactory.getBezierEasing(x1, y1, x2, y2).get;

	      var mult = 0;
	      var s = this.finalS;
	      var e = this.finalE;
	      var type = this.data.sh;
	      if (type === 2) {
	        if (e === s) {
	          mult = ind >= e ? 1 : 0;
	        } else {
	          mult = max(0, min(0.5 / (e - s) + (ind - s) / (e - s), 1));
	        }
	        mult = easer(mult);
	      } else if (type === 3) {
	        if (e === s) {
	          mult = ind >= e ? 0 : 1;
	        } else {
	          mult = 1 - max(0, min(0.5 / (e - s) + (ind - s) / (e - s), 1));
	        }

	        mult = easer(mult);
	      } else if (type === 4) {
	        if (e === s) {
	          mult = 0;
	        } else {
	          mult = max(0, min(0.5 / (e - s) + (ind - s) / (e - s), 1));
	          if (mult < 0.5) {
	            mult *= 2;
	          } else {
	            mult = 1 - 2 * (mult - 0.5);
	          }
	        }
	        mult = easer(mult);
	      } else if (type === 5) {
	        if (e === s) {
	          mult = 0;
	        } else {
	          var tot = e - s;
	          /* ind += 0.5;
	                    mult = -4/(tot*tot)*(ind*ind)+(4/tot)*ind; */
	          ind = min(max(0, ind + 0.5 - s), e - s);
	          var x = -tot / 2 + ind;
	          var a = tot / 2;
	          mult = Math.sqrt(1 - (x * x) / (a * a));
	        }
	        mult = easer(mult);
	      } else if (type === 6) {
	        if (e === s) {
	          mult = 0;
	        } else {
	          ind = min(max(0, ind + 0.5 - s), e - s);
	          mult = (1 + (Math.cos((Math.PI + Math.PI * 2 * (ind) / (e - s))))) / 2; // eslint-disable-line
	        }
	        mult = easer(mult);
	      } else {
	        if (ind >= floor(s)) {
	          if (ind - s < 0) {
	            mult = max(0, min(min(e, 1) - (s - ind), 1));
	          } else {
	            mult = max(0, min(e - ind, 1));
	          }
	        }
	        mult = easer(mult);
	      }
	      return mult * this.a.v;
	    },
	    getValue: function (newCharsFlag) {
	      this.iterateDynamicProperties();
	      this._mdf = newCharsFlag || this._mdf;
	      this._currentTextLength = this.elem.textProperty.currentData.l.length || 0;
	      if (newCharsFlag && this.data.r === 2) {
	        this.e.v = this._currentTextLength;
	      }
	      var divisor = this.data.r === 2 ? 1 : 100 / this.data.totalChars;
	      var o = this.o.v / divisor;
	      var s = this.s.v / divisor + o;
	      var e = (this.e.v / divisor) + o;
	      if (s > e) {
	        var _s = s;
	        s = e;
	        e = _s;
	      }
	      this.finalS = s;
	      this.finalE = e;
	    },
	  };
	  extendPrototype([DynamicPropertyContainer], TextSelectorPropFactory);

	  function getTextSelectorProp(elem, data, arr) {
	    return new TextSelectorPropFactory(elem, data, arr);
	  }

	  return {
	    getTextSelectorProp: getTextSelectorProp,
	  };
	}());

	/* global createSizedArray, pooling */
	/* exported poolFactory */

	var poolFactory = (function () {
	  return function (initialLength, _create, _release) {
	    var _length = 0;
	    var _maxLength = initialLength;
	    var pool = createSizedArray(_maxLength);

	    var ob = {
	      newElement: newElement,
	      release: release,
	    };

	    function newElement() {
	      var element;
	      if (_length) {
	        _length -= 1;
	        element = pool[_length];
	      } else {
	        element = _create();
	      }
	      return element;
	    }

	    function release(element) {
	      if (_length === _maxLength) {
	        pool = pooling.double(pool);
	        _maxLength *= 2;
	      }
	      if (_release) {
	        _release(element);
	      }
	      pool[_length] = element;
	      _length += 1;
	    }

	    return ob;
	  };
	}());

	/* global createSizedArray */
	/* exported pooling */

	var pooling = (function () {
	  function double(arr) {
	    return arr.concat(createSizedArray(arr.length));
	  }

	  return {
	    double: double,
	  };
	}());

	/* global createTypedArray, poolFactory */
	/* exported pointPool */

	var pointPool = (function () {
	  function create() {
	    return createTypedArray('float32', 2);
	  }
	  return poolFactory(8, create);
	}());

	/* global ShapePath, pointPool, poolFactory */
	/* exported shapePool */

	var shapePool = (function () {
	  function create() {
	    return new ShapePath();
	  }

	  function release(shapePath) {
	    var len = shapePath._length;
	    var i;
	    for (i = 0; i < len; i += 1) {
	      pointPool.release(shapePath.v[i]);
	      pointPool.release(shapePath.i[i]);
	      pointPool.release(shapePath.o[i]);
	      shapePath.v[i] = null;
	      shapePath.i[i] = null;
	      shapePath.o[i] = null;
	    }
	    shapePath._length = 0;
	    shapePath.c = false;
	  }

	  function clone(shape) {
	    var cloned = factory.newElement();
	    var i;
	    var len = shape._length === undefined ? shape.v.length : shape._length;
	    cloned.setLength(len);
	    cloned.c = shape.c;

	    for (i = 0; i < len; i += 1) {
	      cloned.setTripleAt(shape.v[i][0], shape.v[i][1], shape.o[i][0], shape.o[i][1], shape.i[i][0], shape.i[i][1], i);
	    }
	    return cloned;
	  }

	  var factory = poolFactory(4, create, release);
	  factory.clone = clone;

	  return factory;
	}());

	/* global createSizedArray, ShapeCollection, shapePool, pooling */
	/* exported shapeCollectionPool */

	var shapeCollectionPool = (function () {
	  var ob = {
	    newShapeCollection: newShapeCollection,
	    release: release,
	  };

	  var _length = 0;
	  var _maxLength = 4;
	  var pool = createSizedArray(_maxLength);

	  function newShapeCollection() {
	    var shapeCollection;
	    if (_length) {
	      _length -= 1;
	      shapeCollection = pool[_length];
	    } else {
	      shapeCollection = new ShapeCollection();
	    }
	    return shapeCollection;
	  }

	  function release(shapeCollection) {
	    var i;
	    var len = shapeCollection._length;
	    for (i = 0; i < len; i += 1) {
	      shapePool.release(shapeCollection.shapes[i]);
	    }
	    shapeCollection._length = 0;

	    if (_length === _maxLength) {
	      pool = pooling.double(pool);
	      _maxLength *= 2;
	    }
	    pool[_length] = shapeCollection;
	    _length += 1;
	  }

	  return ob;
	}());

	/* global poolFactory, bezierLengthPool */
	/* exported segmentsLengthPool */

	var segmentsLengthPool = (function () {
	  function create() {
	    return {
	      lengths: [],
	      totalLength: 0,
	    };
	  }

	  function release(element) {
	    var i;
	    var len = element.lengths.length;
	    for (i = 0; i < len; i += 1) {
	      bezierLengthPool.release(element.lengths[i]);
	    }
	    element.lengths.length = 0;
	  }

	  return poolFactory(8, create, release);
	}());

	/* global createTypedArray, defaultCurveSegments, poolFactory */
	/* exported bezierLengthPool */

	var bezierLengthPool = (function () {
	  function create() {
	    return {
	      addedLength: 0,
	      percents: createTypedArray('float32', defaultCurveSegments),
	      lengths: createTypedArray('float32', defaultCurveSegments),
	    };
	  }
	  return poolFactory(8, create);
	}());

	/* exported markerParser */

	var markerParser = (

	  function () {
	    function parsePayloadLines(payload) {
	      var lines = payload.split('\r\n');
	      var keys = {};
	      var line;
	      var keysCount = 0;
	      for (var i = 0; i < lines.length; i += 1) {
	        line = lines[i].split(':');
	        if (line.length === 2) {
	          keys[line[0]] = line[1].trim();
	          keysCount += 1;
	        }
	      }
	      if (keysCount === 0) {
	        throw new Error();
	      }
	      return keys;
	    }

	    return function (_markers) {
	      var markers = [];
	      for (var i = 0; i < _markers.length; i += 1) {
	        var _marker = _markers[i];
	        var markerData = {
	          time: _marker.tm,
	          duration: _marker.dr,
	        };
	        try {
	          markerData.payload = JSON.parse(_markers[i].cm);
	        } catch (_) {
	          try {
	            markerData.payload = parsePayloadLines(_markers[i].cm);
	          } catch (__) {
	            markerData.payload = {
	              name: _markers[i],
	            };
	          }
	        }
	        markers.push(markerData);
	      }
	      return markers;
	    };
	  }());

	/* global AudioElement, FootageElement, FontManager */

	function BaseRenderer() {}
	BaseRenderer.prototype.checkLayers = function (num) {
	  var i;
	  var len = this.layers.length;
	  var data;
	  this.completeLayers = true;
	  for (i = len - 1; i >= 0; i -= 1) {
	    if (!this.elements[i]) {
	      data = this.layers[i];
	      if (data.ip - data.st <= (num - this.layers[i].st) && data.op - data.st > (num - this.layers[i].st)) {
	        this.buildItem(i);
	      }
	    }
	    this.completeLayers = this.elements[i] ? this.completeLayers : false;
	  }
	  this.checkPendingElements();
	};

	BaseRenderer.prototype.createItem = function (layer) {
	  switch (layer.ty) {
	    case 2:
	      return this.createImage(layer);
	    case 0:
	      return this.createComp(layer);
	    case 1:
	      return this.createSolid(layer);
	    case 3:
	      return this.createNull(layer);
	    case 4:
	      return this.createShape(layer);
	    case 5:
	      return this.createText(layer);
	    case 6:
	      return this.createAudio(layer);
	    case 13:
	      return this.createCamera(layer);
	    case 15:
	      return this.createFootage(layer);
	    default:
	      return this.createNull(layer);
	  }
	};

	BaseRenderer.prototype.createCamera = function () {
	  throw new Error('You\'re using a 3d camera. Try the html renderer.');
	};

	BaseRenderer.prototype.createAudio = function (data) {
	  return new AudioElement(data, this.globalData, this);
	};

	BaseRenderer.prototype.createFootage = function (data) {
	  return new FootageElement(data, this.globalData, this);
	};

	BaseRenderer.prototype.buildAllItems = function () {
	  var i;
	  var len = this.layers.length;
	  for (i = 0; i < len; i += 1) {
	    this.buildItem(i);
	  }
	  this.checkPendingElements();
	};

	BaseRenderer.prototype.includeLayers = function (newLayers) {
	  this.completeLayers = false;
	  var i;
	  var len = newLayers.length;
	  var j;
	  var jLen = this.layers.length;
	  for (i = 0; i < len; i += 1) {
	    j = 0;
	    while (j < jLen) {
	      if (this.layers[j].id === newLayers[i].id) {
	        this.layers[j] = newLayers[i];
	        break;
	      }
	      j += 1;
	    }
	  }
	};

	BaseRenderer.prototype.setProjectInterface = function (pInterface) {
	  this.globalData.projectInterface = pInterface;
	};

	BaseRenderer.prototype.initItems = function () {
	  if (!this.globalData.progressiveLoad) {
	    this.buildAllItems();
	  }
	};
	BaseRenderer.prototype.buildElementParenting = function (element, parentName, hierarchy) {
	  var elements = this.elements;
	  var layers = this.layers;
	  var i = 0;
	  var len = layers.length;
	  while (i < len) {
	    if (layers[i].ind == parentName) { // eslint-disable-line eqeqeq
	      if (!elements[i] || elements[i] === true) {
	        this.buildItem(i);
	        this.addPendingElement(element);
	      } else {
	        hierarchy.push(elements[i]);
	        elements[i].setAsParent();
	        if (layers[i].parent !== undefined) {
	          this.buildElementParenting(element, layers[i].parent, hierarchy);
	        } else {
	          element.setHierarchy(hierarchy);
	        }
	      }
	    }
	    i += 1;
	  }
	};

	BaseRenderer.prototype.addPendingElement = function (element) {
	  this.pendingElements.push(element);
	};

	BaseRenderer.prototype.searchExtraCompositions = function (assets) {
	  var i;
	  var len = assets.length;
	  for (i = 0; i < len; i += 1) {
	    if (assets[i].xt) {
	      var comp = this.createComp(assets[i]);
	      comp.initExpressions();
	      this.globalData.projectInterface.registerComposition(comp);
	    }
	  }
	};

	BaseRenderer.prototype.setupGlobalData = function (animData, fontsContainer) {
	  this.globalData.fontManager = new FontManager();
	  this.globalData.fontManager.addChars(animData.chars);
	  this.globalData.fontManager.addFonts(animData.fonts, fontsContainer);
	  this.globalData.getAssetData = this.animationItem.getAssetData.bind(this.animationItem);
	  this.globalData.getAssetsPath = this.animationItem.getAssetsPath.bind(this.animationItem);
	  this.globalData.imageLoader = this.animationItem.imagePreloader;
	  this.globalData.audioController = this.animationItem.audioController;
	  this.globalData.frameId = 0;
	  this.globalData.frameRate = animData.fr;
	  this.globalData.nm = animData.nm;
	  this.globalData.compSize = {
	    w: animData.w,
	    h: animData.h,
	  };
	};

	/* global createElementID, extendPrototype, BaseRenderer, NullElement, SVGShapeElement, SVGTextLottieElement,
	IImageElement, SVGCompElement, ISolidElement, createNS, locationHref, createSizedArray, expressionsPlugin */

	function SVGRenderer(animationItem, config) {
	  this.animationItem = animationItem;
	  this.layers = null;
	  this.renderedFrame = -1;
	  this.svgElement = createNS('svg');
	  var ariaLabel = '';
	  if (config && config.title) {
	    var titleElement = createNS('title');
	    var titleId = createElementID();
	    titleElement.setAttribute('id', titleId);
	    titleElement.textContent = config.title;
	    this.svgElement.appendChild(titleElement);
	    ariaLabel += titleId;
	  }
	  if (config && config.description) {
	    var descElement = createNS('desc');
	    var descId = createElementID();
	    descElement.setAttribute('id', descId);
	    descElement.textContent = config.description;
	    this.svgElement.appendChild(descElement);
	    ariaLabel += ' ' + descId;
	  }
	  if (ariaLabel) {
	    this.svgElement.setAttribute('aria-labelledby', ariaLabel);
	  }
	  var defs = createNS('defs');
	  this.svgElement.appendChild(defs);
	  var maskElement = createNS('g');
	  this.svgElement.appendChild(maskElement);
	  this.layerElement = maskElement;
	  this.renderConfig = {
	    preserveAspectRatio: (config && config.preserveAspectRatio) || 'xMidYMid meet',
	    imagePreserveAspectRatio: (config && config.imagePreserveAspectRatio) || 'xMidYMid slice',
	    progressiveLoad: (config && config.progressiveLoad) || false,
	    hideOnTransparent: !((config && config.hideOnTransparent === false)),
	    viewBoxOnly: (config && config.viewBoxOnly) || false,
	    viewBoxSize: (config && config.viewBoxSize) || false,
	    className: (config && config.className) || '',
	    id: (config && config.id) || '',
	    focusable: config && config.focusable,
	    filterSize: {
	      width: (config && config.filterSize && config.filterSize.width) || '100%',
	      height: (config && config.filterSize && config.filterSize.height) || '100%',
	      x: (config && config.filterSize && config.filterSize.x) || '0%',
	      y: (config && config.filterSize && config.filterSize.y) || '0%',
	    },
	  };

	  this.globalData = {
	    _mdf: false,
	    frameNum: -1,
	    defs: defs,
	    renderConfig: this.renderConfig,
	  };
	  this.elements = [];
	  this.pendingElements = [];
	  this.destroyed = false;
	  this.rendererType = 'svg';
	}

	extendPrototype([BaseRenderer], SVGRenderer);

	SVGRenderer.prototype.createNull = function (data) {
	  return new NullElement(data, this.globalData, this);
	};

	SVGRenderer.prototype.createShape = function (data) {
	  return new SVGShapeElement(data, this.globalData, this);
	};

	SVGRenderer.prototype.createText = function (data) {
	  return new SVGTextLottieElement(data, this.globalData, this);
	};

	SVGRenderer.prototype.createImage = function (data) {
	  return new IImageElement(data, this.globalData, this);
	};

	SVGRenderer.prototype.createComp = function (data) {
	  return new SVGCompElement(data, this.globalData, this);
	};

	SVGRenderer.prototype.createSolid = function (data) {
	  return new ISolidElement(data, this.globalData, this);
	};

	SVGRenderer.prototype.configAnimation = function (animData) {
	  this.svgElement.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
	  if (this.renderConfig.viewBoxSize) {
	    this.svgElement.setAttribute('viewBox', this.renderConfig.viewBoxSize);
	  } else {
	    this.svgElement.setAttribute('viewBox', '0 0 ' + animData.w + ' ' + animData.h);
	  }

	  if (!this.renderConfig.viewBoxOnly) {
	    this.svgElement.setAttribute('width', animData.w);
	    this.svgElement.setAttribute('height', animData.h);
	    this.svgElement.style.width = '100%';
	    this.svgElement.style.height = '100%';
	    this.svgElement.style.transform = 'translate3d(0,0,0)';
	  }
	  if (this.renderConfig.className) {
	    this.svgElement.setAttribute('class', this.renderConfig.className);
	  }
	  if (this.renderConfig.id) {
	    this.svgElement.setAttribute('id', this.renderConfig.id);
	  }
	  if (this.renderConfig.focusable !== undefined) {
	    this.svgElement.setAttribute('focusable', this.renderConfig.focusable);
	  }
	  this.svgElement.setAttribute('preserveAspectRatio', this.renderConfig.preserveAspectRatio);
	  // this.layerElement.style.transform = 'translate3d(0,0,0)';
	  // this.layerElement.style.transformOrigin = this.layerElement.style.mozTransformOrigin = this.layerElement.style.webkitTransformOrigin = this.layerElement.style['-webkit-transform'] = "0px 0px 0px";
	  this.animationItem.wrapper.appendChild(this.svgElement);
	  // Mask animation
	  var defs = this.globalData.defs;

	  this.setupGlobalData(animData, defs);
	  this.globalData.progressiveLoad = this.renderConfig.progressiveLoad;
	  this.data = animData;

	  var maskElement = createNS('clipPath');
	  var rect = createNS('rect');
	  rect.setAttribute('width', animData.w);
	  rect.setAttribute('height', animData.h);
	  rect.setAttribute('x', 0);
	  rect.setAttribute('y', 0);
	  var maskId = createElementID();
	  maskElement.setAttribute('id', maskId);
	  maskElement.appendChild(rect);
	  this.layerElement.setAttribute('clip-path', 'url(' + locationHref + '#' + maskId + ')');

	  defs.appendChild(maskElement);
	  this.layers = animData.layers;
	  this.elements = createSizedArray(animData.layers.length);
	};

	SVGRenderer.prototype.destroy = function () {
	  if (this.animationItem.wrapper) {
	    this.animationItem.wrapper.innerText = '';
	  }
	  this.layerElement = null;
	  this.globalData.defs = null;
	  var i;
	  var len = this.layers ? this.layers.length : 0;
	  for (i = 0; i < len; i += 1) {
	    if (this.elements[i]) {
	      this.elements[i].destroy();
	    }
	  }
	  this.elements.length = 0;
	  this.destroyed = true;
	  this.animationItem = null;
	};

	SVGRenderer.prototype.updateContainerSize = function () {
	};

	SVGRenderer.prototype.buildItem = function (pos) {
	  var elements = this.elements;
	  if (elements[pos] || this.layers[pos].ty === 99) {
	    return;
	  }
	  elements[pos] = true;
	  var element = this.createItem(this.layers[pos]);

	  elements[pos] = element;
	  if (expressionsPlugin) {
	    if (this.layers[pos].ty === 0) {
	      this.globalData.projectInterface.registerComposition(element);
	    }
	    element.initExpressions();
	  }
	  this.appendElementInPos(element, pos);
	  if (this.layers[pos].tt) {
	    if (!this.elements[pos - 1] || this.elements[pos - 1] === true) {
	      this.buildItem(pos - 1);
	      this.addPendingElement(element);
	    } else {
	      element.setMatte(elements[pos - 1].layerId);
	    }
	  }
	};

	SVGRenderer.prototype.checkPendingElements = function () {
	  while (this.pendingElements.length) {
	    var element = this.pendingElements.pop();
	    element.checkParenting();
	    if (element.data.tt) {
	      var i = 0;
	      var len = this.elements.length;
	      while (i < len) {
	        if (this.elements[i] === element) {
	          element.setMatte(this.elements[i - 1].layerId);
	          break;
	        }
	        i += 1;
	      }
	    }
	  }
	};

	SVGRenderer.prototype.renderFrame = function (num) {
	  if (this.renderedFrame === num || this.destroyed) {
	    return;
	  }
	  if (num === null) {
	    num = this.renderedFrame;
	  } else {
	    this.renderedFrame = num;
	  }
	  // console.log('-------');
	  // console.log('FRAME ',num);
	  this.globalData.frameNum = num;
	  this.globalData.frameId += 1;
	  this.globalData.projectInterface.currentFrame = num;
	  this.globalData._mdf = false;
	  var i;
	  var len = this.layers.length;
	  if (!this.completeLayers) {
	    this.checkLayers(num);
	  }
	  for (i = len - 1; i >= 0; i -= 1) {
	    if (this.completeLayers || this.elements[i]) {
	      this.elements[i].prepareFrame(num - this.layers[i].st);
	    }
	  }
	  if (this.globalData._mdf) {
	    for (i = 0; i < len; i += 1) {
	      if (this.completeLayers || this.elements[i]) {
	        this.elements[i].renderFrame();
	      }
	    }
	  }
	};

	SVGRenderer.prototype.appendElementInPos = function (element, pos) {
	  var newElement = element.getBaseElement();
	  if (!newElement) {
	    return;
	  }
	  var i = 0;
	  var nextElement;
	  while (i < pos) {
	    if (this.elements[i] && this.elements[i] !== true && this.elements[i].getBaseElement()) {
	      nextElement = this.elements[i].getBaseElement();
	    }
	    i += 1;
	  }
	  if (nextElement) {
	    this.layerElement.insertBefore(newElement, nextElement);
	  } else {
	    this.layerElement.appendChild(newElement);
	  }
	};

	SVGRenderer.prototype.hide = function () {
	  this.layerElement.style.display = 'none';
	};

	SVGRenderer.prototype.show = function () {
	  this.layerElement.style.display = 'block';
	};

	/* global CVContextData, Matrix, extendPrototype, BaseRenderer, CVShapeElement, CVTextElement,
	CVImageElement, CVCompElement, CVSolidElement, SVGRenderer, createTag, createSizedArray */

	function CanvasRenderer(animationItem, config) {
	  this.animationItem = animationItem;
	  this.renderConfig = {
	    clearCanvas: (config && config.clearCanvas !== undefined) ? config.clearCanvas : true,
	    context: (config && config.context) || null,
	    progressiveLoad: (config && config.progressiveLoad) || false,
	    preserveAspectRatio: (config && config.preserveAspectRatio) || 'xMidYMid meet',
	    imagePreserveAspectRatio: (config && config.imagePreserveAspectRatio) || 'xMidYMid slice',
	    className: (config && config.className) || '',
	    id: (config && config.id) || '',
	  };
	  this.renderConfig.dpr = (config && config.dpr) || 1;
	  if (this.animationItem.wrapper) {
	    this.renderConfig.dpr = (config && config.dpr) || window.devicePixelRatio || 1;
	  }
	  this.renderedFrame = -1;
	  this.globalData = {
	    frameNum: -1,
	    _mdf: false,
	    renderConfig: this.renderConfig,
	    currentGlobalAlpha: -1,
	  };
	  this.contextData = new CVContextData();
	  this.elements = [];
	  this.pendingElements = [];
	  this.transformMat = new Matrix();
	  this.completeLayers = false;
	  this.rendererType = 'canvas';
	}
	extendPrototype([BaseRenderer], CanvasRenderer);

	CanvasRenderer.prototype.createShape = function (data) {
	  return new CVShapeElement(data, this.globalData, this);
	};

	CanvasRenderer.prototype.createText = function (data) {
	  return new CVTextElement(data, this.globalData, this);
	};

	CanvasRenderer.prototype.createImage = function (data) {
	  return new CVImageElement(data, this.globalData, this);
	};

	CanvasRenderer.prototype.createComp = function (data) {
	  return new CVCompElement(data, this.globalData, this);
	};

	CanvasRenderer.prototype.createSolid = function (data) {
	  return new CVSolidElement(data, this.globalData, this);
	};

	CanvasRenderer.prototype.createNull = SVGRenderer.prototype.createNull;

	CanvasRenderer.prototype.ctxTransform = function (props) {
	  if (props[0] === 1 && props[1] === 0 && props[4] === 0 && props[5] === 1 && props[12] === 0 && props[13] === 0) {
	    return;
	  }
	  if (!this.renderConfig.clearCanvas) {
	    this.canvasContext.transform(props[0], props[1], props[4], props[5], props[12], props[13]);
	    return;
	  }
	  this.transformMat.cloneFromProps(props);
	  var cProps = this.contextData.cTr.props;
	  this.transformMat.transform(cProps[0], cProps[1], cProps[2], cProps[3], cProps[4], cProps[5], cProps[6], cProps[7], cProps[8], cProps[9], cProps[10], cProps[11], cProps[12], cProps[13], cProps[14], cProps[15]);
	  // this.contextData.cTr.transform(props[0],props[1],props[2],props[3],props[4],props[5],props[6],props[7],props[8],props[9],props[10],props[11],props[12],props[13],props[14],props[15]);
	  this.contextData.cTr.cloneFromProps(this.transformMat.props);
	  var trProps = this.contextData.cTr.props;
	  this.canvasContext.setTransform(trProps[0], trProps[1], trProps[4], trProps[5], trProps[12], trProps[13]);
	};

	CanvasRenderer.prototype.ctxOpacity = function (op) {
	  /* if(op === 1){
	        return;
	    } */
	  if (!this.renderConfig.clearCanvas) {
	    this.canvasContext.globalAlpha *= op < 0 ? 0 : op;
	    this.globalData.currentGlobalAlpha = this.contextData.cO;
	    return;
	  }
	  this.contextData.cO *= op < 0 ? 0 : op;
	  if (this.globalData.currentGlobalAlpha !== this.contextData.cO) {
	    this.canvasContext.globalAlpha = this.contextData.cO;
	    this.globalData.currentGlobalAlpha = this.contextData.cO;
	  }
	};

	CanvasRenderer.prototype.reset = function () {
	  if (!this.renderConfig.clearCanvas) {
	    this.canvasContext.restore();
	    return;
	  }
	  this.contextData.reset();
	};

	CanvasRenderer.prototype.save = function (actionFlag) {
	  if (!this.renderConfig.clearCanvas) {
	    this.canvasContext.save();
	    return;
	  }
	  if (actionFlag) {
	    this.canvasContext.save();
	  }
	  var props = this.contextData.cTr.props;
	  if (this.contextData._length <= this.contextData.cArrPos) {
	    this.contextData.duplicate();
	  }
	  var i;
	  var arr = this.contextData.saved[this.contextData.cArrPos];
	  for (i = 0; i < 16; i += 1) {
	    arr[i] = props[i];
	  }
	  this.contextData.savedOp[this.contextData.cArrPos] = this.contextData.cO;
	  this.contextData.cArrPos += 1;
	};

	CanvasRenderer.prototype.restore = function (actionFlag) {
	  if (!this.renderConfig.clearCanvas) {
	    this.canvasContext.restore();
	    return;
	  }
	  if (actionFlag) {
	    this.canvasContext.restore();
	    this.globalData.blendMode = 'source-over';
	  }
	  this.contextData.cArrPos -= 1;
	  var popped = this.contextData.saved[this.contextData.cArrPos];
	  var i;
	  var arr = this.contextData.cTr.props;
	  for (i = 0; i < 16; i += 1) {
	    arr[i] = popped[i];
	  }
	  this.canvasContext.setTransform(popped[0], popped[1], popped[4], popped[5], popped[12], popped[13]);
	  popped = this.contextData.savedOp[this.contextData.cArrPos];
	  this.contextData.cO = popped;
	  if (this.globalData.currentGlobalAlpha !== popped) {
	    this.canvasContext.globalAlpha = popped;
	    this.globalData.currentGlobalAlpha = popped;
	  }
	};

	CanvasRenderer.prototype.configAnimation = function (animData) {
	  if (this.animationItem.wrapper) {
	    this.animationItem.container = createTag('canvas');
	    var containerStyle = this.animationItem.container.style;
	    containerStyle.width = '100%';
	    containerStyle.height = '100%';
	    var origin = '0px 0px 0px';
	    containerStyle.transformOrigin = origin;
	    containerStyle.mozTransformOrigin = origin;
	    containerStyle.webkitTransformOrigin = origin;
	    containerStyle['-webkit-transform'] = origin;
	    this.animationItem.wrapper.appendChild(this.animationItem.container);
	    this.canvasContext = this.animationItem.container.getContext('2d');
	    if (this.renderConfig.className) {
	      this.animationItem.container.setAttribute('class', this.renderConfig.className);
	    }
	    if (this.renderConfig.id) {
	      this.animationItem.container.setAttribute('id', this.renderConfig.id);
	    }
	  } else {
	    this.canvasContext = this.renderConfig.context;
	  }
	  this.data = animData;
	  this.layers = animData.layers;
	  this.transformCanvas = {
	    w: animData.w,
	    h: animData.h,
	    sx: 0,
	    sy: 0,
	    tx: 0,
	    ty: 0,
	  };
	  this.setupGlobalData(animData, document.body);
	  this.globalData.canvasContext = this.canvasContext;
	  this.globalData.renderer = this;
	  this.globalData.isDashed = false;
	  this.globalData.progressiveLoad = this.renderConfig.progressiveLoad;
	  this.globalData.transformCanvas = this.transformCanvas;
	  this.elements = createSizedArray(animData.layers.length);

	  this.updateContainerSize();
	};

	CanvasRenderer.prototype.updateContainerSize = function () {
	  this.reset();
	  var elementWidth;
	  var elementHeight;
	  if (this.animationItem.wrapper && this.animationItem.container) {
	    elementWidth = this.animationItem.wrapper.offsetWidth;
	    elementHeight = this.animationItem.wrapper.offsetHeight;
	    this.animationItem.container.setAttribute('width', elementWidth * this.renderConfig.dpr);
	    this.animationItem.container.setAttribute('height', elementHeight * this.renderConfig.dpr);
	  } else {
	    elementWidth = this.canvasContext.canvas.width * this.renderConfig.dpr;
	    elementHeight = this.canvasContext.canvas.height * this.renderConfig.dpr;
	  }
	  var elementRel;
	  var animationRel;
	  if (this.renderConfig.preserveAspectRatio.indexOf('meet') !== -1 || this.renderConfig.preserveAspectRatio.indexOf('slice') !== -1) {
	    var par = this.renderConfig.preserveAspectRatio.split(' ');
	    var fillType = par[1] || 'meet';
	    var pos = par[0] || 'xMidYMid';
	    var xPos = pos.substr(0, 4);
	    var yPos = pos.substr(4);
	    elementRel = elementWidth / elementHeight;
	    animationRel = this.transformCanvas.w / this.transformCanvas.h;
	    if ((animationRel > elementRel && fillType === 'meet') || (animationRel < elementRel && fillType === 'slice')) {
	      this.transformCanvas.sx = elementWidth / (this.transformCanvas.w / this.renderConfig.dpr);
	      this.transformCanvas.sy = elementWidth / (this.transformCanvas.w / this.renderConfig.dpr);
	    } else {
	      this.transformCanvas.sx = elementHeight / (this.transformCanvas.h / this.renderConfig.dpr);
	      this.transformCanvas.sy = elementHeight / (this.transformCanvas.h / this.renderConfig.dpr);
	    }

	    if (xPos === 'xMid' && ((animationRel < elementRel && fillType === 'meet') || (animationRel > elementRel && fillType === 'slice'))) {
	      this.transformCanvas.tx = ((elementWidth - this.transformCanvas.w * (elementHeight / this.transformCanvas.h)) / 2) * this.renderConfig.dpr;
	    } else if (xPos === 'xMax' && ((animationRel < elementRel && fillType === 'meet') || (animationRel > elementRel && fillType === 'slice'))) {
	      this.transformCanvas.tx = (elementWidth - this.transformCanvas.w * (elementHeight / this.transformCanvas.h)) * this.renderConfig.dpr;
	    } else {
	      this.transformCanvas.tx = 0;
	    }
	    if (yPos === 'YMid' && ((animationRel > elementRel && fillType === 'meet') || (animationRel < elementRel && fillType === 'slice'))) {
	      this.transformCanvas.ty = ((elementHeight - this.transformCanvas.h * (elementWidth / this.transformCanvas.w)) / 2) * this.renderConfig.dpr;
	    } else if (yPos === 'YMax' && ((animationRel > elementRel && fillType === 'meet') || (animationRel < elementRel && fillType === 'slice'))) {
	      this.transformCanvas.ty = ((elementHeight - this.transformCanvas.h * (elementWidth / this.transformCanvas.w))) * this.renderConfig.dpr;
	    } else {
	      this.transformCanvas.ty = 0;
	    }
	  } else if (this.renderConfig.preserveAspectRatio === 'none') {
	    this.transformCanvas.sx = elementWidth / (this.transformCanvas.w / this.renderConfig.dpr);
	    this.transformCanvas.sy = elementHeight / (this.transformCanvas.h / this.renderConfig.dpr);
	    this.transformCanvas.tx = 0;
	    this.transformCanvas.ty = 0;
	  } else {
	    this.transformCanvas.sx = this.renderConfig.dpr;
	    this.transformCanvas.sy = this.renderConfig.dpr;
	    this.transformCanvas.tx = 0;
	    this.transformCanvas.ty = 0;
	  }
	  this.transformCanvas.props = [this.transformCanvas.sx, 0, 0, 0, 0, this.transformCanvas.sy, 0, 0, 0, 0, 1, 0, this.transformCanvas.tx, this.transformCanvas.ty, 0, 1];
	  /* var i, len = this.elements.length;
	    for(i=0;i<len;i+=1){
	        if(this.elements[i] && this.elements[i].data.ty === 0){
	            this.elements[i].resize(this.globalData.transformCanvas);
	        }
	    } */
	  this.ctxTransform(this.transformCanvas.props);
	  this.canvasContext.beginPath();
	  this.canvasContext.rect(0, 0, this.transformCanvas.w, this.transformCanvas.h);
	  this.canvasContext.closePath();
	  this.canvasContext.clip();

	  this.renderFrame(this.renderedFrame, true);
	};

	CanvasRenderer.prototype.destroy = function () {
	  if (this.renderConfig.clearCanvas && this.animationItem.wrapper) {
	    this.animationItem.wrapper.innerText = '';
	  }
	  var i;
	  var len = this.layers ? this.layers.length : 0;
	  for (i = len - 1; i >= 0; i -= 1) {
	    if (this.elements[i]) {
	      this.elements[i].destroy();
	    }
	  }
	  this.elements.length = 0;
	  this.globalData.canvasContext = null;
	  this.animationItem.container = null;
	  this.destroyed = true;
	};

	CanvasRenderer.prototype.renderFrame = function (num, forceRender) {
	  if ((this.renderedFrame === num && this.renderConfig.clearCanvas === true && !forceRender) || this.destroyed || num === -1) {
	    return;
	  }
	  this.renderedFrame = num;
	  this.globalData.frameNum = num - this.animationItem._isFirstFrame;
	  this.globalData.frameId += 1;
	  this.globalData._mdf = !this.renderConfig.clearCanvas || forceRender;
	  this.globalData.projectInterface.currentFrame = num;

	  // console.log('--------');
	  // console.log('NEW: ',num);
	  var i;
	  var len = this.layers.length;
	  if (!this.completeLayers) {
	    this.checkLayers(num);
	  }

	  for (i = 0; i < len; i += 1) {
	    if (this.completeLayers || this.elements[i]) {
	      this.elements[i].prepareFrame(num - this.layers[i].st);
	    }
	  }
	  if (this.globalData._mdf) {
	    if (this.renderConfig.clearCanvas === true) {
	      this.canvasContext.clearRect(0, 0, this.transformCanvas.w, this.transformCanvas.h);
	    } else {
	      this.save();
	    }
	    for (i = len - 1; i >= 0; i -= 1) {
	      if (this.completeLayers || this.elements[i]) {
	        this.elements[i].renderFrame();
	      }
	    }
	    if (this.renderConfig.clearCanvas !== true) {
	      this.restore();
	    }
	  }
	};

	CanvasRenderer.prototype.buildItem = function (pos) {
	  var elements = this.elements;
	  if (elements[pos] || this.layers[pos].ty === 99) {
	    return;
	  }
	  var element = this.createItem(this.layers[pos], this, this.globalData);
	  elements[pos] = element;
	  element.initExpressions();
	  /* if(this.layers[pos].ty === 0){
	        element.resize(this.globalData.transformCanvas);
	    } */
	};

	CanvasRenderer.prototype.checkPendingElements = function () {
	  while (this.pendingElements.length) {
	    var element = this.pendingElements.pop();
	    element.checkParenting();
	  }
	};

	CanvasRenderer.prototype.hide = function () {
	  this.animationItem.container.style.display = 'none';
	};

	CanvasRenderer.prototype.show = function () {
	  this.animationItem.container.style.display = 'block';
	};

	/* global extendPrototype, BaseRenderer, SVGRenderer, SVGShapeElement, HShapeElement, SVGTextLottieElement,
	HTextElement, HCameraElement, IImageElement, HImageElement, SVGCompElement, HCompElement, ISolidElement,
	HSolidElement, styleDiv, createTag, createNS */

	function HybridRenderer(animationItem, config) {
	  this.animationItem = animationItem;
	  this.layers = null;
	  this.renderedFrame = -1;
	  this.renderConfig = {
	    className: (config && config.className) || '',
	    imagePreserveAspectRatio: (config && config.imagePreserveAspectRatio) || 'xMidYMid slice',
	    hideOnTransparent: !(config && config.hideOnTransparent === false),
	    filterSize: {
	      width: (config && config.filterSize && config.filterSize.width) || '400%',
	      height: (config && config.filterSize && config.filterSize.height) || '400%',
	      x: (config && config.filterSize && config.filterSize.x) || '-100%',
	      y: (config && config.filterSize && config.filterSize.y) || '-100%',
	    },
	  };
	  this.globalData = {
	    _mdf: false,
	    frameNum: -1,
	    renderConfig: this.renderConfig,
	  };
	  this.pendingElements = [];
	  this.elements = [];
	  this.threeDElements = [];
	  this.destroyed = false;
	  this.camera = null;
	  this.supports3d = true;
	  this.rendererType = 'html';
	}

	extendPrototype([BaseRenderer], HybridRenderer);

	HybridRenderer.prototype.buildItem = SVGRenderer.prototype.buildItem;

	HybridRenderer.prototype.checkPendingElements = function () {
	  while (this.pendingElements.length) {
	    var element = this.pendingElements.pop();
	    element.checkParenting();
	  }
	};

	HybridRenderer.prototype.appendElementInPos = function (element, pos) {
	  var newDOMElement = element.getBaseElement();
	  if (!newDOMElement) {
	    return;
	  }
	  var layer = this.layers[pos];
	  if (!layer.ddd || !this.supports3d) {
	    if (this.threeDElements) {
	      this.addTo3dContainer(newDOMElement, pos);
	    } else {
	      var i = 0;
	      var nextDOMElement;
	      var nextLayer;
	      var tmpDOMElement;
	      while (i < pos) {
	        if (this.elements[i] && this.elements[i] !== true && this.elements[i].getBaseElement) {
	          nextLayer = this.elements[i];
	          tmpDOMElement = this.layers[i].ddd ? this.getThreeDContainerByPos(i) : nextLayer.getBaseElement();
	          nextDOMElement = tmpDOMElement || nextDOMElement;
	        }
	        i += 1;
	      }
	      if (nextDOMElement) {
	        if (!layer.ddd || !this.supports3d) {
	          this.layerElement.insertBefore(newDOMElement, nextDOMElement);
	        }
	      } else if (!layer.ddd || !this.supports3d) {
	        this.layerElement.appendChild(newDOMElement);
	      }
	    }
	  } else {
	    this.addTo3dContainer(newDOMElement, pos);
	  }
	};

	HybridRenderer.prototype.createShape = function (data) {
	  if (!this.supports3d) {
	    return new SVGShapeElement(data, this.globalData, this);
	  }
	  return new HShapeElement(data, this.globalData, this);
	};

	HybridRenderer.prototype.createText = function (data) {
	  if (!this.supports3d) {
	    return new SVGTextLottieElement(data, this.globalData, this);
	  }
	  return new HTextElement(data, this.globalData, this);
	};

	HybridRenderer.prototype.createCamera = function (data) {
	  this.camera = new HCameraElement(data, this.globalData, this);
	  return this.camera;
	};

	HybridRenderer.prototype.createImage = function (data) {
	  if (!this.supports3d) {
	    return new IImageElement(data, this.globalData, this);
	  }
	  return new HImageElement(data, this.globalData, this);
	};

	HybridRenderer.prototype.createComp = function (data) {
	  if (!this.supports3d) {
	    return new SVGCompElement(data, this.globalData, this);
	  }
	  return new HCompElement(data, this.globalData, this);
	};

	HybridRenderer.prototype.createSolid = function (data) {
	  if (!this.supports3d) {
	    return new ISolidElement(data, this.globalData, this);
	  }
	  return new HSolidElement(data, this.globalData, this);
	};

	HybridRenderer.prototype.createNull = SVGRenderer.prototype.createNull;

	HybridRenderer.prototype.getThreeDContainerByPos = function (pos) {
	  var i = 0;
	  var len = this.threeDElements.length;
	  while (i < len) {
	    if (this.threeDElements[i].startPos <= pos && this.threeDElements[i].endPos >= pos) {
	      return this.threeDElements[i].perspectiveElem;
	    }
	    i += 1;
	  }
	  return null;
	};

	HybridRenderer.prototype.createThreeDContainer = function (pos, type) {
	  var perspectiveElem = createTag('div');
	  var style;
	  var containerStyle;
	  styleDiv(perspectiveElem);
	  var container = createTag('div');
	  styleDiv(container);
	  if (type === '3d') {
	    style = perspectiveElem.style;
	    style.width = this.globalData.compSize.w + 'px';
	    style.height = this.globalData.compSize.h + 'px';
	    var center = '50% 50%';
	    style.webkitTransformOrigin = center;
	    style.mozTransformOrigin = center;
	    style.transformOrigin = center;
	    containerStyle = container.style;
	    var matrix = 'matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)';
	    containerStyle.transform = matrix;
	    containerStyle.webkitTransform = matrix;
	  }

	  perspectiveElem.appendChild(container);
	  // this.resizerElem.appendChild(perspectiveElem);
	  var threeDContainerData = {
	    container: container,
	    perspectiveElem: perspectiveElem,
	    startPos: pos,
	    endPos: pos,
	    type: type,
	  };
	  this.threeDElements.push(threeDContainerData);
	  return threeDContainerData;
	};

	HybridRenderer.prototype.build3dContainers = function () {
	  var i;
	  var len = this.layers.length;
	  var lastThreeDContainerData;
	  var currentContainer = '';
	  for (i = 0; i < len; i += 1) {
	    if (this.layers[i].ddd && this.layers[i].ty !== 3) {
	      if (currentContainer !== '3d') {
	        currentContainer = '3d';
	        lastThreeDContainerData = this.createThreeDContainer(i, '3d');
	      }
	      lastThreeDContainerData.endPos = Math.max(lastThreeDContainerData.endPos, i);
	    } else {
	      if (currentContainer !== '2d') {
	        currentContainer = '2d';
	        lastThreeDContainerData = this.createThreeDContainer(i, '2d');
	      }
	      lastThreeDContainerData.endPos = Math.max(lastThreeDContainerData.endPos, i);
	    }
	  }
	  len = this.threeDElements.length;
	  for (i = len - 1; i >= 0; i -= 1) {
	    this.resizerElem.appendChild(this.threeDElements[i].perspectiveElem);
	  }
	};

	HybridRenderer.prototype.addTo3dContainer = function (elem, pos) {
	  var i = 0;
	  var len = this.threeDElements.length;
	  while (i < len) {
	    if (pos <= this.threeDElements[i].endPos) {
	      var j = this.threeDElements[i].startPos;
	      var nextElement;
	      while (j < pos) {
	        if (this.elements[j] && this.elements[j].getBaseElement) {
	          nextElement = this.elements[j].getBaseElement();
	        }
	        j += 1;
	      }
	      if (nextElement) {
	        this.threeDElements[i].container.insertBefore(elem, nextElement);
	      } else {
	        this.threeDElements[i].container.appendChild(elem);
	      }
	      break;
	    }
	    i += 1;
	  }
	};

	HybridRenderer.prototype.configAnimation = function (animData) {
	  var resizerElem = createTag('div');
	  var wrapper = this.animationItem.wrapper;
	  var style = resizerElem.style;
	  style.width = animData.w + 'px';
	  style.height = animData.h + 'px';
	  this.resizerElem = resizerElem;
	  styleDiv(resizerElem);
	  style.transformStyle = 'flat';
	  style.mozTransformStyle = 'flat';
	  style.webkitTransformStyle = 'flat';
	  if (this.renderConfig.className) {
	    resizerElem.setAttribute('class', this.renderConfig.className);
	  }
	  wrapper.appendChild(resizerElem);

	  style.overflow = 'hidden';
	  var svg = createNS('svg');
	  svg.setAttribute('width', '1');
	  svg.setAttribute('height', '1');
	  styleDiv(svg);
	  this.resizerElem.appendChild(svg);
	  var defs = createNS('defs');
	  svg.appendChild(defs);
	  this.data = animData;
	  // Mask animation
	  this.setupGlobalData(animData, svg);
	  this.globalData.defs = defs;
	  this.layers = animData.layers;
	  this.layerElement = this.resizerElem;
	  this.build3dContainers();
	  this.updateContainerSize();
	};

	HybridRenderer.prototype.destroy = function () {
	  if (this.animationItem.wrapper) {
	    this.animationItem.wrapper.innerText = '';
	  }
	  this.animationItem.container = null;
	  this.globalData.defs = null;
	  var i;
	  var len = this.layers ? this.layers.length : 0;
	  for (i = 0; i < len; i += 1) {
	    this.elements[i].destroy();
	  }
	  this.elements.length = 0;
	  this.destroyed = true;
	  this.animationItem = null;
	};

	HybridRenderer.prototype.updateContainerSize = function () {
	  var elementWidth = this.animationItem.wrapper.offsetWidth;
	  var elementHeight = this.animationItem.wrapper.offsetHeight;
	  var elementRel = elementWidth / elementHeight;
	  var animationRel = this.globalData.compSize.w / this.globalData.compSize.h;
	  var sx;
	  var sy;
	  var tx;
	  var ty;
	  if (animationRel > elementRel) {
	    sx = elementWidth / (this.globalData.compSize.w);
	    sy = elementWidth / (this.globalData.compSize.w);
	    tx = 0;
	    ty = ((elementHeight - this.globalData.compSize.h * (elementWidth / this.globalData.compSize.w)) / 2);
	  } else {
	    sx = elementHeight / (this.globalData.compSize.h);
	    sy = elementHeight / (this.globalData.compSize.h);
	    tx = (elementWidth - this.globalData.compSize.w * (elementHeight / this.globalData.compSize.h)) / 2;
	    ty = 0;
	  }
	  var style = this.resizerElem.style;
	  style.webkitTransform = 'matrix3d(' + sx + ',0,0,0,0,' + sy + ',0,0,0,0,1,0,' + tx + ',' + ty + ',0,1)';
	  style.transform = style.webkitTransform;
	};

	HybridRenderer.prototype.renderFrame = SVGRenderer.prototype.renderFrame;

	HybridRenderer.prototype.hide = function () {
	  this.resizerElem.style.display = 'none';
	};

	HybridRenderer.prototype.show = function () {
	  this.resizerElem.style.display = 'block';
	};

	HybridRenderer.prototype.initItems = function () {
	  this.buildAllItems();
	  if (this.camera) {
	    this.camera.setup();
	  } else {
	    var cWidth = this.globalData.compSize.w;
	    var cHeight = this.globalData.compSize.h;
	    var i;
	    var len = this.threeDElements.length;
	    for (i = 0; i < len; i += 1) {
	      var style = this.threeDElements[i].perspectiveElem.style;
	      style.webkitPerspective = Math.sqrt(Math.pow(cWidth, 2) + Math.pow(cHeight, 2)) + 'px';
	      style.perspective = style.webkitPerspective;
	    }
	  }
	};

	HybridRenderer.prototype.searchExtraCompositions = function (assets) {
	  var i;
	  var len = assets.length;
	  var floatingContainer = createTag('div');
	  for (i = 0; i < len; i += 1) {
	    if (assets[i].xt) {
	      var comp = this.createComp(assets[i], floatingContainer, this.globalData.comp, null);
	      comp.initExpressions();
	      this.globalData.projectInterface.registerComposition(comp);
	    }
	  }
	};

	/* global createSizedArray, createElementID, PropertyFactory, ShapePropertyFactory, createNS, locationHref */

	function MaskElement(data, element, globalData) {
	  this.data = data;
	  this.element = element;
	  this.globalData = globalData;
	  this.storedData = [];
	  this.masksProperties = this.data.masksProperties || [];
	  this.maskElement = null;
	  var defs = this.globalData.defs;
	  var i;
	  var len = this.masksProperties ? this.masksProperties.length : 0;
	  this.viewData = createSizedArray(len);
	  this.solidPath = '';

	  var path;
	  var properties = this.masksProperties;
	  var count = 0;
	  var currentMasks = [];
	  var j;
	  var jLen;
	  var layerId = createElementID();
	  var rect;
	  var expansor;
	  var feMorph;
	  var x;
	  var maskType = 'clipPath';
	  var maskRef = 'clip-path';
	  for (i = 0; i < len; i += 1) {
	    if ((properties[i].mode !== 'a' && properties[i].mode !== 'n') || properties[i].inv || properties[i].o.k !== 100 || properties[i].o.x) {
	      maskType = 'mask';
	      maskRef = 'mask';
	    }

	    if ((properties[i].mode === 's' || properties[i].mode === 'i') && count === 0) {
	      rect = createNS('rect');
	      rect.setAttribute('fill', '#ffffff');
	      rect.setAttribute('width', this.element.comp.data.w || 0);
	      rect.setAttribute('height', this.element.comp.data.h || 0);
	      currentMasks.push(rect);
	    } else {
	      rect = null;
	    }

	    path = createNS('path');
	    if (properties[i].mode === 'n') {
	      // TODO move this to a factory or to a constructor
	      this.viewData[i] = {
	        op: PropertyFactory.getProp(this.element, properties[i].o, 0, 0.01, this.element),
	        prop: ShapePropertyFactory.getShapeProp(this.element, properties[i], 3),
	        elem: path,
	        lastPath: '',
	      };
	      defs.appendChild(path);
	    } else {
	      count += 1;

	      path.setAttribute('fill', properties[i].mode === 's' ? '#000000' : '#ffffff');
	      path.setAttribute('clip-rule', 'nonzero');
	      var filterID;

	      if (properties[i].x.k !== 0) {
	        maskType = 'mask';
	        maskRef = 'mask';
	        x = PropertyFactory.getProp(this.element, properties[i].x, 0, null, this.element);
	        filterID = createElementID();
	        expansor = createNS('filter');
	        expansor.setAttribute('id', filterID);
	        feMorph = createNS('feMorphology');
	        feMorph.setAttribute('operator', 'erode');
	        feMorph.setAttribute('in', 'SourceGraphic');
	        feMorph.setAttribute('radius', '0');
	        expansor.appendChild(feMorph);
	        defs.appendChild(expansor);
	        path.setAttribute('stroke', properties[i].mode === 's' ? '#000000' : '#ffffff');
	      } else {
	        feMorph = null;
	        x = null;
	      }

	      // TODO move this to a factory or to a constructor
	      this.storedData[i] = {
	        elem: path,
	        x: x,
	        expan: feMorph,
	        lastPath: '',
	        lastOperator: '',
	        filterId: filterID,
	        lastRadius: 0,
	      };
	      if (properties[i].mode === 'i') {
	        jLen = currentMasks.length;
	        var g = createNS('g');
	        for (j = 0; j < jLen; j += 1) {
	          g.appendChild(currentMasks[j]);
	        }
	        var mask = createNS('mask');
	        mask.setAttribute('mask-type', 'alpha');
	        mask.setAttribute('id', layerId + '_' + count);
	        mask.appendChild(path);
	        defs.appendChild(mask);
	        g.setAttribute('mask', 'url(' + locationHref + '#' + layerId + '_' + count + ')');

	        currentMasks.length = 0;
	        currentMasks.push(g);
	      } else {
	        currentMasks.push(path);
	      }
	      if (properties[i].inv && !this.solidPath) {
	        this.solidPath = this.createLayerSolidPath();
	      }
	      // TODO move this to a factory or to a constructor
	      this.viewData[i] = {
	        elem: path,
	        lastPath: '',
	        op: PropertyFactory.getProp(this.element, properties[i].o, 0, 0.01, this.element),
	        prop: ShapePropertyFactory.getShapeProp(this.element, properties[i], 3),
	        invRect: rect,
	      };
	      if (!this.viewData[i].prop.k) {
	        this.drawPath(properties[i], this.viewData[i].prop.v, this.viewData[i]);
	      }
	    }
	  }

	  this.maskElement = createNS(maskType);

	  len = currentMasks.length;
	  for (i = 0; i < len; i += 1) {
	    this.maskElement.appendChild(currentMasks[i]);
	  }

	  if (count > 0) {
	    this.maskElement.setAttribute('id', layerId);
	    this.element.maskedElement.setAttribute(maskRef, 'url(' + locationHref + '#' + layerId + ')');
	    defs.appendChild(this.maskElement);
	  }
	  if (this.viewData.length) {
	    this.element.addRenderableComponent(this);
	  }
	}

	MaskElement.prototype.getMaskProperty = function (pos) {
	  return this.viewData[pos].prop;
	};

	MaskElement.prototype.renderFrame = function (isFirstFrame) {
	  var finalMat = this.element.finalTransform.mat;
	  var i;
	  var len = this.masksProperties.length;
	  for (i = 0; i < len; i += 1) {
	    if (this.viewData[i].prop._mdf || isFirstFrame) {
	      this.drawPath(this.masksProperties[i], this.viewData[i].prop.v, this.viewData[i]);
	    }
	    if (this.viewData[i].op._mdf || isFirstFrame) {
	      this.viewData[i].elem.setAttribute('fill-opacity', this.viewData[i].op.v);
	    }
	    if (this.masksProperties[i].mode !== 'n') {
	      if (this.viewData[i].invRect && (this.element.finalTransform.mProp._mdf || isFirstFrame)) {
	        this.viewData[i].invRect.setAttribute('transform', finalMat.getInverseMatrix().to2dCSS());
	      }
	      if (this.storedData[i].x && (this.storedData[i].x._mdf || isFirstFrame)) {
	        var feMorph = this.storedData[i].expan;
	        if (this.storedData[i].x.v < 0) {
	          if (this.storedData[i].lastOperator !== 'erode') {
	            this.storedData[i].lastOperator = 'erode';
	            this.storedData[i].elem.setAttribute('filter', 'url(' + locationHref + '#' + this.storedData[i].filterId + ')');
	          }
	          feMorph.setAttribute('radius', -this.storedData[i].x.v);
	        } else {
	          if (this.storedData[i].lastOperator !== 'dilate') {
	            this.storedData[i].lastOperator = 'dilate';
	            this.storedData[i].elem.setAttribute('filter', null);
	          }
	          this.storedData[i].elem.setAttribute('stroke-width', this.storedData[i].x.v * 2);
	        }
	      }
	    }
	  }
	};

	MaskElement.prototype.getMaskelement = function () {
	  return this.maskElement;
	};

	MaskElement.prototype.createLayerSolidPath = function () {
	  var path = 'M0,0 ';
	  path += ' h' + this.globalData.compSize.w;
	  path += ' v' + this.globalData.compSize.h;
	  path += ' h-' + this.globalData.compSize.w;
	  path += ' v-' + this.globalData.compSize.h + ' ';
	  return path;
	};

	MaskElement.prototype.drawPath = function (pathData, pathNodes, viewData) {
	  var pathString = ' M' + pathNodes.v[0][0] + ',' + pathNodes.v[0][1];
	  var i;
	  var len;
	  len = pathNodes._length;
	  for (i = 1; i < len; i += 1) {
	    // pathString += " C"+pathNodes.o[i-1][0]+','+pathNodes.o[i-1][1] + " "+pathNodes.i[i][0]+','+pathNodes.i[i][1] + " "+pathNodes.v[i][0]+','+pathNodes.v[i][1];
	    pathString += ' C' + pathNodes.o[i - 1][0] + ',' + pathNodes.o[i - 1][1] + ' ' + pathNodes.i[i][0] + ',' + pathNodes.i[i][1] + ' ' + pathNodes.v[i][0] + ',' + pathNodes.v[i][1];
	  }
	  // pathString += " C"+pathNodes.o[i-1][0]+','+pathNodes.o[i-1][1] + " "+pathNodes.i[0][0]+','+pathNodes.i[0][1] + " "+pathNodes.v[0][0]+','+pathNodes.v[0][1];
	  if (pathNodes.c && len > 1) {
	    pathString += ' C' + pathNodes.o[i - 1][0] + ',' + pathNodes.o[i - 1][1] + ' ' + pathNodes.i[0][0] + ',' + pathNodes.i[0][1] + ' ' + pathNodes.v[0][0] + ',' + pathNodes.v[0][1];
	  }
	  // pathNodes.__renderedString = pathString;

	  if (viewData.lastPath !== pathString) {
	    var pathShapeValue = '';
	    if (viewData.elem) {
	      if (pathNodes.c) {
	        pathShapeValue = pathData.inv ? this.solidPath + pathString : pathString;
	      }
	      viewData.elem.setAttribute('d', pathShapeValue);
	    }
	    viewData.lastPath = pathString;
	  }
	};

	MaskElement.prototype.destroy = function () {
	  this.element = null;
	  this.globalData = null;
	  this.maskElement = null;
	  this.data = null;
	  this.masksProperties = null;
	};

	/**
	 * @file
	 * Handles AE's layer parenting property.
	 *
	 */

	function HierarchyElement() {}

	HierarchyElement.prototype = {
	  /**
	     * @function
	     * Initializes hierarchy properties
	     *
	     */
	  initHierarchy: function () {
	    // element's parent list
	    this.hierarchy = [];
	    // if element is parent of another layer _isParent will be true
	    this._isParent = false;
	    this.checkParenting();
	  },
	  /**
	     * @function
	     * Sets layer's hierarchy.
	     * @param {array} hierarch
	     * layer's parent list
	     *
	     */
	  setHierarchy: function (hierarchy) {
	    this.hierarchy = hierarchy;
	  },
	  /**
	     * @function
	     * Sets layer as parent.
	     *
	     */
	  setAsParent: function () {
	    this._isParent = true;
	  },
	  /**
	     * @function
	     * Searches layer's parenting chain
	     *
	     */
	  checkParenting: function () {
	    if (this.data.parent !== undefined) {
	      this.comp.buildElementParenting(this, this.data.parent, []);
	    }
	  },
	};

	/**
	 * @file
	 * Handles element's layer frame update.
	 * Checks layer in point and out point
	 *
	 */

	function FrameElement() {}

	FrameElement.prototype = {
	  /**
	     * @function
	     * Initializes frame related properties.
	     *
	     */
	  initFrame: function () {
	    // set to true when inpoint is rendered
	    this._isFirstFrame = false;
	    // list of animated properties
	    this.dynamicProperties = [];
	    // If layer has been modified in current tick this will be true
	    this._mdf = false;
	  },
	  /**
	     * @function
	     * Calculates all dynamic values
	     *
	     * @param {number} num
	     * current frame number in Layer's time
	     * @param {boolean} isVisible
	     * if layers is currently in range
	     *
	     */
	  prepareProperties: function (num, isVisible) {
	    var i;
	    var len = this.dynamicProperties.length;
	    for (i = 0; i < len; i += 1) {
	      if (isVisible || (this._isParent && this.dynamicProperties[i].propType === 'transform')) {
	        this.dynamicProperties[i].getValue();
	        if (this.dynamicProperties[i]._mdf) {
	          this.globalData._mdf = true;
	          this._mdf = true;
	        }
	      }
	    }
	  },
	  addDynamicProperty: function (prop) {
	    if (this.dynamicProperties.indexOf(prop) === -1) {
	      this.dynamicProperties.push(prop);
	    }
	  },
	};

	/* global TransformPropertyFactory, Matrix */

	function TransformElement() {}

	TransformElement.prototype = {
	  initTransform: function () {
	    this.finalTransform = {
	      mProp: this.data.ks ? TransformPropertyFactory.getTransformProperty(this, this.data.ks, this) : { o: 0 },
	      _matMdf: false,
	      _opMdf: false,
	      mat: new Matrix(),
	    };
	    if (this.data.ao) {
	      this.finalTransform.mProp.autoOriented = true;
	    }

	    // TODO: check TYPE 11: Guided elements
	    if (this.data.ty !== 11) {
	      // this.createElements();
	    }
	  },
	  renderTransform: function () {
	    this.finalTransform._opMdf = this.finalTransform.mProp.o._mdf || this._isFirstFrame;
	    this.finalTransform._matMdf = this.finalTransform.mProp._mdf || this._isFirstFrame;

	    if (this.hierarchy) {
	      var mat;
	      var finalMat = this.finalTransform.mat;
	      var i = 0;
	      var len = this.hierarchy.length;
	      // Checking if any of the transformation matrices in the hierarchy chain has changed.
	      if (!this.finalTransform._matMdf) {
	        while (i < len) {
	          if (this.hierarchy[i].finalTransform.mProp._mdf) {
	            this.finalTransform._matMdf = true;
	            break;
	          }
	          i += 1;
	        }
	      }

	      if (this.finalTransform._matMdf) {
	        mat = this.finalTransform.mProp.v.props;
	        finalMat.cloneFromProps(mat);
	        for (i = 0; i < len; i += 1) {
	          mat = this.hierarchy[i].finalTransform.mProp.v.props;
	          finalMat.transform(mat[0], mat[1], mat[2], mat[3], mat[4], mat[5], mat[6], mat[7], mat[8], mat[9], mat[10], mat[11], mat[12], mat[13], mat[14], mat[15]);
	        }
	      }
	    }
	  },
	  globalToLocal: function (pt) {
	    var transforms = [];
	    transforms.push(this.finalTransform);
	    var flag = true;
	    var comp = this.comp;
	    while (flag) {
	      if (comp.finalTransform) {
	        if (comp.data.hasMask) {
	          transforms.splice(0, 0, comp.finalTransform);
	        }
	        comp = comp.comp;
	      } else {
	        flag = false;
	      }
	    }
	    var i;
	    var len = transforms.length;
	    var ptNew;
	    for (i = 0; i < len; i += 1) {
	      ptNew = transforms[i].mat.applyToPointArray(0, 0, 0);
	      // ptNew = transforms[i].mat.applyToPointArray(pt[0],pt[1],pt[2]);
	      pt = [pt[0] - ptNew[0], pt[1] - ptNew[1], 0];
	    }
	    return pt;
	  },
	  mHelper: new Matrix(),
	};

	function RenderableElement() {

	}

	RenderableElement.prototype = {
	  initRenderable: function () {
	    // layer's visibility related to inpoint and outpoint. Rename isVisible to isInRange
	    this.isInRange = false;
	    // layer's display state
	    this.hidden = false;
	    // If layer's transparency equals 0, it can be hidden
	    this.isTransparent = false;
	    // list of animated components
	    this.renderableComponents = [];
	  },
	  addRenderableComponent: function (component) {
	    if (this.renderableComponents.indexOf(component) === -1) {
	      this.renderableComponents.push(component);
	    }
	  },
	  removeRenderableComponent: function (component) {
	    if (this.renderableComponents.indexOf(component) !== -1) {
	      this.renderableComponents.splice(this.renderableComponents.indexOf(component), 1);
	    }
	  },
	  prepareRenderableFrame: function (num) {
	    this.checkLayerLimits(num);
	  },
	  checkTransparency: function () {
	    if (this.finalTransform.mProp.o.v <= 0) {
	      if (!this.isTransparent && this.globalData.renderConfig.hideOnTransparent) {
	        this.isTransparent = true;
	        this.hide();
	      }
	    } else if (this.isTransparent) {
	      this.isTransparent = false;
	      this.show();
	    }
	  },
	  /**
	     * @function
	     * Initializes frame related properties.
	     *
	     * @param {number} num
	     * current frame number in Layer's time
	     *
	     */
	  checkLayerLimits: function (num) {
	    if (this.data.ip - this.data.st <= num && this.data.op - this.data.st > num) {
	      if (this.isInRange !== true) {
	        this.globalData._mdf = true;
	        this._mdf = true;
	        this.isInRange = true;
	        this.show();
	      }
	    } else if (this.isInRange !== false) {
	      this.globalData._mdf = true;
	      this.isInRange = false;
	      this.hide();
	    }
	  },
	  renderRenderable: function () {
	    var i;
	    var len = this.renderableComponents.length;
	    for (i = 0; i < len; i += 1) {
	      this.renderableComponents[i].renderFrame(this._isFirstFrame);
	    }
	    /* this.maskManager.renderFrame(this.finalTransform.mat);
	        this.renderableEffectsManager.renderFrame(this._isFirstFrame); */
	  },
	  sourceRectAtTime: function () {
	    return {
	      top: 0,
	      left: 0,
	      width: 100,
	      height: 100,
	    };
	  },
	  getLayerSize: function () {
	    if (this.data.ty === 5) {
	      return { w: this.data.textData.width, h: this.data.textData.height };
	    }
	    return { w: this.data.width, h: this.data.height };
	  },
	};

	/* global extendPrototype, RenderableElement, createProxyFunction */

	function RenderableDOMElement() {}

	(function () {
	  var _prototype = {
	    initElement: function (data, globalData, comp) {
	      this.initFrame();
	      this.initBaseData(data, globalData, comp);
	      this.initTransform(data, globalData, comp);
	      this.initHierarchy();
	      this.initRenderable();
	      this.initRendererElement();
	      this.createContainerElements();
	      this.createRenderableComponents();
	      this.createContent();
	      this.hide();
	    },
	    hide: function () {
	      if (!this.hidden && (!this.isInRange || this.isTransparent)) {
	        var elem = this.baseElement || this.layerElement;
	        elem.style.display = 'none';
	        this.hidden = true;
	      }
	    },
	    show: function () {
	      if (this.isInRange && !this.isTransparent) {
	        if (!this.data.hd) {
	          var elem = this.baseElement || this.layerElement;
	          elem.style.display = 'block';
	        }
	        this.hidden = false;
	        this._isFirstFrame = true;
	      }
	    },
	    renderFrame: function () {
	      // If it is exported as hidden (data.hd === true) no need to render
	      // If it is not visible no need to render
	      if (this.data.hd || this.hidden) {
	        return;
	      }
	      this.renderTransform();
	      this.renderRenderable();
	      this.renderElement();
	      this.renderInnerContent();
	      if (this._isFirstFrame) {
	        this._isFirstFrame = false;
	      }
	    },
	    renderInnerContent: function () {},
	    prepareFrame: function (num) {
	      this._mdf = false;
	      this.prepareRenderableFrame(num);
	      this.prepareProperties(num, this.isInRange);
	      this.checkTransparency();
	    },
	    destroy: function () {
	      this.innerElem = null;
	      this.destroyBaseElement();
	    },
	  };
	  extendPrototype([RenderableElement, createProxyFunction(_prototype)], RenderableDOMElement);
	}());

	/* exported ProcessedElement */

	function ProcessedElement(element, position) {
	  this.elem = element;
	  this.pos = position;
	}

	/* global createNS */

	function SVGStyleData(data, level) {
	  this.data = data;
	  this.type = data.ty;
	  this.d = '';
	  this.lvl = level;
	  this._mdf = false;
	  this.closed = data.hd === true;
	  this.pElem = createNS('path');
	  this.msElem = null;
	}

	SVGStyleData.prototype.reset = function () {
	  this.d = '';
	  this._mdf = false;
	};

	function SVGShapeData(transformers, level, shape) {
	  this.caches = [];
	  this.styles = [];
	  this.transformers = transformers;
	  this.lStr = '';
	  this.sh = shape;
	  this.lvl = level;
	  // TODO find if there are some cases where _isAnimated can be false.
	  // For now, since shapes add up with other shapes. They have to be calculated every time.
	  // One way of finding out is checking if all styles associated to this shape depend only of this shape
	  this._isAnimated = !!shape.k;
	  // TODO: commenting this for now since all shapes are animated
	  var i = 0;
	  var len = transformers.length;
	  while (i < len) {
	    if (transformers[i].mProps.dynamicProperties.length) {
	      this._isAnimated = true;
	      break;
	    }
	    i += 1;
	  }
	}

	SVGShapeData.prototype.setAsAnimated = function () {
	  this._isAnimated = true;
	};

	/* exported SVGTransformData */

	function SVGTransformData(mProps, op, container) {
	  this.transform = {
	    mProps: mProps,
	    op: op,
	    container: container,
	  };
	  this.elements = [];
	  this._isAnimated = this.transform.mProps.dynamicProperties.length || this.transform.op.effectsSequence.length;
	}

	/* global DashProperty, PropertyFactory, extendPrototype, DynamicPropertyContainer */

	function SVGStrokeStyleData(elem, data, styleOb) {
	  this.initDynamicPropertyContainer(elem);
	  this.getValue = this.iterateDynamicProperties;
	  this.o = PropertyFactory.getProp(elem, data.o, 0, 0.01, this);
	  this.w = PropertyFactory.getProp(elem, data.w, 0, null, this);
	  this.d = new DashProperty(elem, data.d || {}, 'svg', this);
	  this.c = PropertyFactory.getProp(elem, data.c, 1, 255, this);
	  this.style = styleOb;
	  this._isAnimated = !!this._isAnimated;
	}

	extendPrototype([DynamicPropertyContainer], SVGStrokeStyleData);

	/* global PropertyFactory, extendPrototype, DynamicPropertyContainer */

	function SVGFillStyleData(elem, data, styleOb) {
	  this.initDynamicPropertyContainer(elem);
	  this.getValue = this.iterateDynamicProperties;
	  this.o = PropertyFactory.getProp(elem, data.o, 0, 0.01, this);
	  this.c = PropertyFactory.getProp(elem, data.c, 1, 255, this);
	  this.style = styleOb;
	}

	extendPrototype([DynamicPropertyContainer], SVGFillStyleData);

	/* global PropertyFactory, degToRads, GradientProperty, createElementID, createNS, locationHref,
	extendPrototype, DynamicPropertyContainer, lineCapEnum, lineJoinEnum */

	function SVGGradientFillStyleData(elem, data, styleOb) {
	  this.initDynamicPropertyContainer(elem);
	  this.getValue = this.iterateDynamicProperties;
	  this.initGradientData(elem, data, styleOb);
	}

	SVGGradientFillStyleData.prototype.initGradientData = function (elem, data, styleOb) {
	  this.o = PropertyFactory.getProp(elem, data.o, 0, 0.01, this);
	  this.s = PropertyFactory.getProp(elem, data.s, 1, null, this);
	  this.e = PropertyFactory.getProp(elem, data.e, 1, null, this);
	  this.h = PropertyFactory.getProp(elem, data.h || { k: 0 }, 0, 0.01, this);
	  this.a = PropertyFactory.getProp(elem, data.a || { k: 0 }, 0, degToRads, this);
	  this.g = new GradientProperty(elem, data.g, this);
	  this.style = styleOb;
	  this.stops = [];
	  this.setGradientData(styleOb.pElem, data);
	  this.setGradientOpacity(data, styleOb);
	  this._isAnimated = !!this._isAnimated;
	};

	SVGGradientFillStyleData.prototype.setGradientData = function (pathElement, data) {
	  var gradientId = createElementID();
	  var gfill = createNS(data.t === 1 ? 'linearGradient' : 'radialGradient');
	  gfill.setAttribute('id', gradientId);
	  gfill.setAttribute('spreadMethod', 'pad');
	  gfill.setAttribute('gradientUnits', 'userSpaceOnUse');
	  var stops = [];
	  var stop;
	  var j;
	  var jLen;
	  jLen = data.g.p * 4;
	  for (j = 0; j < jLen; j += 4) {
	    stop = createNS('stop');
	    gfill.appendChild(stop);
	    stops.push(stop);
	  }
	  pathElement.setAttribute(data.ty === 'gf' ? 'fill' : 'stroke', 'url(' + locationHref + '#' + gradientId + ')');
	  this.gf = gfill;
	  this.cst = stops;
	};

	SVGGradientFillStyleData.prototype.setGradientOpacity = function (data, styleOb) {
	  if (this.g._hasOpacity && !this.g._collapsable) {
	    var stop;
	    var j;
	    var jLen;
	    var mask = createNS('mask');
	    var maskElement = createNS('path');
	    mask.appendChild(maskElement);
	    var opacityId = createElementID();
	    var maskId = createElementID();
	    mask.setAttribute('id', maskId);
	    var opFill = createNS(data.t === 1 ? 'linearGradient' : 'radialGradient');
	    opFill.setAttribute('id', opacityId);
	    opFill.setAttribute('spreadMethod', 'pad');
	    opFill.setAttribute('gradientUnits', 'userSpaceOnUse');
	    jLen = data.g.k.k[0].s ? data.g.k.k[0].s.length : data.g.k.k.length;
	    var stops = this.stops;
	    for (j = data.g.p * 4; j < jLen; j += 2) {
	      stop = createNS('stop');
	      stop.setAttribute('stop-color', 'rgb(255,255,255)');
	      opFill.appendChild(stop);
	      stops.push(stop);
	    }
	    maskElement.setAttribute(data.ty === 'gf' ? 'fill' : 'stroke', 'url(' + locationHref + '#' + opacityId + ')');
	    if (data.ty === 'gs') {
	      maskElement.setAttribute('stroke-linecap', lineCapEnum[data.lc || 2]);
	      maskElement.setAttribute('stroke-linejoin', lineJoinEnum[data.lj || 2]);
	      if (data.lj === 1) {
	        maskElement.setAttribute('stroke-miterlimit', data.ml);
	      }
	    }
	    this.of = opFill;
	    this.ms = mask;
	    this.ost = stops;
	    this.maskId = maskId;
	    styleOb.msElem = maskElement;
	  }
	};

	extendPrototype([DynamicPropertyContainer], SVGGradientFillStyleData);

	/* global PropertyFactory, DashProperty, extendPrototype, SVGGradientFillStyleData, DynamicPropertyContainer */

	function SVGGradientStrokeStyleData(elem, data, styleOb) {
	  this.initDynamicPropertyContainer(elem);
	  this.getValue = this.iterateDynamicProperties;
	  this.w = PropertyFactory.getProp(elem, data.w, 0, null, this);
	  this.d = new DashProperty(elem, data.d || {}, 'svg', this);
	  this.initGradientData(elem, data, styleOb);
	  this._isAnimated = !!this._isAnimated;
	}

	extendPrototype([SVGGradientFillStyleData, DynamicPropertyContainer], SVGGradientStrokeStyleData);

	/* global createNS */
	/* exported ShapeGroupData */

	function ShapeGroupData() {
	  this.it = [];
	  this.prevViewData = [];
	  this.gr = createNS('g');
	}

	/* global Matrix, buildShapeString, bmFloor */
	/* exported SVGElementsRenderer */

	var SVGElementsRenderer = (function () {
	  var _identityMatrix = new Matrix();
	  var _matrixHelper = new Matrix();

	  var ob = {
	    createRenderFunction: createRenderFunction,
	  };

	  function createRenderFunction(data) {
	    switch (data.ty) {
	      case 'fl':
	        return renderFill;
	      case 'gf':
	        return renderGradient;
	      case 'gs':
	        return renderGradientStroke;
	      case 'st':
	        return renderStroke;
	      case 'sh':
	      case 'el':
	      case 'rc':
	      case 'sr':
	        return renderPath;
	      case 'tr':
	        return renderContentTransform;
	      default:
	        return null;
	    }
	  }

	  function renderContentTransform(styleData, itemData, isFirstFrame) {
	    if (isFirstFrame || itemData.transform.op._mdf) {
	      itemData.transform.container.setAttribute('opacity', itemData.transform.op.v);
	    }
	    if (isFirstFrame || itemData.transform.mProps._mdf) {
	      itemData.transform.container.setAttribute('transform', itemData.transform.mProps.v.to2dCSS());
	    }
	  }

	  function renderPath(styleData, itemData, isFirstFrame) {
	    var j;
	    var jLen;
	    var pathStringTransformed;
	    var redraw;
	    var pathNodes;
	    var l;
	    var lLen = itemData.styles.length;
	    var lvl = itemData.lvl;
	    var paths;
	    var mat;
	    var props;
	    var iterations;
	    var k;
	    for (l = 0; l < lLen; l += 1) {
	      redraw = itemData.sh._mdf || isFirstFrame;
	      if (itemData.styles[l].lvl < lvl) {
	        mat = _matrixHelper.reset();
	        iterations = lvl - itemData.styles[l].lvl;
	        k = itemData.transformers.length - 1;
	        while (!redraw && iterations > 0) {
	          redraw = itemData.transformers[k].mProps._mdf || redraw;
	          iterations -= 1;
	          k -= 1;
	        }
	        if (redraw) {
	          iterations = lvl - itemData.styles[l].lvl;
	          k = itemData.transformers.length - 1;
	          while (iterations > 0) {
	            props = itemData.transformers[k].mProps.v.props;
	            mat.transform(props[0], props[1], props[2], props[3], props[4], props[5], props[6], props[7], props[8], props[9], props[10], props[11], props[12], props[13], props[14], props[15]);
	            iterations -= 1;
	            k -= 1;
	          }
	        }
	      } else {
	        mat = _identityMatrix;
	      }
	      paths = itemData.sh.paths;
	      jLen = paths._length;
	      if (redraw) {
	        pathStringTransformed = '';
	        for (j = 0; j < jLen; j += 1) {
	          pathNodes = paths.shapes[j];
	          if (pathNodes && pathNodes._length) {
	            pathStringTransformed += buildShapeString(pathNodes, pathNodes._length, pathNodes.c, mat);
	          }
	        }
	        itemData.caches[l] = pathStringTransformed;
	      } else {
	        pathStringTransformed = itemData.caches[l];
	      }
	      itemData.styles[l].d += styleData.hd === true ? '' : pathStringTransformed;
	      itemData.styles[l]._mdf = redraw || itemData.styles[l]._mdf;
	    }
	  }

	  function renderFill(styleData, itemData, isFirstFrame) {
	    var styleElem = itemData.style;

	    if (itemData.c._mdf || isFirstFrame) {
	      styleElem.pElem.setAttribute('fill', 'rgb(' + bmFloor(itemData.c.v[0]) + ',' + bmFloor(itemData.c.v[1]) + ',' + bmFloor(itemData.c.v[2]) + ')');
	    }
	    if (itemData.o._mdf || isFirstFrame) {
	      styleElem.pElem.setAttribute('fill-opacity', itemData.o.v);
	    }
	  }

	  function renderGradientStroke(styleData, itemData, isFirstFrame) {
	    renderGradient(styleData, itemData, isFirstFrame);
	    renderStroke(styleData, itemData, isFirstFrame);
	  }

	  function renderGradient(styleData, itemData, isFirstFrame) {
	    var gfill = itemData.gf;
	    var hasOpacity = itemData.g._hasOpacity;
	    var pt1 = itemData.s.v;
	    var pt2 = itemData.e.v;

	    if (itemData.o._mdf || isFirstFrame) {
	      var attr = styleData.ty === 'gf' ? 'fill-opacity' : 'stroke-opacity';
	      itemData.style.pElem.setAttribute(attr, itemData.o.v);
	    }
	    if (itemData.s._mdf || isFirstFrame) {
	      var attr1 = styleData.t === 1 ? 'x1' : 'cx';
	      var attr2 = attr1 === 'x1' ? 'y1' : 'cy';
	      gfill.setAttribute(attr1, pt1[0]);
	      gfill.setAttribute(attr2, pt1[1]);
	      if (hasOpacity && !itemData.g._collapsable) {
	        itemData.of.setAttribute(attr1, pt1[0]);
	        itemData.of.setAttribute(attr2, pt1[1]);
	      }
	    }
	    var stops;
	    var i;
	    var len;
	    var stop;
	    if (itemData.g._cmdf || isFirstFrame) {
	      stops = itemData.cst;
	      var cValues = itemData.g.c;
	      len = stops.length;
	      for (i = 0; i < len; i += 1) {
	        stop = stops[i];
	        stop.setAttribute('offset', cValues[i * 4] + '%');
	        stop.setAttribute('stop-color', 'rgb(' + cValues[i * 4 + 1] + ',' + cValues[i * 4 + 2] + ',' + cValues[i * 4 + 3] + ')');
	      }
	    }
	    if (hasOpacity && (itemData.g._omdf || isFirstFrame)) {
	      var oValues = itemData.g.o;
	      if (itemData.g._collapsable) {
	        stops = itemData.cst;
	      } else {
	        stops = itemData.ost;
	      }
	      len = stops.length;
	      for (i = 0; i < len; i += 1) {
	        stop = stops[i];
	        if (!itemData.g._collapsable) {
	          stop.setAttribute('offset', oValues[i * 2] + '%');
	        }
	        stop.setAttribute('stop-opacity', oValues[i * 2 + 1]);
	      }
	    }
	    if (styleData.t === 1) {
	      if (itemData.e._mdf || isFirstFrame) {
	        gfill.setAttribute('x2', pt2[0]);
	        gfill.setAttribute('y2', pt2[1]);
	        if (hasOpacity && !itemData.g._collapsable) {
	          itemData.of.setAttribute('x2', pt2[0]);
	          itemData.of.setAttribute('y2', pt2[1]);
	        }
	      }
	    } else {
	      var rad;
	      if (itemData.s._mdf || itemData.e._mdf || isFirstFrame) {
	        rad = Math.sqrt(Math.pow(pt1[0] - pt2[0], 2) + Math.pow(pt1[1] - pt2[1], 2));
	        gfill.setAttribute('r', rad);
	        if (hasOpacity && !itemData.g._collapsable) {
	          itemData.of.setAttribute('r', rad);
	        }
	      }
	      if (itemData.e._mdf || itemData.h._mdf || itemData.a._mdf || isFirstFrame) {
	        if (!rad) {
	          rad = Math.sqrt(Math.pow(pt1[0] - pt2[0], 2) + Math.pow(pt1[1] - pt2[1], 2));
	        }
	        var ang = Math.atan2(pt2[1] - pt1[1], pt2[0] - pt1[0]);

	        var percent = itemData.h.v;
	        if (percent >= 1) {
	          percent = 0.99;
	        } else if (percent <= -1) {
	          percent = -0.99;
	        }
	        var dist = rad * percent;
	        var x = Math.cos(ang + itemData.a.v) * dist + pt1[0];
	        var y = Math.sin(ang + itemData.a.v) * dist + pt1[1];
	        gfill.setAttribute('fx', x);
	        gfill.setAttribute('fy', y);
	        if (hasOpacity && !itemData.g._collapsable) {
	          itemData.of.setAttribute('fx', x);
	          itemData.of.setAttribute('fy', y);
	        }
	      }
	      // gfill.setAttribute('fy','200');
	    }
	  }

	  function renderStroke(styleData, itemData, isFirstFrame) {
	    var styleElem = itemData.style;
	    var d = itemData.d;
	    if (d && (d._mdf || isFirstFrame) && d.dashStr) {
	      styleElem.pElem.setAttribute('stroke-dasharray', d.dashStr);
	      styleElem.pElem.setAttribute('stroke-dashoffset', d.dashoffset[0]);
	    }
	    if (itemData.c && (itemData.c._mdf || isFirstFrame)) {
	      styleElem.pElem.setAttribute('stroke', 'rgb(' + bmFloor(itemData.c.v[0]) + ',' + bmFloor(itemData.c.v[1]) + ',' + bmFloor(itemData.c.v[2]) + ')');
	    }
	    if (itemData.o._mdf || isFirstFrame) {
	      styleElem.pElem.setAttribute('stroke-opacity', itemData.o.v);
	    }
	    if (itemData.w._mdf || isFirstFrame) {
	      styleElem.pElem.setAttribute('stroke-width', itemData.w.v);
	      if (styleElem.msElem) {
	        styleElem.msElem.setAttribute('stroke-width', itemData.w.v);
	      }
	    }
	  }

	  return ob;
	}());

	/* global Matrix */

	function ShapeTransformManager() {
	  this.sequences = {};
	  this.sequenceList = [];
	  this.transform_key_count = 0;
	}

	ShapeTransformManager.prototype = {
	  addTransformSequence: function (transforms) {
	    var i;
	    var len = transforms.length;
	    var key = '_';
	    for (i = 0; i < len; i += 1) {
	      key += transforms[i].transform.key + '_';
	    }
	    var sequence = this.sequences[key];
	    if (!sequence) {
	      sequence = {
	        transforms: [].concat(transforms),
	        finalTransform: new Matrix(),
	        _mdf: false,
	      };
	      this.sequences[key] = sequence;
	      this.sequenceList.push(sequence);
	    }
	    return sequence;
	  },
	  processSequence: function (sequence, isFirstFrame) {
	    var i = 0;
	    var len = sequence.transforms.length;
	    var _mdf = isFirstFrame;
	    while (i < len && !isFirstFrame) {
	      if (sequence.transforms[i].transform.mProps._mdf) {
	        _mdf = true;
	        break;
	      }
	      i += 1;
	    }
	    if (_mdf) {
	      var props;
	      sequence.finalTransform.reset();
	      for (i = len - 1; i >= 0; i -= 1) {
	        props = sequence.transforms[i].transform.mProps.v.props;
	        sequence.finalTransform.transform(props[0], props[1], props[2], props[3], props[4], props[5], props[6], props[7], props[8], props[9], props[10], props[11], props[12], props[13], props[14], props[15]);
	      }
	    }
	    sequence._mdf = _mdf;
	  },
	  processSequences: function (isFirstFrame) {
	    var i;
	    var len = this.sequenceList.length;
	    for (i = 0; i < len; i += 1) {
	      this.processSequence(this.sequenceList[i], isFirstFrame);
	    }
	  },
	  getNewKey: function () {
	    this.transform_key_count += 1;
	    return '_' + this.transform_key_count;
	  },
	};

	/* global ShapePropertyFactory, SVGShapeData */

	function CVShapeData(element, data, styles, transformsManager) {
	  this.styledShapes = [];
	  this.tr = [0, 0, 0, 0, 0, 0];
	  var ty = 4;
	  if (data.ty === 'rc') {
	    ty = 5;
	  } else if (data.ty === 'el') {
	    ty = 6;
	  } else if (data.ty === 'sr') {
	    ty = 7;
	  }
	  this.sh = ShapePropertyFactory.getShapeProp(element, data, ty, element);
	  var i;
	  var len = styles.length;
	  var styledShape;
	  for (i = 0; i < len; i += 1) {
	    if (!styles[i].closed) {
	      styledShape = {
	        transforms: transformsManager.addTransformSequence(styles[i].transforms),
	        trNodes: [],
	      };
	      this.styledShapes.push(styledShape);
	      styles[i].elements.push(styledShape);
	    }
	  }
	}

	CVShapeData.prototype.setAsAnimated = SVGShapeData.prototype.setAsAnimated;

	/* global LayerExpressionInterface, EffectsExpressionInterface, CompExpressionInterface, ShapeExpressionInterface,
	TextExpressionInterface, getBlendMode,createElementID, EffectsManager */

	function BaseElement() {
	}

	BaseElement.prototype = {
	  checkMasks: function () {
	    if (!this.data.hasMask) {
	      return false;
	    }
	    var i = 0;
	    var len = this.data.masksProperties.length;
	    while (i < len) {
	      if ((this.data.masksProperties[i].mode !== 'n' && this.data.masksProperties[i].cl !== false)) {
	        return true;
	      }
	      i += 1;
	    }
	    return false;
	  },
	  initExpressions: function () {
	    this.layerInterface = LayerExpressionInterface(this);
	    if (this.data.hasMask && this.maskManager) {
	      this.layerInterface.registerMaskInterface(this.maskManager);
	    }
	    var effectsInterface = EffectsExpressionInterface.createEffectsInterface(this, this.layerInterface);
	    this.layerInterface.registerEffectsInterface(effectsInterface);

	    if (this.data.ty === 0 || this.data.xt) {
	      this.compInterface = CompExpressionInterface(this);
	    } else if (this.data.ty === 4) {
	      this.layerInterface.shapeInterface = ShapeExpressionInterface(this.shapesData, this.itemsData, this.layerInterface);
	      this.layerInterface.content = this.layerInterface.shapeInterface;
	    } else if (this.data.ty === 5) {
	      this.layerInterface.textInterface = TextExpressionInterface(this);
	      this.layerInterface.text = this.layerInterface.textInterface;
	    }
	  },
	  setBlendMode: function () {
	    var blendModeValue = getBlendMode(this.data.bm);
	    var elem = this.baseElement || this.layerElement;

	    elem.style['mix-blend-mode'] = blendModeValue;
	  },
	  initBaseData: function (data, globalData, comp) {
	    this.globalData = globalData;
	    this.comp = comp;
	    this.data = data;
	    this.layerId = createElementID();

	    // Stretch factor for old animations missing this property.
	    if (!this.data.sr) {
	      this.data.sr = 1;
	    }
	    // effects manager
	    this.effectsManager = new EffectsManager(this.data, this, this.dynamicProperties);
	  },
	  getType: function () {
	    return this.type;
	  },
	  sourceRectAtTime: function () {},
	};

	/* global extendPrototype, BaseElement, TransformElement, HierarchyElement, FrameElement */

	function NullElement(data, globalData, comp) {
	  this.initFrame();
	  this.initBaseData(data, globalData, comp);
	  this.initFrame();
	  this.initTransform(data, globalData, comp);
	  this.initHierarchy();
	}

	NullElement.prototype.prepareFrame = function (num) {
	  this.prepareProperties(num, true);
	};

	NullElement.prototype.renderFrame = function () {
	};

	NullElement.prototype.getBaseElement = function () {
	  return null;
	};

	NullElement.prototype.destroy = function () {
	};

	NullElement.prototype.sourceRectAtTime = function () {
	};

	NullElement.prototype.hide = function () {
	};

	extendPrototype([BaseElement, TransformElement, HierarchyElement, FrameElement], NullElement);

	/* global filtersFactory, featureSupport, filtersFactory, createElementID, createNS, MaskElement, SVGEffects, locationHref */

	function SVGBaseElement() {
	}

	SVGBaseElement.prototype = {
	  initRendererElement: function () {
	    this.layerElement = createNS('g');
	  },
	  createContainerElements: function () {
	    this.matteElement = createNS('g');
	    this.transformedElement = this.layerElement;
	    this.maskedElement = this.layerElement;
	    this._sizeChanged = false;
	    var layerElementParent = null;
	    // If this layer acts as a mask for the following layer
	    var filId;
	    var fil;
	    var gg;
	    if (this.data.td) {
	      if (this.data.td == 3 || this.data.td == 1) { // eslint-disable-line eqeqeq
	        var masker = createNS('mask');
	        masker.setAttribute('id', this.layerId);
	        masker.setAttribute('mask-type', this.data.td == 3 ? 'luminance' : 'alpha'); // eslint-disable-line eqeqeq
	        masker.appendChild(this.layerElement);
	        layerElementParent = masker;
	        this.globalData.defs.appendChild(masker);
	        // This is only for IE and Edge when mask if of type alpha
	        if (!featureSupport.maskType && this.data.td == 1) { // eslint-disable-line eqeqeq
	          masker.setAttribute('mask-type', 'luminance');
	          filId = createElementID();
	          fil = filtersFactory.createFilter(filId);
	          this.globalData.defs.appendChild(fil);
	          fil.appendChild(filtersFactory.createAlphaToLuminanceFilter());
	          gg = createNS('g');
	          gg.appendChild(this.layerElement);
	          layerElementParent = gg;
	          masker.appendChild(gg);
	          gg.setAttribute('filter', 'url(' + locationHref + '#' + filId + ')');
	        }
	      } else if (this.data.td == 2) { // eslint-disable-line eqeqeq
	        var maskGroup = createNS('mask');
	        maskGroup.setAttribute('id', this.layerId);
	        maskGroup.setAttribute('mask-type', 'alpha');
	        var maskGrouper = createNS('g');
	        maskGroup.appendChild(maskGrouper);
	        filId = createElementID();
	        fil = filtersFactory.createFilter(filId);
	        /// /

	        // This solution doesn't work on Android when meta tag with viewport attribute is set
	        /* var feColorMatrix = createNS('feColorMatrix');
	                feColorMatrix.setAttribute('type', 'matrix');
	                feColorMatrix.setAttribute('color-interpolation-filters', 'sRGB');
	                feColorMatrix.setAttribute('values','1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 -1 1');
	                fil.appendChild(feColorMatrix); */
	        /// /
	        var feCTr = createNS('feComponentTransfer');
	        feCTr.setAttribute('in', 'SourceGraphic');
	        fil.appendChild(feCTr);
	        var feFunc = createNS('feFuncA');
	        feFunc.setAttribute('type', 'table');
	        feFunc.setAttribute('tableValues', '1.0 0.0');
	        feCTr.appendChild(feFunc);
	        /// /
	        this.globalData.defs.appendChild(fil);
	        var alphaRect = createNS('rect');
	        alphaRect.setAttribute('width', this.comp.data.w);
	        alphaRect.setAttribute('height', this.comp.data.h);
	        alphaRect.setAttribute('x', '0');
	        alphaRect.setAttribute('y', '0');
	        alphaRect.setAttribute('fill', '#ffffff');
	        alphaRect.setAttribute('opacity', '0');
	        maskGrouper.setAttribute('filter', 'url(' + locationHref + '#' + filId + ')');
	        maskGrouper.appendChild(alphaRect);
	        maskGrouper.appendChild(this.layerElement);
	        layerElementParent = maskGrouper;
	        if (!featureSupport.maskType) {
	          maskGroup.setAttribute('mask-type', 'luminance');
	          fil.appendChild(filtersFactory.createAlphaToLuminanceFilter());
	          gg = createNS('g');
	          maskGrouper.appendChild(alphaRect);
	          gg.appendChild(this.layerElement);
	          layerElementParent = gg;
	          maskGrouper.appendChild(gg);
	        }
	        this.globalData.defs.appendChild(maskGroup);
	      }
	    } else if (this.data.tt) {
	      this.matteElement.appendChild(this.layerElement);
	      layerElementParent = this.matteElement;
	      this.baseElement = this.matteElement;
	    } else {
	      this.baseElement = this.layerElement;
	    }
	    if (this.data.ln) {
	      this.layerElement.setAttribute('id', this.data.ln);
	    }
	    if (this.data.cl) {
	      this.layerElement.setAttribute('class', this.data.cl);
	    }
	    // Clipping compositions to hide content that exceeds boundaries. If collapsed transformations is on, component should not be clipped
	    if (this.data.ty === 0 && !this.data.hd) {
	      var cp = createNS('clipPath');
	      var pt = createNS('path');
	      pt.setAttribute('d', 'M0,0 L' + this.data.w + ',0 L' + this.data.w + ',' + this.data.h + ' L0,' + this.data.h + 'z');
	      var clipId = createElementID();
	      cp.setAttribute('id', clipId);
	      cp.appendChild(pt);
	      this.globalData.defs.appendChild(cp);

	      if (this.checkMasks()) {
	        var cpGroup = createNS('g');
	        cpGroup.setAttribute('clip-path', 'url(' + locationHref + '#' + clipId + ')');
	        cpGroup.appendChild(this.layerElement);
	        this.transformedElement = cpGroup;
	        if (layerElementParent) {
	          layerElementParent.appendChild(this.transformedElement);
	        } else {
	          this.baseElement = this.transformedElement;
	        }
	      } else {
	        this.layerElement.setAttribute('clip-path', 'url(' + locationHref + '#' + clipId + ')');
	      }
	    }
	    if (this.data.bm !== 0) {
	      this.setBlendMode();
	    }
	  },
	  renderElement: function () {
	    if (this.finalTransform._matMdf) {
	      this.transformedElement.setAttribute('transform', this.finalTransform.mat.to2dCSS());
	    }
	    if (this.finalTransform._opMdf) {
	      this.transformedElement.setAttribute('opacity', this.finalTransform.mProp.o.v);
	    }
	  },
	  destroyBaseElement: function () {
	    this.layerElement = null;
	    this.matteElement = null;
	    this.maskManager.destroy();
	  },
	  getBaseElement: function () {
	    if (this.data.hd) {
	      return null;
	    }
	    return this.baseElement;
	  },
	  createRenderableComponents: function () {
	    this.maskManager = new MaskElement(this.data, this, this.globalData);
	    this.renderableEffectsManager = new SVGEffects(this);
	  },
	  setMatte: function (id) {
	    if (!this.matteElement) {
	      return;
	    }
	    this.matteElement.setAttribute('mask', 'url(' + locationHref + '#' + id + ')');
	  },
	};

	/* global ProcessedElement */

	function IShapeElement() {
	}

	IShapeElement.prototype = {
	  addShapeToModifiers: function (data) {
	    var i;
	    var len = this.shapeModifiers.length;
	    for (i = 0; i < len; i += 1) {
	      this.shapeModifiers[i].addShape(data);
	    }
	  },
	  isShapeInAnimatedModifiers: function (data) {
	    var i = 0;
	    var len = this.shapeModifiers.length;
	    while (i < len) {
	      if (this.shapeModifiers[i].isAnimatedWithShape(data)) {
	        return true;
	      }
	    }
	    return false;
	  },
	  renderModifiers: function () {
	    if (!this.shapeModifiers.length) {
	      return;
	    }
	    var i;
	    var len = this.shapes.length;
	    for (i = 0; i < len; i += 1) {
	      this.shapes[i].sh.reset();
	    }

	    len = this.shapeModifiers.length;
	    var shouldBreakProcess;
	    for (i = len - 1; i >= 0; i -= 1) {
	      shouldBreakProcess = this.shapeModifiers[i].processShapes(this._isFirstFrame);
	      // workaround to fix cases where a repeater resets the shape so the following processes get called twice
	      // TODO: find a better solution for this
	      if (shouldBreakProcess) {
	        break;
	      }
	    }
	  },

	  searchProcessedElement: function (elem) {
	    var elements = this.processedElements;
	    var i = 0;
	    var len = elements.length;
	    while (i < len) {
	      if (elements[i].elem === elem) {
	        return elements[i].pos;
	      }
	      i += 1;
	    }
	    return 0;
	  },
	  addProcessedElement: function (elem, pos) {
	    var elements = this.processedElements;
	    var i = elements.length;
	    while (i) {
	      i -= 1;
	      if (elements[i].elem === elem) {
	        elements[i].pos = pos;
	        return;
	      }
	    }
	    elements.push(new ProcessedElement(elem, pos));
	  },
	  prepareFrame: function (num) {
	    this.prepareRenderableFrame(num);
	    this.prepareProperties(num, this.isInRange);
	  },
	};

	/* global TextProperty, TextAnimatorProperty, buildShapeString, LetterProps */

	function ITextElement() {
	}

	ITextElement.prototype.initElement = function (data, globalData, comp) {
	  this.lettersChangedFlag = true;
	  this.initFrame();
	  this.initBaseData(data, globalData, comp);
	  this.textProperty = new TextProperty(this, data.t, this.dynamicProperties);
	  this.textAnimator = new TextAnimatorProperty(data.t, this.renderType, this);
	  this.initTransform(data, globalData, comp);
	  this.initHierarchy();
	  this.initRenderable();
	  this.initRendererElement();
	  this.createContainerElements();
	  this.createRenderableComponents();
	  this.createContent();
	  this.hide();
	  this.textAnimator.searchProperties(this.dynamicProperties);
	};

	ITextElement.prototype.prepareFrame = function (num) {
	  this._mdf = false;
	  this.prepareRenderableFrame(num);
	  this.prepareProperties(num, this.isInRange);
	  if (this.textProperty._mdf || this.textProperty._isFirstFrame) {
	    this.buildNewText();
	    this.textProperty._isFirstFrame = false;
	    this.textProperty._mdf = false;
	  }
	};

	ITextElement.prototype.createPathShape = function (matrixHelper, shapes) {
	  var j;
	  var jLen = shapes.length;
	  var pathNodes;
	  var shapeStr = '';
	  for (j = 0; j < jLen; j += 1) {
	    pathNodes = shapes[j].ks.k;
	    shapeStr += buildShapeString(pathNodes, pathNodes.i.length, true, matrixHelper);
	  }
	  return shapeStr;
	};

	ITextElement.prototype.updateDocumentData = function (newData, index) {
	  this.textProperty.updateDocumentData(newData, index);
	};

	ITextElement.prototype.canResizeFont = function (_canResize) {
	  this.textProperty.canResizeFont(_canResize);
	};

	ITextElement.prototype.setMinimumFontSize = function (_fontSize) {
	  this.textProperty.setMinimumFontSize(_fontSize);
	};

	ITextElement.prototype.applyTextPropertiesToMatrix = function (documentData, matrixHelper, lineNumber, xPos, yPos) {
	  if (documentData.ps) {
	    matrixHelper.translate(documentData.ps[0], documentData.ps[1] + documentData.ascent, 0);
	  }
	  matrixHelper.translate(0, -documentData.ls, 0);
	  switch (documentData.j) {
	    case 1:
	      matrixHelper.translate(documentData.justifyOffset + (documentData.boxWidth - documentData.lineWidths[lineNumber]), 0, 0);
	      break;
	    case 2:
	      matrixHelper.translate(documentData.justifyOffset + (documentData.boxWidth - documentData.lineWidths[lineNumber]) / 2, 0, 0);
	      break;
	    default:
	      break;
	  }
	  matrixHelper.translate(xPos, yPos, 0);
	};

	ITextElement.prototype.buildColor = function (colorData) {
	  return 'rgb(' + Math.round(colorData[0] * 255) + ',' + Math.round(colorData[1] * 255) + ',' + Math.round(colorData[2] * 255) + ')';
	};

	ITextElement.prototype.emptyProp = new LetterProps();

	ITextElement.prototype.destroy = function () {

	};

	/* global extendPrototype, BaseElement, TransformElement, HierarchyElement, FrameElement, RenderableDOMElement */

	function ICompElement() {}

	extendPrototype([BaseElement, TransformElement, HierarchyElement, FrameElement, RenderableDOMElement], ICompElement);

	ICompElement.prototype.initElement = function (data, globalData, comp) {
	  this.initFrame();
	  this.initBaseData(data, globalData, comp);
	  this.initTransform(data, globalData, comp);
	  this.initRenderable();
	  this.initHierarchy();
	  this.initRendererElement();
	  this.createContainerElements();
	  this.createRenderableComponents();
	  if (this.data.xt || !globalData.progressiveLoad) {
	    this.buildAllItems();
	  }
	  this.hide();
	};

	/* ICompElement.prototype.hide = function(){
	    if(!this.hidden){
	        this.hideElement();
	        var i,len = this.elements.length;
	        for( i = 0; i < len; i+=1 ){
	            if(this.elements[i]){
	                this.elements[i].hide();
	            }
	        }
	    }
	}; */

	ICompElement.prototype.prepareFrame = function (num) {
	  this._mdf = false;
	  this.prepareRenderableFrame(num);
	  this.prepareProperties(num, this.isInRange);
	  if (!this.isInRange && !this.data.xt) {
	    return;
	  }

	  if (!this.tm._placeholder) {
	    var timeRemapped = this.tm.v;
	    if (timeRemapped === this.data.op) {
	      timeRemapped = this.data.op - 1;
	    }
	    this.renderedFrame = timeRemapped;
	  } else {
	    this.renderedFrame = num / this.data.sr;
	  }
	  var i;
	  var len = this.elements.length;
	  if (!this.completeLayers) {
	    this.checkLayers(this.renderedFrame);
	  }
	  // This iteration needs to be backwards because of how expressions connect between each other
	  for (i = len - 1; i >= 0; i -= 1) {
	    if (this.completeLayers || this.elements[i]) {
	      this.elements[i].prepareFrame(this.renderedFrame - this.layers[i].st);
	      if (this.elements[i]._mdf) {
	        this._mdf = true;
	      }
	    }
	  }
	};

	ICompElement.prototype.renderInnerContent = function () {
	  var i;
	  var len = this.layers.length;
	  for (i = 0; i < len; i += 1) {
	    if (this.completeLayers || this.elements[i]) {
	      this.elements[i].renderFrame();
	    }
	  }
	};

	ICompElement.prototype.setElements = function (elems) {
	  this.elements = elems;
	};

	ICompElement.prototype.getElements = function () {
	  return this.elements;
	};

	ICompElement.prototype.destroyElements = function () {
	  var i;
	  var len = this.layers.length;
	  for (i = 0; i < len; i += 1) {
	    if (this.elements[i]) {
	      this.elements[i].destroy();
	    }
	  }
	};

	ICompElement.prototype.destroy = function () {
	  this.destroyElements();
	  this.destroyBaseElement();
	};

	/* global extendPrototype, BaseElement, TransformElement, SVGBaseElement, HierarchyElement, FrameElement, RenderableDOMElement, createNS */

	function IImageElement(data, globalData, comp) {
	  this.assetData = globalData.getAssetData(data.refId);
	  this.initElement(data, globalData, comp);
	  this.sourceRect = {
	    top: 0, left: 0, width: this.assetData.w, height: this.assetData.h,
	  };
	}

	extendPrototype([BaseElement, TransformElement, SVGBaseElement, HierarchyElement, FrameElement, RenderableDOMElement], IImageElement);

	IImageElement.prototype.createContent = function () {
	  var assetPath = this.globalData.getAssetsPath(this.assetData);

	  this.innerElem = createNS('image');
	  this.innerElem.setAttribute('width', this.assetData.w + 'px');
	  this.innerElem.setAttribute('height', this.assetData.h + 'px');
	  this.innerElem.setAttribute('preserveAspectRatio', this.assetData.pr || this.globalData.renderConfig.imagePreserveAspectRatio);
	  this.innerElem.setAttributeNS('http://www.w3.org/1999/xlink', 'href', assetPath);

	  this.layerElement.appendChild(this.innerElem);
	};

	IImageElement.prototype.sourceRectAtTime = function () {
	  return this.sourceRect;
	};

	/* global extendPrototype, IImageElement, createNS */

	function ISolidElement(data, globalData, comp) {
	  this.initElement(data, globalData, comp);
	}
	extendPrototype([IImageElement], ISolidElement);

	ISolidElement.prototype.createContent = function () {
	  var rect = createNS('rect');
	  /// /rect.style.width = this.data.sw;
	  /// /rect.style.height = this.data.sh;
	  /// /rect.style.fill = this.data.sc;
	  rect.setAttribute('width', this.data.sw);
	  rect.setAttribute('height', this.data.sh);
	  rect.setAttribute('fill', this.data.sc);
	  this.layerElement.appendChild(rect);
	};

	/* global PropertyFactory, extendPrototype, RenderableElement, BaseElement, FrameElement */

	function AudioElement(data, globalData, comp) {
	  this.initFrame();
	  this.initRenderable();
	  this.assetData = globalData.getAssetData(data.refId);
	  this.initBaseData(data, globalData, comp);
	  this._isPlaying = false;
	  this._canPlay = false;
	  var assetPath = this.globalData.getAssetsPath(this.assetData);
	  this.audio = this.globalData.audioController.createAudio(assetPath);
	  this._currentTime = 0;
	  this.globalData.audioController.addAudio(this);
	  this.tm = data.tm ? PropertyFactory.getProp(this, data.tm, 0, globalData.frameRate, this) : { _placeholder: true };
	}

	AudioElement.prototype.prepareFrame = function (num) {
	  this.prepareRenderableFrame(num, true);
	  this.prepareProperties(num, true);
	  if (!this.tm._placeholder) {
	    var timeRemapped = this.tm.v;
	    this._currentTime = timeRemapped;
	  } else {
	    this._currentTime = num / this.data.sr;
	  }
	};

	extendPrototype([RenderableElement, BaseElement, FrameElement], AudioElement);

	AudioElement.prototype.renderFrame = function () {
	  if (this.isInRange && this._canPlay) {
	    if (!this._isPlaying) {
	      this.audio.play();
	      this.audio.seek(this._currentTime / this.globalData.frameRate);
	      this._isPlaying = true;
	    } else if (!this.audio.playing()
	      || Math.abs(this._currentTime / this.globalData.frameRate - this.audio.seek()) > 0.1
	    ) {
	      this.audio.seek(this._currentTime / this.globalData.frameRate);
	    }
	  }
	};

	AudioElement.prototype.show = function () {
	  // this.audio.play()
	};

	AudioElement.prototype.hide = function () {
	  this.audio.pause();
	  this._isPlaying = false;
	};

	AudioElement.prototype.pause = function () {
	  this.audio.pause();
	  this._isPlaying = false;
	  this._canPlay = false;
	};

	AudioElement.prototype.resume = function () {
	  this._canPlay = true;
	};

	AudioElement.prototype.setRate = function (rateValue) {
	  this.audio.rate(rateValue);
	};

	AudioElement.prototype.volume = function (volumeValue) {
	  this.audio.volume(volumeValue);
	};

	AudioElement.prototype.getBaseElement = function () {
	  return null;
	};

	AudioElement.prototype.destroy = function () {
	};

	AudioElement.prototype.sourceRectAtTime = function () {
	};

	AudioElement.prototype.initExpressions = function () {
	};

	/* global extendPrototype, RenderableElement, BaseElement, FrameElement, FootageInterface */

	function FootageElement(data, globalData, comp) {
	  this.initFrame();
	  this.initRenderable();
	  this.assetData = globalData.getAssetData(data.refId);
	  this.footageData = globalData.imageLoader.getAsset(this.assetData);
	  this.initBaseData(data, globalData, comp);
	}

	FootageElement.prototype.prepareFrame = function () {
	};

	extendPrototype([RenderableElement, BaseElement, FrameElement], FootageElement);

	FootageElement.prototype.getBaseElement = function () {
	  return null;
	};

	FootageElement.prototype.renderFrame = function () {
	};

	FootageElement.prototype.destroy = function () {
	};

	FootageElement.prototype.initExpressions = function () {
	  this.layerInterface = FootageInterface(this);
	};

	FootageElement.prototype.getFootageData = function () {
	  return this.footageData;
	};

	/* global createSizedArray, PropertyFactory, extendPrototype, SVGRenderer, ICompElement, SVGBaseElement */

	function SVGCompElement(data, globalData, comp) {
	  this.layers = data.layers;
	  this.supports3d = true;
	  this.completeLayers = false;
	  this.pendingElements = [];
	  this.elements = this.layers ? createSizedArray(this.layers.length) : [];
	  // this.layerElement = createNS('g');
	  this.initElement(data, globalData, comp);
	  this.tm = data.tm ? PropertyFactory.getProp(this, data.tm, 0, globalData.frameRate, this) : { _placeholder: true };
	}

	extendPrototype([SVGRenderer, ICompElement, SVGBaseElement], SVGCompElement);

	/* global extendPrototype, BaseElement, TransformElement, SVGBaseElement, HierarchyElement, FrameElement,
	RenderableDOMElement, ITextElement, createSizedArray, createNS */

	function SVGTextLottieElement(data, globalData, comp) {
	  this.textSpans = [];
	  this.renderType = 'svg';
	  this.initElement(data, globalData, comp);
	}

	extendPrototype([BaseElement, TransformElement, SVGBaseElement, HierarchyElement, FrameElement, RenderableDOMElement, ITextElement], SVGTextLottieElement);

	SVGTextLottieElement.prototype.createContent = function () {
	  if (this.data.singleShape && !this.globalData.fontManager.chars) {
	    this.textContainer = createNS('text');
	  }
	};

	SVGTextLottieElement.prototype.buildTextContents = function (textArray) {
	  var i = 0;
	  var len = textArray.length;
	  var textContents = [];
	  var currentTextContent = '';
	  while (i < len) {
	    if (textArray[i] === String.fromCharCode(13) || textArray[i] === String.fromCharCode(3)) {
	      textContents.push(currentTextContent);
	      currentTextContent = '';
	    } else {
	      currentTextContent += textArray[i];
	    }
	    i += 1;
	  }
	  textContents.push(currentTextContent);
	  return textContents;
	};

	SVGTextLottieElement.prototype.buildNewText = function () {
	  var i;
	  var len;

	  var documentData = this.textProperty.currentData;
	  this.renderedLetters = createSizedArray(documentData ? documentData.l.length : 0);
	  if (documentData.fc) {
	    this.layerElement.setAttribute('fill', this.buildColor(documentData.fc));
	  } else {
	    this.layerElement.setAttribute('fill', 'rgba(0,0,0,0)');
	  }
	  if (documentData.sc) {
	    this.layerElement.setAttribute('stroke', this.buildColor(documentData.sc));
	    this.layerElement.setAttribute('stroke-width', documentData.sw);
	  }
	  this.layerElement.setAttribute('font-size', documentData.finalSize);
	  var fontData = this.globalData.fontManager.getFontByName(documentData.f);
	  if (fontData.fClass) {
	    this.layerElement.setAttribute('class', fontData.fClass);
	  } else {
	    this.layerElement.setAttribute('font-family', fontData.fFamily);
	    var fWeight = documentData.fWeight;
	    var fStyle = documentData.fStyle;
	    this.layerElement.setAttribute('font-style', fStyle);
	    this.layerElement.setAttribute('font-weight', fWeight);
	  }
	  this.layerElement.setAttribute('aria-label', documentData.t);

	  var letters = documentData.l || [];
	  var usesGlyphs = !!this.globalData.fontManager.chars;
	  len = letters.length;

	  var tSpan;
	  var matrixHelper = this.mHelper;
	  var shapes;
	  var shapeStr = '';
	  var singleShape = this.data.singleShape;
	  var xPos = 0;
	  var yPos = 0;
	  var firstLine = true;
	  var trackingOffset = documentData.tr * 0.001 * documentData.finalSize;
	  if (singleShape && !usesGlyphs && !documentData.sz) {
	    var tElement = this.textContainer;
	    var justify = 'start';
	    switch (documentData.j) {
	      case 1:
	        justify = 'end';
	        break;
	      case 2:
	        justify = 'middle';
	        break;
	      default:
	        justify = 'start';
	        break;
	    }
	    tElement.setAttribute('text-anchor', justify);
	    tElement.setAttribute('letter-spacing', trackingOffset);
	    var textContent = this.buildTextContents(documentData.finalText);
	    len = textContent.length;
	    yPos = documentData.ps ? documentData.ps[1] + documentData.ascent : 0;
	    for (i = 0; i < len; i += 1) {
	      tSpan = this.textSpans[i] || createNS('tspan');
	      tSpan.textContent = textContent[i];
	      tSpan.setAttribute('x', 0);
	      tSpan.setAttribute('y', yPos);
	      tSpan.style.display = 'inherit';
	      tElement.appendChild(tSpan);
	      this.textSpans[i] = tSpan;
	      yPos += documentData.finalLineHeight;
	    }

	    this.layerElement.appendChild(tElement);
	  } else {
	    var cachedSpansLength = this.textSpans.length;
	    var shapeData;
	    var charData;
	    for (i = 0; i < len; i += 1) {
	      if (!usesGlyphs || !singleShape || i === 0) {
	        tSpan = cachedSpansLength > i ? this.textSpans[i] : createNS(usesGlyphs ? 'path' : 'text');
	        if (cachedSpansLength <= i) {
	          tSpan.setAttribute('stroke-linecap', 'butt');
	          tSpan.setAttribute('stroke-linejoin', 'round');
	          tSpan.setAttribute('stroke-miterlimit', '4');
	          this.textSpans[i] = tSpan;
	          this.layerElement.appendChild(tSpan);
	        }
	        tSpan.style.display = 'inherit';
	      }

	      matrixHelper.reset();
	      matrixHelper.scale(documentData.finalSize / 100, documentData.finalSize / 100);
	      if (singleShape) {
	        if (letters[i].n) {
	          xPos = -trackingOffset;
	          yPos += documentData.yOffset;
	          yPos += firstLine ? 1 : 0;
	          firstLine = false;
	        }
	        this.applyTextPropertiesToMatrix(documentData, matrixHelper, letters[i].line, xPos, yPos);
	        xPos += letters[i].l || 0;
	        // xPos += letters[i].val === ' ' ? 0 : trackingOffset;
	        xPos += trackingOffset;
	      }
	      if (usesGlyphs) {
	        charData = this.globalData.fontManager.getCharData(documentData.finalText[i], fontData.fStyle, this.globalData.fontManager.getFontByName(documentData.f).fFamily);
	        shapeData = (charData && charData.data) || {};
	        shapes = shapeData.shapes ? shapeData.shapes[0].it : [];
	        if (!singleShape) {
	          tSpan.setAttribute('d', this.createPathShape(matrixHelper, shapes));
	        } else {
	          shapeStr += this.createPathShape(matrixHelper, shapes);
	        }
	      } else {
	        if (singleShape) {
	          tSpan.setAttribute('transform', 'translate(' + matrixHelper.props[12] + ',' + matrixHelper.props[13] + ')');
	        }
	        tSpan.textContent = letters[i].val;
	        tSpan.setAttributeNS('http://www.w3.org/XML/1998/namespace', 'xml:space', 'preserve');
	      }
	      //
	    }
	    if (singleShape && tSpan) {
	      tSpan.setAttribute('d', shapeStr);
	    }
	  }
	  while (i < this.textSpans.length) {
	    this.textSpans[i].style.display = 'none';
	    i += 1;
	  }

	  this._sizeChanged = true;
	};

	SVGTextLottieElement.prototype.sourceRectAtTime = function () {
	  this.prepareFrame(this.comp.renderedFrame - this.data.st);
	  this.renderInnerContent();
	  if (this._sizeChanged) {
	    this._sizeChanged = false;
	    var textBox = this.layerElement.getBBox();
	    this.bbox = {
	      top: textBox.y,
	      left: textBox.x,
	      width: textBox.width,
	      height: textBox.height,
	    };
	  }
	  return this.bbox;
	};

	SVGTextLottieElement.prototype.renderInnerContent = function () {
	  if (!this.data.singleShape) {
	    this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag);
	    if (this.lettersChangedFlag || this.textAnimator.lettersChangedFlag) {
	      this._sizeChanged = true;
	      var i;
	      var len;
	      var renderedLetters = this.textAnimator.renderedLetters;

	      var letters = this.textProperty.currentData.l;

	      len = letters.length;
	      var renderedLetter;
	      var textSpan;
	      for (i = 0; i < len; i += 1) {
	        if (!letters[i].n) {
	          renderedLetter = renderedLetters[i];
	          textSpan = this.textSpans[i];
	          if (renderedLetter._mdf.m) {
	            textSpan.setAttribute('transform', renderedLetter.m);
	          }
	          if (renderedLetter._mdf.o) {
	            textSpan.setAttribute('opacity', renderedLetter.o);
	          }
	          if (renderedLetter._mdf.sw) {
	            textSpan.setAttribute('stroke-width', renderedLetter.sw);
	          }
	          if (renderedLetter._mdf.sc) {
	            textSpan.setAttribute('stroke', renderedLetter.sc);
	          }
	          if (renderedLetter._mdf.fc) {
	            textSpan.setAttribute('fill', renderedLetter.fc);
	          }
	        }
	      }
	    }
	  }
	};

	/* global extendPrototype, BaseElement, TransformElement, SVGBaseElement, IShapeElement, HierarchyElement,
	FrameElement, RenderableDOMElement, Matrix, SVGStyleData, SVGStrokeStyleData, SVGFillStyleData,
	SVGGradientFillStyleData, SVGGradientStrokeStyleData, locationHref, getBlendMode, ShapeGroupData,
	TransformPropertyFactory, SVGTransformData, ShapePropertyFactory, SVGShapeData, SVGElementsRenderer, ShapeModifiers,
	lineCapEnum, lineJoinEnum */

	function SVGShapeElement(data, globalData, comp) {
	  // List of drawable elements
	  this.shapes = [];
	  // Full shape data
	  this.shapesData = data.shapes;
	  // List of styles that will be applied to shapes
	  this.stylesList = [];
	  // List of modifiers that will be applied to shapes
	  this.shapeModifiers = [];
	  // List of items in shape tree
	  this.itemsData = [];
	  // List of items in previous shape tree
	  this.processedElements = [];
	  // List of animated components
	  this.animatedContents = [];
	  this.initElement(data, globalData, comp);
	  // Moving any property that doesn't get too much access after initialization because of v8 way of handling more than 10 properties.
	  // List of elements that have been created
	  this.prevViewData = [];
	  // Moving any property that doesn't get too much access after initialization because of v8 way of handling more than 10 properties.
	}

	extendPrototype([BaseElement, TransformElement, SVGBaseElement, IShapeElement, HierarchyElement, FrameElement, RenderableDOMElement], SVGShapeElement);

	SVGShapeElement.prototype.initSecondaryElement = function () {
	};

	SVGShapeElement.prototype.identityMatrix = new Matrix();

	SVGShapeElement.prototype.buildExpressionInterface = function () {};

	SVGShapeElement.prototype.createContent = function () {
	  this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, this.layerElement, 0, [], true);
	  this.filterUniqueShapes();
	};

	/*
	This method searches for multiple shapes that affect a single element and one of them is animated
	*/
	SVGShapeElement.prototype.filterUniqueShapes = function () {
	  var i;
	  var len = this.shapes.length;
	  var shape;
	  var j;
	  var jLen = this.stylesList.length;
	  var style;
	  var tempShapes = [];
	  var areAnimated = false;
	  for (j = 0; j < jLen; j += 1) {
	    style = this.stylesList[j];
	    areAnimated = false;
	    tempShapes.length = 0;
	    for (i = 0; i < len; i += 1) {
	      shape = this.shapes[i];
	      if (shape.styles.indexOf(style) !== -1) {
	        tempShapes.push(shape);
	        areAnimated = shape._isAnimated || areAnimated;
	      }
	    }
	    if (tempShapes.length > 1 && areAnimated) {
	      this.setShapesAsAnimated(tempShapes);
	    }
	  }
	};

	SVGShapeElement.prototype.setShapesAsAnimated = function (shapes) {
	  var i;
	  var len = shapes.length;
	  for (i = 0; i < len; i += 1) {
	    shapes[i].setAsAnimated();
	  }
	};

	SVGShapeElement.prototype.createStyleElement = function (data, level) {
	  // TODO: prevent drawing of hidden styles
	  var elementData;
	  var styleOb = new SVGStyleData(data, level);

	  var pathElement = styleOb.pElem;
	  if (data.ty === 'st') {
	    elementData = new SVGStrokeStyleData(this, data, styleOb);
	  } else if (data.ty === 'fl') {
	    elementData = new SVGFillStyleData(this, data, styleOb);
	  } else if (data.ty === 'gf' || data.ty === 'gs') {
	    var GradientConstructor = data.ty === 'gf' ? SVGGradientFillStyleData : SVGGradientStrokeStyleData;
	    elementData = new GradientConstructor(this, data, styleOb);
	    this.globalData.defs.appendChild(elementData.gf);
	    if (elementData.maskId) {
	      this.globalData.defs.appendChild(elementData.ms);
	      this.globalData.defs.appendChild(elementData.of);
	      pathElement.setAttribute('mask', 'url(' + locationHref + '#' + elementData.maskId + ')');
	    }
	  }

	  if (data.ty === 'st' || data.ty === 'gs') {
	    pathElement.setAttribute('stroke-linecap', lineCapEnum[data.lc || 2]);
	    pathElement.setAttribute('stroke-linejoin', lineJoinEnum[data.lj || 2]);
	    pathElement.setAttribute('fill-opacity', '0');
	    if (data.lj === 1) {
	      pathElement.setAttribute('stroke-miterlimit', data.ml);
	    }
	  }

	  if (data.r === 2) {
	    pathElement.setAttribute('fill-rule', 'evenodd');
	  }

	  if (data.ln) {
	    pathElement.setAttribute('id', data.ln);
	  }
	  if (data.cl) {
	    pathElement.setAttribute('class', data.cl);
	  }
	  if (data.bm) {
	    pathElement.style['mix-blend-mode'] = getBlendMode(data.bm);
	  }
	  this.stylesList.push(styleOb);
	  this.addToAnimatedContents(data, elementData);
	  return elementData;
	};

	SVGShapeElement.prototype.createGroupElement = function (data) {
	  var elementData = new ShapeGroupData();
	  if (data.ln) {
	    elementData.gr.setAttribute('id', data.ln);
	  }
	  if (data.cl) {
	    elementData.gr.setAttribute('class', data.cl);
	  }
	  if (data.bm) {
	    elementData.gr.style['mix-blend-mode'] = getBlendMode(data.bm);
	  }
	  return elementData;
	};

	SVGShapeElement.prototype.createTransformElement = function (data, container) {
	  var transformProperty = TransformPropertyFactory.getTransformProperty(this, data, this);
	  var elementData = new SVGTransformData(transformProperty, transformProperty.o, container);
	  this.addToAnimatedContents(data, elementData);
	  return elementData;
	};

	SVGShapeElement.prototype.createShapeElement = function (data, ownTransformers, level) {
	  var ty = 4;
	  if (data.ty === 'rc') {
	    ty = 5;
	  } else if (data.ty === 'el') {
	    ty = 6;
	  } else if (data.ty === 'sr') {
	    ty = 7;
	  }
	  var shapeProperty = ShapePropertyFactory.getShapeProp(this, data, ty, this);
	  var elementData = new SVGShapeData(ownTransformers, level, shapeProperty);
	  this.shapes.push(elementData);
	  this.addShapeToModifiers(elementData);
	  this.addToAnimatedContents(data, elementData);
	  return elementData;
	};

	SVGShapeElement.prototype.addToAnimatedContents = function (data, element) {
	  var i = 0;
	  var len = this.animatedContents.length;
	  while (i < len) {
	    if (this.animatedContents[i].element === element) {
	      return;
	    }
	    i += 1;
	  }
	  this.animatedContents.push({
	    fn: SVGElementsRenderer.createRenderFunction(data),
	    element: element,
	    data: data,
	  });
	};

	SVGShapeElement.prototype.setElementStyles = function (elementData) {
	  var arr = elementData.styles;
	  var j;
	  var jLen = this.stylesList.length;
	  for (j = 0; j < jLen; j += 1) {
	    if (!this.stylesList[j].closed) {
	      arr.push(this.stylesList[j]);
	    }
	  }
	};

	SVGShapeElement.prototype.reloadShapes = function () {
	  this._isFirstFrame = true;
	  var i;
	  var len = this.itemsData.length;
	  for (i = 0; i < len; i += 1) {
	    this.prevViewData[i] = this.itemsData[i];
	  }
	  this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, this.layerElement, 0, [], true);
	  this.filterUniqueShapes();
	  len = this.dynamicProperties.length;
	  for (i = 0; i < len; i += 1) {
	    this.dynamicProperties[i].getValue();
	  }
	  this.renderModifiers();
	};

	SVGShapeElement.prototype.searchShapes = function (arr, itemsData, prevViewData, container, level, transformers, render) {
	  var ownTransformers = [].concat(transformers);
	  var i;
	  var len = arr.length - 1;
	  var j;
	  var jLen;
	  var ownStyles = [];
	  var ownModifiers = [];
	  var currentTransform;
	  var modifier;
	  var processedPos;
	  for (i = len; i >= 0; i -= 1) {
	    processedPos = this.searchProcessedElement(arr[i]);
	    if (!processedPos) {
	      arr[i]._render = render;
	    } else {
	      itemsData[i] = prevViewData[processedPos - 1];
	    }
	    if (arr[i].ty === 'fl' || arr[i].ty === 'st' || arr[i].ty === 'gf' || arr[i].ty === 'gs') {
	      if (!processedPos) {
	        itemsData[i] = this.createStyleElement(arr[i], level);
	      } else {
	        itemsData[i].style.closed = false;
	      }
	      if (arr[i]._render) {
	        container.appendChild(itemsData[i].style.pElem);
	      }
	      ownStyles.push(itemsData[i].style);
	    } else if (arr[i].ty === 'gr') {
	      if (!processedPos) {
	        itemsData[i] = this.createGroupElement(arr[i]);
	      } else {
	        jLen = itemsData[i].it.length;
	        for (j = 0; j < jLen; j += 1) {
	          itemsData[i].prevViewData[j] = itemsData[i].it[j];
	        }
	      }
	      this.searchShapes(arr[i].it, itemsData[i].it, itemsData[i].prevViewData, itemsData[i].gr, level + 1, ownTransformers, render);
	      if (arr[i]._render) {
	        container.appendChild(itemsData[i].gr);
	      }
	    } else if (arr[i].ty === 'tr') {
	      if (!processedPos) {
	        itemsData[i] = this.createTransformElement(arr[i], container);
	      }
	      currentTransform = itemsData[i].transform;
	      ownTransformers.push(currentTransform);
	    } else if (arr[i].ty === 'sh' || arr[i].ty === 'rc' || arr[i].ty === 'el' || arr[i].ty === 'sr') {
	      if (!processedPos) {
	        itemsData[i] = this.createShapeElement(arr[i], ownTransformers, level);
	      }
	      this.setElementStyles(itemsData[i]);
	    } else if (arr[i].ty === 'tm' || arr[i].ty === 'rd' || arr[i].ty === 'ms' || arr[i].ty === 'pb') {
	      if (!processedPos) {
	        modifier = ShapeModifiers.getModifier(arr[i].ty);
	        modifier.init(this, arr[i]);
	        itemsData[i] = modifier;
	        this.shapeModifiers.push(modifier);
	      } else {
	        modifier = itemsData[i];
	        modifier.closed = false;
	      }
	      ownModifiers.push(modifier);
	    } else if (arr[i].ty === 'rp') {
	      if (!processedPos) {
	        modifier = ShapeModifiers.getModifier(arr[i].ty);
	        itemsData[i] = modifier;
	        modifier.init(this, arr, i, itemsData);
	        this.shapeModifiers.push(modifier);
	        render = false;
	      } else {
	        modifier = itemsData[i];
	        modifier.closed = true;
	      }
	      ownModifiers.push(modifier);
	    }
	    this.addProcessedElement(arr[i], i + 1);
	  }
	  len = ownStyles.length;
	  for (i = 0; i < len; i += 1) {
	    ownStyles[i].closed = true;
	  }
	  len = ownModifiers.length;
	  for (i = 0; i < len; i += 1) {
	    ownModifiers[i].closed = true;
	  }
	};

	SVGShapeElement.prototype.renderInnerContent = function () {
	  this.renderModifiers();
	  var i;
	  var len = this.stylesList.length;
	  for (i = 0; i < len; i += 1) {
	    this.stylesList[i].reset();
	  }
	  this.renderShape();

	  for (i = 0; i < len; i += 1) {
	    if (this.stylesList[i]._mdf || this._isFirstFrame) {
	      if (this.stylesList[i].msElem) {
	        this.stylesList[i].msElem.setAttribute('d', this.stylesList[i].d);
	        // Adding M0 0 fixes same mask bug on all browsers
	        this.stylesList[i].d = 'M0 0' + this.stylesList[i].d;
	      }
	      this.stylesList[i].pElem.setAttribute('d', this.stylesList[i].d || 'M0 0');
	    }
	  }
	};

	SVGShapeElement.prototype.renderShape = function () {
	  var i;
	  var len = this.animatedContents.length;
	  var animatedContent;
	  for (i = 0; i < len; i += 1) {
	    animatedContent = this.animatedContents[i];
	    if ((this._isFirstFrame || animatedContent.element._isAnimated) && animatedContent.data !== true) {
	      animatedContent.fn(animatedContent.data, animatedContent.element, this._isFirstFrame);
	    }
	  }
	};

	SVGShapeElement.prototype.destroy = function () {
	  this.destroyBaseElement();
	  this.shapesData = null;
	  this.itemsData = null;
	};

	/* global createNS */

	function SVGTintFilter(filter, filterManager) {
	  this.filterManager = filterManager;
	  var feColorMatrix = createNS('feColorMatrix');
	  feColorMatrix.setAttribute('type', 'matrix');
	  feColorMatrix.setAttribute('color-interpolation-filters', 'linearRGB');
	  feColorMatrix.setAttribute('values', '0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0 1 0');
	  feColorMatrix.setAttribute('result', 'f1');
	  filter.appendChild(feColorMatrix);
	  feColorMatrix = createNS('feColorMatrix');
	  feColorMatrix.setAttribute('type', 'matrix');
	  feColorMatrix.setAttribute('color-interpolation-filters', 'sRGB');
	  feColorMatrix.setAttribute('values', '1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0');
	  feColorMatrix.setAttribute('result', 'f2');
	  filter.appendChild(feColorMatrix);
	  this.matrixFilter = feColorMatrix;
	  if (filterManager.effectElements[2].p.v !== 100 || filterManager.effectElements[2].p.k) {
	    var feMerge = createNS('feMerge');
	    filter.appendChild(feMerge);
	    var feMergeNode;
	    feMergeNode = createNS('feMergeNode');
	    feMergeNode.setAttribute('in', 'SourceGraphic');
	    feMerge.appendChild(feMergeNode);
	    feMergeNode = createNS('feMergeNode');
	    feMergeNode.setAttribute('in', 'f2');
	    feMerge.appendChild(feMergeNode);
	  }
	}

	SVGTintFilter.prototype.renderFrame = function (forceRender) {
	  if (forceRender || this.filterManager._mdf) {
	    var colorBlack = this.filterManager.effectElements[0].p.v;
	    var colorWhite = this.filterManager.effectElements[1].p.v;
	    var opacity = this.filterManager.effectElements[2].p.v / 100;
	    this.matrixFilter.setAttribute('values', (colorWhite[0] - colorBlack[0]) + ' 0 0 0 ' + colorBlack[0] + ' ' + (colorWhite[1] - colorBlack[1]) + ' 0 0 0 ' + colorBlack[1] + ' ' + (colorWhite[2] - colorBlack[2]) + ' 0 0 0 ' + colorBlack[2] + ' 0 0 0 ' + opacity + ' 0');
	  }
	};

	/* global createNS */

	function SVGFillFilter(filter, filterManager) {
	  this.filterManager = filterManager;
	  var feColorMatrix = createNS('feColorMatrix');
	  feColorMatrix.setAttribute('type', 'matrix');
	  feColorMatrix.setAttribute('color-interpolation-filters', 'sRGB');
	  feColorMatrix.setAttribute('values', '1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0');
	  filter.appendChild(feColorMatrix);
	  this.matrixFilter = feColorMatrix;
	}
	SVGFillFilter.prototype.renderFrame = function (forceRender) {
	  if (forceRender || this.filterManager._mdf) {
	    var color = this.filterManager.effectElements[2].p.v;
	    var opacity = this.filterManager.effectElements[6].p.v;
	    this.matrixFilter.setAttribute('values', '0 0 0 0 ' + color[0] + ' 0 0 0 0 ' + color[1] + ' 0 0 0 0 ' + color[2] + ' 0 0 0 ' + opacity + ' 0');
	  }
	};

	/* global createNS */

	function SVGGaussianBlurEffect(filter, filterManager) {
	  // Outset the filter region by 100% on all sides to accommodate blur expansion.
	  filter.setAttribute('x', '-100%');
	  filter.setAttribute('y', '-100%');
	  filter.setAttribute('width', '300%');
	  filter.setAttribute('height', '300%');

	  this.filterManager = filterManager;
	  var feGaussianBlur = createNS('feGaussianBlur');
	  filter.appendChild(feGaussianBlur);
	  this.feGaussianBlur = feGaussianBlur;
	}

	SVGGaussianBlurEffect.prototype.renderFrame = function (forceRender) {
	  if (forceRender || this.filterManager._mdf) {
	    // Empirical value, matching AE's blur appearance.
	    var kBlurrinessToSigma = 0.3;
	    var sigma = this.filterManager.effectElements[0].p.v * kBlurrinessToSigma;

	    // Dimensions mapping:
	    //
	    //   1 -> horizontal & vertical
	    //   2 -> horizontal only
	    //   3 -> vertical only
	    //
	    var dimensions = this.filterManager.effectElements[1].p.v;
	    var sigmaX = (dimensions == 3) ? 0 : sigma; // eslint-disable-line eqeqeq
	    var sigmaY = (dimensions == 2) ? 0 : sigma; // eslint-disable-line eqeqeq

	    this.feGaussianBlur.setAttribute('stdDeviation', sigmaX + ' ' + sigmaY);

	    // Repeat edges mapping:
	    //
	    //   0 -> off -> duplicate
	    //   1 -> on  -> wrap
	    var edgeMode = (this.filterManager.effectElements[2].p.v == 1) ? 'wrap' : 'duplicate'; // eslint-disable-line eqeqeq
	    this.feGaussianBlur.setAttribute('edgeMode', edgeMode);
	  }
	};

	/* global createNS, createElementID, locationHref, bmFloor */

	function SVGStrokeEffect(elem, filterManager) {
	  this.initialized = false;
	  this.filterManager = filterManager;
	  this.elem = elem;
	  this.paths = [];
	}

	SVGStrokeEffect.prototype.initialize = function () {
	  var elemChildren = this.elem.layerElement.children || this.elem.layerElement.childNodes;
	  var path;
	  var groupPath;
	  var i;
	  var len;
	  if (this.filterManager.effectElements[1].p.v === 1) {
	    len = this.elem.maskManager.masksProperties.length;
	    i = 0;
	  } else {
	    i = this.filterManager.effectElements[0].p.v - 1;
	    len = i + 1;
	  }
	  groupPath = createNS('g');
	  groupPath.setAttribute('fill', 'none');
	  groupPath.setAttribute('stroke-linecap', 'round');
	  groupPath.setAttribute('stroke-dashoffset', 1);
	  for (i; i < len; i += 1) {
	    path = createNS('path');
	    groupPath.appendChild(path);
	    this.paths.push({ p: path, m: i });
	  }
	  if (this.filterManager.effectElements[10].p.v === 3) {
	    var mask = createNS('mask');
	    var id = createElementID();
	    mask.setAttribute('id', id);
	    mask.setAttribute('mask-type', 'alpha');
	    mask.appendChild(groupPath);
	    this.elem.globalData.defs.appendChild(mask);
	    var g = createNS('g');
	    g.setAttribute('mask', 'url(' + locationHref + '#' + id + ')');
	    while (elemChildren[0]) {
	      g.appendChild(elemChildren[0]);
	    }
	    this.elem.layerElement.appendChild(g);
	    this.masker = mask;
	    groupPath.setAttribute('stroke', '#fff');
	  } else if (this.filterManager.effectElements[10].p.v === 1 || this.filterManager.effectElements[10].p.v === 2) {
	    if (this.filterManager.effectElements[10].p.v === 2) {
	      elemChildren = this.elem.layerElement.children || this.elem.layerElement.childNodes;
	      while (elemChildren.length) {
	        this.elem.layerElement.removeChild(elemChildren[0]);
	      }
	    }
	    this.elem.layerElement.appendChild(groupPath);
	    this.elem.layerElement.removeAttribute('mask');
	    groupPath.setAttribute('stroke', '#fff');
	  }
	  this.initialized = true;
	  this.pathMasker = groupPath;
	};

	SVGStrokeEffect.prototype.renderFrame = function (forceRender) {
	  if (!this.initialized) {
	    this.initialize();
	  }
	  var i;
	  var len = this.paths.length;
	  var mask;
	  var path;
	  for (i = 0; i < len; i += 1) {
	    if (this.paths[i].m !== -1) {
	      mask = this.elem.maskManager.viewData[this.paths[i].m];
	      path = this.paths[i].p;
	      if (forceRender || this.filterManager._mdf || mask.prop._mdf) {
	        path.setAttribute('d', mask.lastPath);
	      }
	      if (forceRender || this.filterManager.effectElements[9].p._mdf || this.filterManager.effectElements[4].p._mdf || this.filterManager.effectElements[7].p._mdf || this.filterManager.effectElements[8].p._mdf || mask.prop._mdf) {
	        var dasharrayValue;
	        if (this.filterManager.effectElements[7].p.v !== 0 || this.filterManager.effectElements[8].p.v !== 100) {
	          var s = Math.min(this.filterManager.effectElements[7].p.v, this.filterManager.effectElements[8].p.v) * 0.01;
	          var e = Math.max(this.filterManager.effectElements[7].p.v, this.filterManager.effectElements[8].p.v) * 0.01;
	          var l = path.getTotalLength();
	          dasharrayValue = '0 0 0 ' + l * s + ' ';
	          var lineLength = l * (e - s);
	          var segment = 1 + this.filterManager.effectElements[4].p.v * 2 * this.filterManager.effectElements[9].p.v * 0.01;
	          var units = Math.floor(lineLength / segment);
	          var j;
	          for (j = 0; j < units; j += 1) {
	            dasharrayValue += '1 ' + this.filterManager.effectElements[4].p.v * 2 * this.filterManager.effectElements[9].p.v * 0.01 + ' ';
	          }
	          dasharrayValue += '0 ' + l * 10 + ' 0 0';
	        } else {
	          dasharrayValue = '1 ' + this.filterManager.effectElements[4].p.v * 2 * this.filterManager.effectElements[9].p.v * 0.01;
	        }
	        path.setAttribute('stroke-dasharray', dasharrayValue);
	      }
	    }
	  }
	  if (forceRender || this.filterManager.effectElements[4].p._mdf) {
	    this.pathMasker.setAttribute('stroke-width', this.filterManager.effectElements[4].p.v * 2);
	  }

	  if (forceRender || this.filterManager.effectElements[6].p._mdf) {
	    this.pathMasker.setAttribute('opacity', this.filterManager.effectElements[6].p.v);
	  }
	  if (this.filterManager.effectElements[10].p.v === 1 || this.filterManager.effectElements[10].p.v === 2) {
	    if (forceRender || this.filterManager.effectElements[3].p._mdf) {
	      var color = this.filterManager.effectElements[3].p.v;
	      this.pathMasker.setAttribute('stroke', 'rgb(' + bmFloor(color[0] * 255) + ',' + bmFloor(color[1] * 255) + ',' + bmFloor(color[2] * 255) + ')');
	    }
	  }
	};

	/* global createNS */

	function SVGTritoneFilter(filter, filterManager) {
	  this.filterManager = filterManager;
	  var feColorMatrix = createNS('feColorMatrix');
	  feColorMatrix.setAttribute('type', 'matrix');
	  feColorMatrix.setAttribute('color-interpolation-filters', 'linearRGB');
	  feColorMatrix.setAttribute('values', '0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0 1 0');
	  feColorMatrix.setAttribute('result', 'f1');
	  filter.appendChild(feColorMatrix);
	  var feComponentTransfer = createNS('feComponentTransfer');
	  feComponentTransfer.setAttribute('color-interpolation-filters', 'sRGB');
	  filter.appendChild(feComponentTransfer);
	  this.matrixFilter = feComponentTransfer;
	  var feFuncR = createNS('feFuncR');
	  feFuncR.setAttribute('type', 'table');
	  feComponentTransfer.appendChild(feFuncR);
	  this.feFuncR = feFuncR;
	  var feFuncG = createNS('feFuncG');
	  feFuncG.setAttribute('type', 'table');
	  feComponentTransfer.appendChild(feFuncG);
	  this.feFuncG = feFuncG;
	  var feFuncB = createNS('feFuncB');
	  feFuncB.setAttribute('type', 'table');
	  feComponentTransfer.appendChild(feFuncB);
	  this.feFuncB = feFuncB;
	}

	SVGTritoneFilter.prototype.renderFrame = function (forceRender) {
	  if (forceRender || this.filterManager._mdf) {
	    var color1 = this.filterManager.effectElements[0].p.v;
	    var color2 = this.filterManager.effectElements[1].p.v;
	    var color3 = this.filterManager.effectElements[2].p.v;
	    var tableR = color3[0] + ' ' + color2[0] + ' ' + color1[0];
	    var tableG = color3[1] + ' ' + color2[1] + ' ' + color1[1];
	    var tableB = color3[2] + ' ' + color2[2] + ' ' + color1[2];
	    this.feFuncR.setAttribute('tableValues', tableR);
	    this.feFuncG.setAttribute('tableValues', tableG);
	    this.feFuncB.setAttribute('tableValues', tableB);
	    // var opacity = this.filterManager.effectElements[2].p.v/100;
	    // this.matrixFilter.setAttribute('values',(colorWhite[0]- colorBlack[0])+' 0 0 0 '+ colorBlack[0] +' '+ (colorWhite[1]- colorBlack[1]) +' 0 0 0 '+ colorBlack[1] +' '+ (colorWhite[2]- colorBlack[2]) +' 0 0 0 '+ colorBlack[2] +' 0 0 0 ' + opacity + ' 0');
	  }
	};

	/* global createNS */

	function SVGProLevelsFilter(filter, filterManager) {
	  this.filterManager = filterManager;
	  var effectElements = this.filterManager.effectElements;
	  var feComponentTransfer = createNS('feComponentTransfer');

	  if (effectElements[10].p.k || effectElements[10].p.v !== 0 || effectElements[11].p.k || effectElements[11].p.v !== 1 || effectElements[12].p.k || effectElements[12].p.v !== 1 || effectElements[13].p.k || effectElements[13].p.v !== 0 || effectElements[14].p.k || effectElements[14].p.v !== 1) {
	    this.feFuncR = this.createFeFunc('feFuncR', feComponentTransfer);
	  }
	  if (effectElements[17].p.k || effectElements[17].p.v !== 0 || effectElements[18].p.k || effectElements[18].p.v !== 1 || effectElements[19].p.k || effectElements[19].p.v !== 1 || effectElements[20].p.k || effectElements[20].p.v !== 0 || effectElements[21].p.k || effectElements[21].p.v !== 1) {
	    this.feFuncG = this.createFeFunc('feFuncG', feComponentTransfer);
	  }
	  if (effectElements[24].p.k || effectElements[24].p.v !== 0 || effectElements[25].p.k || effectElements[25].p.v !== 1 || effectElements[26].p.k || effectElements[26].p.v !== 1 || effectElements[27].p.k || effectElements[27].p.v !== 0 || effectElements[28].p.k || effectElements[28].p.v !== 1) {
	    this.feFuncB = this.createFeFunc('feFuncB', feComponentTransfer);
	  }
	  if (effectElements[31].p.k || effectElements[31].p.v !== 0 || effectElements[32].p.k || effectElements[32].p.v !== 1 || effectElements[33].p.k || effectElements[33].p.v !== 1 || effectElements[34].p.k || effectElements[34].p.v !== 0 || effectElements[35].p.k || effectElements[35].p.v !== 1) {
	    this.feFuncA = this.createFeFunc('feFuncA', feComponentTransfer);
	  }

	  if (this.feFuncR || this.feFuncG || this.feFuncB || this.feFuncA) {
	    feComponentTransfer.setAttribute('color-interpolation-filters', 'sRGB');
	    filter.appendChild(feComponentTransfer);
	    feComponentTransfer = createNS('feComponentTransfer');
	  }

	  if (effectElements[3].p.k || effectElements[3].p.v !== 0 || effectElements[4].p.k || effectElements[4].p.v !== 1 || effectElements[5].p.k || effectElements[5].p.v !== 1 || effectElements[6].p.k || effectElements[6].p.v !== 0 || effectElements[7].p.k || effectElements[7].p.v !== 1) {
	    feComponentTransfer.setAttribute('color-interpolation-filters', 'sRGB');
	    filter.appendChild(feComponentTransfer);
	    this.feFuncRComposed = this.createFeFunc('feFuncR', feComponentTransfer);
	    this.feFuncGComposed = this.createFeFunc('feFuncG', feComponentTransfer);
	    this.feFuncBComposed = this.createFeFunc('feFuncB', feComponentTransfer);
	  }
	}

	SVGProLevelsFilter.prototype.createFeFunc = function (type, feComponentTransfer) {
	  var feFunc = createNS(type);
	  feFunc.setAttribute('type', 'table');
	  feComponentTransfer.appendChild(feFunc);
	  return feFunc;
	};

	SVGProLevelsFilter.prototype.getTableValue = function (inputBlack, inputWhite, gamma, outputBlack, outputWhite) {
	  var cnt = 0;
	  var segments = 256;
	  var perc;
	  var min = Math.min(inputBlack, inputWhite);
	  var max = Math.max(inputBlack, inputWhite);
	  var table = Array.call(null, { length: segments });
	  var colorValue;
	  var pos = 0;
	  var outputDelta = outputWhite - outputBlack;
	  var inputDelta = inputWhite - inputBlack;
	  while (cnt <= 256) {
	    perc = cnt / 256;
	    if (perc <= min) {
	      colorValue = inputDelta < 0 ? outputWhite : outputBlack;
	    } else if (perc >= max) {
	      colorValue = inputDelta < 0 ? outputBlack : outputWhite;
	    } else {
	      colorValue = (outputBlack + outputDelta * Math.pow((perc - inputBlack) / inputDelta, 1 / gamma));
	    }
	    table[pos] = colorValue;
	    pos += 1;
	    cnt += 256 / (segments - 1);
	  }
	  return table.join(' ');
	};

	SVGProLevelsFilter.prototype.renderFrame = function (forceRender) {
	  if (forceRender || this.filterManager._mdf) {
	    var val;
	    var effectElements = this.filterManager.effectElements;
	    if (this.feFuncRComposed && (forceRender || effectElements[3].p._mdf || effectElements[4].p._mdf || effectElements[5].p._mdf || effectElements[6].p._mdf || effectElements[7].p._mdf)) {
	      val = this.getTableValue(effectElements[3].p.v, effectElements[4].p.v, effectElements[5].p.v, effectElements[6].p.v, effectElements[7].p.v);
	      this.feFuncRComposed.setAttribute('tableValues', val);
	      this.feFuncGComposed.setAttribute('tableValues', val);
	      this.feFuncBComposed.setAttribute('tableValues', val);
	    }

	    if (this.feFuncR && (forceRender || effectElements[10].p._mdf || effectElements[11].p._mdf || effectElements[12].p._mdf || effectElements[13].p._mdf || effectElements[14].p._mdf)) {
	      val = this.getTableValue(effectElements[10].p.v, effectElements[11].p.v, effectElements[12].p.v, effectElements[13].p.v, effectElements[14].p.v);
	      this.feFuncR.setAttribute('tableValues', val);
	    }

	    if (this.feFuncG && (forceRender || effectElements[17].p._mdf || effectElements[18].p._mdf || effectElements[19].p._mdf || effectElements[20].p._mdf || effectElements[21].p._mdf)) {
	      val = this.getTableValue(effectElements[17].p.v, effectElements[18].p.v, effectElements[19].p.v, effectElements[20].p.v, effectElements[21].p.v);
	      this.feFuncG.setAttribute('tableValues', val);
	    }

	    if (this.feFuncB && (forceRender || effectElements[24].p._mdf || effectElements[25].p._mdf || effectElements[26].p._mdf || effectElements[27].p._mdf || effectElements[28].p._mdf)) {
	      val = this.getTableValue(effectElements[24].p.v, effectElements[25].p.v, effectElements[26].p.v, effectElements[27].p.v, effectElements[28].p.v);
	      this.feFuncB.setAttribute('tableValues', val);
	    }

	    if (this.feFuncA && (forceRender || effectElements[31].p._mdf || effectElements[32].p._mdf || effectElements[33].p._mdf || effectElements[34].p._mdf || effectElements[35].p._mdf)) {
	      val = this.getTableValue(effectElements[31].p.v, effectElements[32].p.v, effectElements[33].p.v, effectElements[34].p.v, effectElements[35].p.v);
	      this.feFuncA.setAttribute('tableValues', val);
	    }
	  }
	};

	/* global createNS, rgbToHex, degToRads */

	function SVGDropShadowEffect(filter, filterManager) {
	  var filterSize = filterManager.container.globalData.renderConfig.filterSize;
	  filter.setAttribute('x', filterSize.x);
	  filter.setAttribute('y', filterSize.y);
	  filter.setAttribute('width', filterSize.width);
	  filter.setAttribute('height', filterSize.height);
	  this.filterManager = filterManager;

	  var feGaussianBlur = createNS('feGaussianBlur');
	  feGaussianBlur.setAttribute('in', 'SourceAlpha');
	  feGaussianBlur.setAttribute('result', 'drop_shadow_1');
	  feGaussianBlur.setAttribute('stdDeviation', '0');
	  this.feGaussianBlur = feGaussianBlur;
	  filter.appendChild(feGaussianBlur);

	  var feOffset = createNS('feOffset');
	  feOffset.setAttribute('dx', '25');
	  feOffset.setAttribute('dy', '0');
	  feOffset.setAttribute('in', 'drop_shadow_1');
	  feOffset.setAttribute('result', 'drop_shadow_2');
	  this.feOffset = feOffset;
	  filter.appendChild(feOffset);
	  var feFlood = createNS('feFlood');
	  feFlood.setAttribute('flood-color', '#00ff00');
	  feFlood.setAttribute('flood-opacity', '1');
	  feFlood.setAttribute('result', 'drop_shadow_3');
	  this.feFlood = feFlood;
	  filter.appendChild(feFlood);

	  var feComposite = createNS('feComposite');
	  feComposite.setAttribute('in', 'drop_shadow_3');
	  feComposite.setAttribute('in2', 'drop_shadow_2');
	  feComposite.setAttribute('operator', 'in');
	  feComposite.setAttribute('result', 'drop_shadow_4');
	  filter.appendChild(feComposite);

	  var feMerge = createNS('feMerge');
	  filter.appendChild(feMerge);
	  var feMergeNode;
	  feMergeNode = createNS('feMergeNode');
	  feMerge.appendChild(feMergeNode);
	  feMergeNode = createNS('feMergeNode');
	  feMergeNode.setAttribute('in', 'SourceGraphic');
	  this.feMergeNode = feMergeNode;
	  this.feMerge = feMerge;
	  this.originalNodeAdded = false;
	  feMerge.appendChild(feMergeNode);
	}

	SVGDropShadowEffect.prototype.renderFrame = function (forceRender) {
	  if (forceRender || this.filterManager._mdf) {
	    if (forceRender || this.filterManager.effectElements[4].p._mdf) {
	      this.feGaussianBlur.setAttribute('stdDeviation', this.filterManager.effectElements[4].p.v / 4);
	    }
	    if (forceRender || this.filterManager.effectElements[0].p._mdf) {
	      var col = this.filterManager.effectElements[0].p.v;
	      this.feFlood.setAttribute('flood-color', rgbToHex(Math.round(col[0] * 255), Math.round(col[1] * 255), Math.round(col[2] * 255)));
	    }
	    if (forceRender || this.filterManager.effectElements[1].p._mdf) {
	      this.feFlood.setAttribute('flood-opacity', this.filterManager.effectElements[1].p.v / 255);
	    }
	    if (forceRender || this.filterManager.effectElements[2].p._mdf || this.filterManager.effectElements[3].p._mdf) {
	      var distance = this.filterManager.effectElements[3].p.v;
	      var angle = (this.filterManager.effectElements[2].p.v - 90) * degToRads;
	      var x = distance * Math.cos(angle);
	      var y = distance * Math.sin(angle);
	      this.feOffset.setAttribute('dx', x);
	      this.feOffset.setAttribute('dy', y);
	    }
	    /* if(forceRender || this.filterManager.effectElements[5].p._mdf){
	            if(this.filterManager.effectElements[5].p.v === 1 && this.originalNodeAdded) {
	                this.feMerge.removeChild(this.feMergeNode);
	                this.originalNodeAdded = false;
	            } else if(this.filterManager.effectElements[5].p.v === 0 && !this.originalNodeAdded) {
	                this.feMerge.appendChild(this.feMergeNode);
	                this.originalNodeAdded = true;
	            }
	        } */
	  }
	};

	/* global createElementID, createNS */

	var _svgMatteSymbols = [];

	function SVGMatte3Effect(filterElem, filterManager, elem) {
	  this.initialized = false;
	  this.filterManager = filterManager;
	  this.filterElem = filterElem;
	  this.elem = elem;
	  elem.matteElement = createNS('g');
	  elem.matteElement.appendChild(elem.layerElement);
	  elem.matteElement.appendChild(elem.transformedElement);
	  elem.baseElement = elem.matteElement;
	}

	SVGMatte3Effect.prototype.findSymbol = function (mask) {
	  var i = 0;
	  var len = _svgMatteSymbols.length;
	  while (i < len) {
	    if (_svgMatteSymbols[i] === mask) {
	      return _svgMatteSymbols[i];
	    }
	    i += 1;
	  }
	  return null;
	};

	SVGMatte3Effect.prototype.replaceInParent = function (mask, symbolId) {
	  var parentNode = mask.layerElement.parentNode;
	  if (!parentNode) {
	    return;
	  }
	  var children = parentNode.children;
	  var i = 0;
	  var len = children.length;
	  while (i < len) {
	    if (children[i] === mask.layerElement) {
	      break;
	    }
	    i += 1;
	  }
	  var nextChild;
	  if (i <= len - 2) {
	    nextChild = children[i + 1];
	  }
	  var useElem = createNS('use');
	  useElem.setAttribute('href', '#' + symbolId);
	  if (nextChild) {
	    parentNode.insertBefore(useElem, nextChild);
	  } else {
	    parentNode.appendChild(useElem);
	  }
	};

	SVGMatte3Effect.prototype.setElementAsMask = function (elem, mask) {
	  if (!this.findSymbol(mask)) {
	    var symbolId = createElementID();
	    var masker = createNS('mask');
	    masker.setAttribute('id', mask.layerId);
	    masker.setAttribute('mask-type', 'alpha');
	    _svgMatteSymbols.push(mask);
	    var defs = elem.globalData.defs;
	    defs.appendChild(masker);
	    var symbol = createNS('symbol');
	    symbol.setAttribute('id', symbolId);
	    this.replaceInParent(mask, symbolId);
	    symbol.appendChild(mask.layerElement);
	    defs.appendChild(symbol);
	    var useElem = createNS('use');
	    useElem.setAttribute('href', '#' + symbolId);
	    masker.appendChild(useElem);
	    mask.data.hd = false;
	    mask.show();
	  }
	  elem.setMatte(mask.layerId);
	};

	SVGMatte3Effect.prototype.initialize = function () {
	  var ind = this.filterManager.effectElements[0].p.v;
	  var elements = this.elem.comp.elements;
	  var i = 0;
	  var len = elements.length;
	  while (i < len) {
	    if (elements[i] && elements[i].data.ind === ind) {
	      this.setElementAsMask(this.elem, elements[i]);
	    }
	    i += 1;
	  }
	  this.initialized = true;
	};

	SVGMatte3Effect.prototype.renderFrame = function () {
	  if (!this.initialized) {
	    this.initialize();
	  }
	};

	/* global createElementID, filtersFactory, SVGTintFilter, SVGFillFilter, SVGStrokeEffect, SVGTritoneFilter,
	SVGProLevelsFilter, SVGDropShadowEffect, SVGMatte3Effect, SVGGaussianBlurEffect, locationHref */

	function SVGEffects(elem) {
	  var i;
	  var len = elem.data.ef ? elem.data.ef.length : 0;
	  var filId = createElementID();
	  var fil = filtersFactory.createFilter(filId, true);
	  var count = 0;
	  this.filters = [];
	  var filterManager;
	  for (i = 0; i < len; i += 1) {
	    filterManager = null;
	    if (elem.data.ef[i].ty === 20) {
	      count += 1;
	      filterManager = new SVGTintFilter(fil, elem.effectsManager.effectElements[i]);
	    } else if (elem.data.ef[i].ty === 21) {
	      count += 1;
	      filterManager = new SVGFillFilter(fil, elem.effectsManager.effectElements[i]);
	    } else if (elem.data.ef[i].ty === 22) {
	      filterManager = new SVGStrokeEffect(elem, elem.effectsManager.effectElements[i]);
	    } else if (elem.data.ef[i].ty === 23) {
	      count += 1;
	      filterManager = new SVGTritoneFilter(fil, elem.effectsManager.effectElements[i]);
	    } else if (elem.data.ef[i].ty === 24) {
	      count += 1;
	      filterManager = new SVGProLevelsFilter(fil, elem.effectsManager.effectElements[i]);
	    } else if (elem.data.ef[i].ty === 25) {
	      count += 1;
	      filterManager = new SVGDropShadowEffect(fil, elem.effectsManager.effectElements[i]);
	    } else if (elem.data.ef[i].ty === 28) {
	      // count += 1;
	      filterManager = new SVGMatte3Effect(fil, elem.effectsManager.effectElements[i], elem);
	    } else if (elem.data.ef[i].ty === 29) {
	      count += 1;
	      filterManager = new SVGGaussianBlurEffect(fil, elem.effectsManager.effectElements[i]);
	    }
	    if (filterManager) {
	      this.filters.push(filterManager);
	    }
	  }
	  if (count) {
	    elem.globalData.defs.appendChild(fil);
	    elem.layerElement.setAttribute('filter', 'url(' + locationHref + '#' + filId + ')');
	  }
	  if (this.filters.length) {
	    elem.addRenderableComponent(this);
	  }
	}

	SVGEffects.prototype.renderFrame = function (_isFirstFrame) {
	  var i;
	  var len = this.filters.length;
	  for (i = 0; i < len; i += 1) {
	    this.filters[i].renderFrame(_isFirstFrame);
	  }
	};

	/* global Matrix, createTypedArray */

	function CVContextData() {
	  this.saved = [];
	  this.cArrPos = 0;
	  this.cTr = new Matrix();
	  this.cO = 1;
	  var i;
	  var len = 15;
	  this.savedOp = createTypedArray('float32', len);
	  for (i = 0; i < len; i += 1) {
	    this.saved[i] = createTypedArray('float32', 16);
	  }
	  this._length = len;
	}

	CVContextData.prototype.duplicate = function () {
	  var newLength = this._length * 2;
	  var currentSavedOp = this.savedOp;
	  this.savedOp = createTypedArray('float32', newLength);
	  this.savedOp.set(currentSavedOp);
	  var i = 0;
	  for (i = this._length; i < newLength; i += 1) {
	    this.saved[i] = createTypedArray('float32', 16);
	  }
	  this._length = newLength;
	};

	CVContextData.prototype.reset = function () {
	  this.cArrPos = 0;
	  this.cTr.reset();
	  this.cO = 1;
	};

	/* global CVEffects, getBlendMode, CVMaskElement, Matrix */

	function CVBaseElement() {
	}

	CVBaseElement.prototype = {
	  createElements: function () {},
	  initRendererElement: function () {},
	  createContainerElements: function () {
	    this.canvasContext = this.globalData.canvasContext;
	    this.renderableEffectsManager = new CVEffects(this);
	  },
	  createContent: function () {},
	  setBlendMode: function () {
	    var globalData = this.globalData;
	    if (globalData.blendMode !== this.data.bm) {
	      globalData.blendMode = this.data.bm;
	      var blendModeValue = getBlendMode(this.data.bm);
	      globalData.canvasContext.globalCompositeOperation = blendModeValue;
	    }
	  },
	  createRenderableComponents: function () {
	    this.maskManager = new CVMaskElement(this.data, this);
	  },
	  hideElement: function () {
	    if (!this.hidden && (!this.isInRange || this.isTransparent)) {
	      this.hidden = true;
	    }
	  },
	  showElement: function () {
	    if (this.isInRange && !this.isTransparent) {
	      this.hidden = false;
	      this._isFirstFrame = true;
	      this.maskManager._isFirstFrame = true;
	    }
	  },
	  renderFrame: function () {
	    if (this.hidden || this.data.hd) {
	      return;
	    }
	    this.renderTransform();
	    this.renderRenderable();
	    this.setBlendMode();
	    var forceRealStack = this.data.ty === 0;
	    this.globalData.renderer.save(forceRealStack);
	    this.globalData.renderer.ctxTransform(this.finalTransform.mat.props);
	    this.globalData.renderer.ctxOpacity(this.finalTransform.mProp.o.v);
	    this.renderInnerContent();
	    this.globalData.renderer.restore(forceRealStack);
	    if (this.maskManager.hasMasks) {
	      this.globalData.renderer.restore(true);
	    }
	    if (this._isFirstFrame) {
	      this._isFirstFrame = false;
	    }
	  },
	  destroy: function () {
	    this.canvasContext = null;
	    this.data = null;
	    this.globalData = null;
	    this.maskManager.destroy();
	  },
	  mHelper: new Matrix(),
	};
	CVBaseElement.prototype.hide = CVBaseElement.prototype.hideElement;
	CVBaseElement.prototype.show = CVBaseElement.prototype.showElement;

	/* global extendPrototype, BaseElement, TransformElement, CVBaseElement,HierarchyElement, FrameElement,
	RenderableElement, SVGShapeElement, IImageElement, createTag */

	function CVImageElement(data, globalData, comp) {
	  this.assetData = globalData.getAssetData(data.refId);
	  this.img = globalData.imageLoader.getAsset(this.assetData);
	  this.initElement(data, globalData, comp);
	}
	extendPrototype([BaseElement, TransformElement, CVBaseElement, HierarchyElement, FrameElement, RenderableElement], CVImageElement);

	CVImageElement.prototype.initElement = SVGShapeElement.prototype.initElement;
	CVImageElement.prototype.prepareFrame = IImageElement.prototype.prepareFrame;

	CVImageElement.prototype.createContent = function () {
	  if (this.img.width && (this.assetData.w !== this.img.width || this.assetData.h !== this.img.height)) {
	    var canvas = createTag('canvas');
	    canvas.width = this.assetData.w;
	    canvas.height = this.assetData.h;
	    var ctx = canvas.getContext('2d');

	    var imgW = this.img.width;
	    var imgH = this.img.height;
	    var imgRel = imgW / imgH;
	    var canvasRel = this.assetData.w / this.assetData.h;
	    var widthCrop;
	    var heightCrop;
	    var par = this.assetData.pr || this.globalData.renderConfig.imagePreserveAspectRatio;
	    if ((imgRel > canvasRel && par === 'xMidYMid slice') || (imgRel < canvasRel && par !== 'xMidYMid slice')) {
	      heightCrop = imgH;
	      widthCrop = heightCrop * canvasRel;
	    } else {
	      widthCrop = imgW;
	      heightCrop = widthCrop / canvasRel;
	    }
	    ctx.drawImage(this.img, (imgW - widthCrop) / 2, (imgH - heightCrop) / 2, widthCrop, heightCrop, 0, 0, this.assetData.w, this.assetData.h);
	    this.img = canvas;
	  }
	};

	CVImageElement.prototype.renderInnerContent = function () {
	  this.canvasContext.drawImage(this.img, 0, 0);
	};

	CVImageElement.prototype.destroy = function () {
	  this.img = null;
	};

	/* global createSizedArray, PropertyFactory, extendPrototype, CanvasRenderer, ICompElement, CVBaseElement */

	function CVCompElement(data, globalData, comp) {
	  this.completeLayers = false;
	  this.layers = data.layers;
	  this.pendingElements = [];
	  this.elements = createSizedArray(this.layers.length);
	  this.initElement(data, globalData, comp);
	  this.tm = data.tm ? PropertyFactory.getProp(this, data.tm, 0, globalData.frameRate, this) : { _placeholder: true };
	}

	extendPrototype([CanvasRenderer, ICompElement, CVBaseElement], CVCompElement);

	CVCompElement.prototype.renderInnerContent = function () {
	  var ctx = this.canvasContext;
	  ctx.beginPath();
	  ctx.moveTo(0, 0);
	  ctx.lineTo(this.data.w, 0);
	  ctx.lineTo(this.data.w, this.data.h);
	  ctx.lineTo(0, this.data.h);
	  ctx.lineTo(0, 0);
	  ctx.clip();
	  var i;
	  var len = this.layers.length;
	  for (i = len - 1; i >= 0; i -= 1) {
	    if (this.completeLayers || this.elements[i]) {
	      this.elements[i].renderFrame();
	    }
	  }
	};

	CVCompElement.prototype.destroy = function () {
	  var i;
	  var len = this.layers.length;
	  for (i = len - 1; i >= 0; i -= 1) {
	    if (this.elements[i]) {
	      this.elements[i].destroy();
	    }
	  }
	  this.layers = null;
	  this.elements = null;
	};

	/* global createSizedArray, ShapePropertyFactory, MaskElement */

	function CVMaskElement(data, element) {
	  this.data = data;
	  this.element = element;
	  this.masksProperties = this.data.masksProperties || [];
	  this.viewData = createSizedArray(this.masksProperties.length);
	  var i;
	  var len = this.masksProperties.length;
	  var hasMasks = false;
	  for (i = 0; i < len; i += 1) {
	    if (this.masksProperties[i].mode !== 'n') {
	      hasMasks = true;
	    }
	    this.viewData[i] = ShapePropertyFactory.getShapeProp(this.element, this.masksProperties[i], 3);
	  }
	  this.hasMasks = hasMasks;
	  if (hasMasks) {
	    this.element.addRenderableComponent(this);
	  }
	}

	CVMaskElement.prototype.renderFrame = function () {
	  if (!this.hasMasks) {
	    return;
	  }
	  var transform = this.element.finalTransform.mat;
	  var ctx = this.element.canvasContext;
	  var i;
	  var len = this.masksProperties.length;
	  var pt;
	  var pts;
	  var data;
	  ctx.beginPath();
	  for (i = 0; i < len; i += 1) {
	    if (this.masksProperties[i].mode !== 'n') {
	      if (this.masksProperties[i].inv) {
	        ctx.moveTo(0, 0);
	        ctx.lineTo(this.element.globalData.compSize.w, 0);
	        ctx.lineTo(this.element.globalData.compSize.w, this.element.globalData.compSize.h);
	        ctx.lineTo(0, this.element.globalData.compSize.h);
	        ctx.lineTo(0, 0);
	      }
	      data = this.viewData[i].v;
	      pt = transform.applyToPointArray(data.v[0][0], data.v[0][1], 0);
	      ctx.moveTo(pt[0], pt[1]);
	      var j;
	      var jLen = data._length;
	      for (j = 1; j < jLen; j += 1) {
	        pts = transform.applyToTriplePoints(data.o[j - 1], data.i[j], data.v[j]);
	        ctx.bezierCurveTo(pts[0], pts[1], pts[2], pts[3], pts[4], pts[5]);
	      }
	      pts = transform.applyToTriplePoints(data.o[j - 1], data.i[0], data.v[0]);
	      ctx.bezierCurveTo(pts[0], pts[1], pts[2], pts[3], pts[4], pts[5]);
	    }
	  }
	  this.element.globalData.renderer.save(true);
	  ctx.clip();
	};

	CVMaskElement.prototype.getMaskProperty = MaskElement.prototype.getMaskProperty;

	CVMaskElement.prototype.destroy = function () {
	  this.element = null;
	};

	/* global ShapeTransformManager, extendPrototype, BaseElement, TransformElement, CVBaseElement, IShapeElement,
	HierarchyElement, FrameElement, RenderableElement, RenderableDOMElement, PropertyFactory, degToRads, GradientProperty,
	DashProperty, TransformPropertyFactory, CVShapeData, ShapeModifiers, bmFloor, lineCapEnum, lineJoinEnum */

	function CVShapeElement(data, globalData, comp) {
	  this.shapes = [];
	  this.shapesData = data.shapes;
	  this.stylesList = [];
	  this.itemsData = [];
	  this.prevViewData = [];
	  this.shapeModifiers = [];
	  this.processedElements = [];
	  this.transformsManager = new ShapeTransformManager();
	  this.initElement(data, globalData, comp);
	}

	extendPrototype([BaseElement, TransformElement, CVBaseElement, IShapeElement, HierarchyElement, FrameElement, RenderableElement], CVShapeElement);

	CVShapeElement.prototype.initElement = RenderableDOMElement.prototype.initElement;

	CVShapeElement.prototype.transformHelper = { opacity: 1, _opMdf: false };

	CVShapeElement.prototype.dashResetter = [];

	CVShapeElement.prototype.createContent = function () {
	  this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, true, []);
	};

	CVShapeElement.prototype.createStyleElement = function (data, transforms) {
	  var styleElem = {
	    data: data,
	    type: data.ty,
	    preTransforms: this.transformsManager.addTransformSequence(transforms),
	    transforms: [],
	    elements: [],
	    closed: data.hd === true,
	  };
	  var elementData = {};
	  if (data.ty === 'fl' || data.ty === 'st') {
	    elementData.c = PropertyFactory.getProp(this, data.c, 1, 255, this);
	    if (!elementData.c.k) {
	      styleElem.co = 'rgb(' + bmFloor(elementData.c.v[0]) + ',' + bmFloor(elementData.c.v[1]) + ',' + bmFloor(elementData.c.v[2]) + ')';
	    }
	  } else if (data.ty === 'gf' || data.ty === 'gs') {
	    elementData.s = PropertyFactory.getProp(this, data.s, 1, null, this);
	    elementData.e = PropertyFactory.getProp(this, data.e, 1, null, this);
	    elementData.h = PropertyFactory.getProp(this, data.h || { k: 0 }, 0, 0.01, this);
	    elementData.a = PropertyFactory.getProp(this, data.a || { k: 0 }, 0, degToRads, this);
	    elementData.g = new GradientProperty(this, data.g, this);
	  }
	  elementData.o = PropertyFactory.getProp(this, data.o, 0, 0.01, this);
	  if (data.ty === 'st' || data.ty === 'gs') {
	    styleElem.lc = lineCapEnum[data.lc || 2];
	    styleElem.lj = lineJoinEnum[data.lj || 2];
	    if (data.lj == 1) { // eslint-disable-line eqeqeq
	      styleElem.ml = data.ml;
	    }
	    elementData.w = PropertyFactory.getProp(this, data.w, 0, null, this);
	    if (!elementData.w.k) {
	      styleElem.wi = elementData.w.v;
	    }
	    if (data.d) {
	      var d = new DashProperty(this, data.d, 'canvas', this);
	      elementData.d = d;
	      if (!elementData.d.k) {
	        styleElem.da = elementData.d.dashArray;
	        styleElem.do = elementData.d.dashoffset[0];
	      }
	    }
	  } else {
	    styleElem.r = data.r === 2 ? 'evenodd' : 'nonzero';
	  }
	  this.stylesList.push(styleElem);
	  elementData.style = styleElem;
	  return elementData;
	};

	CVShapeElement.prototype.createGroupElement = function () {
	  var elementData = {
	    it: [],
	    prevViewData: [],
	  };
	  return elementData;
	};

	CVShapeElement.prototype.createTransformElement = function (data) {
	  var elementData = {
	    transform: {
	      opacity: 1,
	      _opMdf: false,
	      key: this.transformsManager.getNewKey(),
	      op: PropertyFactory.getProp(this, data.o, 0, 0.01, this),
	      mProps: TransformPropertyFactory.getTransformProperty(this, data, this),
	    },
	  };
	  return elementData;
	};

	CVShapeElement.prototype.createShapeElement = function (data) {
	  var elementData = new CVShapeData(this, data, this.stylesList, this.transformsManager);

	  this.shapes.push(elementData);
	  this.addShapeToModifiers(elementData);
	  return elementData;
	};

	CVShapeElement.prototype.reloadShapes = function () {
	  this._isFirstFrame = true;
	  var i;
	  var len = this.itemsData.length;
	  for (i = 0; i < len; i += 1) {
	    this.prevViewData[i] = this.itemsData[i];
	  }
	  this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, true, []);
	  len = this.dynamicProperties.length;
	  for (i = 0; i < len; i += 1) {
	    this.dynamicProperties[i].getValue();
	  }
	  this.renderModifiers();
	  this.transformsManager.processSequences(this._isFirstFrame);
	};

	CVShapeElement.prototype.addTransformToStyleList = function (transform) {
	  var i;
	  var len = this.stylesList.length;
	  for (i = 0; i < len; i += 1) {
	    if (!this.stylesList[i].closed) {
	      this.stylesList[i].transforms.push(transform);
	    }
	  }
	};

	CVShapeElement.prototype.removeTransformFromStyleList = function () {
	  var i;
	  var len = this.stylesList.length;
	  for (i = 0; i < len; i += 1) {
	    if (!this.stylesList[i].closed) {
	      this.stylesList[i].transforms.pop();
	    }
	  }
	};

	CVShapeElement.prototype.closeStyles = function (styles) {
	  var i;
	  var len = styles.length;
	  for (i = 0; i < len; i += 1) {
	    styles[i].closed = true;
	  }
	};

	CVShapeElement.prototype.searchShapes = function (arr, itemsData, prevViewData, shouldRender, transforms) {
	  var i;
	  var len = arr.length - 1;
	  var j;
	  var jLen;
	  var ownStyles = [];
	  var ownModifiers = [];
	  var processedPos;
	  var modifier;
	  var currentTransform;
	  var ownTransforms = [].concat(transforms);
	  for (i = len; i >= 0; i -= 1) {
	    processedPos = this.searchProcessedElement(arr[i]);
	    if (!processedPos) {
	      arr[i]._shouldRender = shouldRender;
	    } else {
	      itemsData[i] = prevViewData[processedPos - 1];
	    }
	    if (arr[i].ty === 'fl' || arr[i].ty === 'st' || arr[i].ty === 'gf' || arr[i].ty === 'gs') {
	      if (!processedPos) {
	        itemsData[i] = this.createStyleElement(arr[i], ownTransforms);
	      } else {
	        itemsData[i].style.closed = false;
	      }

	      ownStyles.push(itemsData[i].style);
	    } else if (arr[i].ty === 'gr') {
	      if (!processedPos) {
	        itemsData[i] = this.createGroupElement(arr[i]);
	      } else {
	        jLen = itemsData[i].it.length;
	        for (j = 0; j < jLen; j += 1) {
	          itemsData[i].prevViewData[j] = itemsData[i].it[j];
	        }
	      }
	      this.searchShapes(arr[i].it, itemsData[i].it, itemsData[i].prevViewData, shouldRender, ownTransforms);
	    } else if (arr[i].ty === 'tr') {
	      if (!processedPos) {
	        currentTransform = this.createTransformElement(arr[i]);
	        itemsData[i] = currentTransform;
	      }
	      ownTransforms.push(itemsData[i]);
	      this.addTransformToStyleList(itemsData[i]);
	    } else if (arr[i].ty === 'sh' || arr[i].ty === 'rc' || arr[i].ty === 'el' || arr[i].ty === 'sr') {
	      if (!processedPos) {
	        itemsData[i] = this.createShapeElement(arr[i]);
	      }
	    } else if (arr[i].ty === 'tm' || arr[i].ty === 'rd' || arr[i].ty === 'pb') {
	      if (!processedPos) {
	        modifier = ShapeModifiers.getModifier(arr[i].ty);
	        modifier.init(this, arr[i]);
	        itemsData[i] = modifier;
	        this.shapeModifiers.push(modifier);
	      } else {
	        modifier = itemsData[i];
	        modifier.closed = false;
	      }
	      ownModifiers.push(modifier);
	    } else if (arr[i].ty === 'rp') {
	      if (!processedPos) {
	        modifier = ShapeModifiers.getModifier(arr[i].ty);
	        itemsData[i] = modifier;
	        modifier.init(this, arr, i, itemsData);
	        this.shapeModifiers.push(modifier);
	        shouldRender = false;
	      } else {
	        modifier = itemsData[i];
	        modifier.closed = true;
	      }
	      ownModifiers.push(modifier);
	    }
	    this.addProcessedElement(arr[i], i + 1);
	  }
	  this.removeTransformFromStyleList();
	  this.closeStyles(ownStyles);
	  len = ownModifiers.length;
	  for (i = 0; i < len; i += 1) {
	    ownModifiers[i].closed = true;
	  }
	};

	CVShapeElement.prototype.renderInnerContent = function () {
	  this.transformHelper.opacity = 1;
	  this.transformHelper._opMdf = false;
	  this.renderModifiers();
	  this.transformsManager.processSequences(this._isFirstFrame);
	  this.renderShape(this.transformHelper, this.shapesData, this.itemsData, true);
	};

	CVShapeElement.prototype.renderShapeTransform = function (parentTransform, groupTransform) {
	  if (parentTransform._opMdf || groupTransform.op._mdf || this._isFirstFrame) {
	    groupTransform.opacity = parentTransform.opacity;
	    groupTransform.opacity *= groupTransform.op.v;
	    groupTransform._opMdf = true;
	  }
	};

	CVShapeElement.prototype.drawLayer = function () {
	  var i;
	  var len = this.stylesList.length;
	  var j;
	  var jLen;
	  var k;
	  var kLen;
	  var elems;
	  var nodes;
	  var renderer = this.globalData.renderer;
	  var ctx = this.globalData.canvasContext;
	  var type;
	  var currentStyle;
	  for (i = 0; i < len; i += 1) {
	    currentStyle = this.stylesList[i];
	    type = currentStyle.type;

	    // Skipping style when
	    // Stroke width equals 0
	    // style should not be rendered (extra unused repeaters)
	    // current opacity equals 0
	    // global opacity equals 0
	    if (!(((type === 'st' || type === 'gs') && currentStyle.wi === 0) || !currentStyle.data._shouldRender || currentStyle.coOp === 0 || this.globalData.currentGlobalAlpha === 0)) {
	      renderer.save();
	      elems = currentStyle.elements;
	      if (type === 'st' || type === 'gs') {
	        ctx.strokeStyle = type === 'st' ? currentStyle.co : currentStyle.grd;
	        ctx.lineWidth = currentStyle.wi;
	        ctx.lineCap = currentStyle.lc;
	        ctx.lineJoin = currentStyle.lj;
	        ctx.miterLimit = currentStyle.ml || 0;
	      } else {
	        ctx.fillStyle = type === 'fl' ? currentStyle.co : currentStyle.grd;
	      }
	      renderer.ctxOpacity(currentStyle.coOp);
	      if (type !== 'st' && type !== 'gs') {
	        ctx.beginPath();
	      }
	      renderer.ctxTransform(currentStyle.preTransforms.finalTransform.props);
	      jLen = elems.length;
	      for (j = 0; j < jLen; j += 1) {
	        if (type === 'st' || type === 'gs') {
	          ctx.beginPath();
	          if (currentStyle.da) {
	            ctx.setLineDash(currentStyle.da);
	            ctx.lineDashOffset = currentStyle.do;
	          }
	        }
	        nodes = elems[j].trNodes;
	        kLen = nodes.length;

	        for (k = 0; k < kLen; k += 1) {
	          if (nodes[k].t === 'm') {
	            ctx.moveTo(nodes[k].p[0], nodes[k].p[1]);
	          } else if (nodes[k].t === 'c') {
	            ctx.bezierCurveTo(nodes[k].pts[0], nodes[k].pts[1], nodes[k].pts[2], nodes[k].pts[3], nodes[k].pts[4], nodes[k].pts[5]);
	          } else {
	            ctx.closePath();
	          }
	        }
	        if (type === 'st' || type === 'gs') {
	          ctx.stroke();
	          if (currentStyle.da) {
	            ctx.setLineDash(this.dashResetter);
	          }
	        }
	      }
	      if (type !== 'st' && type !== 'gs') {
	        ctx.fill(currentStyle.r);
	      }
	      renderer.restore();
	    }
	  }
	};

	CVShapeElement.prototype.renderShape = function (parentTransform, items, data, isMain) {
	  var i;
	  var len = items.length - 1;
	  var groupTransform;
	  groupTransform = parentTransform;
	  for (i = len; i >= 0; i -= 1) {
	    if (items[i].ty === 'tr') {
	      groupTransform = data[i].transform;
	      this.renderShapeTransform(parentTransform, groupTransform);
	    } else if (items[i].ty === 'sh' || items[i].ty === 'el' || items[i].ty === 'rc' || items[i].ty === 'sr') {
	      this.renderPath(items[i], data[i]);
	    } else if (items[i].ty === 'fl') {
	      this.renderFill(items[i], data[i], groupTransform);
	    } else if (items[i].ty === 'st') {
	      this.renderStroke(items[i], data[i], groupTransform);
	    } else if (items[i].ty === 'gf' || items[i].ty === 'gs') {
	      this.renderGradientFill(items[i], data[i], groupTransform);
	    } else if (items[i].ty === 'gr') {
	      this.renderShape(groupTransform, items[i].it, data[i].it);
	    } else if (items[i].ty === 'tm') {
	      //
	    }
	  }
	  if (isMain) {
	    this.drawLayer();
	  }
	};

	CVShapeElement.prototype.renderStyledShape = function (styledShape, shape) {
	  if (this._isFirstFrame || shape._mdf || styledShape.transforms._mdf) {
	    var shapeNodes = styledShape.trNodes;
	    var paths = shape.paths;
	    var i;
	    var len;
	    var j;
	    var jLen = paths._length;
	    shapeNodes.length = 0;
	    var groupTransformMat = styledShape.transforms.finalTransform;
	    for (j = 0; j < jLen; j += 1) {
	      var pathNodes = paths.shapes[j];
	      if (pathNodes && pathNodes.v) {
	        len = pathNodes._length;
	        for (i = 1; i < len; i += 1) {
	          if (i === 1) {
	            shapeNodes.push({
	              t: 'm',
	              p: groupTransformMat.applyToPointArray(pathNodes.v[0][0], pathNodes.v[0][1], 0),
	            });
	          }
	          shapeNodes.push({
	            t: 'c',
	            pts: groupTransformMat.applyToTriplePoints(pathNodes.o[i - 1], pathNodes.i[i], pathNodes.v[i]),
	          });
	        }
	        if (len === 1) {
	          shapeNodes.push({
	            t: 'm',
	            p: groupTransformMat.applyToPointArray(pathNodes.v[0][0], pathNodes.v[0][1], 0),
	          });
	        }
	        if (pathNodes.c && len) {
	          shapeNodes.push({
	            t: 'c',
	            pts: groupTransformMat.applyToTriplePoints(pathNodes.o[i - 1], pathNodes.i[0], pathNodes.v[0]),
	          });
	          shapeNodes.push({
	            t: 'z',
	          });
	        }
	      }
	    }
	    styledShape.trNodes = shapeNodes;
	  }
	};

	CVShapeElement.prototype.renderPath = function (pathData, itemData) {
	  if (pathData.hd !== true && pathData._shouldRender) {
	    var i;
	    var len = itemData.styledShapes.length;
	    for (i = 0; i < len; i += 1) {
	      this.renderStyledShape(itemData.styledShapes[i], itemData.sh);
	    }
	  }
	};

	CVShapeElement.prototype.renderFill = function (styleData, itemData, groupTransform) {
	  var styleElem = itemData.style;

	  if (itemData.c._mdf || this._isFirstFrame) {
	    styleElem.co = 'rgb('
	        + bmFloor(itemData.c.v[0]) + ','
	        + bmFloor(itemData.c.v[1]) + ','
	        + bmFloor(itemData.c.v[2]) + ')';
	  }
	  if (itemData.o._mdf || groupTransform._opMdf || this._isFirstFrame) {
	    styleElem.coOp = itemData.o.v * groupTransform.opacity;
	  }
	};

	CVShapeElement.prototype.renderGradientFill = function (styleData, itemData, groupTransform) {
	  var styleElem = itemData.style;
	  var grd;
	  if (!styleElem.grd || itemData.g._mdf || itemData.s._mdf || itemData.e._mdf || (styleData.t !== 1 && (itemData.h._mdf || itemData.a._mdf))) {
	    var ctx = this.globalData.canvasContext;
	    var pt1 = itemData.s.v;
	    var pt2 = itemData.e.v;
	    if (styleData.t === 1) {
	      grd = ctx.createLinearGradient(pt1[0], pt1[1], pt2[0], pt2[1]);
	    } else {
	      var rad = Math.sqrt(Math.pow(pt1[0] - pt2[0], 2) + Math.pow(pt1[1] - pt2[1], 2));
	      var ang = Math.atan2(pt2[1] - pt1[1], pt2[0] - pt1[0]);

	      var percent = itemData.h.v;
	      if (percent >= 1) {
	        percent = 0.99;
	      } else if (percent <= -1) {
	        percent = -0.99;
	      }
	      var dist = rad * percent;
	      var x = Math.cos(ang + itemData.a.v) * dist + pt1[0];
	      var y = Math.sin(ang + itemData.a.v) * dist + pt1[1];
	      grd = ctx.createRadialGradient(x, y, 0, pt1[0], pt1[1], rad);
	    }

	    var i;
	    var len = styleData.g.p;
	    var cValues = itemData.g.c;
	    var opacity = 1;

	    for (i = 0; i < len; i += 1) {
	      if (itemData.g._hasOpacity && itemData.g._collapsable) {
	        opacity = itemData.g.o[i * 2 + 1];
	      }
	      grd.addColorStop(cValues[i * 4] / 100, 'rgba(' + cValues[i * 4 + 1] + ',' + cValues[i * 4 + 2] + ',' + cValues[i * 4 + 3] + ',' + opacity + ')');
	    }
	    styleElem.grd = grd;
	  }
	  styleElem.coOp = itemData.o.v * groupTransform.opacity;
	};

	CVShapeElement.prototype.renderStroke = function (styleData, itemData, groupTransform) {
	  var styleElem = itemData.style;
	  var d = itemData.d;
	  if (d && (d._mdf || this._isFirstFrame)) {
	    styleElem.da = d.dashArray;
	    styleElem.do = d.dashoffset[0];
	  }
	  if (itemData.c._mdf || this._isFirstFrame) {
	    styleElem.co = 'rgb(' + bmFloor(itemData.c.v[0]) + ',' + bmFloor(itemData.c.v[1]) + ',' + bmFloor(itemData.c.v[2]) + ')';
	  }
	  if (itemData.o._mdf || groupTransform._opMdf || this._isFirstFrame) {
	    styleElem.coOp = itemData.o.v * groupTransform.opacity;
	  }
	  if (itemData.w._mdf || this._isFirstFrame) {
	    styleElem.wi = itemData.w.v;
	  }
	};

	CVShapeElement.prototype.destroy = function () {
	  this.shapesData = null;
	  this.globalData = null;
	  this.canvasContext = null;
	  this.stylesList.length = 0;
	  this.itemsData.length = 0;
	};

	/* global extendPrototype, BaseElement, TransformElement, CVBaseElement, HierarchyElement, FrameElement, RenderableElement,
	SVGShapeElement, IImageElement */

	function CVSolidElement(data, globalData, comp) {
	  this.initElement(data, globalData, comp);
	}
	extendPrototype([BaseElement, TransformElement, CVBaseElement, HierarchyElement, FrameElement, RenderableElement], CVSolidElement);

	CVSolidElement.prototype.initElement = SVGShapeElement.prototype.initElement;
	CVSolidElement.prototype.prepareFrame = IImageElement.prototype.prepareFrame;

	CVSolidElement.prototype.renderInnerContent = function () {
	  var ctx = this.canvasContext;
	  ctx.fillStyle = this.data.sc;
	  ctx.fillRect(0, 0, this.data.sw, this.data.sh);
	  //
	};

	/* global extendPrototype, BaseElement, TransformElement, CVBaseElement, HierarchyElement, FrameElement,
	RenderableElement, ITextElement, createTag, createSizedArray */

	function CVTextElement(data, globalData, comp) {
	  this.textSpans = [];
	  this.yOffset = 0;
	  this.fillColorAnim = false;
	  this.strokeColorAnim = false;
	  this.strokeWidthAnim = false;
	  this.stroke = false;
	  this.fill = false;
	  this.justifyOffset = 0;
	  this.currentRender = null;
	  this.renderType = 'canvas';
	  this.values = {
	    fill: 'rgba(0,0,0,0)',
	    stroke: 'rgba(0,0,0,0)',
	    sWidth: 0,
	    fValue: '',
	  };
	  this.initElement(data, globalData, comp);
	}
	extendPrototype([BaseElement, TransformElement, CVBaseElement, HierarchyElement, FrameElement, RenderableElement, ITextElement], CVTextElement);

	CVTextElement.prototype.tHelper = createTag('canvas').getContext('2d');

	CVTextElement.prototype.buildNewText = function () {
	  var documentData = this.textProperty.currentData;
	  this.renderedLetters = createSizedArray(documentData.l ? documentData.l.length : 0);

	  var hasFill = false;
	  if (documentData.fc) {
	    hasFill = true;
	    this.values.fill = this.buildColor(documentData.fc);
	  } else {
	    this.values.fill = 'rgba(0,0,0,0)';
	  }
	  this.fill = hasFill;
	  var hasStroke = false;
	  if (documentData.sc) {
	    hasStroke = true;
	    this.values.stroke = this.buildColor(documentData.sc);
	    this.values.sWidth = documentData.sw;
	  }
	  var fontData = this.globalData.fontManager.getFontByName(documentData.f);
	  var i;
	  var len;
	  var letters = documentData.l;
	  var matrixHelper = this.mHelper;
	  this.stroke = hasStroke;
	  this.values.fValue = documentData.finalSize + 'px ' + this.globalData.fontManager.getFontByName(documentData.f).fFamily;
	  len = documentData.finalText.length;
	  // this.tHelper.font = this.values.fValue;
	  var charData;
	  var shapeData;
	  var k;
	  var kLen;
	  var shapes;
	  var j;
	  var jLen;
	  var pathNodes;
	  var commands;
	  var pathArr;
	  var singleShape = this.data.singleShape;
	  var trackingOffset = documentData.tr * 0.001 * documentData.finalSize;
	  var xPos = 0;
	  var yPos = 0;
	  var firstLine = true;
	  var cnt = 0;
	  for (i = 0; i < len; i += 1) {
	    charData = this.globalData.fontManager.getCharData(documentData.finalText[i], fontData.fStyle, this.globalData.fontManager.getFontByName(documentData.f).fFamily);
	    shapeData = (charData && charData.data) || {};
	    matrixHelper.reset();
	    if (singleShape && letters[i].n) {
	      xPos = -trackingOffset;
	      yPos += documentData.yOffset;
	      yPos += firstLine ? 1 : 0;
	      firstLine = false;
	    }

	    shapes = shapeData.shapes ? shapeData.shapes[0].it : [];
	    jLen = shapes.length;
	    matrixHelper.scale(documentData.finalSize / 100, documentData.finalSize / 100);
	    if (singleShape) {
	      this.applyTextPropertiesToMatrix(documentData, matrixHelper, letters[i].line, xPos, yPos);
	    }
	    commands = createSizedArray(jLen);
	    for (j = 0; j < jLen; j += 1) {
	      kLen = shapes[j].ks.k.i.length;
	      pathNodes = shapes[j].ks.k;
	      pathArr = [];
	      for (k = 1; k < kLen; k += 1) {
	        if (k === 1) {
	          pathArr.push(matrixHelper.applyToX(pathNodes.v[0][0], pathNodes.v[0][1], 0), matrixHelper.applyToY(pathNodes.v[0][0], pathNodes.v[0][1], 0));
	        }
	        pathArr.push(matrixHelper.applyToX(pathNodes.o[k - 1][0], pathNodes.o[k - 1][1], 0), matrixHelper.applyToY(pathNodes.o[k - 1][0], pathNodes.o[k - 1][1], 0), matrixHelper.applyToX(pathNodes.i[k][0], pathNodes.i[k][1], 0), matrixHelper.applyToY(pathNodes.i[k][0], pathNodes.i[k][1], 0), matrixHelper.applyToX(pathNodes.v[k][0], pathNodes.v[k][1], 0), matrixHelper.applyToY(pathNodes.v[k][0], pathNodes.v[k][1], 0));
	      }
	      pathArr.push(matrixHelper.applyToX(pathNodes.o[k - 1][0], pathNodes.o[k - 1][1], 0), matrixHelper.applyToY(pathNodes.o[k - 1][0], pathNodes.o[k - 1][1], 0), matrixHelper.applyToX(pathNodes.i[0][0], pathNodes.i[0][1], 0), matrixHelper.applyToY(pathNodes.i[0][0], pathNodes.i[0][1], 0), matrixHelper.applyToX(pathNodes.v[0][0], pathNodes.v[0][1], 0), matrixHelper.applyToY(pathNodes.v[0][0], pathNodes.v[0][1], 0));
	      commands[j] = pathArr;
	    }
	    if (singleShape) {
	      xPos += letters[i].l;
	      xPos += trackingOffset;
	    }
	    if (this.textSpans[cnt]) {
	      this.textSpans[cnt].elem = commands;
	    } else {
	      this.textSpans[cnt] = { elem: commands };
	    }
	    cnt += 1;
	  }
	};

	CVTextElement.prototype.renderInnerContent = function () {
	  var ctx = this.canvasContext;
	  ctx.font = this.values.fValue;
	  ctx.lineCap = 'butt';
	  ctx.lineJoin = 'miter';
	  ctx.miterLimit = 4;

	  if (!this.data.singleShape) {
	    this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag);
	  }

	  var i;
	  var len;
	  var j;
	  var jLen;
	  var k;
	  var kLen;
	  var renderedLetters = this.textAnimator.renderedLetters;

	  var letters = this.textProperty.currentData.l;

	  len = letters.length;
	  var renderedLetter;
	  var lastFill = null;
	  var lastStroke = null;
	  var lastStrokeW = null;
	  var commands;
	  var pathArr;
	  for (i = 0; i < len; i += 1) {
	    if (!letters[i].n) {
	      renderedLetter = renderedLetters[i];
	      if (renderedLetter) {
	        this.globalData.renderer.save();
	        this.globalData.renderer.ctxTransform(renderedLetter.p);
	        this.globalData.renderer.ctxOpacity(renderedLetter.o);
	      }
	      if (this.fill) {
	        if (renderedLetter && renderedLetter.fc) {
	          if (lastFill !== renderedLetter.fc) {
	            lastFill = renderedLetter.fc;
	            ctx.fillStyle = renderedLetter.fc;
	          }
	        } else if (lastFill !== this.values.fill) {
	          lastFill = this.values.fill;
	          ctx.fillStyle = this.values.fill;
	        }
	        commands = this.textSpans[i].elem;
	        jLen = commands.length;
	        this.globalData.canvasContext.beginPath();
	        for (j = 0; j < jLen; j += 1) {
	          pathArr = commands[j];
	          kLen = pathArr.length;
	          this.globalData.canvasContext.moveTo(pathArr[0], pathArr[1]);
	          for (k = 2; k < kLen; k += 6) {
	            this.globalData.canvasContext.bezierCurveTo(pathArr[k], pathArr[k + 1], pathArr[k + 2], pathArr[k + 3], pathArr[k + 4], pathArr[k + 5]);
	          }
	        }
	        this.globalData.canvasContext.closePath();
	        this.globalData.canvasContext.fill();
	        /// ctx.fillText(this.textSpans[i].val,0,0);
	      }
	      if (this.stroke) {
	        if (renderedLetter && renderedLetter.sw) {
	          if (lastStrokeW !== renderedLetter.sw) {
	            lastStrokeW = renderedLetter.sw;
	            ctx.lineWidth = renderedLetter.sw;
	          }
	        } else if (lastStrokeW !== this.values.sWidth) {
	          lastStrokeW = this.values.sWidth;
	          ctx.lineWidth = this.values.sWidth;
	        }
	        if (renderedLetter && renderedLetter.sc) {
	          if (lastStroke !== renderedLetter.sc) {
	            lastStroke = renderedLetter.sc;
	            ctx.strokeStyle = renderedLetter.sc;
	          }
	        } else if (lastStroke !== this.values.stroke) {
	          lastStroke = this.values.stroke;
	          ctx.strokeStyle = this.values.stroke;
	        }
	        commands = this.textSpans[i].elem;
	        jLen = commands.length;
	        this.globalData.canvasContext.beginPath();
	        for (j = 0; j < jLen; j += 1) {
	          pathArr = commands[j];
	          kLen = pathArr.length;
	          this.globalData.canvasContext.moveTo(pathArr[0], pathArr[1]);
	          for (k = 2; k < kLen; k += 6) {
	            this.globalData.canvasContext.bezierCurveTo(pathArr[k], pathArr[k + 1], pathArr[k + 2], pathArr[k + 3], pathArr[k + 4], pathArr[k + 5]);
	          }
	        }
	        this.globalData.canvasContext.closePath();
	        this.globalData.canvasContext.stroke();
	        /// ctx.strokeText(letters[i].val,0,0);
	      }
	      if (renderedLetter) {
	        this.globalData.renderer.restore();
	      }
	    }
	  }
	};

	function CVEffects() {

	}
	CVEffects.prototype.renderFrame = function () {};

	/* global createTag, createNS, styleDiv, CVEffects, MaskElement, SVGBaseElement, HybridRenderer */

	function HBaseElement() {}
	HBaseElement.prototype = {
	  checkBlendMode: function () {},
	  initRendererElement: function () {
	    this.baseElement = createTag(this.data.tg || 'div');
	    if (this.data.hasMask) {
	      this.svgElement = createNS('svg');
	      this.layerElement = createNS('g');
	      this.maskedElement = this.layerElement;
	      this.svgElement.appendChild(this.layerElement);
	      this.baseElement.appendChild(this.svgElement);
	    } else {
	      this.layerElement = this.baseElement;
	    }
	    styleDiv(this.baseElement);
	  },
	  createContainerElements: function () {
	    this.renderableEffectsManager = new CVEffects(this);
	    this.transformedElement = this.baseElement;
	    this.maskedElement = this.layerElement;
	    if (this.data.ln) {
	      this.layerElement.setAttribute('id', this.data.ln);
	    }
	    if (this.data.cl) {
	      this.layerElement.setAttribute('class', this.data.cl);
	    }
	    if (this.data.bm !== 0) {
	      this.setBlendMode();
	    }
	  },
	  renderElement: function () {
	    var transformedElementStyle = this.transformedElement ? this.transformedElement.style : {};
	    if (this.finalTransform._matMdf) {
	      var matrixValue = this.finalTransform.mat.toCSS();
	      transformedElementStyle.transform = matrixValue;
	      transformedElementStyle.webkitTransform = matrixValue;
	    }
	    if (this.finalTransform._opMdf) {
	      transformedElementStyle.opacity = this.finalTransform.mProp.o.v;
	    }
	  },
	  renderFrame: function () {
	    // If it is exported as hidden (data.hd === true) no need to render
	    // If it is not visible no need to render
	    if (this.data.hd || this.hidden) {
	      return;
	    }
	    this.renderTransform();
	    this.renderRenderable();
	    this.renderElement();
	    this.renderInnerContent();
	    if (this._isFirstFrame) {
	      this._isFirstFrame = false;
	    }
	  },
	  destroy: function () {
	    this.layerElement = null;
	    this.transformedElement = null;
	    if (this.matteElement) {
	      this.matteElement = null;
	    }
	    if (this.maskManager) {
	      this.maskManager.destroy();
	      this.maskManager = null;
	    }
	  },
	  createRenderableComponents: function () {
	    this.maskManager = new MaskElement(this.data, this, this.globalData);
	  },
	  addEffects: function () {
	  },
	  setMatte: function () {},
	};
	HBaseElement.prototype.getBaseElement = SVGBaseElement.prototype.getBaseElement;
	HBaseElement.prototype.destroyBaseElement = HBaseElement.prototype.destroy;
	HBaseElement.prototype.buildElementParenting = HybridRenderer.prototype.buildElementParenting;

	/* global extendPrototype, BaseElement, TransformElement, HBaseElement, HierarchyElement, FrameElement,
	RenderableDOMElement, createNS, createTag */

	function HSolidElement(data, globalData, comp) {
	  this.initElement(data, globalData, comp);
	}
	extendPrototype([BaseElement, TransformElement, HBaseElement, HierarchyElement, FrameElement, RenderableDOMElement], HSolidElement);

	HSolidElement.prototype.createContent = function () {
	  var rect;
	  if (this.data.hasMask) {
	    rect = createNS('rect');
	    rect.setAttribute('width', this.data.sw);
	    rect.setAttribute('height', this.data.sh);
	    rect.setAttribute('fill', this.data.sc);
	    this.svgElement.setAttribute('width', this.data.sw);
	    this.svgElement.setAttribute('height', this.data.sh);
	  } else {
	    rect = createTag('div');
	    rect.style.width = this.data.sw + 'px';
	    rect.style.height = this.data.sh + 'px';
	    rect.style.backgroundColor = this.data.sc;
	  }
	  this.layerElement.appendChild(rect);
	};

	/* global createSizedArray, PropertyFactory, extendPrototype, HybridRenderer, ICompElement, HBaseElement */

	function HCompElement(data, globalData, comp) {
	  this.layers = data.layers;
	  this.supports3d = !data.hasMask;
	  this.completeLayers = false;
	  this.pendingElements = [];
	  this.elements = this.layers ? createSizedArray(this.layers.length) : [];
	  this.initElement(data, globalData, comp);
	  this.tm = data.tm ? PropertyFactory.getProp(this, data.tm, 0, globalData.frameRate, this) : { _placeholder: true };
	}

	extendPrototype([HybridRenderer, ICompElement, HBaseElement], HCompElement);
	HCompElement.prototype._createBaseContainerElements = HCompElement.prototype.createContainerElements;

	HCompElement.prototype.createContainerElements = function () {
	  this._createBaseContainerElements();
	  // divElement.style.clip = 'rect(0px, '+this.data.w+'px, '+this.data.h+'px, 0px)';
	  if (this.data.hasMask) {
	    this.svgElement.setAttribute('width', this.data.w);
	    this.svgElement.setAttribute('height', this.data.h);
	    this.transformedElement = this.baseElement;
	  } else {
	    this.transformedElement = this.layerElement;
	  }
	};

	HCompElement.prototype.addTo3dContainer = function (elem, pos) {
	  var j = 0;
	  var nextElement;
	  while (j < pos) {
	    if (this.elements[j] && this.elements[j].getBaseElement) {
	      nextElement = this.elements[j].getBaseElement();
	    }
	    j += 1;
	  }
	  if (nextElement) {
	    this.layerElement.insertBefore(elem, nextElement);
	  } else {
	    this.layerElement.appendChild(elem);
	  }
	};

	/* global createNS, extendPrototype, BaseElement, TransformElement, HSolidElement, SVGShapeElement, HBaseElement,
	HierarchyElement, FrameElement, RenderableElement, createNS, bmMin, bmSqrt, bmMin, bmMax, bmPow */

	function HShapeElement(data, globalData, comp) {
	  // List of drawable elements
	  this.shapes = [];
	  // Full shape data
	  this.shapesData = data.shapes;
	  // List of styles that will be applied to shapes
	  this.stylesList = [];
	  // List of modifiers that will be applied to shapes
	  this.shapeModifiers = [];
	  // List of items in shape tree
	  this.itemsData = [];
	  // List of items in previous shape tree
	  this.processedElements = [];
	  // List of animated components
	  this.animatedContents = [];
	  this.shapesContainer = createNS('g');
	  this.initElement(data, globalData, comp);
	  // Moving any property that doesn't get too much access after initialization because of v8 way of handling more than 10 properties.
	  // List of elements that have been created
	  this.prevViewData = [];
	  this.currentBBox = {
	    x: 999999,
	    y: -999999,
	    h: 0,
	    w: 0,
	  };
	}
	extendPrototype([BaseElement, TransformElement, HSolidElement, SVGShapeElement, HBaseElement, HierarchyElement, FrameElement, RenderableElement], HShapeElement);
	HShapeElement.prototype._renderShapeFrame = HShapeElement.prototype.renderInnerContent;

	HShapeElement.prototype.createContent = function () {
	  var cont;
	  this.baseElement.style.fontSize = 0;
	  if (this.data.hasMask) {
	    this.layerElement.appendChild(this.shapesContainer);
	    cont = this.svgElement;
	  } else {
	    cont = createNS('svg');
	    var size = this.comp.data ? this.comp.data : this.globalData.compSize;
	    cont.setAttribute('width', size.w);
	    cont.setAttribute('height', size.h);
	    cont.appendChild(this.shapesContainer);
	    this.layerElement.appendChild(cont);
	  }

	  this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, this.shapesContainer, 0, [], true);
	  this.filterUniqueShapes();
	  this.shapeCont = cont;
	};

	HShapeElement.prototype.getTransformedPoint = function (transformers, point) {
	  var i;
	  var len = transformers.length;
	  for (i = 0; i < len; i += 1) {
	    point = transformers[i].mProps.v.applyToPointArray(point[0], point[1], 0);
	  }
	  return point;
	};

	HShapeElement.prototype.calculateShapeBoundingBox = function (item, boundingBox) {
	  var shape = item.sh.v;
	  var transformers = item.transformers;
	  var i;
	  var len = shape._length;
	  var vPoint;
	  var oPoint;
	  var nextIPoint;
	  var nextVPoint;
	  if (len <= 1) {
	    return;
	  }
	  for (i = 0; i < len - 1; i += 1) {
	    vPoint = this.getTransformedPoint(transformers, shape.v[i]);
	    oPoint = this.getTransformedPoint(transformers, shape.o[i]);
	    nextIPoint = this.getTransformedPoint(transformers, shape.i[i + 1]);
	    nextVPoint = this.getTransformedPoint(transformers, shape.v[i + 1]);
	    this.checkBounds(vPoint, oPoint, nextIPoint, nextVPoint, boundingBox);
	  }
	  if (shape.c) {
	    vPoint = this.getTransformedPoint(transformers, shape.v[i]);
	    oPoint = this.getTransformedPoint(transformers, shape.o[i]);
	    nextIPoint = this.getTransformedPoint(transformers, shape.i[0]);
	    nextVPoint = this.getTransformedPoint(transformers, shape.v[0]);
	    this.checkBounds(vPoint, oPoint, nextIPoint, nextVPoint, boundingBox);
	  }
	};

	HShapeElement.prototype.checkBounds = function (vPoint, oPoint, nextIPoint, nextVPoint, boundingBox) {
	  this.getBoundsOfCurve(vPoint, oPoint, nextIPoint, nextVPoint);
	  var bounds = this.shapeBoundingBox;
	  boundingBox.x = bmMin(bounds.left, boundingBox.x);
	  boundingBox.xMax = bmMax(bounds.right, boundingBox.xMax);
	  boundingBox.y = bmMin(bounds.top, boundingBox.y);
	  boundingBox.yMax = bmMax(bounds.bottom, boundingBox.yMax);
	};

	HShapeElement.prototype.shapeBoundingBox = {
	  left: 0,
	  right: 0,
	  top: 0,
	  bottom: 0,
	};

	HShapeElement.prototype.tempBoundingBox = {
	  x: 0,
	  xMax: 0,
	  y: 0,
	  yMax: 0,
	  width: 0,
	  height: 0,
	};

	HShapeElement.prototype.getBoundsOfCurve = function (p0, p1, p2, p3) {
	  var bounds = [[p0[0], p3[0]], [p0[1], p3[1]]];

	  for (var a, b, c, t, b2ac, t1, t2, i = 0; i < 2; ++i) { // eslint-disable-line no-plusplus
	    b = 6 * p0[i] - 12 * p1[i] + 6 * p2[i];
	    a = -3 * p0[i] + 9 * p1[i] - 9 * p2[i] + 3 * p3[i];
	    c = 3 * p1[i] - 3 * p0[i];

	    b |= 0; // eslint-disable-line no-bitwise
	    a |= 0; // eslint-disable-line no-bitwise
	    c |= 0; // eslint-disable-line no-bitwise

	    if (a === 0 && b === 0) {
	      //
	    } else if (a === 0) {
	      t = -c / b;

	      if (t > 0 && t < 1) {
	        bounds[i].push(this.calculateF(t, p0, p1, p2, p3, i));
	      }
	    } else {
	      b2ac = b * b - 4 * c * a;

	      if (b2ac >= 0) {
	        t1 = (-b + bmSqrt(b2ac)) / (2 * a);
	        if (t1 > 0 && t1 < 1) bounds[i].push(this.calculateF(t1, p0, p1, p2, p3, i));
	        t2 = (-b - bmSqrt(b2ac)) / (2 * a);
	        if (t2 > 0 && t2 < 1) bounds[i].push(this.calculateF(t2, p0, p1, p2, p3, i));
	      }
	    }
	  }

	  this.shapeBoundingBox.left = bmMin.apply(null, bounds[0]);
	  this.shapeBoundingBox.top = bmMin.apply(null, bounds[1]);
	  this.shapeBoundingBox.right = bmMax.apply(null, bounds[0]);
	  this.shapeBoundingBox.bottom = bmMax.apply(null, bounds[1]);
	};

	HShapeElement.prototype.calculateF = function (t, p0, p1, p2, p3, i) {
	  return bmPow(1 - t, 3) * p0[i]
	        + 3 * bmPow(1 - t, 2) * t * p1[i]
	        + 3 * (1 - t) * bmPow(t, 2) * p2[i]
	        + bmPow(t, 3) * p3[i];
	};

	HShapeElement.prototype.calculateBoundingBox = function (itemsData, boundingBox) {
	  var i;
	  var len = itemsData.length;
	  for (i = 0; i < len; i += 1) {
	    if (itemsData[i] && itemsData[i].sh) {
	      this.calculateShapeBoundingBox(itemsData[i], boundingBox);
	    } else if (itemsData[i] && itemsData[i].it) {
	      this.calculateBoundingBox(itemsData[i].it, boundingBox);
	    }
	  }
	};

	HShapeElement.prototype.currentBoxContains = function (box) {
	  return this.currentBBox.x <= box.x
	    && this.currentBBox.y <= box.y
	    && this.currentBBox.width + this.currentBBox.x >= box.x + box.width
	    && this.currentBBox.height + this.currentBBox.y >= box.y + box.height;
	};

	HShapeElement.prototype.renderInnerContent = function () {
	  this._renderShapeFrame();

	  if (!this.hidden && (this._isFirstFrame || this._mdf)) {
	    var tempBoundingBox = this.tempBoundingBox;
	    var max = 999999;
	    tempBoundingBox.x = max;
	    tempBoundingBox.xMax = -max;
	    tempBoundingBox.y = max;
	    tempBoundingBox.yMax = -max;
	    this.calculateBoundingBox(this.itemsData, tempBoundingBox);
	    tempBoundingBox.width = tempBoundingBox.xMax < tempBoundingBox.x ? 0 : tempBoundingBox.xMax - tempBoundingBox.x;
	    tempBoundingBox.height = tempBoundingBox.yMax < tempBoundingBox.y ? 0 : tempBoundingBox.yMax - tempBoundingBox.y;
	    // var tempBoundingBox = this.shapeCont.getBBox();
	    if (this.currentBoxContains(tempBoundingBox)) {
	      return;
	    }
	    var changed = false;
	    if (this.currentBBox.w !== tempBoundingBox.width) {
	      this.currentBBox.w = tempBoundingBox.width;
	      this.shapeCont.setAttribute('width', tempBoundingBox.width);
	      changed = true;
	    }
	    if (this.currentBBox.h !== tempBoundingBox.height) {
	      this.currentBBox.h = tempBoundingBox.height;
	      this.shapeCont.setAttribute('height', tempBoundingBox.height);
	      changed = true;
	    }
	    if (changed || this.currentBBox.x !== tempBoundingBox.x || this.currentBBox.y !== tempBoundingBox.y) {
	      this.currentBBox.w = tempBoundingBox.width;
	      this.currentBBox.h = tempBoundingBox.height;
	      this.currentBBox.x = tempBoundingBox.x;
	      this.currentBBox.y = tempBoundingBox.y;

	      this.shapeCont.setAttribute('viewBox', this.currentBBox.x + ' ' + this.currentBBox.y + ' ' + this.currentBBox.w + ' ' + this.currentBBox.h);
	      var shapeStyle = this.shapeCont.style;
	      var shapeTransform = 'translate(' + this.currentBBox.x + 'px,' + this.currentBBox.y + 'px)';
	      shapeStyle.transform = shapeTransform;
	      shapeStyle.webkitTransform = shapeTransform;
	    }
	  }
	};

	/* global extendPrototype, BaseElement, TransformElement, HBaseElement, HierarchyElement, FrameElement,
	RenderableDOMElement, ITextElement, createSizedArray, createTag, styleDiv, createNS, lineJoinEnum, lineCapEnum */

	function HTextElement(data, globalData, comp) {
	  this.textSpans = [];
	  this.textPaths = [];
	  this.currentBBox = {
	    x: 999999,
	    y: -999999,
	    h: 0,
	    w: 0,
	  };
	  this.renderType = 'svg';
	  this.isMasked = false;
	  this.initElement(data, globalData, comp);
	}
	extendPrototype([BaseElement, TransformElement, HBaseElement, HierarchyElement, FrameElement, RenderableDOMElement, ITextElement], HTextElement);

	HTextElement.prototype.createContent = function () {
	  this.isMasked = this.checkMasks();
	  if (this.isMasked) {
	    this.renderType = 'svg';
	    this.compW = this.comp.data.w;
	    this.compH = this.comp.data.h;
	    this.svgElement.setAttribute('width', this.compW);
	    this.svgElement.setAttribute('height', this.compH);
	    var g = createNS('g');
	    this.maskedElement.appendChild(g);
	    this.innerElem = g;
	  } else {
	    this.renderType = 'html';
	    this.innerElem = this.layerElement;
	  }

	  this.checkParenting();
	};

	HTextElement.prototype.buildNewText = function () {
	  var documentData = this.textProperty.currentData;
	  this.renderedLetters = createSizedArray(documentData.l ? documentData.l.length : 0);
	  var innerElemStyle = this.innerElem.style;
	  var textColor = documentData.fc ? this.buildColor(documentData.fc) : 'rgba(0,0,0,0)';
	  innerElemStyle.fill = textColor;
	  innerElemStyle.color = textColor;
	  if (documentData.sc) {
	    innerElemStyle.stroke = this.buildColor(documentData.sc);
	    innerElemStyle.strokeWidth = documentData.sw + 'px';
	  }
	  var fontData = this.globalData.fontManager.getFontByName(documentData.f);
	  if (!this.globalData.fontManager.chars) {
	    innerElemStyle.fontSize = documentData.finalSize + 'px';
	    innerElemStyle.lineHeight = documentData.finalSize + 'px';
	    if (fontData.fClass) {
	      this.innerElem.className = fontData.fClass;
	    } else {
	      innerElemStyle.fontFamily = fontData.fFamily;
	      var fWeight = documentData.fWeight;
	      var fStyle = documentData.fStyle;
	      innerElemStyle.fontStyle = fStyle;
	      innerElemStyle.fontWeight = fWeight;
	    }
	  }
	  var i;
	  var len;

	  var letters = documentData.l;
	  len = letters.length;
	  var tSpan;
	  var tParent;
	  var tCont;
	  var matrixHelper = this.mHelper;
	  var shapes;
	  var shapeStr = '';
	  var cnt = 0;
	  for (i = 0; i < len; i += 1) {
	    if (this.globalData.fontManager.chars) {
	      if (!this.textPaths[cnt]) {
	        tSpan = createNS('path');
	        tSpan.setAttribute('stroke-linecap', lineCapEnum[1]);
	        tSpan.setAttribute('stroke-linejoin', lineJoinEnum[2]);
	        tSpan.setAttribute('stroke-miterlimit', '4');
	      } else {
	        tSpan = this.textPaths[cnt];
	      }
	      if (!this.isMasked) {
	        if (this.textSpans[cnt]) {
	          tParent = this.textSpans[cnt];
	          tCont = tParent.children[0];
	        } else {
	          tParent = createTag('div');
	          tParent.style.lineHeight = 0;
	          tCont = createNS('svg');
	          tCont.appendChild(tSpan);
	          styleDiv(tParent);
	        }
	      }
	    } else if (!this.isMasked) {
	      if (this.textSpans[cnt]) {
	        tParent = this.textSpans[cnt];
	        tSpan = this.textPaths[cnt];
	      } else {
	        tParent = createTag('span');
	        styleDiv(tParent);
	        tSpan = createTag('span');
	        styleDiv(tSpan);
	        tParent.appendChild(tSpan);
	      }
	    } else {
	      tSpan = this.textPaths[cnt] ? this.textPaths[cnt] : createNS('text');
	    }
	    // tSpan.setAttribute('visibility', 'hidden');
	    if (this.globalData.fontManager.chars) {
	      var charData = this.globalData.fontManager.getCharData(documentData.finalText[i], fontData.fStyle, this.globalData.fontManager.getFontByName(documentData.f).fFamily);
	      var shapeData;
	      if (charData) {
	        shapeData = charData.data;
	      } else {
	        shapeData = null;
	      }
	      matrixHelper.reset();
	      if (shapeData && shapeData.shapes) {
	        shapes = shapeData.shapes[0].it;
	        matrixHelper.scale(documentData.finalSize / 100, documentData.finalSize / 100);
	        shapeStr = this.createPathShape(matrixHelper, shapes);
	        tSpan.setAttribute('d', shapeStr);
	      }
	      if (!this.isMasked) {
	        this.innerElem.appendChild(tParent);
	        if (shapeData && shapeData.shapes) {
	          // document.body.appendChild is needed to get exact measure of shape
	          document.body.appendChild(tCont);
	          var boundingBox = tCont.getBBox();
	          tCont.setAttribute('width', boundingBox.width + 2);
	          tCont.setAttribute('height', boundingBox.height + 2);
	          tCont.setAttribute('viewBox', (boundingBox.x - 1) + ' ' + (boundingBox.y - 1) + ' ' + (boundingBox.width + 2) + ' ' + (boundingBox.height + 2));
	          var tContStyle = tCont.style;
	          var tContTranslation = 'translate(' + (boundingBox.x - 1) + 'px,' + (boundingBox.y - 1) + 'px)';
	          tContStyle.transform = tContTranslation;
	          tContStyle.webkitTransform = tContTranslation;

	          letters[i].yOffset = boundingBox.y - 1;
	        } else {
	          tCont.setAttribute('width', 1);
	          tCont.setAttribute('height', 1);
	        }
	        tParent.appendChild(tCont);
	      } else {
	        this.innerElem.appendChild(tSpan);
	      }
	    } else {
	      tSpan.textContent = letters[i].val;
	      tSpan.setAttributeNS('http://www.w3.org/XML/1998/namespace', 'xml:space', 'preserve');
	      if (!this.isMasked) {
	        this.innerElem.appendChild(tParent);
	        //
	        var tStyle = tSpan.style;
	        var tSpanTranslation = 'translate3d(0,' + -documentData.finalSize / 1.2 + 'px,0)';
	        tStyle.transform = tSpanTranslation;
	        tStyle.webkitTransform = tSpanTranslation;
	      } else {
	        this.innerElem.appendChild(tSpan);
	      }
	    }
	    //
	    if (!this.isMasked) {
	      this.textSpans[cnt] = tParent;
	    } else {
	      this.textSpans[cnt] = tSpan;
	    }
	    this.textSpans[cnt].style.display = 'block';
	    this.textPaths[cnt] = tSpan;
	    cnt += 1;
	  }
	  while (cnt < this.textSpans.length) {
	    this.textSpans[cnt].style.display = 'none';
	    cnt += 1;
	  }
	};

	HTextElement.prototype.renderInnerContent = function () {
	  var svgStyle;
	  if (this.data.singleShape) {
	    if (!this._isFirstFrame && !this.lettersChangedFlag) {
	      return;
	    } if (this.isMasked && this.finalTransform._matMdf) {
	      // Todo Benchmark if using this is better than getBBox
	      this.svgElement.setAttribute('viewBox', -this.finalTransform.mProp.p.v[0] + ' ' + -this.finalTransform.mProp.p.v[1] + ' ' + this.compW + ' ' + this.compH);
	      svgStyle = this.svgElement.style;
	      var translation = 'translate(' + -this.finalTransform.mProp.p.v[0] + 'px,' + -this.finalTransform.mProp.p.v[1] + 'px)';
	      svgStyle.transform = translation;
	      svgStyle.webkitTransform = translation;
	    }
	  }

	  this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag);
	  if (!this.lettersChangedFlag && !this.textAnimator.lettersChangedFlag) {
	    return;
	  }
	  var i;
	  var len;
	  var count = 0;
	  var renderedLetters = this.textAnimator.renderedLetters;

	  var letters = this.textProperty.currentData.l;

	  len = letters.length;
	  var renderedLetter;
	  var textSpan;
	  var textPath;
	  for (i = 0; i < len; i += 1) {
	    if (letters[i].n) {
	      count += 1;
	    } else {
	      textSpan = this.textSpans[i];
	      textPath = this.textPaths[i];
	      renderedLetter = renderedLetters[count];
	      count += 1;
	      if (renderedLetter._mdf.m) {
	        if (!this.isMasked) {
	          textSpan.style.webkitTransform = renderedLetter.m;
	          textSpan.style.transform = renderedLetter.m;
	        } else {
	          textSpan.setAttribute('transform', renderedLetter.m);
	        }
	      }
	      /// /textSpan.setAttribute('opacity',renderedLetter.o);
	      textSpan.style.opacity = renderedLetter.o;
	      if (renderedLetter.sw && renderedLetter._mdf.sw) {
	        textPath.setAttribute('stroke-width', renderedLetter.sw);
	      }
	      if (renderedLetter.sc && renderedLetter._mdf.sc) {
	        textPath.setAttribute('stroke', renderedLetter.sc);
	      }
	      if (renderedLetter.fc && renderedLetter._mdf.fc) {
	        textPath.setAttribute('fill', renderedLetter.fc);
	        textPath.style.color = renderedLetter.fc;
	      }
	    }
	  }

	  if (this.innerElem.getBBox && !this.hidden && (this._isFirstFrame || this._mdf)) {
	    var boundingBox = this.innerElem.getBBox();

	    if (this.currentBBox.w !== boundingBox.width) {
	      this.currentBBox.w = boundingBox.width;
	      this.svgElement.setAttribute('width', boundingBox.width);
	    }
	    if (this.currentBBox.h !== boundingBox.height) {
	      this.currentBBox.h = boundingBox.height;
	      this.svgElement.setAttribute('height', boundingBox.height);
	    }

	    var margin = 1;
	    if (this.currentBBox.w !== (boundingBox.width + margin * 2) || this.currentBBox.h !== (boundingBox.height + margin * 2) || this.currentBBox.x !== (boundingBox.x - margin) || this.currentBBox.y !== (boundingBox.y - margin)) {
	      this.currentBBox.w = boundingBox.width + margin * 2;
	      this.currentBBox.h = boundingBox.height + margin * 2;
	      this.currentBBox.x = boundingBox.x - margin;
	      this.currentBBox.y = boundingBox.y - margin;

	      this.svgElement.setAttribute('viewBox', this.currentBBox.x + ' ' + this.currentBBox.y + ' ' + this.currentBBox.w + ' ' + this.currentBBox.h);
	      svgStyle = this.svgElement.style;
	      var svgTransform = 'translate(' + this.currentBBox.x + 'px,' + this.currentBBox.y + 'px)';
	      svgStyle.transform = svgTransform;
	      svgStyle.webkitTransform = svgTransform;
	    }
	  }
	};

	/* global extendPrototype, BaseElement, TransformElement, HBaseElement, HSolidElement, HierarchyElement,
	FrameElement, RenderableElement, createNS */

	function HImageElement(data, globalData, comp) {
	  this.assetData = globalData.getAssetData(data.refId);
	  this.initElement(data, globalData, comp);
	}

	extendPrototype([BaseElement, TransformElement, HBaseElement, HSolidElement, HierarchyElement, FrameElement, RenderableElement], HImageElement);

	HImageElement.prototype.createContent = function () {
	  var assetPath = this.globalData.getAssetsPath(this.assetData);
	  var img = new Image();

	  if (this.data.hasMask) {
	    this.imageElem = createNS('image');
	    this.imageElem.setAttribute('width', this.assetData.w + 'px');
	    this.imageElem.setAttribute('height', this.assetData.h + 'px');
	    this.imageElem.setAttributeNS('http://www.w3.org/1999/xlink', 'href', assetPath);
	    this.layerElement.appendChild(this.imageElem);
	    this.baseElement.setAttribute('width', this.assetData.w);
	    this.baseElement.setAttribute('height', this.assetData.h);
	  } else {
	    this.layerElement.appendChild(img);
	  }
	  img.crossOrigin = 'anonymous';
	  img.src = assetPath;
	  if (this.data.ln) {
	    this.baseElement.setAttribute('id', this.data.ln);
	  }
	};

	/* global PropertyFactory, degToRads, Matrix, extendPrototype, BaseElement, FrameElement, HierarchyElement */

	function HCameraElement(data, globalData, comp) {
	  this.initFrame();
	  this.initBaseData(data, globalData, comp);
	  this.initHierarchy();
	  var getProp = PropertyFactory.getProp;
	  this.pe = getProp(this, data.pe, 0, 0, this);
	  if (data.ks.p.s) {
	    this.px = getProp(this, data.ks.p.x, 1, 0, this);
	    this.py = getProp(this, data.ks.p.y, 1, 0, this);
	    this.pz = getProp(this, data.ks.p.z, 1, 0, this);
	  } else {
	    this.p = getProp(this, data.ks.p, 1, 0, this);
	  }
	  if (data.ks.a) {
	    this.a = getProp(this, data.ks.a, 1, 0, this);
	  }
	  if (data.ks.or.k.length && data.ks.or.k[0].to) {
	    var i;
	    var len = data.ks.or.k.length;
	    for (i = 0; i < len; i += 1) {
	      data.ks.or.k[i].to = null;
	      data.ks.or.k[i].ti = null;
	    }
	  }
	  this.or = getProp(this, data.ks.or, 1, degToRads, this);
	  this.or.sh = true;
	  this.rx = getProp(this, data.ks.rx, 0, degToRads, this);
	  this.ry = getProp(this, data.ks.ry, 0, degToRads, this);
	  this.rz = getProp(this, data.ks.rz, 0, degToRads, this);
	  this.mat = new Matrix();
	  this._prevMat = new Matrix();
	  this._isFirstFrame = true;

	  // TODO: find a better way to make the HCamera element to be compatible with the LayerInterface and TransformInterface.
	  this.finalTransform = {
	    mProp: this,
	  };
	}
	extendPrototype([BaseElement, FrameElement, HierarchyElement], HCameraElement);

	HCameraElement.prototype.setup = function () {
	  var i;
	  var len = this.comp.threeDElements.length;
	  var comp;
	  var perspectiveStyle;
	  var containerStyle;
	  for (i = 0; i < len; i += 1) {
	    // [perspectiveElem,container]
	    comp = this.comp.threeDElements[i];
	    if (comp.type === '3d') {
	      perspectiveStyle = comp.perspectiveElem.style;
	      containerStyle = comp.container.style;
	      var perspective = this.pe.v + 'px';
	      var origin = '0px 0px 0px';
	      var matrix = 'matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)';
	      perspectiveStyle.perspective = perspective;
	      perspectiveStyle.webkitPerspective = perspective;
	      containerStyle.transformOrigin = origin;
	      containerStyle.mozTransformOrigin = origin;
	      containerStyle.webkitTransformOrigin = origin;
	      perspectiveStyle.transform = matrix;
	      perspectiveStyle.webkitTransform = matrix;
	    }
	  }
	};

	HCameraElement.prototype.createElements = function () {
	};

	HCameraElement.prototype.hide = function () {
	};

	HCameraElement.prototype.renderFrame = function () {
	  var _mdf = this._isFirstFrame;
	  var i;
	  var len;
	  if (this.hierarchy) {
	    len = this.hierarchy.length;
	    for (i = 0; i < len; i += 1) {
	      _mdf = this.hierarchy[i].finalTransform.mProp._mdf || _mdf;
	    }
	  }
	  if (_mdf || this.pe._mdf || (this.p && this.p._mdf) || (this.px && (this.px._mdf || this.py._mdf || this.pz._mdf)) || this.rx._mdf || this.ry._mdf || this.rz._mdf || this.or._mdf || (this.a && this.a._mdf)) {
	    this.mat.reset();

	    if (this.hierarchy) {
	      len = this.hierarchy.length - 1;
	      for (i = len; i >= 0; i -= 1) {
	        var mTransf = this.hierarchy[i].finalTransform.mProp;
	        this.mat.translate(-mTransf.p.v[0], -mTransf.p.v[1], mTransf.p.v[2]);
	        this.mat.rotateX(-mTransf.or.v[0]).rotateY(-mTransf.or.v[1]).rotateZ(mTransf.or.v[2]);
	        this.mat.rotateX(-mTransf.rx.v).rotateY(-mTransf.ry.v).rotateZ(mTransf.rz.v);
	        this.mat.scale(1 / mTransf.s.v[0], 1 / mTransf.s.v[1], 1 / mTransf.s.v[2]);
	        this.mat.translate(mTransf.a.v[0], mTransf.a.v[1], mTransf.a.v[2]);
	      }
	    }
	    if (this.p) {
	      this.mat.translate(-this.p.v[0], -this.p.v[1], this.p.v[2]);
	    } else {
	      this.mat.translate(-this.px.v, -this.py.v, this.pz.v);
	    }
	    if (this.a) {
	      var diffVector;
	      if (this.p) {
	        diffVector = [this.p.v[0] - this.a.v[0], this.p.v[1] - this.a.v[1], this.p.v[2] - this.a.v[2]];
	      } else {
	        diffVector = [this.px.v - this.a.v[0], this.py.v - this.a.v[1], this.pz.v - this.a.v[2]];
	      }
	      var mag = Math.sqrt(Math.pow(diffVector[0], 2) + Math.pow(diffVector[1], 2) + Math.pow(diffVector[2], 2));
	      // var lookDir = getNormalizedPoint(getDiffVector(this.a.v,this.p.v));
	      var lookDir = [diffVector[0] / mag, diffVector[1] / mag, diffVector[2] / mag];
	      var lookLengthOnXZ = Math.sqrt(lookDir[2] * lookDir[2] + lookDir[0] * lookDir[0]);
	      var mRotationX = (Math.atan2(lookDir[1], lookLengthOnXZ));
	      var mRotationY = (Math.atan2(lookDir[0], -lookDir[2]));
	      this.mat.rotateY(mRotationY).rotateX(-mRotationX);
	    }
	    this.mat.rotateX(-this.rx.v).rotateY(-this.ry.v).rotateZ(this.rz.v);
	    this.mat.rotateX(-this.or.v[0]).rotateY(-this.or.v[1]).rotateZ(this.or.v[2]);
	    this.mat.translate(this.globalData.compSize.w / 2, this.globalData.compSize.h / 2, 0);
	    this.mat.translate(0, 0, this.pe.v);

	    var hasMatrixChanged = !this._prevMat.equals(this.mat);
	    if ((hasMatrixChanged || this.pe._mdf) && this.comp.threeDElements) {
	      len = this.comp.threeDElements.length;
	      var comp;
	      var perspectiveStyle;
	      var containerStyle;
	      for (i = 0; i < len; i += 1) {
	        comp = this.comp.threeDElements[i];
	        if (comp.type === '3d') {
	          if (hasMatrixChanged) {
	            var matValue = this.mat.toCSS();
	            containerStyle = comp.container.style;
	            containerStyle.transform = matValue;
	            containerStyle.webkitTransform = matValue;
	          }
	          if (this.pe._mdf) {
	            perspectiveStyle = comp.perspectiveElem.style;
	            perspectiveStyle.perspective = this.pe.v + 'px';
	            perspectiveStyle.webkitPerspective = this.pe.v + 'px';
	          }
	        }
	      }
	      this.mat.clone(this._prevMat);
	    }
	  }
	  this._isFirstFrame = false;
	};

	HCameraElement.prototype.prepareFrame = function (num) {
	  this.prepareProperties(num, true);
	};

	HCameraElement.prototype.destroy = function () {
	};
	HCameraElement.prototype.getBaseElement = function () { return null; };

	function HEffects() {
	}
	HEffects.prototype.renderFrame = function () {};

	/* global createTag, AnimationItem */
	/* exported animationManager */

	var animationManager = (function () {
	  var moduleOb = {};
	  var registeredAnimations = [];
	  var initTime = 0;
	  var len = 0;
	  var playingAnimationsNum = 0;
	  var _stopped = true;
	  var _isFrozen = false;

	  function removeElement(ev) {
	    var i = 0;
	    var animItem = ev.target;
	    while (i < len) {
	      if (registeredAnimations[i].animation === animItem) {
	        registeredAnimations.splice(i, 1);
	        i -= 1;
	        len -= 1;
	        if (!animItem.isPaused) {
	          subtractPlayingCount();
	        }
	      }
	      i += 1;
	    }
	  }

	  function registerAnimation(element, animationData) {
	    if (!element) {
	      return null;
	    }
	    var i = 0;
	    while (i < len) {
	      if (registeredAnimations[i].elem === element && registeredAnimations[i].elem !== null) {
	        return registeredAnimations[i].animation;
	      }
	      i += 1;
	    }
	    var animItem = new AnimationItem();
	    setupAnimation(animItem, element);
	    animItem.setData(element, animationData);
	    return animItem;
	  }

	  function getRegisteredAnimations() {
	    var i;
	    var lenAnims = registeredAnimations.length;
	    var animations = [];
	    for (i = 0; i < lenAnims; i += 1) {
	      animations.push(registeredAnimations[i].animation);
	    }
	    return animations;
	  }

	  function addPlayingCount() {
	    playingAnimationsNum += 1;
	    activate();
	  }

	  function subtractPlayingCount() {
	    playingAnimationsNum -= 1;
	  }

	  function setupAnimation(animItem, element) {
	    animItem.addEventListener('destroy', removeElement);
	    animItem.addEventListener('_active', addPlayingCount);
	    animItem.addEventListener('_idle', subtractPlayingCount);
	    registeredAnimations.push({ elem: element, animation: animItem });
	    len += 1;
	  }

	  function loadAnimation(params) {
	    var animItem = new AnimationItem();
	    setupAnimation(animItem, null);
	    animItem.setParams(params);
	    return animItem;
	  }

	  function setSpeed(val, animation) {
	    var i;
	    for (i = 0; i < len; i += 1) {
	      registeredAnimations[i].animation.setSpeed(val, animation);
	    }
	  }

	  function setDirection(val, animation) {
	    var i;
	    for (i = 0; i < len; i += 1) {
	      registeredAnimations[i].animation.setDirection(val, animation);
	    }
	  }

	  function play(animation) {
	    var i;
	    for (i = 0; i < len; i += 1) {
	      registeredAnimations[i].animation.play(animation);
	    }
	  }
	  function resume(nowTime) {
	    var elapsedTime = nowTime - initTime;
	    var i;
	    for (i = 0; i < len; i += 1) {
	      registeredAnimations[i].animation.advanceTime(elapsedTime);
	    }
	    initTime = nowTime;
	    if (playingAnimationsNum && !_isFrozen) {
	      window.requestAnimationFrame(resume);
	    } else {
	      _stopped = true;
	    }
	  }

	  function first(nowTime) {
	    initTime = nowTime;
	    window.requestAnimationFrame(resume);
	  }

	  function pause(animation) {
	    var i;
	    for (i = 0; i < len; i += 1) {
	      registeredAnimations[i].animation.pause(animation);
	    }
	  }

	  function goToAndStop(value, isFrame, animation) {
	    var i;
	    for (i = 0; i < len; i += 1) {
	      registeredAnimations[i].animation.goToAndStop(value, isFrame, animation);
	    }
	  }

	  function stop(animation) {
	    var i;
	    for (i = 0; i < len; i += 1) {
	      registeredAnimations[i].animation.stop(animation);
	    }
	  }

	  function togglePause(animation) {
	    var i;
	    for (i = 0; i < len; i += 1) {
	      registeredAnimations[i].animation.togglePause(animation);
	    }
	  }

	  function destroy(animation) {
	    var i;
	    for (i = (len - 1); i >= 0; i -= 1) {
	      registeredAnimations[i].animation.destroy(animation);
	    }
	  }

	  function searchAnimations(animationData, standalone, renderer) {
	    var animElements = [].concat([].slice.call(document.getElementsByClassName('lottie')),
	      [].slice.call(document.getElementsByClassName('bodymovin')));
	    var i;
	    var lenAnims = animElements.length;
	    for (i = 0; i < lenAnims; i += 1) {
	      if (renderer) {
	        animElements[i].setAttribute('data-bm-type', renderer);
	      }
	      registerAnimation(animElements[i], animationData);
	    }
	    if (standalone && lenAnims === 0) {
	      if (!renderer) {
	        renderer = 'svg';
	      }
	      var body = document.getElementsByTagName('body')[0];
	      body.innerText = '';
	      var div = createTag('div');
	      div.style.width = '100%';
	      div.style.height = '100%';
	      div.setAttribute('data-bm-type', renderer);
	      body.appendChild(div);
	      registerAnimation(div, animationData);
	    }
	  }

	  function resize() {
	    var i;
	    for (i = 0; i < len; i += 1) {
	      registeredAnimations[i].animation.resize();
	    }
	  }

	  function activate() {
	    if (!_isFrozen && playingAnimationsNum) {
	      if (_stopped) {
	        window.requestAnimationFrame(first);
	        _stopped = false;
	      }
	    }
	  }

	  function freeze() {
	    _isFrozen = true;
	  }

	  function unfreeze() {
	    _isFrozen = false;
	    activate();
	  }

	  function setVolume(val, animation) {
	    var i;
	    for (i = 0; i < len; i += 1) {
	      registeredAnimations[i].animation.setVolume(val, animation);
	    }
	  }

	  function mute(animation) {
	    var i;
	    for (i = 0; i < len; i += 1) {
	      registeredAnimations[i].animation.mute(animation);
	    }
	  }

	  function unmute(animation) {
	    var i;
	    for (i = 0; i < len; i += 1) {
	      registeredAnimations[i].animation.unmute(animation);
	    }
	  }

	  moduleOb.registerAnimation = registerAnimation;
	  moduleOb.loadAnimation = loadAnimation;
	  moduleOb.setSpeed = setSpeed;
	  moduleOb.setDirection = setDirection;
	  moduleOb.play = play;
	  moduleOb.pause = pause;
	  moduleOb.stop = stop;
	  moduleOb.togglePause = togglePause;
	  moduleOb.searchAnimations = searchAnimations;
	  moduleOb.resize = resize;
	  // moduleOb.start = start;
	  moduleOb.goToAndStop = goToAndStop;
	  moduleOb.destroy = destroy;
	  moduleOb.freeze = freeze;
	  moduleOb.unfreeze = unfreeze;
	  moduleOb.setVolume = setVolume;
	  moduleOb.mute = mute;
	  moduleOb.unmute = unmute;
	  moduleOb.getRegisteredAnimations = getRegisteredAnimations;
	  return moduleOb;
	}());

	/* global createElementID, subframeEnabled, ProjectInterface, ImagePreloader, audioControllerFactory, extendPrototype, BaseEvent,
	CanvasRenderer, SVGRenderer, HybridRenderer, assetLoader, dataManager, expressionsPlugin, BMEnterFrameEvent, BMCompleteLoopEvent,
	BMCompleteEvent, BMSegmentStartEvent, BMDestroyEvent, BMEnterFrameEvent, BMCompleteLoopEvent, BMCompleteEvent, BMSegmentStartEvent,
	BMDestroyEvent, BMRenderFrameErrorEvent, BMConfigErrorEvent, markerParser */

	var AnimationItem = function () {
	  this._cbs = [];
	  this.name = '';
	  this.path = '';
	  this.isLoaded = false;
	  this.currentFrame = 0;
	  this.currentRawFrame = 0;
	  this.firstFrame = 0;
	  this.totalFrames = 0;
	  this.frameRate = 0;
	  this.frameMult = 0;
	  this.playSpeed = 1;
	  this.playDirection = 1;
	  this.playCount = 0;
	  this.animationData = {};
	  this.assets = [];
	  this.isPaused = true;
	  this.autoplay = false;
	  this.loop = true;
	  this.renderer = null;
	  this.animationID = createElementID();
	  this.assetsPath = '';
	  this.timeCompleted = 0;
	  this.segmentPos = 0;
	  this.isSubframeEnabled = subframeEnabled;
	  this.segments = [];
	  this._idle = true;
	  this._completedLoop = false;
	  this.projectInterface = ProjectInterface();
	  this.imagePreloader = new ImagePreloader();
	  this.audioController = audioControllerFactory();
	  this.markers = [];
	};

	extendPrototype([BaseEvent], AnimationItem);

	AnimationItem.prototype.setParams = function (params) {
	  if (params.wrapper || params.container) {
	    this.wrapper = params.wrapper || params.container;
	  }
	  var animType = 'svg';
	  if (params.animType) {
	    animType = params.animType;
	  } else if (params.renderer) {
	    animType = params.renderer;
	  }
	  switch (animType) {
	    case 'canvas':
	      this.renderer = new CanvasRenderer(this, params.rendererSettings);
	      break;
	    case 'svg':
	      this.renderer = new SVGRenderer(this, params.rendererSettings);
	      break;
	    default:
	      this.renderer = new HybridRenderer(this, params.rendererSettings);
	      break;
	  }
	  this.imagePreloader.setCacheType(animType, this.renderer.globalData.defs);
	  this.renderer.setProjectInterface(this.projectInterface);
	  this.animType = animType;
	  if (params.loop === ''
	        || params.loop === null
	        || params.loop === undefined
	        || params.loop === true) {
	    this.loop = true;
	  } else if (params.loop === false) {
	    this.loop = false;
	  } else {
	    this.loop = parseInt(params.loop, 10);
	  }
	  this.autoplay = 'autoplay' in params ? params.autoplay : true;
	  this.name = params.name ? params.name : '';
	  this.autoloadSegments = Object.prototype.hasOwnProperty.call(params, 'autoloadSegments') ? params.autoloadSegments : true;
	  this.assetsPath = params.assetsPath;
	  this.initialSegment = params.initialSegment;
	  if (params.audioFactory) {
	    this.audioController.setAudioFactory(params.audioFactory);
	  }
	  if (params.animationData) {
	    this.configAnimation(params.animationData);
	  } else if (params.path) {
	    if (params.path.lastIndexOf('\\') !== -1) {
	      this.path = params.path.substr(0, params.path.lastIndexOf('\\') + 1);
	    } else {
	      this.path = params.path.substr(0, params.path.lastIndexOf('/') + 1);
	    }
	    this.fileName = params.path.substr(params.path.lastIndexOf('/') + 1);
	    this.fileName = this.fileName.substr(0, this.fileName.lastIndexOf('.json'));

	    assetLoader.load(params.path, this.configAnimation.bind(this), function () {
	      this.trigger('data_failed');
	    }.bind(this));
	  }
	};

	AnimationItem.prototype.setData = function (wrapper, animationData) {
	  if (animationData) {
	    if (typeof animationData !== 'object') {
	      animationData = JSON.parse(animationData);
	    }
	  }
	  var params = {
	    wrapper: wrapper,
	    animationData: animationData,
	  };
	  var wrapperAttributes = wrapper.attributes;

	  params.path = wrapperAttributes.getNamedItem('data-animation-path') // eslint-disable-line no-nested-ternary
	    ? wrapperAttributes.getNamedItem('data-animation-path').value
	    : wrapperAttributes.getNamedItem('data-bm-path') // eslint-disable-line no-nested-ternary
	      ? wrapperAttributes.getNamedItem('data-bm-path').value
	      : wrapperAttributes.getNamedItem('bm-path')
	        ? wrapperAttributes.getNamedItem('bm-path').value
	        : '';
	  params.animType = wrapperAttributes.getNamedItem('data-anim-type') // eslint-disable-line no-nested-ternary
	    ? wrapperAttributes.getNamedItem('data-anim-type').value
	    : wrapperAttributes.getNamedItem('data-bm-type') // eslint-disable-line no-nested-ternary
	      ? wrapperAttributes.getNamedItem('data-bm-type').value
	      : wrapperAttributes.getNamedItem('bm-type') // eslint-disable-line no-nested-ternary
	        ? wrapperAttributes.getNamedItem('bm-type').value
	        : wrapperAttributes.getNamedItem('data-bm-renderer') // eslint-disable-line no-nested-ternary
	          ? wrapperAttributes.getNamedItem('data-bm-renderer').value
	          : wrapperAttributes.getNamedItem('bm-renderer')
	            ? wrapperAttributes.getNamedItem('bm-renderer').value
	            : 'canvas';

	  var loop = wrapperAttributes.getNamedItem('data-anim-loop') // eslint-disable-line no-nested-ternary
	    ? wrapperAttributes.getNamedItem('data-anim-loop').value
	    : wrapperAttributes.getNamedItem('data-bm-loop') // eslint-disable-line no-nested-ternary
	      ? wrapperAttributes.getNamedItem('data-bm-loop').value
	      : wrapperAttributes.getNamedItem('bm-loop')
	        ? wrapperAttributes.getNamedItem('bm-loop').value
	        : '';
	  if (loop === 'false') {
	    params.loop = false;
	  } else if (loop === 'true') {
	    params.loop = true;
	  } else if (loop !== '') {
	    params.loop = parseInt(loop, 10);
	  }
	  var autoplay = wrapperAttributes.getNamedItem('data-anim-autoplay') // eslint-disable-line no-nested-ternary
	    ? wrapperAttributes.getNamedItem('data-anim-autoplay').value
	    : wrapperAttributes.getNamedItem('data-bm-autoplay') // eslint-disable-line no-nested-ternary
	      ? wrapperAttributes.getNamedItem('data-bm-autoplay').value
	      : wrapperAttributes.getNamedItem('bm-autoplay')
	        ? wrapperAttributes.getNamedItem('bm-autoplay').value
	        : true;
	  params.autoplay = autoplay !== 'false';

	  params.name = wrapperAttributes.getNamedItem('data-name') // eslint-disable-line no-nested-ternary
	    ? wrapperAttributes.getNamedItem('data-name').value
	    : wrapperAttributes.getNamedItem('data-bm-name') // eslint-disable-line no-nested-ternary
	      ? wrapperAttributes.getNamedItem('data-bm-name').value
	      : wrapperAttributes.getNamedItem('bm-name')
	        ? wrapperAttributes.getNamedItem('bm-name').value
	        : '';
	  var prerender = wrapperAttributes.getNamedItem('data-anim-prerender') // eslint-disable-line no-nested-ternary
	    ? wrapperAttributes.getNamedItem('data-anim-prerender').value
	    : wrapperAttributes.getNamedItem('data-bm-prerender') // eslint-disable-line no-nested-ternary
	      ? wrapperAttributes.getNamedItem('data-bm-prerender').value
	      : wrapperAttributes.getNamedItem('bm-prerender')
	        ? wrapperAttributes.getNamedItem('bm-prerender').value
	        : '';

	  if (prerender === 'false') {
	    params.prerender = false;
	  }
	  this.setParams(params);
	};

	AnimationItem.prototype.includeLayers = function (data) {
	  if (data.op > this.animationData.op) {
	    this.animationData.op = data.op;
	    this.totalFrames = Math.floor(data.op - this.animationData.ip);
	  }
	  var layers = this.animationData.layers;
	  var i;
	  var len = layers.length;
	  var newLayers = data.layers;
	  var j;
	  var jLen = newLayers.length;
	  for (j = 0; j < jLen; j += 1) {
	    i = 0;
	    while (i < len) {
	      if (layers[i].id === newLayers[j].id) {
	        layers[i] = newLayers[j];
	        break;
	      }
	      i += 1;
	    }
	  }
	  if (data.chars || data.fonts) {
	    this.renderer.globalData.fontManager.addChars(data.chars);
	    this.renderer.globalData.fontManager.addFonts(data.fonts, this.renderer.globalData.defs);
	  }
	  if (data.assets) {
	    len = data.assets.length;
	    for (i = 0; i < len; i += 1) {
	      this.animationData.assets.push(data.assets[i]);
	    }
	  }
	  this.animationData.__complete = false;
	  dataManager.completeData(this.animationData, this.renderer.globalData.fontManager);
	  this.renderer.includeLayers(data.layers);
	  if (expressionsPlugin) {
	    expressionsPlugin.initExpressions(this);
	  }
	  this.loadNextSegment();
	};

	AnimationItem.prototype.loadNextSegment = function () {
	  var segments = this.animationData.segments;
	  if (!segments || segments.length === 0 || !this.autoloadSegments) {
	    this.trigger('data_ready');
	    this.timeCompleted = this.totalFrames;
	    return;
	  }
	  var segment = segments.shift();
	  this.timeCompleted = segment.time * this.frameRate;
	  var segmentPath = this.path + this.fileName + '_' + this.segmentPos + '.json';
	  this.segmentPos += 1;
	  assetLoader.load(segmentPath, this.includeLayers.bind(this), function () {
	    this.trigger('data_failed');
	  }.bind(this));
	};

	AnimationItem.prototype.loadSegments = function () {
	  var segments = this.animationData.segments;
	  if (!segments) {
	    this.timeCompleted = this.totalFrames;
	  }
	  this.loadNextSegment();
	};

	AnimationItem.prototype.imagesLoaded = function () {
	  this.trigger('loaded_images');
	  this.checkLoaded();
	};

	AnimationItem.prototype.preloadImages = function () {
	  this.imagePreloader.setAssetsPath(this.assetsPath);
	  this.imagePreloader.setPath(this.path);
	  this.imagePreloader.loadAssets(this.animationData.assets, this.imagesLoaded.bind(this));
	};

	AnimationItem.prototype.configAnimation = function (animData) {
	  if (!this.renderer) {
	    return;
	  }
	  try {
	    this.animationData = animData;

	    if (this.initialSegment) {
	      this.totalFrames = Math.floor(this.initialSegment[1] - this.initialSegment[0]);
	      this.firstFrame = Math.round(this.initialSegment[0]);
	    } else {
	      this.totalFrames = Math.floor(this.animationData.op - this.animationData.ip);
	      this.firstFrame = Math.round(this.animationData.ip);
	    }
	    this.renderer.configAnimation(animData);
	    if (!animData.assets) {
	      animData.assets = [];
	    }

	    this.assets = this.animationData.assets;
	    this.frameRate = this.animationData.fr;
	    this.frameMult = this.animationData.fr / 1000;
	    this.renderer.searchExtraCompositions(animData.assets);
	    this.markers = markerParser(animData.markers || []);
	    this.trigger('config_ready');
	    this.preloadImages();
	    this.loadSegments();
	    this.updaFrameModifier();
	    this.waitForFontsLoaded();
	    if (this.isPaused) {
	      this.audioController.pause();
	    }
	  } catch (error) {
	    this.triggerConfigError(error);
	  }
	};

	AnimationItem.prototype.waitForFontsLoaded = function () {
	  if (!this.renderer) {
	    return;
	  }
	  if (this.renderer.globalData.fontManager.isLoaded) {
	    this.checkLoaded();
	  } else {
	    setTimeout(this.waitForFontsLoaded.bind(this), 20);
	  }
	};

	AnimationItem.prototype.checkLoaded = function () {
	  if (!this.isLoaded
	        && this.renderer.globalData.fontManager.isLoaded
	        && (this.imagePreloader.loadedImages() || this.renderer.rendererType !== 'canvas')
	        && (this.imagePreloader.loadedFootages())
	  ) {
	    this.isLoaded = true;
	    dataManager.completeData(this.animationData, this.renderer.globalData.fontManager);
	    if (expressionsPlugin) {
	      expressionsPlugin.initExpressions(this);
	    }
	    this.renderer.initItems();
	    setTimeout(function () {
	      this.trigger('DOMLoaded');
	    }.bind(this), 0);
	    this.gotoFrame();
	    if (this.autoplay) {
	      this.play();
	    }
	  }
	};

	AnimationItem.prototype.resize = function () {
	  this.renderer.updateContainerSize();
	};

	AnimationItem.prototype.setSubframe = function (flag) {
	  this.isSubframeEnabled = !!flag;
	};

	AnimationItem.prototype.gotoFrame = function () {
	  this.currentFrame = this.isSubframeEnabled ? this.currentRawFrame : ~~this.currentRawFrame; // eslint-disable-line no-bitwise

	  if (this.timeCompleted !== this.totalFrames && this.currentFrame > this.timeCompleted) {
	    this.currentFrame = this.timeCompleted;
	  }
	  this.trigger('enterFrame');
	  this.renderFrame();
	};

	AnimationItem.prototype.renderFrame = function () {
	  if (this.isLoaded === false || !this.renderer) {
	    return;
	  }
	  try {
	    this.renderer.renderFrame(this.currentFrame + this.firstFrame);
	  } catch (error) {
	    this.triggerRenderFrameError(error);
	  }
	};

	AnimationItem.prototype.play = function (name) {
	  if (name && this.name !== name) {
	    return;
	  }
	  if (this.isPaused === true) {
	    this.isPaused = false;
	    this.audioController.resume();
	    if (this._idle) {
	      this._idle = false;
	      this.trigger('_active');
	    }
	  }
	};

	AnimationItem.prototype.pause = function (name) {
	  if (name && this.name !== name) {
	    return;
	  }
	  if (this.isPaused === false) {
	    this.isPaused = true;
	    this._idle = true;
	    this.trigger('_idle');
	    this.audioController.pause();
	  }
	};

	AnimationItem.prototype.togglePause = function (name) {
	  if (name && this.name !== name) {
	    return;
	  }
	  if (this.isPaused === true) {
	    this.play();
	  } else {
	    this.pause();
	  }
	};

	AnimationItem.prototype.stop = function (name) {
	  if (name && this.name !== name) {
	    return;
	  }
	  this.pause();
	  this.playCount = 0;
	  this._completedLoop = false;
	  this.setCurrentRawFrameValue(0);
	};

	AnimationItem.prototype.getMarkerData = function (markerName) {
	  var marker;
	  for (var i = 0; i < this.markers.length; i += 1) {
	    marker = this.markers[i];
	    if (marker.payload && marker.payload.name === markerName) {
	      return marker;
	    }
	  }
	  return null;
	};

	AnimationItem.prototype.goToAndStop = function (value, isFrame, name) {
	  if (name && this.name !== name) {
	    return;
	  }
	  var numValue = Number(value);
	  if (isNaN(numValue)) {
	    var marker = this.getMarkerData(value);
	    if (marker) {
	      this.goToAndStop(marker.time, true);
	    }
	  } else if (isFrame) {
	    this.setCurrentRawFrameValue(value);
	  } else {
	    this.setCurrentRawFrameValue(value * this.frameModifier);
	  }
	  this.pause();
	};

	AnimationItem.prototype.goToAndPlay = function (value, isFrame, name) {
	  if (name && this.name !== name) {
	    return;
	  }
	  var numValue = Number(value);
	  if (isNaN(numValue)) {
	    var marker = this.getMarkerData(value);
	    if (marker) {
	      if (!marker.duration) {
	        this.goToAndStop(marker.time, true);
	      } else {
	        this.playSegments([marker.time, marker.time + marker.duration], true);
	      }
	    }
	  } else {
	    this.goToAndStop(numValue, isFrame, name);
	  }
	  this.play();
	};

	AnimationItem.prototype.advanceTime = function (value) {
	  if (this.isPaused === true || this.isLoaded === false) {
	    return;
	  }
	  var nextValue = this.currentRawFrame + value * this.frameModifier;
	  var _isComplete = false;
	  // Checking if nextValue > totalFrames - 1 for addressing non looping and looping animations.
	  // If animation won't loop, it should stop at totalFrames - 1. If it will loop it should complete the last frame and then loop.
	  if (nextValue >= this.totalFrames - 1 && this.frameModifier > 0) {
	    if (!this.loop || this.playCount === this.loop) {
	      if (!this.checkSegments(nextValue > this.totalFrames ? nextValue % this.totalFrames : 0)) {
	        _isComplete = true;
	        nextValue = this.totalFrames - 1;
	      }
	    } else if (nextValue >= this.totalFrames) {
	      this.playCount += 1;
	      if (!this.checkSegments(nextValue % this.totalFrames)) {
	        this.setCurrentRawFrameValue(nextValue % this.totalFrames);
	        this._completedLoop = true;
	        this.trigger('loopComplete');
	      }
	    } else {
	      this.setCurrentRawFrameValue(nextValue);
	    }
	  } else if (nextValue < 0) {
	    if (!this.checkSegments(nextValue % this.totalFrames)) {
	      if (this.loop && !(this.playCount-- <= 0 && this.loop !== true)) { // eslint-disable-line no-plusplus
	        this.setCurrentRawFrameValue(this.totalFrames + (nextValue % this.totalFrames));
	        if (!this._completedLoop) {
	          this._completedLoop = true;
	        } else {
	          this.trigger('loopComplete');
	        }
	      } else {
	        _isComplete = true;
	        nextValue = 0;
	      }
	    }
	  } else {
	    this.setCurrentRawFrameValue(nextValue);
	  }
	  if (_isComplete) {
	    this.setCurrentRawFrameValue(nextValue);
	    this.pause();
	    this.trigger('complete');
	  }
	};

	AnimationItem.prototype.adjustSegment = function (arr, offset) {
	  this.playCount = 0;
	  if (arr[1] < arr[0]) {
	    if (this.frameModifier > 0) {
	      if (this.playSpeed < 0) {
	        this.setSpeed(-this.playSpeed);
	      } else {
	        this.setDirection(-1);
	      }
	    }
	    this.totalFrames = arr[0] - arr[1];
	    this.timeCompleted = this.totalFrames;
	    this.firstFrame = arr[1];
	    this.setCurrentRawFrameValue(this.totalFrames - 0.001 - offset);
	  } else if (arr[1] > arr[0]) {
	    if (this.frameModifier < 0) {
	      if (this.playSpeed < 0) {
	        this.setSpeed(-this.playSpeed);
	      } else {
	        this.setDirection(1);
	      }
	    }
	    this.totalFrames = arr[1] - arr[0];
	    this.timeCompleted = this.totalFrames;
	    this.firstFrame = arr[0];
	    this.setCurrentRawFrameValue(0.001 + offset);
	  }
	  this.trigger('segmentStart');
	};
	AnimationItem.prototype.setSegment = function (init, end) {
	  var pendingFrame = -1;
	  if (this.isPaused) {
	    if (this.currentRawFrame + this.firstFrame < init) {
	      pendingFrame = init;
	    } else if (this.currentRawFrame + this.firstFrame > end) {
	      pendingFrame = end - init;
	    }
	  }

	  this.firstFrame = init;
	  this.totalFrames = end - init;
	  this.timeCompleted = this.totalFrames;
	  if (pendingFrame !== -1) {
	    this.goToAndStop(pendingFrame, true);
	  }
	};

	AnimationItem.prototype.playSegments = function (arr, forceFlag) {
	  if (forceFlag) {
	    this.segments.length = 0;
	  }
	  if (typeof arr[0] === 'object') {
	    var i;
	    var len = arr.length;
	    for (i = 0; i < len; i += 1) {
	      this.segments.push(arr[i]);
	    }
	  } else {
	    this.segments.push(arr);
	  }
	  if (this.segments.length && forceFlag) {
	    this.adjustSegment(this.segments.shift(), 0);
	  }
	  if (this.isPaused) {
	    this.play();
	  }
	};

	AnimationItem.prototype.resetSegments = function (forceFlag) {
	  this.segments.length = 0;
	  this.segments.push([this.animationData.ip, this.animationData.op]);
	  // this.segments.push([this.animationData.ip*this.frameRate,Math.floor(this.animationData.op - this.animationData.ip+this.animationData.ip*this.frameRate)]);
	  if (forceFlag) {
	    this.checkSegments(0);
	  }
	};
	AnimationItem.prototype.checkSegments = function (offset) {
	  if (this.segments.length) {
	    this.adjustSegment(this.segments.shift(), offset);
	    return true;
	  }
	  return false;
	};

	AnimationItem.prototype.destroy = function (name) {
	  if ((name && this.name !== name) || !this.renderer) {
	    return;
	  }
	  this.renderer.destroy();
	  this.imagePreloader.destroy();
	  this.trigger('destroy');
	  this._cbs = null;
	  this.onEnterFrame = null;
	  this.onLoopComplete = null;
	  this.onComplete = null;
	  this.onSegmentStart = null;
	  this.onDestroy = null;
	  this.renderer = null;
	  this.renderer = null;
	  this.imagePreloader = null;
	  this.projectInterface = null;
	};

	AnimationItem.prototype.setCurrentRawFrameValue = function (value) {
	  this.currentRawFrame = value;
	  this.gotoFrame();
	};

	AnimationItem.prototype.setSpeed = function (val) {
	  this.playSpeed = val;
	  this.updaFrameModifier();
	};

	AnimationItem.prototype.setDirection = function (val) {
	  this.playDirection = val < 0 ? -1 : 1;
	  this.updaFrameModifier();
	};

	AnimationItem.prototype.setVolume = function (val, name) {
	  if (name && this.name !== name) {
	    return;
	  }
	  this.audioController.setVolume(val);
	};

	AnimationItem.prototype.getVolume = function () {
	  return this.audioController.getVolume();
	};

	AnimationItem.prototype.mute = function (name) {
	  if (name && this.name !== name) {
	    return;
	  }
	  this.audioController.mute();
	};

	AnimationItem.prototype.unmute = function (name) {
	  if (name && this.name !== name) {
	    return;
	  }
	  this.audioController.unmute();
	};

	AnimationItem.prototype.updaFrameModifier = function () {
	  this.frameModifier = this.frameMult * this.playSpeed * this.playDirection;
	  this.audioController.setRate(this.playSpeed * this.playDirection);
	};

	AnimationItem.prototype.getPath = function () {
	  return this.path;
	};

	AnimationItem.prototype.getAssetsPath = function (assetData) {
	  var path = '';
	  if (assetData.e) {
	    path = assetData.p;
	  } else if (this.assetsPath) {
	    var imagePath = assetData.p;
	    if (imagePath.indexOf('images/') !== -1) {
	      imagePath = imagePath.split('/')[1];
	    }
	    path = this.assetsPath + imagePath;
	  } else {
	    path = this.path;
	    path += assetData.u ? assetData.u : '';
	    path += assetData.p;
	  }
	  return path;
	};

	AnimationItem.prototype.getAssetData = function (id) {
	  var i = 0;
	  var len = this.assets.length;
	  while (i < len) {
	    if (id === this.assets[i].id) {
	      return this.assets[i];
	    }
	    i += 1;
	  }
	  return null;
	};

	AnimationItem.prototype.hide = function () {
	  this.renderer.hide();
	};

	AnimationItem.prototype.show = function () {
	  this.renderer.show();
	};

	AnimationItem.prototype.getDuration = function (isFrame) {
	  return isFrame ? this.totalFrames : this.totalFrames / this.frameRate;
	};

	AnimationItem.prototype.trigger = function (name) {
	  if (this._cbs && this._cbs[name]) {
	    switch (name) {
	      case 'enterFrame':
	        this.triggerEvent(name, new BMEnterFrameEvent(name, this.currentFrame, this.totalFrames, this.frameModifier));
	        break;
	      case 'loopComplete':
	        this.triggerEvent(name, new BMCompleteLoopEvent(name, this.loop, this.playCount, this.frameMult));
	        break;
	      case 'complete':
	        this.triggerEvent(name, new BMCompleteEvent(name, this.frameMult));
	        break;
	      case 'segmentStart':
	        this.triggerEvent(name, new BMSegmentStartEvent(name, this.firstFrame, this.totalFrames));
	        break;
	      case 'destroy':
	        this.triggerEvent(name, new BMDestroyEvent(name, this));
	        break;
	      default:
	        this.triggerEvent(name);
	    }
	  }
	  if (name === 'enterFrame' && this.onEnterFrame) {
	    this.onEnterFrame.call(this, new BMEnterFrameEvent(name, this.currentFrame, this.totalFrames, this.frameMult));
	  }
	  if (name === 'loopComplete' && this.onLoopComplete) {
	    this.onLoopComplete.call(this, new BMCompleteLoopEvent(name, this.loop, this.playCount, this.frameMult));
	  }
	  if (name === 'complete' && this.onComplete) {
	    this.onComplete.call(this, new BMCompleteEvent(name, this.frameMult));
	  }
	  if (name === 'segmentStart' && this.onSegmentStart) {
	    this.onSegmentStart.call(this, new BMSegmentStartEvent(name, this.firstFrame, this.totalFrames));
	  }
	  if (name === 'destroy' && this.onDestroy) {
	    this.onDestroy.call(this, new BMDestroyEvent(name, this));
	  }
	};

	AnimationItem.prototype.triggerRenderFrameError = function (nativeError) {
	  var error = new BMRenderFrameErrorEvent(nativeError, this.currentFrame);
	  this.triggerEvent('error', error);

	  if (this.onError) {
	    this.onError.call(this, error);
	  }
	};

	AnimationItem.prototype.triggerConfigError = function (nativeError) {
	  var error = new BMConfigErrorEvent(nativeError, this.currentFrame);
	  this.triggerEvent('error', error);

	  if (this.onError) {
	    this.onError.call(this, error);
	  }
	};

	/* global CompExpressionInterface, expressionsPlugin: writable */
	/* exported expressionsPlugin */

	var Expressions = (function () {
	  var ob = {};
	  ob.initExpressions = initExpressions;

	  function initExpressions(animation) {
	    var stackCount = 0;
	    var registers = [];

	    function pushExpression() {
	      stackCount += 1;
	    }

	    function popExpression() {
	      stackCount -= 1;
	      if (stackCount === 0) {
	        releaseInstances();
	      }
	    }

	    function registerExpressionProperty(expression) {
	      if (registers.indexOf(expression) === -1) {
	        registers.push(expression);
	      }
	    }

	    function releaseInstances() {
	      var i;
	      var len = registers.length;
	      for (i = 0; i < len; i += 1) {
	        registers[i].release();
	      }
	      registers.length = 0;
	    }

	    animation.renderer.compInterface = CompExpressionInterface(animation.renderer);
	    animation.renderer.globalData.projectInterface.registerComposition(animation.renderer);
	    animation.renderer.globalData.pushExpression = pushExpression;
	    animation.renderer.globalData.popExpression = popExpression;
	    animation.renderer.globalData.registerExpressionProperty = registerExpressionProperty;
	  }
	  return ob;
	}());

	expressionsPlugin = Expressions;

	/* eslint-disable camelcase, no-unused-vars */
	/* global BMMath, BezierFactory, createTypedArray, degToRads, shapePool */

	var ExpressionManager = (function () {
	  'use strict';

	  var ob = {};
	  var Math = BMMath;
	  var window = null;
	  var document = null;
	  var XMLHttpRequest = null;
	  var fetch = null;

	  function $bm_isInstanceOfArray(arr) {
	    return arr.constructor === Array || arr.constructor === Float32Array;
	  }

	  function isNumerable(tOfV, v) {
	    return tOfV === 'number' || tOfV === 'boolean' || tOfV === 'string' || v instanceof Number;
	  }

	  function $bm_neg(a) {
	    var tOfA = typeof a;
	    if (tOfA === 'number' || tOfA === 'boolean' || a instanceof Number) {
	      return -a;
	    }
	    if ($bm_isInstanceOfArray(a)) {
	      var i;
	      var lenA = a.length;
	      var retArr = [];
	      for (i = 0; i < lenA; i += 1) {
	        retArr[i] = -a[i];
	      }
	      return retArr;
	    }
	    if (a.propType) {
	      return a.v;
	    }
	    return -a;
	  }

	  var easeInBez = BezierFactory.getBezierEasing(0.333, 0, 0.833, 0.833, 'easeIn').get;
	  var easeOutBez = BezierFactory.getBezierEasing(0.167, 0.167, 0.667, 1, 'easeOut').get;
	  var easeInOutBez = BezierFactory.getBezierEasing(0.33, 0, 0.667, 1, 'easeInOut').get;

	  function sum(a, b) {
	    var tOfA = typeof a;
	    var tOfB = typeof b;
	    if (tOfA === 'string' || tOfB === 'string') {
	      return a + b;
	    }
	    if (isNumerable(tOfA, a) && isNumerable(tOfB, b)) {
	      return a + b;
	    }
	    if ($bm_isInstanceOfArray(a) && isNumerable(tOfB, b)) {
	      a = a.slice(0);
	      a[0] += b;
	      return a;
	    }
	    if (isNumerable(tOfA, a) && $bm_isInstanceOfArray(b)) {
	      b = b.slice(0);
	      b[0] = a + b[0];
	      return b;
	    }
	    if ($bm_isInstanceOfArray(a) && $bm_isInstanceOfArray(b)) {
	      var i = 0;
	      var lenA = a.length;
	      var lenB = b.length;
	      var retArr = [];
	      while (i < lenA || i < lenB) {
	        if ((typeof a[i] === 'number' || a[i] instanceof Number) && (typeof b[i] === 'number' || b[i] instanceof Number)) {
	          retArr[i] = a[i] + b[i];
	        } else {
	          retArr[i] = b[i] === undefined ? a[i] : a[i] || b[i];
	        }
	        i += 1;
	      }
	      return retArr;
	    }
	    return 0;
	  }
	  var add = sum;

	  function sub(a, b) {
	    var tOfA = typeof a;
	    var tOfB = typeof b;
	    if (isNumerable(tOfA, a) && isNumerable(tOfB, b)) {
	      if (tOfA === 'string') {
	        a = parseInt(a, 10);
	      }
	      if (tOfB === 'string') {
	        b = parseInt(b, 10);
	      }
	      return a - b;
	    }
	    if ($bm_isInstanceOfArray(a) && isNumerable(tOfB, b)) {
	      a = a.slice(0);
	      a[0] -= b;
	      return a;
	    }
	    if (isNumerable(tOfA, a) && $bm_isInstanceOfArray(b)) {
	      b = b.slice(0);
	      b[0] = a - b[0];
	      return b;
	    }
	    if ($bm_isInstanceOfArray(a) && $bm_isInstanceOfArray(b)) {
	      var i = 0;
	      var lenA = a.length;
	      var lenB = b.length;
	      var retArr = [];
	      while (i < lenA || i < lenB) {
	        if ((typeof a[i] === 'number' || a[i] instanceof Number) && (typeof b[i] === 'number' || b[i] instanceof Number)) {
	          retArr[i] = a[i] - b[i];
	        } else {
	          retArr[i] = b[i] === undefined ? a[i] : a[i] || b[i];
	        }
	        i += 1;
	      }
	      return retArr;
	    }
	    return 0;
	  }

	  function mul(a, b) {
	    var tOfA = typeof a;
	    var tOfB = typeof b;
	    var arr;
	    if (isNumerable(tOfA, a) && isNumerable(tOfB, b)) {
	      return a * b;
	    }

	    var i;
	    var len;
	    if ($bm_isInstanceOfArray(a) && isNumerable(tOfB, b)) {
	      len = a.length;
	      arr = createTypedArray('float32', len);
	      for (i = 0; i < len; i += 1) {
	        arr[i] = a[i] * b;
	      }
	      return arr;
	    }
	    if (isNumerable(tOfA, a) && $bm_isInstanceOfArray(b)) {
	      len = b.length;
	      arr = createTypedArray('float32', len);
	      for (i = 0; i < len; i += 1) {
	        arr[i] = a * b[i];
	      }
	      return arr;
	    }
	    return 0;
	  }

	  function div(a, b) {
	    var tOfA = typeof a;
	    var tOfB = typeof b;
	    var arr;
	    if (isNumerable(tOfA, a) && isNumerable(tOfB, b)) {
	      return a / b;
	    }
	    var i;
	    var len;
	    if ($bm_isInstanceOfArray(a) && isNumerable(tOfB, b)) {
	      len = a.length;
	      arr = createTypedArray('float32', len);
	      for (i = 0; i < len; i += 1) {
	        arr[i] = a[i] / b;
	      }
	      return arr;
	    }
	    if (isNumerable(tOfA, a) && $bm_isInstanceOfArray(b)) {
	      len = b.length;
	      arr = createTypedArray('float32', len);
	      for (i = 0; i < len; i += 1) {
	        arr[i] = a / b[i];
	      }
	      return arr;
	    }
	    return 0;
	  }
	  function mod(a, b) {
	    if (typeof a === 'string') {
	      a = parseInt(a, 10);
	    }
	    if (typeof b === 'string') {
	      b = parseInt(b, 10);
	    }
	    return a % b;
	  }
	  var $bm_sum = sum;
	  var $bm_sub = sub;
	  var $bm_mul = mul;
	  var $bm_div = div;
	  var $bm_mod = mod;

	  function clamp(num, min, max) {
	    if (min > max) {
	      var mm = max;
	      max = min;
	      min = mm;
	    }
	    return Math.min(Math.max(num, min), max);
	  }

	  function radiansToDegrees(val) {
	    return val / degToRads;
	  }
	  var radians_to_degrees = radiansToDegrees;

	  function degreesToRadians(val) {
	    return val * degToRads;
	  }
	  var degrees_to_radians = radiansToDegrees;

	  var helperLengthArray = [0, 0, 0, 0, 0, 0];

	  function length(arr1, arr2) {
	    if (typeof arr1 === 'number' || arr1 instanceof Number) {
	      arr2 = arr2 || 0;
	      return Math.abs(arr1 - arr2);
	    }
	    if (!arr2) {
	      arr2 = helperLengthArray;
	    }
	    var i;
	    var len = Math.min(arr1.length, arr2.length);
	    var addedLength = 0;
	    for (i = 0; i < len; i += 1) {
	      addedLength += Math.pow(arr2[i] - arr1[i], 2);
	    }
	    return Math.sqrt(addedLength);
	  }

	  function normalize(vec) {
	    return div(vec, length(vec));
	  }

	  function rgbToHsl(val) {
	    var r = val[0]; var g = val[1]; var b = val[2];
	    var max = Math.max(r, g, b);
	    var min = Math.min(r, g, b);
	    var h;
	    var s;
	    var l = (max + min) / 2;

	    if (max === min) {
	      h = 0; // achromatic
	      s = 0; // achromatic
	    } else {
	      var d = max - min;
	      s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
	      switch (max) {
	        case r: h = (g - b) / d + (g < b ? 6 : 0); break;
	        case g: h = (b - r) / d + 2; break;
	        case b: h = (r - g) / d + 4; break;
	        default: break;
	      }
	      h /= 6;
	    }

	    return [h, s, l, val[3]];
	  }

	  function hue2rgb(p, q, t) {
	    if (t < 0) t += 1;
	    if (t > 1) t -= 1;
	    if (t < 1 / 6) return p + (q - p) * 6 * t;
	    if (t < 1 / 2) return q;
	    if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
	    return p;
	  }

	  function hslToRgb(val) {
	    var h = val[0];
	    var s = val[1];
	    var l = val[2];

	    var r;
	    var g;
	    var b;

	    if (s === 0) {
	      r = l; // achromatic
	      b = l; // achromatic
	      g = l; // achromatic
	    } else {
	      var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
	      var p = 2 * l - q;
	      r = hue2rgb(p, q, h + 1 / 3);
	      g = hue2rgb(p, q, h);
	      b = hue2rgb(p, q, h - 1 / 3);
	    }

	    return [r, g, b, val[3]];
	  }

	  function linear(t, tMin, tMax, value1, value2) {
	    if (value1 === undefined || value2 === undefined) {
	      value1 = tMin;
	      value2 = tMax;
	      tMin = 0;
	      tMax = 1;
	    }
	    if (tMax < tMin) {
	      var _tMin = tMax;
	      tMax = tMin;
	      tMin = _tMin;
	    }
	    if (t <= tMin) {
	      return value1;
	    } if (t >= tMax) {
	      return value2;
	    }
	    var perc = tMax === tMin ? 0 : (t - tMin) / (tMax - tMin);
	    if (!value1.length) {
	      return value1 + (value2 - value1) * perc;
	    }
	    var i;
	    var len = value1.length;
	    var arr = createTypedArray('float32', len);
	    for (i = 0; i < len; i += 1) {
	      arr[i] = value1[i] + (value2[i] - value1[i]) * perc;
	    }
	    return arr;
	  }
	  function random(min, max) {
	    if (max === undefined) {
	      if (min === undefined) {
	        min = 0;
	        max = 1;
	      } else {
	        max = min;
	        min = undefined;
	      }
	    }
	    if (max.length) {
	      var i;
	      var len = max.length;
	      if (!min) {
	        min = createTypedArray('float32', len);
	      }
	      var arr = createTypedArray('float32', len);
	      var rnd = BMMath.random();
	      for (i = 0; i < len; i += 1) {
	        arr[i] = min[i] + rnd * (max[i] - min[i]);
	      }
	      return arr;
	    }
	    if (min === undefined) {
	      min = 0;
	    }
	    var rndm = BMMath.random();
	    return min + rndm * (max - min);
	  }

	  function createPath(points, inTangents, outTangents, closed) {
	    var i;
	    var len = points.length;
	    var path = shapePool.newElement();
	    path.setPathData(!!closed, len);
	    var arrPlaceholder = [0, 0];
	    var inVertexPoint;
	    var outVertexPoint;
	    for (i = 0; i < len; i += 1) {
	      inVertexPoint = (inTangents && inTangents[i]) ? inTangents[i] : arrPlaceholder;
	      outVertexPoint = (outTangents && outTangents[i]) ? outTangents[i] : arrPlaceholder;
	      path.setTripleAt(points[i][0], points[i][1], outVertexPoint[0] + points[i][0], outVertexPoint[1] + points[i][1], inVertexPoint[0] + points[i][0], inVertexPoint[1] + points[i][1], i, true);
	    }
	    return path;
	  }

	  function initiateExpression(elem, data, property) {
	    var val = data.x;
	    var needsVelocity = /velocity(?![\w\d])/.test(val);
	    var _needsRandom = val.indexOf('random') !== -1;
	    var elemType = elem.data.ty;
	    var transform;
	    var $bm_transform;
	    var content;
	    var effect;
	    var thisProperty = property;
	    thisProperty.valueAtTime = thisProperty.getValueAtTime;
	    Object.defineProperty(thisProperty, 'value', {
	      get: function () {
	        return thisProperty.v;
	      },
	    });
	    elem.comp.frameDuration = 1 / elem.comp.globalData.frameRate;
	    elem.comp.displayStartTime = 0;
	    var inPoint = elem.data.ip / elem.comp.globalData.frameRate;
	    var outPoint = elem.data.op / elem.comp.globalData.frameRate;
	    var width = elem.data.sw ? elem.data.sw : 0;
	    var height = elem.data.sh ? elem.data.sh : 0;
	    var name = elem.data.nm;
	    var loopIn;
	    var loop_in;
	    var loopOut;
	    var loop_out;
	    var smooth;
	    var toWorld;
	    var fromWorld;
	    var fromComp;
	    var toComp;
	    var fromCompToSurface;
	    var position;
	    var rotation;
	    var anchorPoint;
	    var scale;
	    var thisLayer;
	    var thisComp;
	    var mask;
	    var valueAtTime;
	    var velocityAtTime;

	    var scoped_bm_rt;
	    // val = val.replace(/(\\?"|')((http)(s)?(:\/))?\/.*?(\\?"|')/g, "\"\""); // deter potential network calls
	    var expression_function = eval('[function _expression_function(){' + val + ';scoped_bm_rt=$bm_rt}]')[0]; // eslint-disable-line no-eval
	    var numKeys = property.kf ? data.k.length : 0;

	    var active = !this.data || this.data.hd !== true;

	    var wiggle = function wiggle(freq, amp) {
	      var iWiggle;
	      var j;
	      var lenWiggle = this.pv.length ? this.pv.length : 1;
	      var addedAmps = createTypedArray('float32', lenWiggle);
	      freq = 5;
	      var iterations = Math.floor(time * freq);
	      iWiggle = 0;
	      j = 0;
	      while (iWiggle < iterations) {
	        // var rnd = BMMath.random();
	        for (j = 0; j < lenWiggle; j += 1) {
	          addedAmps[j] += -amp + amp * 2 * BMMath.random();
	          // addedAmps[j] += -amp + amp*2*rnd;
	        }
	        iWiggle += 1;
	      }
	      // var rnd2 = BMMath.random();
	      var periods = time * freq;
	      var perc = periods - Math.floor(periods);
	      var arr = createTypedArray('float32', lenWiggle);
	      if (lenWiggle > 1) {
	        for (j = 0; j < lenWiggle; j += 1) {
	          arr[j] = this.pv[j] + addedAmps[j] + (-amp + amp * 2 * BMMath.random()) * perc;
	          // arr[j] = this.pv[j] + addedAmps[j] + (-amp + amp*2*rnd)*perc;
	          // arr[i] = this.pv[i] + addedAmp + amp1*perc + amp2*(1-perc);
	        }
	        return arr;
	      }
	      return this.pv + addedAmps[0] + (-amp + amp * 2 * BMMath.random()) * perc;
	    }.bind(this);

	    if (thisProperty.loopIn) {
	      loopIn = thisProperty.loopIn.bind(thisProperty);
	      loop_in = loopIn;
	    }

	    if (thisProperty.loopOut) {
	      loopOut = thisProperty.loopOut.bind(thisProperty);
	      loop_out = loopOut;
	    }

	    if (thisProperty.smooth) {
	      smooth = thisProperty.smooth.bind(thisProperty);
	    }

	    function loopInDuration(type, duration) {
	      return loopIn(type, duration, true);
	    }

	    function loopOutDuration(type, duration) {
	      return loopOut(type, duration, true);
	    }

	    if (this.getValueAtTime) {
	      valueAtTime = this.getValueAtTime.bind(this);
	    }

	    if (this.getVelocityAtTime) {
	      velocityAtTime = this.getVelocityAtTime.bind(this);
	    }

	    var comp = elem.comp.globalData.projectInterface.bind(elem.comp.globalData.projectInterface);

	    function lookAt(elem1, elem2) {
	      var fVec = [elem2[0] - elem1[0], elem2[1] - elem1[1], elem2[2] - elem1[2]];
	      var pitch = Math.atan2(fVec[0], Math.sqrt(fVec[1] * fVec[1] + fVec[2] * fVec[2])) / degToRads;
	      var yaw = -Math.atan2(fVec[1], fVec[2]) / degToRads;
	      return [yaw, pitch, 0];
	    }

	    function easeOut(t, tMin, tMax, val1, val2) {
	      return applyEase(easeOutBez, t, tMin, tMax, val1, val2);
	    }

	    function easeIn(t, tMin, tMax, val1, val2) {
	      return applyEase(easeInBez, t, tMin, tMax, val1, val2);
	    }

	    function ease(t, tMin, tMax, val1, val2) {
	      return applyEase(easeInOutBez, t, tMin, tMax, val1, val2);
	    }

	    function applyEase(fn, t, tMin, tMax, val1, val2) {
	      if (val1 === undefined) {
	        val1 = tMin;
	        val2 = tMax;
	      } else {
	        t = (t - tMin) / (tMax - tMin);
	      }
	      if (t > 1) {
	        t = 1;
	      } else if (t < 0) {
	        t = 0;
	      }
	      var mult = fn(t);
	      if ($bm_isInstanceOfArray(val1)) {
	        var iKey;
	        var lenKey = val1.length;
	        var arr = createTypedArray('float32', lenKey);
	        for (iKey = 0; iKey < lenKey; iKey += 1) {
	          arr[iKey] = (val2[iKey] - val1[iKey]) * mult + val1[iKey];
	        }
	        return arr;
	      }
	      return (val2 - val1) * mult + val1;
	    }

	    function nearestKey(time) {
	      var iKey;
	      var lenKey = data.k.length;
	      var index;
	      var keyTime;
	      if (!data.k.length || typeof (data.k[0]) === 'number') {
	        index = 0;
	        keyTime = 0;
	      } else {
	        index = -1;
	        time *= elem.comp.globalData.frameRate;
	        if (time < data.k[0].t) {
	          index = 1;
	          keyTime = data.k[0].t;
	        } else {
	          for (iKey = 0; iKey < lenKey - 1; iKey += 1) {
	            if (time === data.k[iKey].t) {
	              index = iKey + 1;
	              keyTime = data.k[iKey].t;
	              break;
	            } else if (time > data.k[iKey].t && time < data.k[iKey + 1].t) {
	              if (time - data.k[iKey].t > data.k[iKey + 1].t - time) {
	                index = iKey + 2;
	                keyTime = data.k[iKey + 1].t;
	              } else {
	                index = iKey + 1;
	                keyTime = data.k[iKey].t;
	              }
	              break;
	            }
	          }
	          if (index === -1) {
	            index = iKey + 1;
	            keyTime = data.k[iKey].t;
	          }
	        }
	      }
	      var obKey = {};
	      obKey.index = index;
	      obKey.time = keyTime / elem.comp.globalData.frameRate;
	      return obKey;
	    }

	    function key(ind) {
	      var obKey;
	      var iKey;
	      var lenKey;
	      if (!data.k.length || typeof (data.k[0]) === 'number') {
	        throw new Error('The property has no keyframe at index ' + ind);
	      }
	      ind -= 1;
	      obKey = {
	        time: data.k[ind].t / elem.comp.globalData.frameRate,
	        value: [],
	      };
	      var arr = Object.prototype.hasOwnProperty.call(data.k[ind], 's') ? data.k[ind].s : data.k[ind - 1].e;

	      lenKey = arr.length;
	      for (iKey = 0; iKey < lenKey; iKey += 1) {
	        obKey[iKey] = arr[iKey];
	        obKey.value[iKey] = arr[iKey];
	      }
	      return obKey;
	    }

	    function framesToTime(frames, fps) {
	      if (!fps) {
	        fps = elem.comp.globalData.frameRate;
	      }
	      return frames / fps;
	    }

	    function timeToFrames(t, fps) {
	      if (!t && t !== 0) {
	        t = time;
	      }
	      if (!fps) {
	        fps = elem.comp.globalData.frameRate;
	      }
	      return t * fps;
	    }

	    function seedRandom(seed) {
	      BMMath.seedrandom(randSeed + seed);
	    }

	    function sourceRectAtTime() {
	      return elem.sourceRectAtTime();
	    }

	    function substring(init, end) {
	      if (typeof value === 'string') {
	        if (end === undefined) {
	          return value.substring(init);
	        }
	        return value.substring(init, end);
	      }
	      return '';
	    }

	    function substr(init, end) {
	      if (typeof value === 'string') {
	        if (end === undefined) {
	          return value.substr(init);
	        }
	        return value.substr(init, end);
	      }
	      return '';
	    }

	    function posterizeTime(framesPerSecond) {
	      time = framesPerSecond === 0 ? 0 : Math.floor(time * framesPerSecond) / framesPerSecond;
	      value = valueAtTime(time);
	    }

	    var time;
	    var velocity;
	    var value;
	    var text;
	    var textIndex;
	    var textTotal;
	    var selectorValue;
	    var index = elem.data.ind;
	    var hasParent = !!(elem.hierarchy && elem.hierarchy.length);
	    var parent;
	    var randSeed = Math.floor(Math.random() * 1000000);
	    var globalData = elem.globalData;
	    function executeExpression(_value) {
	      // globalData.pushExpression();
	      value = _value;
	      if (_needsRandom) {
	        seedRandom(randSeed);
	      }
	      if (this.frameExpressionId === elem.globalData.frameId && this.propType !== 'textSelector') {
	        return value;
	      }
	      if (this.propType === 'textSelector') {
	        textIndex = this.textIndex;
	        textTotal = this.textTotal;
	        selectorValue = this.selectorValue;
	      }
	      if (!thisLayer) {
	        text = elem.layerInterface.text;
	        thisLayer = elem.layerInterface;
	        thisComp = elem.comp.compInterface;
	        toWorld = thisLayer.toWorld.bind(thisLayer);
	        fromWorld = thisLayer.fromWorld.bind(thisLayer);
	        fromComp = thisLayer.fromComp.bind(thisLayer);
	        toComp = thisLayer.toComp.bind(thisLayer);
	        mask = thisLayer.mask ? thisLayer.mask.bind(thisLayer) : null;
	        fromCompToSurface = fromComp;
	      }
	      if (!transform) {
	        transform = elem.layerInterface('ADBE Transform Group');
	        $bm_transform = transform;
	        if (transform) {
	          anchorPoint = transform.anchorPoint;
	          /* position = transform.position;
	                    rotation = transform.rotation;
	                    scale = transform.scale; */
	        }
	      }

	      if (elemType === 4 && !content) {
	        content = thisLayer('ADBE Root Vectors Group');
	      }
	      if (!effect) {
	        effect = thisLayer(4);
	      }
	      hasParent = !!(elem.hierarchy && elem.hierarchy.length);
	      if (hasParent && !parent) {
	        parent = elem.hierarchy[0].layerInterface;
	      }
	      time = this.comp.renderedFrame / this.comp.globalData.frameRate;
	      if (needsVelocity) {
	        velocity = velocityAtTime(time);
	      }
	      expression_function();
	      this.frameExpressionId = elem.globalData.frameId;

	      // TODO: Check if it's possible to return on ShapeInterface the .v value
	      if (scoped_bm_rt.propType === 'shape') {
	        scoped_bm_rt = scoped_bm_rt.v;
	      }
	      // globalData.popExpression();
	      return scoped_bm_rt;
	    }
	    return executeExpression;
	  }

	  ob.initiateExpression = initiateExpression;
	  return ob;
	}());

	/* global ExpressionManager, createTypedArray */
	/* exported expressionHelpers */

	var expressionHelpers = (function () {
	  function searchExpressions(elem, data, prop) {
	    if (data.x) {
	      prop.k = true;
	      prop.x = true;
	      prop.initiateExpression = ExpressionManager.initiateExpression;
	      prop.effectsSequence.push(prop.initiateExpression(elem, data, prop).bind(prop));
	    }
	  }

	  function getValueAtTime(frameNum) {
	    frameNum *= this.elem.globalData.frameRate;
	    frameNum -= this.offsetTime;
	    if (frameNum !== this._cachingAtTime.lastFrame) {
	      this._cachingAtTime.lastIndex = this._cachingAtTime.lastFrame < frameNum ? this._cachingAtTime.lastIndex : 0;
	      this._cachingAtTime.value = this.interpolateValue(frameNum, this._cachingAtTime);
	      this._cachingAtTime.lastFrame = frameNum;
	    }
	    return this._cachingAtTime.value;
	  }

	  function getSpeedAtTime(frameNum) {
	    var delta = -0.01;
	    var v1 = this.getValueAtTime(frameNum);
	    var v2 = this.getValueAtTime(frameNum + delta);
	    var speed = 0;
	    if (v1.length) {
	      var i;
	      for (i = 0; i < v1.length; i += 1) {
	        speed += Math.pow(v2[i] - v1[i], 2);
	      }
	      speed = Math.sqrt(speed) * 100;
	    } else {
	      speed = 0;
	    }
	    return speed;
	  }

	  function getVelocityAtTime(frameNum) {
	    if (this.vel !== undefined) {
	      return this.vel;
	    }
	    var delta = -0.001;
	    // frameNum += this.elem.data.st;
	    var v1 = this.getValueAtTime(frameNum);
	    var v2 = this.getValueAtTime(frameNum + delta);
	    var velocity;
	    if (v1.length) {
	      velocity = createTypedArray('float32', v1.length);
	      var i;
	      for (i = 0; i < v1.length; i += 1) {
	        // removing frameRate
	        // if needed, don't add it here
	        // velocity[i] = this.elem.globalData.frameRate*((v2[i] - v1[i])/delta);
	        velocity[i] = (v2[i] - v1[i]) / delta;
	      }
	    } else {
	      velocity = (v2 - v1) / delta;
	    }
	    return velocity;
	  }

	  function getStaticValueAtTime() {
	    return this.pv;
	  }

	  function setGroupProperty(propertyGroup) {
	    this.propertyGroup = propertyGroup;
	  }

	  return {
	    searchExpressions: searchExpressions,
	    getSpeedAtTime: getSpeedAtTime,
	    getVelocityAtTime: getVelocityAtTime,
	    getValueAtTime: getValueAtTime,
	    getStaticValueAtTime: getStaticValueAtTime,
	    setGroupProperty: setGroupProperty,
	  };
	}());

	/* global createTypedArray, Matrix, TransformPropertyFactory, expressionHelpers, PropertyFactory, expressionHelpers,
	initialDefaultFrame, shapePool, ShapePropertyFactory, bez, extendPrototype, ExpressionManager, createSizedArray */

	(function addPropertyDecorator() {
	  function loopOut(type, duration, durationFlag) {
	    if (!this.k || !this.keyframes) {
	      return this.pv;
	    }
	    type = type ? type.toLowerCase() : '';
	    var currentFrame = this.comp.renderedFrame;
	    var keyframes = this.keyframes;
	    var lastKeyFrame = keyframes[keyframes.length - 1].t;
	    if (currentFrame <= lastKeyFrame) {
	      return this.pv;
	    }
	    var cycleDuration;
	    var firstKeyFrame;
	    if (!durationFlag) {
	      if (!duration || duration > keyframes.length - 1) {
	        duration = keyframes.length - 1;
	      }
	      firstKeyFrame = keyframes[keyframes.length - 1 - duration].t;
	      cycleDuration = lastKeyFrame - firstKeyFrame;
	    } else {
	      if (!duration) {
	        cycleDuration = Math.max(0, lastKeyFrame - this.elem.data.ip);
	      } else {
	        cycleDuration = Math.abs(lastKeyFrame - this.elem.comp.globalData.frameRate * duration);
	      }
	      firstKeyFrame = lastKeyFrame - cycleDuration;
	    }
	    var i;
	    var len;
	    var ret;
	    if (type === 'pingpong') {
	      var iterations = Math.floor((currentFrame - firstKeyFrame) / cycleDuration);
	      if (iterations % 2 !== 0) {
	          return this.getValueAtTime(((cycleDuration - (currentFrame - firstKeyFrame) % cycleDuration + firstKeyFrame)) / this.comp.globalData.frameRate, 0); // eslint-disable-line
	      }
	    } else if (type === 'offset') {
	      var initV = this.getValueAtTime(firstKeyFrame / this.comp.globalData.frameRate, 0);
	      var endV = this.getValueAtTime(lastKeyFrame / this.comp.globalData.frameRate, 0);
	        var current = this.getValueAtTime(((currentFrame - firstKeyFrame) % cycleDuration + firstKeyFrame) / this.comp.globalData.frameRate, 0); // eslint-disable-line
	      var repeats = Math.floor((currentFrame - firstKeyFrame) / cycleDuration);
	      if (this.pv.length) {
	        ret = new Array(initV.length);
	        len = ret.length;
	        for (i = 0; i < len; i += 1) {
	          ret[i] = (endV[i] - initV[i]) * repeats + current[i];
	        }
	        return ret;
	      }
	      return (endV - initV) * repeats + current;
	    } else if (type === 'continue') {
	      var lastValue = this.getValueAtTime(lastKeyFrame / this.comp.globalData.frameRate, 0);
	      var nextLastValue = this.getValueAtTime((lastKeyFrame - 0.001) / this.comp.globalData.frameRate, 0);
	      if (this.pv.length) {
	        ret = new Array(lastValue.length);
	        len = ret.length;
	        for (i = 0; i < len; i += 1) {
	            ret[i] = lastValue[i] + (lastValue[i] - nextLastValue[i]) * ((currentFrame - lastKeyFrame) / this.comp.globalData.frameRate) / 0.0005; // eslint-disable-line
	        }
	        return ret;
	      }
	      return lastValue + (lastValue - nextLastValue) * (((currentFrame - lastKeyFrame)) / 0.001);
	    }
	      return this.getValueAtTime((((currentFrame - firstKeyFrame) % cycleDuration + firstKeyFrame)) / this.comp.globalData.frameRate, 0); // eslint-disable-line

	  }

	  function loopIn(type, duration, durationFlag) {
	    if (!this.k) {
	      return this.pv;
	    }
	    type = type ? type.toLowerCase() : '';
	    var currentFrame = this.comp.renderedFrame;
	    var keyframes = this.keyframes;
	    var firstKeyFrame = keyframes[0].t;
	    if (currentFrame >= firstKeyFrame) {
	      return this.pv;
	    }
	    var cycleDuration;
	    var lastKeyFrame;
	    if (!durationFlag) {
	      if (!duration || duration > keyframes.length - 1) {
	        duration = keyframes.length - 1;
	      }
	      lastKeyFrame = keyframes[duration].t;
	      cycleDuration = lastKeyFrame - firstKeyFrame;
	    } else {
	      if (!duration) {
	        cycleDuration = Math.max(0, this.elem.data.op - firstKeyFrame);
	      } else {
	        cycleDuration = Math.abs(this.elem.comp.globalData.frameRate * duration);
	      }
	      lastKeyFrame = firstKeyFrame + cycleDuration;
	    }
	    var i;
	    var len;
	    var ret;
	    if (type === 'pingpong') {
	      var iterations = Math.floor((firstKeyFrame - currentFrame) / cycleDuration);
	      if (iterations % 2 === 0) {
	          return this.getValueAtTime((((firstKeyFrame - currentFrame) % cycleDuration + firstKeyFrame)) / this.comp.globalData.frameRate, 0); // eslint-disable-line
	      }
	    } else if (type === 'offset') {
	      var initV = this.getValueAtTime(firstKeyFrame / this.comp.globalData.frameRate, 0);
	      var endV = this.getValueAtTime(lastKeyFrame / this.comp.globalData.frameRate, 0);
	      var current = this.getValueAtTime((cycleDuration - ((firstKeyFrame - currentFrame) % cycleDuration) + firstKeyFrame) / this.comp.globalData.frameRate, 0);
	      var repeats = Math.floor((firstKeyFrame - currentFrame) / cycleDuration) + 1;
	      if (this.pv.length) {
	        ret = new Array(initV.length);
	        len = ret.length;
	        for (i = 0; i < len; i += 1) {
	          ret[i] = current[i] - (endV[i] - initV[i]) * repeats;
	        }
	        return ret;
	      }
	      return current - (endV - initV) * repeats;
	    } else if (type === 'continue') {
	      var firstValue = this.getValueAtTime(firstKeyFrame / this.comp.globalData.frameRate, 0);
	      var nextFirstValue = this.getValueAtTime((firstKeyFrame + 0.001) / this.comp.globalData.frameRate, 0);
	      if (this.pv.length) {
	        ret = new Array(firstValue.length);
	        len = ret.length;
	        for (i = 0; i < len; i += 1) {
	          ret[i] = firstValue[i] + ((firstValue[i] - nextFirstValue[i]) * (firstKeyFrame - currentFrame)) / 0.001;
	        }
	        return ret;
	      }
	      return firstValue + ((firstValue - nextFirstValue) * (firstKeyFrame - currentFrame)) / 0.001;
	    }
	      return this.getValueAtTime(((cycleDuration - ((firstKeyFrame - currentFrame) % cycleDuration + firstKeyFrame))) / this.comp.globalData.frameRate, 0); // eslint-disable-line

	  }

	  function smooth(width, samples) {
	    if (!this.k) {
	      return this.pv;
	    }
	    width = (width || 0.4) * 0.5;
	    samples = Math.floor(samples || 5);
	    if (samples <= 1) {
	      return this.pv;
	    }
	    var currentTime = this.comp.renderedFrame / this.comp.globalData.frameRate;
	    var initFrame = currentTime - width;
	    var endFrame = currentTime + width;
	    var sampleFrequency = samples > 1 ? (endFrame - initFrame) / (samples - 1) : 1;
	    var i = 0;
	    var j = 0;
	    var value;
	    if (this.pv.length) {
	      value = createTypedArray('float32', this.pv.length);
	    } else {
	      value = 0;
	    }
	    var sampleValue;
	    while (i < samples) {
	      sampleValue = this.getValueAtTime(initFrame + i * sampleFrequency);
	      if (this.pv.length) {
	        for (j = 0; j < this.pv.length; j += 1) {
	          value[j] += sampleValue[j];
	        }
	      } else {
	        value += sampleValue;
	      }
	      i += 1;
	    }
	    if (this.pv.length) {
	      for (j = 0; j < this.pv.length; j += 1) {
	        value[j] /= samples;
	      }
	    } else {
	      value /= samples;
	    }
	    return value;
	  }

	  function getTransformValueAtTime(time) {
	    if (!this._transformCachingAtTime) {
	      this._transformCachingAtTime = {
	        v: new Matrix(),
	      };
	    }
	    /// /
	    var matrix = this._transformCachingAtTime.v;
	    matrix.cloneFromProps(this.pre.props);
	    if (this.appliedTransformations < 1) {
	      var anchor = this.a.getValueAtTime(time);
	      matrix.translate(
	        -anchor[0] * this.a.mult,
	        -anchor[1] * this.a.mult,
	        anchor[2] * this.a.mult
	      );
	    }
	    if (this.appliedTransformations < 2) {
	      var scale = this.s.getValueAtTime(time);
	      matrix.scale(
	        scale[0] * this.s.mult,
	        scale[1] * this.s.mult,
	        scale[2] * this.s.mult
	      );
	    }
	    if (this.sk && this.appliedTransformations < 3) {
	      var skew = this.sk.getValueAtTime(time);
	      var skewAxis = this.sa.getValueAtTime(time);
	      matrix.skewFromAxis(-skew * this.sk.mult, skewAxis * this.sa.mult);
	    }
	    if (this.r && this.appliedTransformations < 4) {
	      var rotation = this.r.getValueAtTime(time);
	      matrix.rotate(-rotation * this.r.mult);
	    } else if (!this.r && this.appliedTransformations < 4) {
	      var rotationZ = this.rz.getValueAtTime(time);
	      var rotationY = this.ry.getValueAtTime(time);
	      var rotationX = this.rx.getValueAtTime(time);
	      var orientation = this.or.getValueAtTime(time);
	      matrix.rotateZ(-rotationZ * this.rz.mult)
	        .rotateY(rotationY * this.ry.mult)
	        .rotateX(rotationX * this.rx.mult)
	        .rotateZ(-orientation[2] * this.or.mult)
	        .rotateY(orientation[1] * this.or.mult)
	        .rotateX(orientation[0] * this.or.mult);
	    }
	    if (this.data.p && this.data.p.s) {
	      var positionX = this.px.getValueAtTime(time);
	      var positionY = this.py.getValueAtTime(time);
	      if (this.data.p.z) {
	        var positionZ = this.pz.getValueAtTime(time);
	        matrix.translate(
	          positionX * this.px.mult,
	          positionY * this.py.mult,
	          -positionZ * this.pz.mult
	        );
	      } else {
	        matrix.translate(positionX * this.px.mult, positionY * this.py.mult, 0);
	      }
	    } else {
	      var position = this.p.getValueAtTime(time);
	      matrix.translate(
	        position[0] * this.p.mult,
	        position[1] * this.p.mult,
	        -position[2] * this.p.mult
	      );
	    }
	    return matrix;
	    /// /
	  }

	  function getTransformStaticValueAtTime() {
	    return this.v.clone(new Matrix());
	  }

	  var getTransformProperty = TransformPropertyFactory.getTransformProperty;
	  TransformPropertyFactory.getTransformProperty = function (elem, data, container) {
	    var prop = getTransformProperty(elem, data, container);
	    if (prop.dynamicProperties.length) {
	      prop.getValueAtTime = getTransformValueAtTime.bind(prop);
	    } else {
	      prop.getValueAtTime = getTransformStaticValueAtTime.bind(prop);
	    }
	    prop.setGroupProperty = expressionHelpers.setGroupProperty;
	    return prop;
	  };

	  var propertyGetProp = PropertyFactory.getProp;
	  PropertyFactory.getProp = function (elem, data, type, mult, container) {
	    var prop = propertyGetProp(elem, data, type, mult, container);
	    // prop.getVelocityAtTime = getVelocityAtTime;
	    // prop.loopOut = loopOut;
	    // prop.loopIn = loopIn;
	    if (prop.kf) {
	      prop.getValueAtTime = expressionHelpers.getValueAtTime.bind(prop);
	    } else {
	      prop.getValueAtTime = expressionHelpers.getStaticValueAtTime.bind(prop);
	    }
	    prop.setGroupProperty = expressionHelpers.setGroupProperty;
	    prop.loopOut = loopOut;
	    prop.loopIn = loopIn;
	    prop.smooth = smooth;
	    prop.getVelocityAtTime = expressionHelpers.getVelocityAtTime.bind(prop);
	    prop.getSpeedAtTime = expressionHelpers.getSpeedAtTime.bind(prop);
	    prop.numKeys = data.a === 1 ? data.k.length : 0;
	    prop.propertyIndex = data.ix;
	    var value = 0;
	    if (type !== 0) {
	      value = createTypedArray('float32', data.a === 1 ? data.k[0].s.length : data.k.length);
	    }
	    prop._cachingAtTime = {
	      lastFrame: initialDefaultFrame,
	      lastIndex: 0,
	      value: value,
	    };
	    expressionHelpers.searchExpressions(elem, data, prop);
	    if (prop.k) {
	      container.addDynamicProperty(prop);
	    }

	    return prop;
	  };

	  function getShapeValueAtTime(frameNum) {
	    // For now this caching object is created only when needed instead of creating it when the shape is initialized.
	    if (!this._cachingAtTime) {
	      this._cachingAtTime = {
	        shapeValue: shapePool.clone(this.pv),
	        lastIndex: 0,
	        lastTime: initialDefaultFrame,
	      };
	    }

	    frameNum *= this.elem.globalData.frameRate;
	    frameNum -= this.offsetTime;
	    if (frameNum !== this._cachingAtTime.lastTime) {
	      this._cachingAtTime.lastIndex = this._cachingAtTime.lastTime < frameNum ? this._caching.lastIndex : 0;
	      this._cachingAtTime.lastTime = frameNum;
	      this.interpolateShape(frameNum, this._cachingAtTime.shapeValue, this._cachingAtTime);
	    }
	    return this._cachingAtTime.shapeValue;
	  }

	  var ShapePropertyConstructorFunction = ShapePropertyFactory.getConstructorFunction();
	  var KeyframedShapePropertyConstructorFunction = ShapePropertyFactory.getKeyframedConstructorFunction();

	  function ShapeExpressions() {}
	  ShapeExpressions.prototype = {
	    vertices: function (prop, time) {
	      if (this.k) {
	        this.getValue();
	      }
	      var shapePath = this.v;
	      if (time !== undefined) {
	        shapePath = this.getValueAtTime(time, 0);
	      }
	      var i;
	      var len = shapePath._length;
	      var vertices = shapePath[prop];
	      var points = shapePath.v;
	      var arr = createSizedArray(len);
	      for (i = 0; i < len; i += 1) {
	        if (prop === 'i' || prop === 'o') {
	          arr[i] = [vertices[i][0] - points[i][0], vertices[i][1] - points[i][1]];
	        } else {
	          arr[i] = [vertices[i][0], vertices[i][1]];
	        }
	      }
	      return arr;
	    },
	    points: function (time) {
	      return this.vertices('v', time);
	    },
	    inTangents: function (time) {
	      return this.vertices('i', time);
	    },
	    outTangents: function (time) {
	      return this.vertices('o', time);
	    },
	    isClosed: function () {
	      return this.v.c;
	    },
	    pointOnPath: function (perc, time) {
	      var shapePath = this.v;
	      if (time !== undefined) {
	        shapePath = this.getValueAtTime(time, 0);
	      }
	      if (!this._segmentsLength) {
	        this._segmentsLength = bez.getSegmentsLength(shapePath);
	      }

	      var segmentsLength = this._segmentsLength;
	      var lengths = segmentsLength.lengths;
	      var lengthPos = segmentsLength.totalLength * perc;
	      var i = 0;
	      var len = lengths.length;
	      var accumulatedLength = 0;
	      var pt;
	      while (i < len) {
	        if (accumulatedLength + lengths[i].addedLength > lengthPos) {
	          var initIndex = i;
	          var endIndex = (shapePath.c && i === len - 1) ? 0 : i + 1;
	          var segmentPerc = (lengthPos - accumulatedLength) / lengths[i].addedLength;
	          pt = bez.getPointInSegment(shapePath.v[initIndex], shapePath.v[endIndex], shapePath.o[initIndex], shapePath.i[endIndex], segmentPerc, lengths[i]);
	          break;
	        } else {
	          accumulatedLength += lengths[i].addedLength;
	        }
	        i += 1;
	      }
	      if (!pt) {
	        pt = shapePath.c ? [shapePath.v[0][0], shapePath.v[0][1]] : [shapePath.v[shapePath._length - 1][0], shapePath.v[shapePath._length - 1][1]];
	      }
	      return pt;
	    },
	    vectorOnPath: function (perc, time, vectorType) {
	      // perc doesn't use triple equality because it can be a Number object as well as a primitive.
	      if (perc == 1) { // eslint-disable-line eqeqeq
	        perc = this.v.c;
	      } else if (perc == 0) { // eslint-disable-line eqeqeq
	        perc = 0.999;
	      }
	      var pt1 = this.pointOnPath(perc, time);
	      var pt2 = this.pointOnPath(perc + 0.001, time);
	      var xLength = pt2[0] - pt1[0];
	      var yLength = pt2[1] - pt1[1];
	      var magnitude = Math.sqrt(Math.pow(xLength, 2) + Math.pow(yLength, 2));
	      if (magnitude === 0) {
	        return [0, 0];
	      }
	      var unitVector = vectorType === 'tangent' ? [xLength / magnitude, yLength / magnitude] : [-yLength / magnitude, xLength / magnitude];
	      return unitVector;
	    },
	    tangentOnPath: function (perc, time) {
	      return this.vectorOnPath(perc, time, 'tangent');
	    },
	    normalOnPath: function (perc, time) {
	      return this.vectorOnPath(perc, time, 'normal');
	    },
	    setGroupProperty: expressionHelpers.setGroupProperty,
	    getValueAtTime: expressionHelpers.getStaticValueAtTime,
	  };
	  extendPrototype([ShapeExpressions], ShapePropertyConstructorFunction);
	  extendPrototype([ShapeExpressions], KeyframedShapePropertyConstructorFunction);
	  KeyframedShapePropertyConstructorFunction.prototype.getValueAtTime = getShapeValueAtTime;
	  KeyframedShapePropertyConstructorFunction.prototype.initiateExpression = ExpressionManager.initiateExpression;

	  var propertyGetShapeProp = ShapePropertyFactory.getShapeProp;
	  ShapePropertyFactory.getShapeProp = function (elem, data, type, arr, trims) {
	    var prop = propertyGetShapeProp(elem, data, type, arr, trims);
	    prop.propertyIndex = data.ix;
	    prop.lock = false;
	    if (type === 3) {
	      expressionHelpers.searchExpressions(elem, data.pt, prop);
	    } else if (type === 4) {
	      expressionHelpers.searchExpressions(elem, data.ks, prop);
	    }
	    if (prop.k) {
	      elem.addDynamicProperty(prop);
	    }
	    return prop;
	  };
	}());

	/* global ExpressionManager, TextProperty */

	(function addDecorator() {
	  function searchExpressions() {
	    if (this.data.d.x) {
	      this.calculateExpression = ExpressionManager.initiateExpression.bind(this)(this.elem, this.data.d, this);
	      this.addEffect(this.getExpressionValue.bind(this));
	      return true;
	    }
	    return null;
	  }

	  TextProperty.prototype.getExpressionValue = function (currentValue, text) {
	    var newValue = this.calculateExpression(text);
	    if (currentValue.t !== newValue) {
	      var newData = {};
	      this.copyData(newData, currentValue);
	      newData.t = newValue.toString();
	      newData.__complete = false;
	      return newData;
	    }
	    return currentValue;
	  };

	  TextProperty.prototype.searchProperty = function () {
	    var isKeyframed = this.searchKeyframes();
	    var hasExpressions = this.searchExpressions();
	    this.kf = isKeyframed || hasExpressions;
	    return this.kf;
	  };

	  TextProperty.prototype.searchExpressions = searchExpressions;
	}());

	/* global propertyGroupFactory, PropertyInterface */
	/* exported ShapePathInterface */

	var ShapePathInterface = (

	  function () {
	    return function pathInterfaceFactory(shape, view, propertyGroup) {
	      var prop = view.sh;

	      function interfaceFunction(val) {
	        if (val === 'Shape' || val === 'shape' || val === 'Path' || val === 'path' || val === 'ADBE Vector Shape' || val === 2) {
	          return interfaceFunction.path;
	        }
	        return null;
	      }

	      var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
	      prop.setGroupProperty(PropertyInterface('Path', _propertyGroup));
	      Object.defineProperties(interfaceFunction, {
	        path: {
	          get: function () {
	            if (prop.k) {
	              prop.getValue();
	            }
	            return prop;
	          },
	        },
	        shape: {
	          get: function () {
	            if (prop.k) {
	              prop.getValue();
	            }
	            return prop;
	          },
	        },
	        _name: { value: shape.nm },
	        ix: { value: shape.ix },
	        propertyIndex: { value: shape.ix },
	        mn: { value: shape.mn },
	        propertyGroup: { value: propertyGroup },
	      });
	      return interfaceFunction;
	    };
	  }()
	);

	/* exported propertyGroupFactory */

	var propertyGroupFactory = (function () {
	  return function (interfaceFunction, parentPropertyGroup) {
	    return function (val) {
	      val = val === undefined ? 1 : val;
	      if (val <= 0) {
	        return interfaceFunction;
	      }
	      return parentPropertyGroup(val - 1);
	    };
	  };
	}());

	/* exported PropertyInterface */

	var PropertyInterface = (function () {
	  return function (propertyName, propertyGroup) {
	    var interfaceFunction = {
	      _name: propertyName,
	    };

	    function _propertyGroup(val) {
	      val = val === undefined ? 1 : val;
	      if (val <= 0) {
	        return interfaceFunction;
	      }
	      return propertyGroup(val - 1);
	    }

	    return _propertyGroup;
	  };
	}());

	/* global ExpressionPropertyInterface, PropertyInterface, propertyGroupFactory, ShapePathInterface */
	/* exported ShapeExpressionInterface */

	var ShapeExpressionInterface = (function () {
	  function iterateElements(shapes, view, propertyGroup) {
	    var arr = [];
	    var i;
	    var len = shapes ? shapes.length : 0;
	    for (i = 0; i < len; i += 1) {
	      if (shapes[i].ty === 'gr') {
	        arr.push(groupInterfaceFactory(shapes[i], view[i], propertyGroup));
	      } else if (shapes[i].ty === 'fl') {
	        arr.push(fillInterfaceFactory(shapes[i], view[i], propertyGroup));
	      } else if (shapes[i].ty === 'st') {
	        arr.push(strokeInterfaceFactory(shapes[i], view[i], propertyGroup));
	      } else if (shapes[i].ty === 'tm') {
	        arr.push(trimInterfaceFactory(shapes[i], view[i], propertyGroup));
	      } else if (shapes[i].ty === 'tr') {
	        // arr.push(transformInterfaceFactory(shapes[i],view[i],propertyGroup));
	      } else if (shapes[i].ty === 'el') {
	        arr.push(ellipseInterfaceFactory(shapes[i], view[i], propertyGroup));
	      } else if (shapes[i].ty === 'sr') {
	        arr.push(starInterfaceFactory(shapes[i], view[i], propertyGroup));
	      } else if (shapes[i].ty === 'sh') {
	        arr.push(ShapePathInterface(shapes[i], view[i], propertyGroup));
	      } else if (shapes[i].ty === 'rc') {
	        arr.push(rectInterfaceFactory(shapes[i], view[i], propertyGroup));
	      } else if (shapes[i].ty === 'rd') {
	        arr.push(roundedInterfaceFactory(shapes[i], view[i], propertyGroup));
	      } else if (shapes[i].ty === 'rp') {
	        arr.push(repeaterInterfaceFactory(shapes[i], view[i], propertyGroup));
	      } else if (shapes[i].ty === 'gf') {
	        arr.push(gradientFillInterfaceFactory(shapes[i], view[i], propertyGroup));
	      } else {
	        arr.push(defaultInterfaceFactory(shapes[i], view[i], propertyGroup));
	      }
	    }
	    return arr;
	  }

	  function contentsInterfaceFactory(shape, view, propertyGroup) {
	    var interfaces;
	    var interfaceFunction = function _interfaceFunction(value) {
	      var i = 0;
	      var len = interfaces.length;
	      while (i < len) {
	        if (interfaces[i]._name === value || interfaces[i].mn === value || interfaces[i].propertyIndex === value || interfaces[i].ix === value || interfaces[i].ind === value) {
	          return interfaces[i];
	        }
	        i += 1;
	      }
	      if (typeof value === 'number') {
	        return interfaces[value - 1];
	      }
	      return null;
	    };

	    interfaceFunction.propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
	    interfaces = iterateElements(shape.it, view.it, interfaceFunction.propertyGroup);
	    interfaceFunction.numProperties = interfaces.length;
	    var transformInterface = transformInterfaceFactory(shape.it[shape.it.length - 1], view.it[view.it.length - 1], interfaceFunction.propertyGroup);
	    interfaceFunction.transform = transformInterface;
	    interfaceFunction.propertyIndex = shape.cix;
	    interfaceFunction._name = shape.nm;

	    return interfaceFunction;
	  }

	  function groupInterfaceFactory(shape, view, propertyGroup) {
	    var interfaceFunction = function _interfaceFunction(value) {
	      switch (value) {
	        case 'ADBE Vectors Group':
	        case 'Contents':
	        case 2:
	          return interfaceFunction.content;
	          // Not necessary for now. Keeping them here in case a new case appears
	          // case 'ADBE Vector Transform Group':
	          // case 3:
	        default:
	          return interfaceFunction.transform;
	      }
	    };
	    interfaceFunction.propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
	    var content = contentsInterfaceFactory(shape, view, interfaceFunction.propertyGroup);
	    var transformInterface = transformInterfaceFactory(shape.it[shape.it.length - 1], view.it[view.it.length - 1], interfaceFunction.propertyGroup);
	    interfaceFunction.content = content;
	    interfaceFunction.transform = transformInterface;
	    Object.defineProperty(interfaceFunction, '_name', {
	      get: function () {
	        return shape.nm;
	      },
	    });
	    // interfaceFunction.content = interfaceFunction;
	    interfaceFunction.numProperties = shape.np;
	    interfaceFunction.propertyIndex = shape.ix;
	    interfaceFunction.nm = shape.nm;
	    interfaceFunction.mn = shape.mn;
	    return interfaceFunction;
	  }

	  function fillInterfaceFactory(shape, view, propertyGroup) {
	    function interfaceFunction(val) {
	      if (val === 'Color' || val === 'color') {
	        return interfaceFunction.color;
	      } if (val === 'Opacity' || val === 'opacity') {
	        return interfaceFunction.opacity;
	      }
	      return null;
	    }
	    Object.defineProperties(interfaceFunction, {
	      color: {
	        get: ExpressionPropertyInterface(view.c),
	      },
	      opacity: {
	        get: ExpressionPropertyInterface(view.o),
	      },
	      _name: { value: shape.nm },
	      mn: { value: shape.mn },
	    });

	    view.c.setGroupProperty(PropertyInterface('Color', propertyGroup));
	    view.o.setGroupProperty(PropertyInterface('Opacity', propertyGroup));
	    return interfaceFunction;
	  }

	  function gradientFillInterfaceFactory(shape, view, propertyGroup) {
	    function interfaceFunction(val) {
	      if (val === 'Start Point' || val === 'start point') {
	        return interfaceFunction.startPoint;
	      }
	      if (val === 'End Point' || val === 'end point') {
	        return interfaceFunction.endPoint;
	      }
	      if (val === 'Opacity' || val === 'opacity') {
	        return interfaceFunction.opacity;
	      }
	      return null;
	    }
	    Object.defineProperties(interfaceFunction, {
	      startPoint: {
	        get: ExpressionPropertyInterface(view.s),
	      },
	      endPoint: {
	        get: ExpressionPropertyInterface(view.e),
	      },
	      opacity: {
	        get: ExpressionPropertyInterface(view.o),
	      },
	      type: {
	        get: function () {
	          return 'a';
	        },
	      },
	      _name: { value: shape.nm },
	      mn: { value: shape.mn },
	    });

	    view.s.setGroupProperty(PropertyInterface('Start Point', propertyGroup));
	    view.e.setGroupProperty(PropertyInterface('End Point', propertyGroup));
	    view.o.setGroupProperty(PropertyInterface('Opacity', propertyGroup));
	    return interfaceFunction;
	  }
	  function defaultInterfaceFactory() {
	    function interfaceFunction() {
	      return null;
	    }
	    return interfaceFunction;
	  }

	  function strokeInterfaceFactory(shape, view, propertyGroup) {
	    var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
	    var _dashPropertyGroup = propertyGroupFactory(dashOb, _propertyGroup);
	    function addPropertyToDashOb(i) {
	      Object.defineProperty(dashOb, shape.d[i].nm, {
	        get: ExpressionPropertyInterface(view.d.dataProps[i].p),
	      });
	    }
	    var i;
	    var len = shape.d ? shape.d.length : 0;
	    var dashOb = {};
	    for (i = 0; i < len; i += 1) {
	      addPropertyToDashOb(i);
	      view.d.dataProps[i].p.setGroupProperty(_dashPropertyGroup);
	    }

	    function interfaceFunction(val) {
	      if (val === 'Color' || val === 'color') {
	        return interfaceFunction.color;
	      } if (val === 'Opacity' || val === 'opacity') {
	        return interfaceFunction.opacity;
	      } if (val === 'Stroke Width' || val === 'stroke width') {
	        return interfaceFunction.strokeWidth;
	      }
	      return null;
	    }
	    Object.defineProperties(interfaceFunction, {
	      color: {
	        get: ExpressionPropertyInterface(view.c),
	      },
	      opacity: {
	        get: ExpressionPropertyInterface(view.o),
	      },
	      strokeWidth: {
	        get: ExpressionPropertyInterface(view.w),
	      },
	      dash: {
	        get: function () {
	          return dashOb;
	        },
	      },
	      _name: { value: shape.nm },
	      mn: { value: shape.mn },
	    });

	    view.c.setGroupProperty(PropertyInterface('Color', _propertyGroup));
	    view.o.setGroupProperty(PropertyInterface('Opacity', _propertyGroup));
	    view.w.setGroupProperty(PropertyInterface('Stroke Width', _propertyGroup));
	    return interfaceFunction;
	  }

	  function trimInterfaceFactory(shape, view, propertyGroup) {
	    function interfaceFunction(val) {
	      if (val === shape.e.ix || val === 'End' || val === 'end') {
	        return interfaceFunction.end;
	      }
	      if (val === shape.s.ix) {
	        return interfaceFunction.start;
	      }
	      if (val === shape.o.ix) {
	        return interfaceFunction.offset;
	      }
	      return null;
	    }

	    var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
	    interfaceFunction.propertyIndex = shape.ix;

	    view.s.setGroupProperty(PropertyInterface('Start', _propertyGroup));
	    view.e.setGroupProperty(PropertyInterface('End', _propertyGroup));
	    view.o.setGroupProperty(PropertyInterface('Offset', _propertyGroup));
	    interfaceFunction.propertyIndex = shape.ix;
	    interfaceFunction.propertyGroup = propertyGroup;

	    Object.defineProperties(interfaceFunction, {
	      start: {
	        get: ExpressionPropertyInterface(view.s),
	      },
	      end: {
	        get: ExpressionPropertyInterface(view.e),
	      },
	      offset: {
	        get: ExpressionPropertyInterface(view.o),
	      },
	      _name: { value: shape.nm },
	    });
	    interfaceFunction.mn = shape.mn;
	    return interfaceFunction;
	  }

	  function transformInterfaceFactory(shape, view, propertyGroup) {
	    function interfaceFunction(value) {
	      if (shape.a.ix === value || value === 'Anchor Point') {
	        return interfaceFunction.anchorPoint;
	      }
	      if (shape.o.ix === value || value === 'Opacity') {
	        return interfaceFunction.opacity;
	      }
	      if (shape.p.ix === value || value === 'Position') {
	        return interfaceFunction.position;
	      }
	      if (shape.r.ix === value || value === 'Rotation' || value === 'ADBE Vector Rotation') {
	        return interfaceFunction.rotation;
	      }
	      if (shape.s.ix === value || value === 'Scale') {
	        return interfaceFunction.scale;
	      }
	      if ((shape.sk && shape.sk.ix === value) || value === 'Skew') {
	        return interfaceFunction.skew;
	      }
	      if ((shape.sa && shape.sa.ix === value) || value === 'Skew Axis') {
	        return interfaceFunction.skewAxis;
	      }
	      return null;
	    }
	    var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
	    view.transform.mProps.o.setGroupProperty(PropertyInterface('Opacity', _propertyGroup));
	    view.transform.mProps.p.setGroupProperty(PropertyInterface('Position', _propertyGroup));
	    view.transform.mProps.a.setGroupProperty(PropertyInterface('Anchor Point', _propertyGroup));
	    view.transform.mProps.s.setGroupProperty(PropertyInterface('Scale', _propertyGroup));
	    view.transform.mProps.r.setGroupProperty(PropertyInterface('Rotation', _propertyGroup));
	    if (view.transform.mProps.sk) {
	      view.transform.mProps.sk.setGroupProperty(PropertyInterface('Skew', _propertyGroup));
	      view.transform.mProps.sa.setGroupProperty(PropertyInterface('Skew Angle', _propertyGroup));
	    }
	    view.transform.op.setGroupProperty(PropertyInterface('Opacity', _propertyGroup));
	    Object.defineProperties(interfaceFunction, {
	      opacity: {
	        get: ExpressionPropertyInterface(view.transform.mProps.o),
	      },
	      position: {
	        get: ExpressionPropertyInterface(view.transform.mProps.p),
	      },
	      anchorPoint: {
	        get: ExpressionPropertyInterface(view.transform.mProps.a),
	      },
	      scale: {
	        get: ExpressionPropertyInterface(view.transform.mProps.s),
	      },
	      rotation: {
	        get: ExpressionPropertyInterface(view.transform.mProps.r),
	      },
	      skew: {
	        get: ExpressionPropertyInterface(view.transform.mProps.sk),
	      },
	      skewAxis: {
	        get: ExpressionPropertyInterface(view.transform.mProps.sa),
	      },
	      _name: { value: shape.nm },
	    });
	    interfaceFunction.ty = 'tr';
	    interfaceFunction.mn = shape.mn;
	    interfaceFunction.propertyGroup = propertyGroup;
	    return interfaceFunction;
	  }

	  function ellipseInterfaceFactory(shape, view, propertyGroup) {
	    function interfaceFunction(value) {
	      if (shape.p.ix === value) {
	        return interfaceFunction.position;
	      }
	      if (shape.s.ix === value) {
	        return interfaceFunction.size;
	      }
	      return null;
	    }
	    var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
	    interfaceFunction.propertyIndex = shape.ix;
	    var prop = view.sh.ty === 'tm' ? view.sh.prop : view.sh;
	    prop.s.setGroupProperty(PropertyInterface('Size', _propertyGroup));
	    prop.p.setGroupProperty(PropertyInterface('Position', _propertyGroup));

	    Object.defineProperties(interfaceFunction, {
	      size: {
	        get: ExpressionPropertyInterface(prop.s),
	      },
	      position: {
	        get: ExpressionPropertyInterface(prop.p),
	      },
	      _name: { value: shape.nm },
	    });
	    interfaceFunction.mn = shape.mn;
	    return interfaceFunction;
	  }

	  function starInterfaceFactory(shape, view, propertyGroup) {
	    function interfaceFunction(value) {
	      if (shape.p.ix === value) {
	        return interfaceFunction.position;
	      }
	      if (shape.r.ix === value) {
	        return interfaceFunction.rotation;
	      }
	      if (shape.pt.ix === value) {
	        return interfaceFunction.points;
	      }
	      if (shape.or.ix === value || value === 'ADBE Vector Star Outer Radius') {
	        return interfaceFunction.outerRadius;
	      }
	      if (shape.os.ix === value) {
	        return interfaceFunction.outerRoundness;
	      }
	      if (shape.ir && (shape.ir.ix === value || value === 'ADBE Vector Star Inner Radius')) {
	        return interfaceFunction.innerRadius;
	      }
	      if (shape.is && shape.is.ix === value) {
	        return interfaceFunction.innerRoundness;
	      }
	      return null;
	    }

	    var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
	    var prop = view.sh.ty === 'tm' ? view.sh.prop : view.sh;
	    interfaceFunction.propertyIndex = shape.ix;
	    prop.or.setGroupProperty(PropertyInterface('Outer Radius', _propertyGroup));
	    prop.os.setGroupProperty(PropertyInterface('Outer Roundness', _propertyGroup));
	    prop.pt.setGroupProperty(PropertyInterface('Points', _propertyGroup));
	    prop.p.setGroupProperty(PropertyInterface('Position', _propertyGroup));
	    prop.r.setGroupProperty(PropertyInterface('Rotation', _propertyGroup));
	    if (shape.ir) {
	      prop.ir.setGroupProperty(PropertyInterface('Inner Radius', _propertyGroup));
	      prop.is.setGroupProperty(PropertyInterface('Inner Roundness', _propertyGroup));
	    }

	    Object.defineProperties(interfaceFunction, {
	      position: {
	        get: ExpressionPropertyInterface(prop.p),
	      },
	      rotation: {
	        get: ExpressionPropertyInterface(prop.r),
	      },
	      points: {
	        get: ExpressionPropertyInterface(prop.pt),
	      },
	      outerRadius: {
	        get: ExpressionPropertyInterface(prop.or),
	      },
	      outerRoundness: {
	        get: ExpressionPropertyInterface(prop.os),
	      },
	      innerRadius: {
	        get: ExpressionPropertyInterface(prop.ir),
	      },
	      innerRoundness: {
	        get: ExpressionPropertyInterface(prop.is),
	      },
	      _name: { value: shape.nm },
	    });
	    interfaceFunction.mn = shape.mn;
	    return interfaceFunction;
	  }

	  function rectInterfaceFactory(shape, view, propertyGroup) {
	    function interfaceFunction(value) {
	      if (shape.p.ix === value) {
	        return interfaceFunction.position;
	      }
	      if (shape.r.ix === value) {
	        return interfaceFunction.roundness;
	      }
	      if (shape.s.ix === value || value === 'Size' || value === 'ADBE Vector Rect Size') {
	        return interfaceFunction.size;
	      }
	      return null;
	    }
	    var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);

	    var prop = view.sh.ty === 'tm' ? view.sh.prop : view.sh;
	    interfaceFunction.propertyIndex = shape.ix;
	    prop.p.setGroupProperty(PropertyInterface('Position', _propertyGroup));
	    prop.s.setGroupProperty(PropertyInterface('Size', _propertyGroup));
	    prop.r.setGroupProperty(PropertyInterface('Rotation', _propertyGroup));

	    Object.defineProperties(interfaceFunction, {
	      position: {
	        get: ExpressionPropertyInterface(prop.p),
	      },
	      roundness: {
	        get: ExpressionPropertyInterface(prop.r),
	      },
	      size: {
	        get: ExpressionPropertyInterface(prop.s),
	      },
	      _name: { value: shape.nm },
	    });
	    interfaceFunction.mn = shape.mn;
	    return interfaceFunction;
	  }

	  function roundedInterfaceFactory(shape, view, propertyGroup) {
	    function interfaceFunction(value) {
	      if (shape.r.ix === value || value === 'Round Corners 1') {
	        return interfaceFunction.radius;
	      }
	      return null;
	    }

	    var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
	    var prop = view;
	    interfaceFunction.propertyIndex = shape.ix;
	    prop.rd.setGroupProperty(PropertyInterface('Radius', _propertyGroup));

	    Object.defineProperties(interfaceFunction, {
	      radius: {
	        get: ExpressionPropertyInterface(prop.rd),
	      },
	      _name: { value: shape.nm },
	    });
	    interfaceFunction.mn = shape.mn;
	    return interfaceFunction;
	  }

	  function repeaterInterfaceFactory(shape, view, propertyGroup) {
	    function interfaceFunction(value) {
	      if (shape.c.ix === value || value === 'Copies') {
	        return interfaceFunction.copies;
	      } if (shape.o.ix === value || value === 'Offset') {
	        return interfaceFunction.offset;
	      }
	      return null;
	    }

	    var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
	    var prop = view;
	    interfaceFunction.propertyIndex = shape.ix;
	    prop.c.setGroupProperty(PropertyInterface('Copies', _propertyGroup));
	    prop.o.setGroupProperty(PropertyInterface('Offset', _propertyGroup));
	    Object.defineProperties(interfaceFunction, {
	      copies: {
	        get: ExpressionPropertyInterface(prop.c),
	      },
	      offset: {
	        get: ExpressionPropertyInterface(prop.o),
	      },
	      _name: { value: shape.nm },
	    });
	    interfaceFunction.mn = shape.mn;
	    return interfaceFunction;
	  }

	  return function (shapes, view, propertyGroup) {
	    var interfaces;
	    function _interfaceFunction(value) {
	      if (typeof value === 'number') {
	        value = value === undefined ? 1 : value;
	        if (value === 0) {
	          return propertyGroup;
	        }
	        return interfaces[value - 1];
	      }
	      var i = 0;
	      var len = interfaces.length;
	      while (i < len) {
	        if (interfaces[i]._name === value) {
	          return interfaces[i];
	        }
	        i += 1;
	      }
	      return null;
	    }
	    function parentGroupWrapper() {
	      return propertyGroup;
	    }
	    _interfaceFunction.propertyGroup = propertyGroupFactory(_interfaceFunction, parentGroupWrapper);
	    interfaces = iterateElements(shapes, view, _interfaceFunction.propertyGroup);
	    _interfaceFunction.numProperties = interfaces.length;
	    _interfaceFunction._name = 'Contents';
	    return _interfaceFunction;
	  };
	}());

	/* exported TextExpressionInterface */

	var TextExpressionInterface = (function () {
	  return function (elem) {
	    var _prevValue;
	    var _sourceText;
	    function _thisLayerFunction(name) {
	      switch (name) {
	        case 'ADBE Text Document':
	          return _thisLayerFunction.sourceText;
	        default:
	          return null;
	      }
	    }
	    Object.defineProperty(_thisLayerFunction, 'sourceText', {
	      get: function () {
	        elem.textProperty.getValue();
	        var stringValue = elem.textProperty.currentData.t;
	        if (stringValue !== _prevValue) {
	          elem.textProperty.currentData.t = _prevValue;
	          _sourceText = new String(stringValue); // eslint-disable-line no-new-wrappers
	          // If stringValue is an empty string, eval returns undefined, so it has to be returned as a String primitive
	          _sourceText.value = stringValue || new String(stringValue); // eslint-disable-line no-new-wrappers
	        }
	        return _sourceText;
	      },
	    });
	    return _thisLayerFunction;
	  };
	}());

	/* global Matrix, MaskManagerInterface, TransformExpressionInterface, getDescriptor */
	/* exported LayerExpressionInterface */

	var LayerExpressionInterface = (function () {
	  function getMatrix(time) {
	    var toWorldMat = new Matrix();
	    if (time !== undefined) {
	      var propMatrix = this._elem.finalTransform.mProp.getValueAtTime(time);
	      propMatrix.clone(toWorldMat);
	    } else {
	      var transformMat = this._elem.finalTransform.mProp;
	      transformMat.applyToMatrix(toWorldMat);
	    }
	    return toWorldMat;
	  }

	  function toWorldVec(arr, time) {
	    var toWorldMat = this.getMatrix(time);
	    toWorldMat.props[12] = 0;
	    toWorldMat.props[13] = 0;
	    toWorldMat.props[14] = 0;
	    return this.applyPoint(toWorldMat, arr);
	  }

	  function toWorld(arr, time) {
	    var toWorldMat = this.getMatrix(time);
	    return this.applyPoint(toWorldMat, arr);
	  }

	  function fromWorldVec(arr, time) {
	    var toWorldMat = this.getMatrix(time);
	    toWorldMat.props[12] = 0;
	    toWorldMat.props[13] = 0;
	    toWorldMat.props[14] = 0;
	    return this.invertPoint(toWorldMat, arr);
	  }

	  function fromWorld(arr, time) {
	    var toWorldMat = this.getMatrix(time);
	    return this.invertPoint(toWorldMat, arr);
	  }

	  function applyPoint(matrix, arr) {
	    if (this._elem.hierarchy && this._elem.hierarchy.length) {
	      var i;
	      var len = this._elem.hierarchy.length;
	      for (i = 0; i < len; i += 1) {
	        this._elem.hierarchy[i].finalTransform.mProp.applyToMatrix(matrix);
	      }
	    }
	    return matrix.applyToPointArray(arr[0], arr[1], arr[2] || 0);
	  }

	  function invertPoint(matrix, arr) {
	    if (this._elem.hierarchy && this._elem.hierarchy.length) {
	      var i;
	      var len = this._elem.hierarchy.length;
	      for (i = 0; i < len; i += 1) {
	        this._elem.hierarchy[i].finalTransform.mProp.applyToMatrix(matrix);
	      }
	    }
	    return matrix.inversePoint(arr);
	  }

	  function fromComp(arr) {
	    var toWorldMat = new Matrix();
	    toWorldMat.reset();
	    this._elem.finalTransform.mProp.applyToMatrix(toWorldMat);
	    if (this._elem.hierarchy && this._elem.hierarchy.length) {
	      var i;
	      var len = this._elem.hierarchy.length;
	      for (i = 0; i < len; i += 1) {
	        this._elem.hierarchy[i].finalTransform.mProp.applyToMatrix(toWorldMat);
	      }
	      return toWorldMat.inversePoint(arr);
	    }
	    return toWorldMat.inversePoint(arr);
	  }

	  function sampleImage() {
	    return [1, 1, 1, 1];
	  }

	  return function (elem) {
	    var transformInterface;

	    function _registerMaskInterface(maskManager) {
	      _thisLayerFunction.mask = new MaskManagerInterface(maskManager, elem);
	    }
	    function _registerEffectsInterface(effects) {
	      _thisLayerFunction.effect = effects;
	    }

	    function _thisLayerFunction(name) {
	      switch (name) {
	        case 'ADBE Root Vectors Group':
	        case 'Contents':
	        case 2:
	          return _thisLayerFunction.shapeInterface;
	        case 1:
	        case 6:
	        case 'Transform':
	        case 'transform':
	        case 'ADBE Transform Group':
	          return transformInterface;
	        case 4:
	        case 'ADBE Effect Parade':
	        case 'effects':
	        case 'Effects':
	          return _thisLayerFunction.effect;
	        case 'ADBE Text Properties':
	          return _thisLayerFunction.textInterface;
	        default:
	          return null;
	      }
	    }
	    _thisLayerFunction.getMatrix = getMatrix;
	    _thisLayerFunction.invertPoint = invertPoint;
	    _thisLayerFunction.applyPoint = applyPoint;
	    _thisLayerFunction.toWorld = toWorld;
	    _thisLayerFunction.toWorldVec = toWorldVec;
	    _thisLayerFunction.fromWorld = fromWorld;
	    _thisLayerFunction.fromWorldVec = fromWorldVec;
	    _thisLayerFunction.toComp = toWorld;
	    _thisLayerFunction.fromComp = fromComp;
	    _thisLayerFunction.sampleImage = sampleImage;
	    _thisLayerFunction.sourceRectAtTime = elem.sourceRectAtTime.bind(elem);
	    _thisLayerFunction._elem = elem;
	    transformInterface = TransformExpressionInterface(elem.finalTransform.mProp);
	    var anchorPointDescriptor = getDescriptor(transformInterface, 'anchorPoint');
	    Object.defineProperties(_thisLayerFunction, {
	      hasParent: {
	        get: function () {
	          return elem.hierarchy.length;
	        },
	      },
	      parent: {
	        get: function () {
	          return elem.hierarchy[0].layerInterface;
	        },
	      },
	      rotation: getDescriptor(transformInterface, 'rotation'),
	      scale: getDescriptor(transformInterface, 'scale'),
	      position: getDescriptor(transformInterface, 'position'),
	      opacity: getDescriptor(transformInterface, 'opacity'),
	      anchorPoint: anchorPointDescriptor,
	      anchor_point: anchorPointDescriptor,
	      transform: {
	        get: function () {
	          return transformInterface;
	        },
	      },
	      active: {
	        get: function () {
	          return elem.isInRange;
	        },
	      },
	    });

	    _thisLayerFunction.startTime = elem.data.st;
	    _thisLayerFunction.index = elem.data.ind;
	    _thisLayerFunction.source = elem.data.refId;
	    _thisLayerFunction.height = elem.data.ty === 0 ? elem.data.h : 100;
	    _thisLayerFunction.width = elem.data.ty === 0 ? elem.data.w : 100;
	    _thisLayerFunction.inPoint = elem.data.ip / elem.comp.globalData.frameRate;
	    _thisLayerFunction.outPoint = elem.data.op / elem.comp.globalData.frameRate;
	    _thisLayerFunction._name = elem.data.nm;

	    _thisLayerFunction.registerMaskInterface = _registerMaskInterface;
	    _thisLayerFunction.registerEffectsInterface = _registerEffectsInterface;
	    return _thisLayerFunction;
	  };
	}());

	/* global */
	/* exported FootageInterface */

	var FootageInterface = (function () {
	  var outlineInterfaceFactory = (function (elem) {
	    var currentPropertyName = '';
	    var currentProperty = elem.getFootageData();
	    function init() {
	      currentPropertyName = '';
	      currentProperty = elem.getFootageData();
	      return searchProperty;
	    }
	    function searchProperty(value) {
	      if (currentProperty[value]) {
	        currentPropertyName = value;
	        currentProperty = currentProperty[value];
	        if (typeof currentProperty === 'object') {
	          return searchProperty;
	        }
	        return currentProperty;
	      }
	      var propertyNameIndex = value.indexOf(currentPropertyName);
	      if (propertyNameIndex !== -1) {
	        var index = parseInt(value.substr(propertyNameIndex + currentPropertyName.length), 10);
	        currentProperty = currentProperty[index];
	        if (typeof currentProperty === 'object') {
	          return searchProperty;
	        }
	        return currentProperty;
	      }
	      return '';
	    }
	    return init;
	  });

	  var dataInterfaceFactory = function (elem) {
	    function interfaceFunction(value) {
	      if (value === 'Outline') {
	        return interfaceFunction.outlineInterface();
	      }
	      return null;
	    }

	    interfaceFunction._name = 'Outline';
	    interfaceFunction.outlineInterface = outlineInterfaceFactory(elem);
	    return interfaceFunction;
	  };

	  return function (elem) {
	    function _interfaceFunction(value) {
	      if (value === 'Data') {
	        return _interfaceFunction.dataInterface;
	      }
	      return null;
	    }

	    _interfaceFunction._name = 'Data';
	    _interfaceFunction.dataInterface = dataInterfaceFactory(elem);
	    return _interfaceFunction;
	  };
	}());

	/* exported CompExpressionInterface */

	var CompExpressionInterface = (function () {
	  return function (comp) {
	    function _thisLayerFunction(name) {
	      var i = 0;
	      var len = comp.layers.length;
	      while (i < len) {
	        if (comp.layers[i].nm === name || comp.layers[i].ind === name) {
	          return comp.elements[i].layerInterface;
	        }
	        i += 1;
	      }
	      return null;
	      // return {active:false};
	    }
	    Object.defineProperty(_thisLayerFunction, '_name', { value: comp.data.nm });
	    _thisLayerFunction.layer = _thisLayerFunction;
	    _thisLayerFunction.pixelAspect = 1;
	    _thisLayerFunction.height = comp.data.h || comp.globalData.compSize.h;
	    _thisLayerFunction.width = comp.data.w || comp.globalData.compSize.w;
	    _thisLayerFunction.pixelAspect = 1;
	    _thisLayerFunction.frameDuration = 1 / comp.globalData.frameRate;
	    _thisLayerFunction.displayStartTime = 0;
	    _thisLayerFunction.numLayers = comp.layers.length;
	    return _thisLayerFunction;
	  };
	}());

	/* global ExpressionPropertyInterface */
	/* exported TransformExpressionInterface */

	var TransformExpressionInterface = (function () {
	  return function (transform) {
	    function _thisFunction(name) {
	      switch (name) {
	        case 'scale':
	        case 'Scale':
	        case 'ADBE Scale':
	        case 6:
	          return _thisFunction.scale;
	        case 'rotation':
	        case 'Rotation':
	        case 'ADBE Rotation':
	        case 'ADBE Rotate Z':
	        case 10:
	          return _thisFunction.rotation;
	        case 'ADBE Rotate X':
	          return _thisFunction.xRotation;
	        case 'ADBE Rotate Y':
	          return _thisFunction.yRotation;
	        case 'position':
	        case 'Position':
	        case 'ADBE Position':
	        case 2:
	          return _thisFunction.position;
	        case 'ADBE Position_0':
	          return _thisFunction.xPosition;
	        case 'ADBE Position_1':
	          return _thisFunction.yPosition;
	        case 'ADBE Position_2':
	          return _thisFunction.zPosition;
	        case 'anchorPoint':
	        case 'AnchorPoint':
	        case 'Anchor Point':
	        case 'ADBE AnchorPoint':
	        case 1:
	          return _thisFunction.anchorPoint;
	        case 'opacity':
	        case 'Opacity':
	        case 11:
	          return _thisFunction.opacity;
	        default:
	          return null;
	      }
	    }
	    Object.defineProperty(_thisFunction, 'rotation', {
	      get: ExpressionPropertyInterface(transform.r || transform.rz),
	    });

	    Object.defineProperty(_thisFunction, 'zRotation', {
	      get: ExpressionPropertyInterface(transform.rz || transform.r),
	    });

	    Object.defineProperty(_thisFunction, 'xRotation', {
	      get: ExpressionPropertyInterface(transform.rx),
	    });

	    Object.defineProperty(_thisFunction, 'yRotation', {
	      get: ExpressionPropertyInterface(transform.ry),
	    });
	    Object.defineProperty(_thisFunction, 'scale', {
	      get: ExpressionPropertyInterface(transform.s),
	    });
	    var _px;
	    var _py;
	    var _pz;
	    var _transformFactory;
	    if (transform.p) {
	      _transformFactory = ExpressionPropertyInterface(transform.p);
	    } else {
	      _px = ExpressionPropertyInterface(transform.px);
	      _py = ExpressionPropertyInterface(transform.py);
	      if (transform.pz) {
	        _pz = ExpressionPropertyInterface(transform.pz);
	      }
	    }
	    Object.defineProperty(_thisFunction, 'position', {
	      get: function () {
	        if (transform.p) {
	          return _transformFactory();
	        }
	        return [
	          _px(),
	          _py(),
	          _pz ? _pz() : 0];
	      },
	    });

	    Object.defineProperty(_thisFunction, 'xPosition', {
	      get: ExpressionPropertyInterface(transform.px),
	    });

	    Object.defineProperty(_thisFunction, 'yPosition', {
	      get: ExpressionPropertyInterface(transform.py),
	    });

	    Object.defineProperty(_thisFunction, 'zPosition', {
	      get: ExpressionPropertyInterface(transform.pz),
	    });

	    Object.defineProperty(_thisFunction, 'anchorPoint', {
	      get: ExpressionPropertyInterface(transform.a),
	    });

	    Object.defineProperty(_thisFunction, 'opacity', {
	      get: ExpressionPropertyInterface(transform.o),
	    });

	    Object.defineProperty(_thisFunction, 'skew', {
	      get: ExpressionPropertyInterface(transform.sk),
	    });

	    Object.defineProperty(_thisFunction, 'skewAxis', {
	      get: ExpressionPropertyInterface(transform.sa),
	    });

	    Object.defineProperty(_thisFunction, 'orientation', {
	      get: ExpressionPropertyInterface(transform.or),
	    });

	    return _thisFunction;
	  };
	}());

	/* exported ProjectInterface */

	var ProjectInterface = (function () {
	  function registerComposition(comp) {
	    this.compositions.push(comp);
	  }

	  return function () {
	    function _thisProjectFunction(name) {
	      var i = 0;
	      var len = this.compositions.length;
	      while (i < len) {
	        if (this.compositions[i].data && this.compositions[i].data.nm === name) {
	          if (this.compositions[i].prepareFrame && this.compositions[i].data.xt) {
	            this.compositions[i].prepareFrame(this.currentFrame);
	          }
	          return this.compositions[i].compInterface;
	        }
	        i += 1;
	      }
	      return null;
	    }

	    _thisProjectFunction.compositions = [];
	    _thisProjectFunction.currentFrame = 0;

	    _thisProjectFunction.registerComposition = registerComposition;

	    return _thisProjectFunction;
	  };
	}());

	/* global propertyGroupFactory, ExpressionPropertyInterface, PropertyInterface */
	/* exported EffectsExpressionInterface */

	var EffectsExpressionInterface = (function () {
	  var ob = {
	    createEffectsInterface: createEffectsInterface,
	  };

	  function createEffectsInterface(elem, propertyGroup) {
	    if (elem.effectsManager) {
	      var effectElements = [];
	      var effectsData = elem.data.ef;
	      var i;
	      var len = elem.effectsManager.effectElements.length;
	      for (i = 0; i < len; i += 1) {
	        effectElements.push(createGroupInterface(effectsData[i], elem.effectsManager.effectElements[i], propertyGroup, elem));
	      }

	      var effects = elem.data.ef || [];
	      var groupInterface = function (name) {
	        i = 0;
	        len = effects.length;
	        while (i < len) {
	          if (name === effects[i].nm || name === effects[i].mn || name === effects[i].ix) {
	            return effectElements[i];
	          }
	          i += 1;
	        }
	        return null;
	      };
	      Object.defineProperty(groupInterface, 'numProperties', {
	        get: function () {
	          return effects.length;
	        },
	      });
	      return groupInterface;
	    }
	    return null;
	  }

	  function createGroupInterface(data, elements, propertyGroup, elem) {
	    function groupInterface(name) {
	      var effects = data.ef;
	      var i = 0;
	      var len = effects.length;
	      while (i < len) {
	        if (name === effects[i].nm || name === effects[i].mn || name === effects[i].ix) {
	          if (effects[i].ty === 5) {
	            return effectElements[i];
	          }
	          return effectElements[i]();
	        }
	        i += 1;
	      }
	      throw new Error();
	    }
	    var _propertyGroup = propertyGroupFactory(groupInterface, propertyGroup);

	    var effectElements = [];
	    var i;
	    var len = data.ef.length;
	    for (i = 0; i < len; i += 1) {
	      if (data.ef[i].ty === 5) {
	        effectElements.push(createGroupInterface(data.ef[i], elements.effectElements[i], elements.effectElements[i].propertyGroup, elem));
	      } else {
	        effectElements.push(createValueInterface(elements.effectElements[i], data.ef[i].ty, elem, _propertyGroup));
	      }
	    }

	    if (data.mn === 'ADBE Color Control') {
	      Object.defineProperty(groupInterface, 'color', {
	        get: function () {
	          return effectElements[0]();
	        },
	      });
	    }
	    Object.defineProperties(groupInterface, {
	      numProperties: {
	        get: function () {
	          return data.np;
	        },
	      },
	      _name: { value: data.nm },
	      propertyGroup: { value: _propertyGroup },
	    });
	    groupInterface.enabled = data.en !== 0;
	    groupInterface.active = groupInterface.enabled;
	    return groupInterface;
	  }

	  function createValueInterface(element, type, elem, propertyGroup) {
	    var expressionProperty = ExpressionPropertyInterface(element.p);
	    function interfaceFunction() {
	      if (type === 10) {
	        return elem.comp.compInterface(element.p.v);
	      }
	      return expressionProperty();
	    }

	    if (element.p.setGroupProperty) {
	      element.p.setGroupProperty(PropertyInterface('', propertyGroup));
	    }

	    return interfaceFunction;
	  }

	  return ob;
	}());

	/* global createSizedArray */
	/* exported MaskManagerInterface */

	var MaskManagerInterface = (function () {
	  function MaskInterface(mask, data) {
	    this._mask = mask;
	    this._data = data;
	  }
	  Object.defineProperty(MaskInterface.prototype, 'maskPath', {
	    get: function () {
	      if (this._mask.prop.k) {
	        this._mask.prop.getValue();
	      }
	      return this._mask.prop;
	    },
	  });
	  Object.defineProperty(MaskInterface.prototype, 'maskOpacity', {
	    get: function () {
	      if (this._mask.op.k) {
	        this._mask.op.getValue();
	      }
	      return this._mask.op.v * 100;
	    },
	  });

	  var MaskManager = function (maskManager) {
	    var _masksInterfaces = createSizedArray(maskManager.viewData.length);
	    var i;
	    var len = maskManager.viewData.length;
	    for (i = 0; i < len; i += 1) {
	      _masksInterfaces[i] = new MaskInterface(maskManager.viewData[i], maskManager.masksProperties[i]);
	    }

	    var maskFunction = function (name) {
	      i = 0;
	      while (i < len) {
	        if (maskManager.masksProperties[i].nm === name) {
	          return _masksInterfaces[i];
	        }
	        i += 1;
	      }
	      return null;
	    };
	    return maskFunction;
	  };
	  return MaskManager;
	}());

	/* global createTypedArray */
	/* exported ExpressionPropertyInterface */

	var ExpressionPropertyInterface = (function () {
	  var defaultUnidimensionalValue = { pv: 0, v: 0, mult: 1 };
	  var defaultMultidimensionalValue = { pv: [0, 0, 0], v: [0, 0, 0], mult: 1 };

	  function completeProperty(expressionValue, property, type) {
	    Object.defineProperty(expressionValue, 'velocity', {
	      get: function () {
	        return property.getVelocityAtTime(property.comp.currentFrame);
	      },
	    });
	    expressionValue.numKeys = property.keyframes ? property.keyframes.length : 0;
	    expressionValue.key = function (pos) {
	      if (!expressionValue.numKeys) {
	        return 0;
	      }
	      var value = '';
	      if ('s' in property.keyframes[pos - 1]) {
	        value = property.keyframes[pos - 1].s;
	      } else if ('e' in property.keyframes[pos - 2]) {
	        value = property.keyframes[pos - 2].e;
	      } else {
	        value = property.keyframes[pos - 2].s;
	      }
	      var valueProp = type === 'unidimensional' ? new Number(value) : Object.assign({}, value); // eslint-disable-line no-new-wrappers
	      valueProp.time = property.keyframes[pos - 1].t / property.elem.comp.globalData.frameRate;
	      valueProp.value = type === 'unidimensional' ? value[0] : value;
	      return valueProp;
	    };
	    expressionValue.valueAtTime = property.getValueAtTime;
	    expressionValue.speedAtTime = property.getSpeedAtTime;
	    expressionValue.velocityAtTime = property.getVelocityAtTime;
	    expressionValue.propertyGroup = property.propertyGroup;
	  }

	  function UnidimensionalPropertyInterface(property) {
	    if (!property || !('pv' in property)) {
	      property = defaultUnidimensionalValue;
	    }
	    var mult = 1 / property.mult;
	    var val = property.pv * mult;
	    var expressionValue = new Number(val); // eslint-disable-line no-new-wrappers
	    expressionValue.value = val;
	    completeProperty(expressionValue, property, 'unidimensional');

	    return function () {
	      if (property.k) {
	        property.getValue();
	      }
	      val = property.v * mult;
	      if (expressionValue.value !== val) {
	        expressionValue = new Number(val); // eslint-disable-line no-new-wrappers
	        expressionValue.value = val;
	        completeProperty(expressionValue, property, 'unidimensional');
	      }
	      return expressionValue;
	    };
	  }

	  function MultidimensionalPropertyInterface(property) {
	    if (!property || !('pv' in property)) {
	      property = defaultMultidimensionalValue;
	    }
	    var mult = 1 / property.mult;
	    var len = (property.data && property.data.l) || property.pv.length;
	    var expressionValue = createTypedArray('float32', len);
	    var arrValue = createTypedArray('float32', len);
	    expressionValue.value = arrValue;
	    completeProperty(expressionValue, property, 'multidimensional');

	    return function () {
	      if (property.k) {
	        property.getValue();
	      }
	      for (var i = 0; i < len; i += 1) {
	        arrValue[i] = property.v[i] * mult;
	        expressionValue[i] = arrValue[i];
	      }
	      return expressionValue;
	    };
	  }

	  // TODO: try to avoid using this getter
	  function defaultGetter() {
	    return defaultUnidimensionalValue;
	  }

	  return function (property) {
	    if (!property) {
	      return defaultGetter;
	    } if (property.propType === 'unidimensional') {
	      return UnidimensionalPropertyInterface(property);
	    }
	    return MultidimensionalPropertyInterface(property);
	  };
	}());

	/* global expressionHelpers, TextSelectorProp, ExpressionManager */
	/* exported TextExpressionSelectorPropFactory */

	var TextExpressionSelectorPropFactory = (function () { // eslint-disable-line no-unused-vars
	  function getValueProxy(index, total) {
	    this.textIndex = index + 1;
	    this.textTotal = total;
	    this.v = this.getValue() * this.mult;
	    return this.v;
	  }

	  return function (elem, data) {
	    this.pv = 1;
	    this.comp = elem.comp;
	    this.elem = elem;
	    this.mult = 0.01;
	    this.propType = 'textSelector';
	    this.textTotal = data.totalChars;
	    this.selectorValue = 100;
	    this.lastValue = [1, 1, 1];
	    this.k = true;
	    this.x = true;
	    this.getValue = ExpressionManager.initiateExpression.bind(this)(elem, data, this);
	    this.getMult = getValueProxy;
	    this.getVelocityAtTime = expressionHelpers.getVelocityAtTime;
	    if (this.kf) {
	      this.getValueAtTime = expressionHelpers.getValueAtTime.bind(this);
	    } else {
	      this.getValueAtTime = expressionHelpers.getStaticValueAtTime.bind(this);
	    }
	    this.setGroupProperty = expressionHelpers.setGroupProperty;
	  };
	}());

	var propertyGetTextProp = TextSelectorProp.getTextSelectorProp;
	TextSelectorProp.getTextSelectorProp = function (elem, data, arr) {
	  if (data.t === 1) {
	    return new TextExpressionSelectorPropFactory(elem, data, arr); // eslint-disable-line no-undef
	  }
	  return propertyGetTextProp(elem, data, arr);
	};

	/* global PropertyFactory */
	/* exported SliderEffect, AngleEffect, ColorEffect, PointEffect, LayerIndexEffect, MaskIndexEffect, CheckboxEffect, NoValueEffect */

	function SliderEffect(data, elem, container) {
	  this.p = PropertyFactory.getProp(elem, data.v, 0, 0, container);
	}
	function AngleEffect(data, elem, container) {
	  this.p = PropertyFactory.getProp(elem, data.v, 0, 0, container);
	}
	function ColorEffect(data, elem, container) {
	  this.p = PropertyFactory.getProp(elem, data.v, 1, 0, container);
	}
	function PointEffect(data, elem, container) {
	  this.p = PropertyFactory.getProp(elem, data.v, 1, 0, container);
	}
	function LayerIndexEffect(data, elem, container) {
	  this.p = PropertyFactory.getProp(elem, data.v, 0, 0, container);
	}
	function MaskIndexEffect(data, elem, container) {
	  this.p = PropertyFactory.getProp(elem, data.v, 0, 0, container);
	}
	function CheckboxEffect(data, elem, container) {
	  this.p = PropertyFactory.getProp(elem, data.v, 0, 0, container);
	}
	function NoValueEffect() {
	  this.p = {};
	}

	/* global extendPrototype, SliderEffect, AngleEffect, ColorEffect, PointEffect, CheckboxEffect, LayerIndexEffect,
	MaskIndexEffect, NoValueEffect, DynamicPropertyContainer */

	function EffectsManager(data, element) {
	  var effects = data.ef || [];
	  this.effectElements = [];
	  var i;
	  var len = effects.length;
	  var effectItem;
	  for (i = 0; i < len; i += 1) {
	    effectItem = new GroupEffect(effects[i], element);
	    this.effectElements.push(effectItem);
	  }
	}

	function GroupEffect(data, element) {
	  this.init(data, element);
	}

	extendPrototype([DynamicPropertyContainer], GroupEffect);

	GroupEffect.prototype.getValue = GroupEffect.prototype.iterateDynamicProperties;

	GroupEffect.prototype.init = function (data, element) {
	  this.data = data;
	  this.effectElements = [];
	  this.initDynamicPropertyContainer(element);
	  var i;
	  var len = this.data.ef.length;
	  var eff;
	  var effects = this.data.ef;
	  for (i = 0; i < len; i += 1) {
	    eff = null;
	    switch (effects[i].ty) {
	      case 0:
	        eff = new SliderEffect(effects[i], element, this);
	        break;
	      case 1:
	        eff = new AngleEffect(effects[i], element, this);
	        break;
	      case 2:
	        eff = new ColorEffect(effects[i], element, this);
	        break;
	      case 3:
	        eff = new PointEffect(effects[i], element, this);
	        break;
	      case 4:
	      case 7:
	        eff = new CheckboxEffect(effects[i], element, this);
	        break;
	      case 10:
	        eff = new LayerIndexEffect(effects[i], element, this);
	        break;
	      case 11:
	        eff = new MaskIndexEffect(effects[i], element, this);
	        break;
	      case 5:
	        eff = new EffectsManager(effects[i], element, this);
	        break;
	        // case 6:
	      default:
	        eff = new NoValueEffect(effects[i], element, this);
	        break;
	    }
	    if (eff) {
	      this.effectElements.push(eff);
	    }
	  }
	};


	var lottie = {};

	function setLocationHref(href) {
	  locationHref = href;
	}

	function searchAnimations() {
	  if (standalone === true) {
	    animationManager.searchAnimations(animationData, standalone, renderer);
	  } else {
	    animationManager.searchAnimations();
	  }
	}

	function setSubframeRendering(flag) {
	  subframeEnabled = flag;
	}

	function setIDPrefix(prefix) {
	  idPrefix = prefix;
	}

	function loadAnimation(params) {
	  if (standalone === true) {
	    params.animationData = JSON.parse(animationData);
	  }
	  return animationManager.loadAnimation(params);
	}

	function setQuality(value) {
	  if (typeof value === 'string') {
	    switch (value) {
	      case 'high':
	        defaultCurveSegments = 200;
	        break;
	      default:
	      case 'medium':
	        defaultCurveSegments = 50;
	        break;
	      case 'low':
	        defaultCurveSegments = 10;
	        break;
	    }
	  } else if (!isNaN(value) && value > 1) {
	    defaultCurveSegments = value;
	  }
	  if (defaultCurveSegments >= 50) {
	    roundValues(false);
	  } else {
	    roundValues(true);
	  }
	}

	function inBrowser() {
	  return typeof navigator !== 'undefined';
	}

	function installPlugin(type, plugin) {
	  if (type === 'expressions') {
	    expressionsPlugin = plugin;
	  }
	}

	function getFactory(name) {
	  switch (name) {
	    case 'propertyFactory':
	      return PropertyFactory;
	    case 'shapePropertyFactory':
	      return ShapePropertyFactory;
	    case 'matrix':
	      return Matrix;
	    default:
	      return null;
	  }
	}

	lottie.play = animationManager.play;
	lottie.pause = animationManager.pause;
	lottie.setLocationHref = setLocationHref;
	lottie.togglePause = animationManager.togglePause;
	lottie.setSpeed = animationManager.setSpeed;
	lottie.setDirection = animationManager.setDirection;
	lottie.stop = animationManager.stop;
	lottie.searchAnimations = searchAnimations;
	lottie.registerAnimation = animationManager.registerAnimation;
	lottie.loadAnimation = loadAnimation;
	lottie.setSubframeRendering = setSubframeRendering;
	lottie.resize = animationManager.resize;
	// lottie.start = start;
	lottie.goToAndStop = animationManager.goToAndStop;
	lottie.destroy = animationManager.destroy;
	lottie.setQuality = setQuality;
	lottie.inBrowser = inBrowser;
	lottie.installPlugin = installPlugin;
	lottie.freeze = animationManager.freeze;
	lottie.unfreeze = animationManager.unfreeze;
	lottie.setVolume = animationManager.setVolume;
	lottie.mute = animationManager.mute;
	lottie.unmute = animationManager.unmute;
	lottie.getRegisteredAnimations = animationManager.getRegisteredAnimations;
	lottie.setIDPrefix = setIDPrefix;
	lottie.__getFactory = getFactory;
	lottie.version = '5.7.13';

	function checkReady() {
	  if (document.readyState === 'complete') {
	    clearInterval(readyStateCheckInterval);
	    searchAnimations();
	  }
	}

	function getQueryVariable(variable) {
	  var vars = queryString.split('&');
	  for (var i = 0; i < vars.length; i += 1) {
	    var pair = vars[i].split('=');
	    if (decodeURIComponent(pair[0]) == variable) { // eslint-disable-line eqeqeq
	      return decodeURIComponent(pair[1]);
	    }
	  }
	  return null;
	}
	var standalone = '__[STANDALONE]__';
	var animationData = '__[ANIMATIONDATA]__';
	var renderer = '';
	var queryString;
	if (standalone) {
	  var scripts = document.getElementsByTagName('script');
	  var index = scripts.length - 1;
	  var myScript = scripts[index] || {
	    src: '',
	  };
	  queryString = myScript.src.replace(/^[^\?]+\??/, ''); // eslint-disable-line no-useless-escape
	  renderer = getQueryVariable('renderer');
	}
	var readyStateCheckInterval = setInterval(checkReady, 100);

	return lottie;
	}));

/***/ })
/******/ ]);